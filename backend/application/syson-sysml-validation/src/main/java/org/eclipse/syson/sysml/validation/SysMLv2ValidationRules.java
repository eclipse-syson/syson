/*******************************************************************************
 * Copyright (c) 2025 Obeo.
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Obeo - initial API and implementation
 *******************************************************************************/
package org.eclipse.syson.sysml.validation;

import java.util.List;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.syson.sysml.SysmlPackage;

/**
 * Contains all SysMLv2 validation rules from the specification.
 *
 * @author arichard
 */
public class SysMLv2ValidationRules {

    // @formatter:off

    public static final List<ValidationRule> VALIDATION_RULES = List.of(
          new ValidationRule(SysmlPackage.eINSTANCE.getAcceptActionUsage(), "checkAcceptActionUsageReceiverBindingConnector", "aql:self.payloadArgument <> null and self.payloadArgument.oclIsKindOf(sysml::TriggerInvocationExpression) implies let invocation : sysml::Expression = self.payloadArgument.oclAsType(sysml::Expression) in self.parameter->size() >= 2 and invocation.parameter->size() >= 2 and self.ownedFeature->filter(sysml::BindingConnector)->exists(b | b.relatedFeatures->includes(parameter->at(2)) and b.relatedFeatures->includes(invocation.parameter->at(2)))", "If the payloadArgument of an AcceptActionUsage is a TriggerInvocationExpression, then the AcceptActionusage must have an ownedFeature that is a BindingConnector between its receiver parameter and the receiver parameter of the TriggerInvocationExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAcceptActionUsage(), "checkAcceptActionUsageSpecialization", "aql:not self.isTriggerAction() implies self.specializesFromLibrary('Actions::acceptActions')", "An AcceptActionUsage that is not the triggerAction of a TransitionUsage must directly or indirectly specialize the ActionUsage Actions::acceptActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAcceptActionUsage(), "checkAcceptActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() and not self.isTriggerAction() implies self.specializesFromLibrary('Actions::Action::acceptSubactions')", "A composite AcceptActionUsage that is a subaction usage, but is not the triggerAction of a TransitionUsage, must directly or indirectly specialize the ActionUsage Actions::Action::acceptSubactions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAcceptActionUsage(), "checkAcceptActionUsageTriggerActionSpecialization", "aql:self.isTriggerAction() implies self.specializesFromLibrary('Actions::TransitionAction::accepter')", "An AcceptActionUsage that is the triggerAction of TransitionUsage must directly or indirectly specialize the ActionUsage Actions::TransitionAction::accepter from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getActionDefinition(), "checkActionDefinitionSpecialization", "aql:self.specializesFromLibrary('Actions::Action')", "An ActionDefinition must directly or indirectly specialize the ActionDefinition Actions::Action from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getActionUsage(), "checkActionUsageOwnedActionSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::PartDefinition) or self.owningType.oclIsKindOf(sysml::PartUsage)) implies self.specializesFromLibrary('Parts::Part::ownedActions')", "A composite ActionUsage whose owningType is  PartDefinition or PartUsage must directly or indirectly specialize the ActionUsage Parts::Part::ownedActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getActionUsage(), "checkActionUsageSpecialization", "aql:self.specializesFromLibrary('Actions::actions')", "An ActionUsage must directly or indirectly specialize the ActionUsage Actions::actions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getActionUsage(), "checkActionUsageStateActionRedefinition", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::StateSubactionMembership) implies let kind : sysml::StateSubactionKind = self.owningFeatureMembership.oclAsType(sysml::StateSubactionMembership).kind in if kind = sysml::StateSubactionKind::entry then self.redefinesFromLibrary('States::StateAction::entryAction') else if kind = sysml::StateSubactionKind::do then self.redefinesFromLibrary('States::StateAction::doAction') else self.redefinesFromLibrary('States::StateAction::exitAction') endif endif", "An ActionUsage that is the entry, do, or exit Action of a StateDefinition or StateUsage must redefine the entryAction, doAction, or exitAction feature, respectively, of the StateDefinition States::StateAction from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getActionUsage(), "checkActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() implies self.specializesFromLibrary('Actions::Action::subactions')", "A composite ActionUsage that is a subaction usage must directly or indirectly specialize the ActionUsage Actions::Action::subactions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAllocationDefinition(), "checkAllocationDefinitionSpecialization", "aql:self.specializesFromLibrary('Allocations::Allocation')", "An AllocationDefinition must directly or indirectly specialize the AllocationDefinition Allocations::Allocation from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAllocationUsage(), "checkAllocationUsageSpecialization", "aql:self.specializesFromLibrary('Allocations::allocations')", "An AllocationUsage must directly or indirectly specialize the AllocationUsage Allocations::allocations from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAnalysisCaseDefinition(), "checkAnalysisCaseDefinitionSpecialization", "aql:self.specializesFromLibrary('AnalysisCases::AnalysisCase')", "An AnalysisCaseDefinition must directly or indirectly specialize the base AnalysisCaseDefinition AnalysisCases::AnalysisCase from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAnalysisCaseUsage(), "checkAnalysisCaseUsageSpecialization", "aql:self.specializesFromLibrary('AnalysisCases::analysisCases')", "An AnalysisCaseUsage must directly or indirectly specialize the base AnalysisCaseUsage AnalysisCases::analysisCases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAnalysisCaseUsage(), "checkAnalysisCaseUsageSubAnalysisCaseSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::AnalysisCaseDefinition) or self.owningType.oclIsKindOf(sysml::AnalysisCaseUsage)) implies self.specializesFromLibrary('AnalysisCases::AnalysisCase::subAnalysisCases')", "A composite AnalysisCaseUsage whose owningType is an AnalysisCaseDefinition or AnalysisCaseUsage must specialize the AnalysisCaseUsage AnalysisCases::AnalysisCase::subAnalysisCases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssertConstraintUsage(), "checkAssertConstraintUsageSpecialization", "aql:if self.isNegated then self.specializesFromLibrary('Constraints::negatedConstraintChecks') else self.specializesFromLibrary('Constraints::assertedConstraintChecks') endif", "If a AssertConstraintUsage is negated, then it must directly or indirectly specialize the ConstraintUsage Constraints::negatedConstraintChecks. Otherwise, it must directly or indirectly specialize the ConstraintUsage Constraints::assertedConstraintChecks."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssignmentActionUsage(), "checkAssignmentActionUsageAccessedFeatureRedefinition", "aql:let targetParameter : sysml::Feature = self.inputParameter(1) in targetParameter <> null and targetParameter.ownedFeature->notEmpty() and targetParameter->first().ownedFeature->notEmpty() and targetParameter->first().ownedFeature->first().redefines('AssigmentAction::target::startingAt::accessedFeature')", "The first ownedFeature of the first ownedFeature of the first parameter of an AssignmentActionUsage must redefine AssignmentAction::target::startingAt::accessedFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssignmentActionUsage(), "checkAssignmentActionUsageReferentRedefinition", "aql:let targetParameter : sysml::Feature = self.inputParameter(1) in targetParameter <> null and targetParameter.ownedFeature->notEmpty() and targetParameter->first().ownedFeature->notEmpty() and targetParameter->first().ownedFeature->first().redefines(referent)", "The first ownedFeature of the first ownedFeature of the first parameter of an AssignmentActionUsage must redefine the referent of the AssignmentActionUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssignmentActionUsage(), "checkAssignmentActionUsageSpecialization", "aql:self.specializesFromLibrary('Actions::assignmentActions')", "An AssignmentActionUsage must directly or indirectly specialize the ActionUsage Actions::assignmentActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssignmentActionUsage(), "checkAssignmentActionUsageStartingAtRedefinition", "aql:let targetParameter : sysml::Feature = self.inputParameter(1) in targetParameter <> null and targetParameter.ownedFeature->notEmpty() and targetParameter.ownedFeature->first().redefines('AssignmentAction::target::startingAt')", "The first ownedFeature of the first parameter of an AssignmentActionUsage must redefine AssignmentAction::target::startingAt."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssignmentActionUsage(), "checkAssignmentActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() implies self.specializesFromLibrary('Actions::Action::assignments')", "A composite AssignmentActionUsage that is a subaction usage must directly or indirectly specialize the ActionUsage Actions::Action::assignments from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociation(), "checkAssociationBinarySpecialization", "aql:self.associationEnd->size() = 2 implies self.specializesFromLibrary('Links::BinaryLink')", "A binary Association must directly or indirectly specialize the base Association Links::binaryLink from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociation(), "checkAssociationSpecialization", "aql:self.specializesFromLibrary('Links::Link')", "An Association must directly or indirectly specialize the base Association Links::Link from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociationStructure(), "checkAssociationStructureBinarySpecialization", "aql:self.endFeature->size() = 2 implies self.specializesFromLibrary('Objects::BinaryLinkObject')", "A binary AssociationStructure must directly or indirectly specialize the base AssociationStructure Objects::BinaryLinkObject from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociationStructure(), "checkAssociationStructureSpecialization", "aql:self.specializesFromLibrary('Objects::LinkObject')", "An AssociationStructure must directly or indirectly specialize the base AssociationStructure Objects::LinkObject from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAttributeUsage(), "checkAttributeUsageSpecialization", "aql:self.specializesFromLibrary('Base::dataValues')", "An AttributeUsage must directly or indirectly specialize Base::dataValues from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getBehavior(), "checkBehaviorSpecialization", "aql:self.specializesFromLibrary('Performances::Performance')", "A Behavior must directly or indirectly specialize the base Behavior Performances::Performance from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getBindingConnector(), "checkBindingConnectorSpecialization", "aql:self.specializesFromLibrary('Links::selfLinks')", "A BindingConnector must directly or indirectly specialize the base BindingConnector Links::selfLinks from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getBooleanExpression(), "checkBooleanExpressionSpecialization", "aql:self.specializesFromLibrary('Performances::booleanEvaluations')", "A BooleanExpression must directly or indirectly specialize the base BooleanExpression Performances::booleanEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCalculationDefinition(), "checkCalculationDefinitionSpecialization", "aql:self.specializesFromLibrary('Calculations::Calculation')", "A CalculationDefinition must directly or indirectly specialize the CalculationDefinition Calculations::Calculation from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCalculationUsage(), "checkCalculationUsageSpecialization", "aql:self.specializesFromLibrary('Calculations::calculations')", "A CalculationUsage must specialize directly or indirectly the CalculationUsage Calculations::calculations from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCalculationUsage(), "checkCalculationUsageSubcalculationSpecialization", "aql:self.owningType <> null and (self.owningType.oclIsKindOf(sysml::CalculationDefinition) or self.owningType.oclIsKindOf(sysml::CalculationUsage)) implies self.specializesFromLibrary('Calculations::Calculation::subcalculations')", ""),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseDefinition(), "checkCaseDefinitionSpecialization", "aql:self.specializesFromLibrary('Cases::Case')", "A CaseDefinition must directly or indirectly specialize the base CaseDefinition Cases::Case> from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseUsage(), "checkCaseUsageSpecialization", "aql:self.specializesFromLibrary('Cases::cases')", "A CaseUsage must directly or indirectly specialize the base CaseUsage Cases::cases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseUsage(), "checkCaseUsageSubcaseSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::CaseDefinition) or self.owningType.oclIsKindOf(sysml::CaseUsage)) implies self.specializesFromLibrary('Cases::Case::subcases')", "A composite CaseUsage whose owningType is a CaseDefinition or CaseUsage must directly or indirectly specialize the CaseUsage Cases::Case::subcases."),
          new ValidationRule(SysmlPackage.eINSTANCE.getClass_(), "checkClassSpecialization", "aql:self.specializesFromLibrary('Occurrences::Occurrence')", "A Class must directly or indirectly specialize the base Class Occurrences::Occurrence from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConcernDefinition(), "checkConcernDefinitionSpecialization", "aql:self.specializesFromLibrary('Requirements::ConcernCheck')", "A ConcernDefinition must directly or indirectly specialize the base ConcernDefinition Requirements::ConcernCheck from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConcernUsage(), "checkConcernUsageFramedConcernSpecialization", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::FramedConcernMembership) implies self.specializesFromLibrary('Requirements::RequirementCheck::concerns')", "If a ConcernUsage is owned via a FramedConcernMembership, then it must directly or indirectly specialize the ConcernUsage Requirements::RequirementCheck::concerns from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConcernUsage(), "checkConcernUsageSpecialization", "aql:self.specializesFromLibrary('Requirements::concernChecks')", "A ConcernUsage must directly or indirectly specialize the base ConcernUsage Requirements::concernChecks from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnectionDefinition(), "checkConnectionDefinitionBinarySpecialization", "aql:self.ownedEndFeature->size() = 2 implies self.specializesFromLibrary('Connections::BinaryConnections')", "A binary ConnectionDefinition must directly or indirectly specialize the ConnectionDefinition Connections::BinaryConnection from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnectionDefinition(), "checkConnectionDefinitionSpecializations", "aql:self.specializesFromLibrary('Connections::Connection')", "A ConnectionDefinition must directly or indirectly specialize the ConnectionDefinition Connections::Connection from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnectionUsage(), "checkConnectionUsageBinarySpecialization", "aql:self.ownedEndFeature->size() = 2 implies self.specializesFromLibrary('Connections::binaryConnections')", "A binary ConnectionUsage must directly or indirectly specialize the ConnectionUsage Connections::binaryConnections from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnectionUsage(), "checkConnectionUsageSpecialization", "aql:self.specializesFromLibrary('Connections::connections')", "A ConnectionUsage must directly or indirectly specialize the ConnectionUsage Connections::connections from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "checkConnectorBinaryObjectSpecialization", "aql:self.connectorEnd->size() = 2 and self.association->exists(e | e.oclIsKindOf(sysml::AssociationStructure)) implies self.specializesFromLibrary('Objects::binaryLinkObjects')", "A binary Connector for an AssociationStructure  must directly or indirectly specialize the base Connector Objects::binaryLinkObjects from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "checkConnectorBinarySpecialization", "aql:self.connectorEnd->size() = 2 implies self.specializesFromLibrary('Links::binaryLinks')", "A binary Connector must directly or indirectly specialize the base Connector Links::binaryLinks from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "checkConnectorObjectSpecialization", "aql:self.association->exists(e | e.oclIsKindOf(sysml::AssociationStructure)) implies self.specializesFromLibrary('Objects::linkObjects')", "A Connector for an AssociationStructure must directly or indirectly specialize the base Connector Objects::linkObjects from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "checkConnectorSpecialization", "aql:self.specializesFromLibrary('Links::links')", "A Connector must directly or indirectly specialize the base Connector Links::links from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "checkConnectorTypeFeaturing", "aql:self.relatedFeature->forAll(f | if self.featuringType->isEmpty() then f.isFeaturedWithin(null) else self.featuringType->forAll(t | f.isFeaturedWithin(t)) endif)", "Each relatedFeature of a Connector must have each featuringType of the Connector as a direct or indirect featuringType (where a Feature with no featuringType is treated as if the Classifier Base::Anything was its featuringType)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstraintDefinition(), "checkConstraintDefinitionSpecialization", "aql:self.specializesFromLibrary('Constraints::ConstraintCheck')", "A ConstraintDefinition must directly or indirectly specialize the base ConstraintDefinition Constraints::ConstraintCheck from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstraintUsage(), "checkConstraintUsageCheckedConstraintSpecialization", "aql:self.owningType <> null and (self.owningType.oclIsKindOf(sysml::ItemDefinition) or self.owningType.oclIsKindOf(sysml::ItemUsage)) implies self.specializesFromLibrary('Items::Item::checkedConstraints')", "A ConstraintUsage whose owningType is an ItemDefinition or ItemUsage must directly or indirectly specialize the ConstraintUsage Items::Item::checkedConstraints."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstraintUsage(), "checkConstraintUsageRequirementConstraintSpecialization", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::RequirementConstraintMembership) implies if self.owningFeatureMembership.oclAsType(sysml::RequirementConstraintMembership).kind = sysml::RequirementConstraintKind::assumption then self.specializesFromLibrary('Requirements::RequirementCheck::assumptions') else self.specializesFromLibrary('Requirements::RequirementCheck::constraints') endif", "A ConstraintUsage whose owningFeatureMembership is a RequirementConstraintMembership must directly or indirectly specialize on the ConstraintUsages assumptions or constraints from the ConstraintDefinition Requirements::RequirementCheck in the Systems Model Library, depending on whether the kind of the RequirementConstraintMembership is assumption or requirement, respectively."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstraintUsage(), "checkConstraintUsageSpecialization", "aql:self.specializesFromLibrary('Constraints::constraintChecks')", "A ConstraintUsage must directly or indirectly specialize the base ConstraintUsage Constraints::constraintChecks from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstructorExpression(), "checkConstructorExpressionResultDefaultValueBindingConnector", "aql:self.TBD", "The result of a ConstructorExpression must own a BindingConnector between the featureWithValue and value Expression of any FeatureValue that is the effective default value for a feature of the instantiatedType of the InvocationExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstructorExpression(), "checkConstructorExpressionResultFeatureRedefinition", "aql:let features : OrderedSet(sysml::Feature) = self.instantiatedType.feature->select(owningMembership.visibility = sysml::VisibilityKind::public) in self.result.ownedFeature->forAll(f | f.ownedRedefinition.redefinedFeature->intersection(features)->size() = 1)", "Each ownedFeature of the result of a ConstructionExpression must redefine exactly one public feature of the instantiatedType of the ConstructorExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstructorExpression(), "checkConstructorExpressionResultSpecialization", "aql:self.result.specializes(instantiatedType)", "The result of a ConstructorExpression must specialize the instantiatedType of the ConstructorExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstructorExpression(), "checkConstructorExpressionSpecialization", "aql:self.specializes('Performances::constructorEvaluations')", "A ConstructorExpression must directly or indirectly specialize the Expression Performances::constructorEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getControlNode(), "checkControlNodeSpecialization", "aql:self.specializesFromLibrary('Action::Action::controls')", "A ControlNode must directly or indirectly specialize the ActionUsage Actions::Action::control from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDataType(), "checkDataTypeSpecialization", "aql:self.specializesFromLibrary('Base::DataValue')", "A DataType must directly or indirectly specialize the base DataType Base::DataValue from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDecisionNode(), "checkDecisionNodeOutgoingSuccessionSpecialization", "aql:self.sourceConnector->filter(sysml::Succession)->forAll(subsetsChain(self, self.resolveGlobal('ControlPerformances::MergePerformance::outgoingHBLink')))", "All outgoing Successions from a DecisionNode must subset the inherited outgoingHBLink feature of the DecisionNode."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDecisionNode(), "checkDecisionNodeSpecialization", "aql:self.specializesFromLibrary('Actions::Action::decisions')", "A DecisionNode must directly or indirectly specialize the ActionUsage Actions::Action::decisions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getEventOccurrenceUsage(), "checkEventOccurrenceUsageSpecialization", "aql:self.owningType <> null and (self.owningType.oclIsKindOf(sysml::OccurrenceDefinition) or self.owningType.oclIsKindOf(sysml::OccurrenceUsage)) implies self.specializesFromLibrary('Occurrences::Occurrence::timeEnclosedOccurrences')", "If an EventOccurrenceUsage has an owningType that is an OccurrenceDefinition or OccurrenceUsage, then it must directly or indirectly specialize the Feature Occurrences::Occurrence::timeEnclosedOccurrences."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExhibitStateUsage(), "checkExhibitStateUsageSpecialization", "aql:self.owningType <> null and (self.owningType.oclIsKindOf(sysml::PartDefinition) or self.owningType.oclIsKindOf(sysml::PartUsage)) implies self.specializesFromLibrary('Parts::Part::exhibitedStates')", "If an ExhibitStateUsage has an owningType that is a PartDefinition or PartUsage, then it must directly or indirectly specialize the StateUsage Parts::Part::exhibitedStates."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpression(), "checkExpressionResultBindingConnector", "aql:self.ownedMembership->filter(sysml::ResultExpressionMembership)->forAll(mem | self.ownedFeature.oclIsKindOf(sysml::BindingConnector)->exists(binding | binding.relatedFeature->includes(self.result) and binding.relatedFeature->includes(mem.ownedResultExpression.result)))", "If an Expression has an Expression owned via a ResultExpressionMembership, then the owning Expression must also own a BindingConnector between its result parameter and the result parameter of the result Expression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpression(), "checkExpressionSpecialization", "aql:self.specializesFromLibrary('Performances::evaluations')", "An Expression must directly or indirectly specialize the base Expression Performances::evaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpression(), "checkExpressionTypeFeaturing", "aql:self.owningMembership <> null and self.owningMembership.oclIsKindOf(sysml::FeatureValue) implies let featureWithValue : sysml::Feature = self.owningMembership.oclAsType(sysml::FeatureValue).featureWithValue in self.featuringType = featureWithValue.featuringType", "If this Expression is owned by a FeatureValue, then it must have the same featuringTypes as the featureWithValue of the FeatureValue."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureChainExpression(), "checkFeatureChainExpressionResultSpecialization", "aql:let inputParameters : Sequence(sysml::Feature) = self.ownedFeatures->select(direction = _'in') in let self.sourceTargetFeature : sysml::Feature = owningExpression.sourceTargetFeature() in self.sourceTargetFeature <> null and self.result.subsetsChain(inputParameters->first(), self.sourceTargetFeature) and self.result.owningType = self", "The result parameter of a FeatureChainExpression must specialize the feature chain of the FeatureChainExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureChainExpression(), "checkFeatureChainExpressionSourceTargetRedefinition", "aql:let sourceParameter : sysml::Feature = self.sourceTargetFeature() in self.sourceTargetFeature <> null and self.sourceTargetFeature.redefines(targetFeature)", "The first ownedFeature of the first owned input parameter of a FeatureChainExpression must redefine its targetFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureChainExpression(), "checkFeatureChainExpressionTargetRedefinition", "aql:let sourceParameter : sysml::Feature = self.sourceTargetFeature() in self.sourceTargetFeature <> null and self.sourceTargetFeature.redefinesFromLibrary('ControlFunctions::\'.\'::source::target')", "The first ownedFeature of the first owned input parameter of a FeatureChainExpression must redefine the Feature ControlFunctions::'.'::source::target from the Kernel Functions Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureCrossingSpecialization", "aql:self.ownedCrossFeature() <> null implies self.crossFeature = self.ownedCrossFeature()", "If this Feature has isEnd = true and ownedCrossFeature returns a non-null value, then the crossFeature of the Feature must be the Feature returned from ownedCrossFeature (which implies that this Feature has an appropriate ownedCrossSubsetting to realize this)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureDataValueSpecialization", "aql:self.ownedTyping.type->exists(e | e.oclIsKindOf(sysml::DataType)) implies self.specializesFromLibrary('Base::dataValues')", "If a Feature has an ownedTyping relationship to a DataType, then it must directly or indirectly specialize Base::dataValues from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureEndRedefinition", "aql:self.isEnd and self.owningType <> null implies let i : Integer = self.owningType.ownedEndFeature->indexOf(self) in self.owningType.ownedSpecialization.general->forAll(supertype | supertype.endFeature->size() >= i implies self.redefines(supertype.endFeature->at(i)))", "If a Feature has isEnd = true and an owningType that is not empty, then, for each direct supertype of its owningType, it must redefine the endFeature at the same position, if any."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureEndSpecialization", "aql:self.isEnd and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::Association) or self.owningType.oclIsKindOf(sysml::Connector)) implies self.specializesFromLibrary('Links::Link::participant')", "If a Feature has isEnd = true and an owningType that is an Association or a Connector, then it must directly or indirectly specialize Links::Link::participant from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureFeatureMembershipTypeFeaturing", "aql:self.owningFeatureMembership <> null implies self.featuringType->exists(t | self.isFeaturingType(t))", "If a Feature is owned via a FeatureMembership, then it must have a featuringType for which the operation isFeaturingType returns true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureFlowFeatureRedefinition", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::FlowEnd) and self.owningType.ownedFeature->at(1) = self implies let flowType : sysml::Type = self.owningType.owningType in flowType <> null implies let i : Integer = flowType.ownedFeature.indexOf(owningType) in (i = 1 implies self.redefinesFromLibrary('Transfers::Transfer::source::sourceOutput')) and (i = 2 implies self.redefinesFromLibrary('Transfers::Transfer::source::targetInput'))", "If a Feature is the first ownedFeature of a first or second FlowEnd, then it must directly or indirectly specialize either Transfers::Transfer::source::sourceOutput or Transfers::Transfer::target::targetInput, respectively, from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureObjectSpecialization", "aql:self.ownedTyping.type->exists(e | e.oclIsKindOf(sysml::Structure)) implies self.specializesFromLibrary('Objects::objects')", "If a Feature has an ownedTyping relationship to a Structure, then it must directly or indirectly specialize Objects::objects from the Kernel Semantics Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureOccurrenceSpecialization", "aql:self.ownedTyping.type->exists(e | e.oclIsKindOf(sysml::Class)) implies self.specializesFromLibrary('Occurrences::occurrences')", "If a Feature has an ownedTyping relationship to a Class, then it must directly or indirectly specialize Occurrences::occurrences from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureOwnedCrossFeatureRedefinitionSpecialization", "aql:self.isOwnedCrossFeature() implies self.ownedSubsetting.subsettedFeature->includesAll( self.owner.oclAsType(sysml::Feature).ownedRedefinition.redefinedFeature->select(crossFeature <> null).crossFeature)", "If this Feature is the ownedCrossFeature of an end Feature, then, for any end Feature that is redefined by the owning end Feature of this Feature, this Feature must subset the crossFeature of the redefined end Feature, if this exists."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureOwnedCrossFeatureSpecialization", "aql:self.isOwnedCrossFeature() implies self.owner.oclAsType(sysml::Feature).type->forAll(t | self.specializes(t))", "If this Feature is the ownedCrossFeature of an end Feature, then it must directly or indirectly specialize the types of its owning end Feature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureOwnedCrossFeatureTypeFeaturing", "aql:self.isOwnedCrossFeature() implies let otherEnds : OrderedSet(sysml::Feature) = self.owner.oclAsType(sysml::Feature).owningType.endFeature->excluding(self) in if (otherEnds->size() = 1) then self.featuringType = otherEnds->first().type else self.featuringType->size() = 1 and self.featuringType->first().isCartesianProduct() and self.featuringType->first().asCartesianProduct() = otherEnds.type and self.featuringType->first().allSupertypes()->includesAll( self.owner.oclAsType(sysml::Feature).ownedRedefinition.redefinedFeature->select(crossFeature() <> null).crossFeature().featuringType) endif", "If this Feature is the ownedCrossFeature of an end Feature, then it must have featuringTypes consistent with the crossing from other end Features of the owningType of its end Feature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureParameterRedefinition", "aql:self.owningType <> null and not self.owningFeatureMembership.oclIsKindOf(sysml::ReturnParameterMembership) and (self.owningType.oclIsKindOf(sysml::Behavior) or self.owningType.oclIsKindOf(sysml::Step) and (self.owningType.oclIsKindOf(sysml::InvocationExpression) implies not self.ownedRedefinition->exists(e | not e.isImplied)) implies let i : Integer = self.owningType.ownedFeature->select(f | f.direction <> null)->reject(i | i.owningFeatureMembership.oclIsKindOf(sysml::ReturnParameterMembership))->indexOf(self) in self.owningType.ownedSpecialization.general->forAll(supertype | let ownedParameters : Sequence(sysml::Feature) = supertype.ownedFeature->select(f | f.direction <> null)->reject(i | i.owningFeatureMembership.oclIsKindOf(sysml::ReturnParameterMembership)) in ownedParameters->size() >= i implies self.redefines(ownedParameters->at(i)))", "If a Feature is a parameter of an owningType that is a Behavior or Step, but not a result parameter or a parameter of an InvocationExpression, with at least one non-implied ownedRedefinition, then, for each direct supertype of its owningType that is also a Behavior or Step, it must redefine the parameter at the same position, if any."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeaturePortionSpecialization", "aql:self.isPortion and self.ownedTyping.type->exists(i | i.oclIsKindOf(sysml::Class)) and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::Class) or self.owningType.oclIsKindOf(sysml::Feature) and self.owningType.oclAsType(sysml::Feature).type->exists(e | e.oclIsKindOf(sysml::Class))) implies self.specializesFromLibrary('Occurrence::Occurrence::portions')", "If a Feature has isPortion = true, an ownedTyping  relationship to a Class, and an owningType that is a Class or another Feature typed by a Class, then it must directly or indirectly specialize Occurrences::Occurrence::portions from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureReferenceExpression(), "checkFeatureReferenceExpressionBindingConnector", "aql:self.ownedMember->filter(sysml::BindingConnector)->exists(b | b.relatedFeatures->includes(targetFeature) and b.relatedFeatures->includes(self.result))", "A FeatureReferenceExpression must have an ownedMember that is a BindingConnector between the referent and result of the FeatureReferenceExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureReferenceExpression(), "checkFeatureReferenceExpressionResultSpecialization", "aql:self.result.owningType = self and self.result.specializes(self.referent)", "The result parameter of a FeatureReferenceExpression must specialize the referent of the FeatureReferenceExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureResultRedefinition", "aql:self.owningType <> null and (self.owningType.oclIsKindOf(sysml::Function) and self = self.owningType.oclAsType(sysml::Function).result or self.owningType.oclIsKindOf(sysml::Expression) and self = self.owningType.oclAsType(sysml::Expression).result) implies self.owningType.ownedSpecialization.general->select(x | x.oclIsKindOf(sysml::sysml::Function) or x.oclIsKindOf(sysml::sysml::Expression))->forAll(supertype | self.redefines( if superType.oclIsKindOf(sysml::Function) then superType.oclAsType(sysml::Function).result else superType.oclAsType(sysml::Expression).result endif))", "If a Feature is a result parameter of an owningType that is a Function or Expression, then, for each direct supertype of its owningType that is also a Function or Expression, it must redefine the result parameter."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureSpecialization", "aql:self.specializesFromLibrary('Base::things')", "A Feature must directly or indirectly specialize Base::things from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureSubobjectSpecialization", "aql:self.isComposite and self.ownedTyping.type->exists(i | i.oclIsKindOf(sysml::Structure)) and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::Structure) or self.owningType.type->exists(i | i.oclIsKindOf(sysml::Structure))) implies self.specializesFromLibrary('Occurrence::Occurrence::suboccurrences')", "A composite Feature typed by a Structure, and whose ownedType is a Structure or another Feature typed by a Structure must directly or indirectly specialize Objects::Object::subobjects."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureSuboccurrenceSpecialization", "aql:self.isComposite and self.ownedTyping.type->exists(i | i.oclIsKindOf(sysml::Class)) and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::Class) or self.owningType.oclIsKindOf(sysml::Feature) and self.owningType.oclAsType(sysml::Feature).type->exists(e | e.oclIsKindOf(sysml::Class))) implies self.specializesFromLibrary('Occurrence::Occurrence::suboccurrences')", "A composite Feature that has an ownedTyping relationship to a Class, and whose ownedType is a Class or another Feature typed by a Class, must directly or indirectly specialize Occurrences::Occurrence::suboccurrences."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureValuationSpecialization", "aql:self.direction = null and self.ownedSpecialization->forAll(i | i.isImplied) implies self.ownedMembership->filter(sysml::FeatureValue)->forAll(fv | self.specializes(fv.value.result))", "If a Feature has a FeatureValue, no ownedSpecializations that are not implied, and is not directed, then it must specialize the result of the value Expression of the FeatureValue."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureValue(), "checkFeatureValueBindingConnector", "aql:not self.isDefault implies self.featureWithValue.ownedMember->filter(sysml::BindingConnector)->exists(b | b.relatedFeature->includes(featureWithValue) and b.relatedFeature->exists(f | f.chainingFeature = Sequence{value, self.value.result}) and if not self.isInitial then b.featuringType = self.featureWithValue.featuringType else b.featuringType->exists(t | t.oclIsKindOf(sysml::Feature) and t.oclAsType(sysml::Feature).chainingFeature = Sequence{ self.resolveGlobal('Base::things::that').memberElement, self.resolveGlobal('Occurrences::Occurrence::startShot').memberElement } ) endif)", "If isDefault = false, then the featureWithValue must have an ownedMember that is a BindingConnector whose relatedElements are the featureWithValue and a feature chain consisting of the value Expression and its result. If isInitial = false, then this BindingConnector must have featuringTypes that are the same as those of the featureWithValue. If isInitial = true, then the BindingConnector must have that.startShot as its featuringType."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFlowDefinition(), "checkFlowDefinitionBinarySpecialization", "aql:self.flowEnd->size() = 2 implies self.specializesFromLibrary('Flows::Message')", "A binary FlowDefinition must directly or indirectly specialize the base FlowDefinition Flows::Message from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFlowDefinition(), "checkFlowDefinitionSpecialization", "aql:self.specializesFromLibrary('Flows::MessageAction')", "A FlowDefinition must directly or indirectly specialize the base FlowDefinition Flows::MessageAction from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFlow(), "checkFlowSpecialization", "aql:self.specializesFromLibrary('Transfers::transfers')", "A Flow must directly or indirectly specialize the Step Transfers::transfers from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFlowUsage(), "checkFlowUsageFlowSpecialization", "aql:self.ownedEndFeatures->notEmpty() implies self.specializesFromLibrary('Flows::flows')", "If a FlowUsage has ownedEndFeatures, it must directly or indirectly specialize the FlowUsage Flows::flows from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFlowUsage(), "checkFlowUsageSpecialization", "aql:self.specializesFromLibrary('Flows::messages')", "A FlowUsage must directly or indirectly specialize the base FlowUsage Flows::messages from the Systems Library model."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFlow(), "checkFlowWithEndsSpecialization", "aql:self.ownedEndFeatures->notEmpty() implies self.specializesFromLibrary('Transfers::flowTransfers')", "A Flow with ownedEndFeatures must specialize the Step Transfers::flowTransfers from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForLoopActionUsage(), "checkForLoopActionUsageSpecialization", "aql:self.specializesFromLibrary('Actions::forLoopActions')", "A ForLoopActionUsage must directly or indirectly specialize the ActionUsage Actions::forLoopActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForLoopActionUsage(), "checkForLoopActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() implies self.specializesFromLibrary('Actions::Action::forLoops')", "A composite ForLoopActionUsage that is a subaction usage must directly or indirectly specialize the ActionUsage Actions::Action::forLoops from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForLoopActionUsage(), "checkForLoopActionUsageVarRedefinition", "aql:self.loopVariable <> null and self.loopVariable.redefinesFromLibrary('Actions::ForLoopAction::var')", "The loopVariable of a ForLoopActionUsage must redefine the ActionUsage Actions::ForLoopAction::var."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForkNode(), "checkForkNodeSpecialization", "aql:self.specializesFromLibrary('Actions::Action::forks')", "A ForkNode must directly or indirectly specialize the ActionUsage Actions::Action::forks from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFunction(), "checkFunctionResultBindingConnector", "aql:self.ownedMembership->filter(sysml::ResultExpressionMembership)->forAll(mem | self.ownedFeature.oclIsKindOf(sysml::BindingConnector)->exists(binding | binding.relatedFeature->includes(self.result) and binding.relatedFeature->includes(mem.ownedResultExpression.result)))", "If a Function has an Expression owned via a ResultExpressionMembership, then the owning Function must also own a BindingConnector between its result parameter and the result parameter of the result Expression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFunction(), "checkFunctionSpecialization", "aql:self.specializesFromLibrary('Performances::Evaluation')", "A Function must directly or indirectly specialize the base Function Performances::Evaluation from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getIfActionUsage(), "checkIfActionUsageSpecialization", "aql:if self.elseAction = null then self.specializesFromLibrary('Actions::ifThenActions') else self.specializesFromLibrary('Actions::ifThenElseActions') endif", "A IfActionUsage must directly or indirectly specialize the ActionUsage Actions::ifThenActions from the Systems Model Library. If it has an elseAction, then it must directly or indirectly specialize Actions::ifThenElseActions."),
          new ValidationRule(SysmlPackage.eINSTANCE.getIfActionUsage(), "checkIfActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() implies self.specializesFromLibrary('Actions::Action::ifSubactions')", "A composite IfActionUsage that is a subaction usage must directly or indirectly specialize the ActionUsage Actions::Action::ifSubactions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getIncludeUseCaseUsage(), "checkIncludeUseCaseSpecialization", "aql:self.owningType <> null and (self.owningType.oclIsKindOf(sysml::UseCaseDefinition) or self.owningType.oclIsKindOf(sysml::UseCaseUsage) implies self.specializesFromLibrary('UseCases::UseCase::includedUseCases')", "A IncludeUseCaseUsage whose owningType is a UseCaseDefinition or UseCaseUsage must directly or indirectly specialize the UseCaseUsage UseCases::UseCase::includedUseCases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getIndexExpression(), "checkIndexExpressionResultSpecialization", "aql:self.arguments->notEmpty() and not self.arguments->first().result.specializesFromLibrary('Collections::Array') implies self.result.specializes(arguments->first().result)", "The result of an IndexExpression must specialize the result parameter of the first argument of the IndexExpression, unless that result already directly or indirectly specializes the DataType Collections::Array from the Kernel Data Type Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInterfaceDefinition(), "checkInterfaceDefinitionBinarySpecialization", "aql:self.ownedEndFeature->size() = 2 implies self.specializesFromLibrary('Interfaces::BinaryInterface')", "A binary InterfaceDefinition must directly or indirectly specialize the InterfaceDefinition Interfaces::BinaryInterface from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInterfaceDefinition(), "checkInterfaceDefinitionSpecialization", "aql:self.specializesFromLibrary('Interfaces::Interface')", "An InterfaceDefinition must directly or indirectly specialize the InterfaceDefinition Interfaces::Interface from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInterfaceUsage(), "checkInterfaceUsageBinarySpecialization", "aql:self.ownedEndFeature->size() = 2 implies self.specializesFromLibrary('Interfaces::binaryInterfaces')", "A binary InterfaceUsage must directly or indirectly specialize the InterfaceUsage Interfaces::binaryInterfaces from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInterfaceUsage(), "checkInterfaceUsageSpecialization", "aql:self.specializesFromLibrary('Interfaces::interfaces')", "An InterfaceUsage must directly or indirectly specialize the InterfaceUsage Interfaces::interfaces from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInvariant(), "checkInvariantSpecialization", "aql:if self.isNegated then self.specializesFromLibrary('Performances::falseEvaluations') else self.specializesFromLibrary('Performances::trueEvaluations') endif", "An Invariant must directly or indirectly specialize either of the following BooleanExpressions from the Kernel Semantic Library: Performances::trueEvaluations, if isNegated = false, or  Performances::falseEvaluations, if isNegated = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInvocationExpression(), "checkInvocationExpressionBehaviorBindingConnector", "aql:not self.instantiatedType.oclIsKindOf(sysml::Function) and not (self.instantiatedType.oclIsKindOf(sysml::Feature) and self.instantiatedType.oclAsType(sysml::Feature).type->exists(e | e.oclIsKindOf(sysml::Function))) implies self.ownedFeature.oclIsKindOf(sysml::BindingConnector)->exists( relatedFeature->includes(self) and relatedFeature->includes(self.result))", "If the instantiatedType of an InvocationExpression is neither a Function nor a Feature whose type is a Function, then the InvocationExpression must own a BindingConnector between itself and its result parameter."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInvocationExpression(), "checkInvocationExpressionBehaviorResultSpecialization", "aql:not self.instantiatedType.oclIsKindOf(sysml::Function) and not (self.instantiatedType.oclIsKindOf(sysml::Feature) and self.instantiatedType.oclAsType(sysml::Feature).type->exists(e | e.oclIsKindOf(sysml::Function))) implies self.result.specializes(instantiatedType)", "If the instantiatedType of an InvocationExpression is neither a Function nor a Feature whose type is a Function, then the result of the InvocationExpression must specialize the instantiatedType."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInvocationExpression(), "checkInvocationExpressionSpecialization", "aql:self.specializes(instantiatedType)", "An InvocationExpression must specialize its instantiatedType."),
          new ValidationRule(SysmlPackage.eINSTANCE.getItemDefinition(), "checkItemDefinitionSpecialization", "aql:self.specializesFromLibrary('Items::Item')", "An ItemDefinition must directly or indirectly specialize the Systems Library Model ItemDefinition Items::Item."),
          new ValidationRule(SysmlPackage.eINSTANCE.getItemUsage(), "checkItemUsageSpecialization", "aql:self.specializesFromLibrary('Items::items')", "An ItemUsage must directly or indirectly specialize the Systems Model Library ItemUsage items."),
          new ValidationRule(SysmlPackage.eINSTANCE.getItemUsage(), "checkItemUsageSubitemSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::ItemDefinition) or self.owningType.oclIsKindOf(sysml::ItemUsage)) implies self.specializesFromLibrary('Items::Item::subitem')", ""),
          new ValidationRule(SysmlPackage.eINSTANCE.getJoinNode(), "checkJoinNodeSpecialization", "aql:self.specializesFromLibrary('Actions::Action::join')", "A JoinNode must directly or indirectly specialize the ActionUsage Actions::Action::joins from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLiteralBoolean(), "checkLiteralBooleanSpecialization", "aql:self.specializesFromLibrary('Performances::literalBooleanEvaluations')", "A LiteralBoolean must directly or indirectly specialize Performances::literalBooleanEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLiteralExpression(), "checkLiteralExpressionSpecialization", "aql:self.specializesFromLibrary('Performances::literalEvaluations')", "A LiteralExpression must directly or indirectly specialize the base LiteralExpression Performances::literalEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLiteralInfinity(), "checkLiteralInfinitySpecialization", "aql:self.specializesFromLibrary('Performances::literalIntegerEvaluations')", "A LiteralInfinity must directly or indirectly specialize Performances::literalIntegerEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLiteralInteger(), "checkLiteralIntegerSpecialization", "aql:self.specializesFromLibrary('Performances::literalIntegerEvaluations')", "A LiteralInteger must directly or indirectly specialize Performances::literalIntegerEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLiteralRational(), "checkLiteralRationalSpecialization", "aql:self.specializesFromLibrary('Performances::literalRationalEvaluations')", "A LiteralRational must directly or indirectly specialize Performances::literalRationalEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLiteralString(), "checkLiteralStringSpecialization", "aql:self.specializesFromLibrary('Performances::literalStringEvaluations')", "A LiteralString must directly or indirectly specialize Performances::literalStringEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMergeNode(), "checkMergeNodeIncomingSuccessionSpecialization", "aql:self.targetConnector->filter(sysml::Succession)->forAll(subsetsChain(self, self.resolveGlobal('ControlPerformances::MergePerformance::incomingHBLink')))", "All incoming Successions to a MergeNode must subset the inherited incomingHBLink feature of the MergeNode."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMergeNode(), "checkMergeNodeSpecialization", "aql:self.specializesFromLibrary('Actions::Action::merges')", "A MergeNode must directly or indirectly specialize the ActionUsage Actions::Action::merges from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetaclass(), "checkMetaclassSpecialization", "aql:self.specializesFromLibrary('Metaobjects::Metaobject')", "A Metaclass must directly or indirectly specialize the base Metaclass Metaobjects::Metaobject from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataAccessExpression(), "checkMetadataAccessExpressionSpecialization", "aql:self.specializesFromLibrary('Performances::metadataAccessEvaluations')", "A MetadataAccessExpression must directly or indirectly specialize the base MetadataAccessExpression Performances::metadataAccessEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataDefinition(), "checkMetadataDefinitionSpecialization", "aql:self.specializesFromLibrary('Metadata::MetadataItem')", "A MetadataDefinition must directly or indirectly specialize the base MetadataDefinition Metadata::MetadataItem from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataFeature(), "checkMetadataFeatureSemanticSpecialization", "aql:self.isSemantic() implies let annotatedTypes : Sequence(sysml::Type) = self.annotatedElement->selectAsKind(Type) in let baseTypes : Sequence(sysml::MetadataFeature) = self.evaluateFeature(resolveGlobal( 'Metaobjects::SemanticMetadata::baseType').memberElement.oclAsType(sysml::Feature))->selectAsKind(MetadataFeature) in annotatedTypes->notEmpty() and baseTypes()->notEmpty() and baseTypes()->first().isSyntactic() implies let annotatedType : sysml::Type = annotatedTypes->first() in let baseType : sysml::Element = baseTypes->first().syntaxElement() in if annotatedType.oclIsKindOf(sysml::Classifier) and baseType.oclIsKindOf(sysml::Feature) then baseType.oclAsType(sysml::Feature).type->forAll(t | annotatedType.specializes(t)) else if baseType.oclIsKindOf(sysml::Type) then annotatedType.specializes(baseType.oclAsType(sysml::Type)) else true endif", "If this MetadataFeature is an application of SemanticMetadata, then its annotatingElement must be a Type. The annotated Type must then directly or indirectly specialize the specified value of the baseType, unless the Type is a Classifier and the baseType represents a kind of Feature, in which case the Classifier must directly or indirectly specialize each of the types of the Feature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataFeature(), "checkMetadataFeatureSpecialization", "aql:self.specializesFromLibrary('Metaobjects::metaobjects')", "A MetadataFeature must directly or indirectly specialize the base MetadataFeature Metaobjects::metaobjects from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataUsage(), "checkMetadataUsageSpecialization", "aql:self.specializesFromLibrary('Metadata::metadataItems')", "A MetadataUsage must directly or indirectly specialize the base MetadataUsage Metadata::metadataItems from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMultiplicityRange(), "checkMultiplicityRangeExpressionTypeFeaturing", "aql:self.bound->forAll(b | b.featuringType = self.featuringType)", "The bounds of a MultiplicityRange must have the same featuringTypes as the MultiplicityRange."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMultiplicity(), "checkMultiplicitySpecialization", "aql:self.specializesFromLibrary('Base::naturals')", "A Multiplicity must directly or indirectly specialize the Feature Base::naturals from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMultiplicity(), "checkMultiplicityTypeFeaturing", "aql:if self.owningType <> null and self.owningType.oclIsKindOf(sysml::Feature) then self.featuringType = self.owningType.oclAsType(sysml::Feature).featuringType else self.featuringType->isEmpty() endif", "If the owningType of a Multiplicity is a Feature, then the Multiplicity must have the same featuringTypes as that Feature. Otherwise, it must have no featuringTypes (meaning that it is implicitly featured by the base Classifier Anything)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getNullExpression(), "checkNullExpressionSpecialization", "aql:self.specializesFromLibrary('Performances::nullEvaluations')", "A NullExpression must directly or indirectly specialize the base NullExpression Performances::nullEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceDefinition(), "checkOccurrenceDefinitionIndividualSpecialization", "aql:self.isIndividual implies self.specializesFromLibrary('Occurrences::Life')", "An OccurrenceDefinition with isIndividual = true must directly or indirectly specialize Occurrences::Life from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceDefinition(), "checkOccurrenceDefinitionMultiplicitySpecialization", "aql:self.isIndividual implies self.multiplicity <> null and self.multiplicity.specializesFromLibrary('Base::zeroOrOne')", "An OccurrenceDefinition with isIndividual = true must have a multiplicity that specializes Base::zeroOrOne from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceUsage(), "checkOccurrenceUsageSnapshotSpecialization", "aql:self.portionKind = sysml::PortionKind::snapshot implies self.specializesFromLibrary('Occurrences::Occurrence::snapshots')", "If an OccurrenceUsage has portionKind = snapshot, then it must directly or indirectly specialize Occurrences::Occurrence::snapshots from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceUsage(), "checkOccurrenceUsageSpecialization", "aql:self.specializesFromLibrary('Occurrences::occurrences')", "An OccurrenceUsage must directly or indirectly specialize Occurrences::occurrences from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceUsage(), "checkOccurrenceUsageSuboccurrenceSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::Class) or self.owningType.oclIsKindOf(sysml::OccurrenceUsage) or self.owningType.oclIsKindOf(sysml::Feature) and self.owningType.oclAsType(sysml::Feature).type->exists(e | e.oclIsKindOf(sysml::Class))) implies self.specializesFromLibrary('Occurrences::Occurrence::suboccurrences')", "A composite OccurrenceUsage, whose ownedType is a Class, another OccurrenceUsage, or any kind of Feature typed by a Class, must directly or indirectly specialize Occurrences::Occurrence::suboccurrences."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceUsage(), "checkOccurrenceUsageTimeSliceSpecialization", "aql:self.portionKind = sysml::PortionKind::timeslice implies self.specializesFromLibrary('Occurrences::Occurrence::timeSlices')", "If an OccurrenceUsage has portionKind = timeslice, then it must directly or indirectly specialize Occurrences::Occurrence::timeSlices from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPartDefinition(), "checkPartDefinitionSpecialization", "aql:self.specializesFromLibrary('Parts::Part')", "A PartDefinition must directly or indirectly specialize the base PartDefinition Parts::Part from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPartUsage(), "checkPartUsageActorSpecialization", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::ActorMembership) implies if self.owningType.oclIsKindOf(sysml::RequirementDefinition) or self.owningType.oclIsKindOf(sysml::RequirementUsage) then self.specializesFromLibrary('Requirements::RequirementCheck::actors') else self.specializesFromLibrary('Cases::Case::actors') endif", "If a PartUsage is owned via an ActorMembership, then it must directly or indirectly specialize either Requirements::RequirementCheck::actors (if its owningType is a RequirementDefinition or RequirementUsage or Cases::Case::actors (otherwise)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPartUsage(), "checkPartUsageSpecialization", "aql:self.specializesFromLibrary('Parts::parts')", "A PartUsage must directly or indirectly specialize the PartUsage Parts::parts from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPartUsage(), "checkPartUsageStakeholderSpecialization", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::StakeholderMembership) implies self.specializesFromLibrary('Requirements::RequirementCheck::stakeholders')", "If a PartUsage is owned via a StakeholderMembership, then it must directly or indirectly specialize either Requirements::RequirementCheck::stakeholders."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPartUsage(), "checkPartUsageSubpartSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::ItemDefinition) or self.owningType.oclIsKindOf(sysml::ItemUsage)) implies self.specializesFromLibrary('Items::Item::subparts')", "A composite PartUsage whose owningType is a ItemDefinition or ItemUsage must directly or indirectly specialize the  PartUsage Items::Item::subparts from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPayloadFeature(), "checkPayloadFeatureRedefinition", "aql:self.redefinesFromLibrary('Transfers::Transfer::payload')", "A PayloadFeature must redefine the Feature Transfers::Transfer::payload from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPerformActionUsage(), "checkPerformActionUsageSpecialization", "aql:self.owningType <> null and (self.owningType.oclIsKindOf(sysml::PartDefinition) or self.owningType.oclIsKindOf(sysml::PartUsage)) implies self.specializesFromLibrary('Parts::Part::performedActions')", "If a PerformActionUsage has an owningType that is a PartDefinition or PartUsage, then it must directly or indirectly specialize the ActionUsage Parts::Part::performedActions."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortDefinition(), "checkPortDefinitionSpecialization", "aql:self.specializesFromLibrary('Ports::Port')", "A PortDefinition must directly or indirectly specialize the PortDefinition Ports::Port from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortUsage(), "checkPortUsageOwnedPortSpecialization", "aql:self.owningType <> null and (self.owningType.oclIsKindOf(sysml::PartDefinition) or self.owningType.oclIsKindOf(sysml::PartUsage)) implies self.specializesFromLibrary('Parts::Part::ownedPorts')", "A PortUsage whose owningType is a PartDefinition or PartUsage must directly or indirectly specialize the PortUsage Parts::Part::ownedPorts from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortUsage(), "checkPortUsageSpecialization", "aql:self.specializesFromLibrary('Ports::ports')", "A PortUsage must directly or indirectly specialize the PortUsage Ports::ports from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortUsage(), "checkPortUsageSubportSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::PortDefinition) or self.owningType.oclIsKindOf(sysml::PortUsage)) implies self.specializesFromLibrary('Ports::Port::subports')", "A composite PortUsage with an owningType that is a PortDefinition or PortUsage must directly or indirectly specialize the PortUsage Ports::Port::subports from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPredicate(), "checkPredicateSpecialization", "aql:self.specializesFromLibrary('Performances::BooleanEvaluation')", "A Predicate must directly or indirectly specialize the base Predicate Performances::BooleanEvaluation from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRenderingDefinition(), "checkRenderingDefinitionSpecialization", "aql:self.specializesFromLibrary('Views::Rendering')", "A RenderingDefinition must directly or indirectly specialize the base RenderingDefinition Views::Rendering from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRenderingUsage(), "checkRenderingUsageRedefinition", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::ViewRenderingMembership) implies self.redefinesFromLibrary('Views::View::viewRendering')", "A RenderingUsage whose owningFeatureMembership is a ViewRenderingMembership must redefine the RenderingUsage Views::View::viewRendering."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRenderingUsage(), "checkRenderingUsageSpecialization", "aql:self.specializesFromLibrary('Views::renderings')", "A RenderingUsage must directly or indirectly specialize the base RenderingUsage Views::renderings from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRenderingUsage(), "checkRenderingUsageSubrenderingSpecialization", "aql:self.owningType <> null and (self.owningType.oclIsKindOf(sysml::RenderingDefinition) or self.owningType.oclIsKindOf(sysml::RenderingUsage)) implies self.specializesFromLibrary('Views::Rendering::subrenderings')", "A RenderingUsage whose owningType is a RenderingDefinition or RenderingUsage must directly or indirectly specialize the RenderingUsage Views::Rendering::subrenderings from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementDefinition(), "checkRequirementDefinitionSpecialization", "aql:self.specializesFromLibrary('Requirements::RequirementCheck')", "A RequirementDefinition must directly or indirectly specialize the base RequirementDefinition Requirements::RequirementCheck from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementUsage(), "checkRequirementUsageObjectiveRedefinition", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::ObjectiveMembership) implies self.owningType.ownedSpecialization.general->forAll(gen | (gen.oclIsKindOf(sysml::CaseDefinition) implies self.redefines(gen.oclAsType(sysml::CaseDefinition).objectiveRequirement)) and (gen.oclIsKindOf(sysml::CaseUsage) implies self.redefines(gen.oclAsType(sysml::CaseUsage).objectiveRequirement)))", "A RequirementUsage whose owningFeatureMembership is a ObjectiveMembership must redefine the objectiveRequirement of each CaseDefinition or CaseUsage that is specialized by the owningType of the RequirementUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementUsage(), "checkRequirementUsageRequirementVerificationSpecialization", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::RequirementVerificationMembership) implies self.specializesFromLibrary('VerificationCases::VerificationCase::obj::requirementVerifications')", "A RequirementUsage whose owningFeatureMembership is a RequirementVerificationMembership must directly or indirectly specialize the RequirementUsage VerificationCases::VerificationCase::obj::requirementVerifications."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementUsage(), "checkRequirementUsageSpecialization", "aql:self.specializesFromLibrary('Requirements::requirementChecks')", "A RequirementUsage must directly or indirectly specialize the base RequirementUsage Requirements::requirementChecks from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementUsage(), "checkRequirementUsageSubrequirementSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::RequirementDefinition) or self.owningType.oclIsKindOf(sysml::RequirementUsage)) implies self.specializesFromLibrary('Requirements::RequirementCheck::subrequirements')", "A composite RequirementUsage whose owningType is a RequirementDefinition or ,code>RequirementUsage must directly or indirectly specialize the RequirementUsage Requirements::RequirementCheck::subrequirements from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSatisfyRequirementUsage(), "checkSatisfyRequirementUsageBindingConnector", "aql:self.ownedMember->filter(sysml::BindingConnector)->select(b | b.relatedElement->includes(subjectParameter) and b.relatedElement->exists(r | r <> self.subjectParameter))->size() = 1", "A SatisfyRequirementUsage must have exactly one ownedMember that is a BindingConnector between its subjectParameter and some Feature other than the subjectParameter."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSatisfyRequirementUsage(), "checkSatisfyRequirementUsageSpecialization", "aql:if self.isNegated then self.specializesFromLibrary('Requirements::notSatisfiedRequirementChecks') else self.specializesFromLibrary('Requirements::satisfiedRequirementChecks') endif", "If a SatisfyRequirementUsage is negated, then it must directly or indirectly specialize the RequirementUsage Requirements::notSatisfiedRequirementChecks. Otherwise, it must directly or indirectly specialize the RequirementUsage Requirements::satisfiedRequirementChecks."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSelectExpression(), "checkSelectExpressionResultSpecialization", "aql:self.arguments->notEmpty() implies self.result.specializes(arguments->first().result)", "The result of a SelectExpression must specialize the result parameter of the first argument of the SelectExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSendActionUsage(), "checkSendActionUsageSpecialization", "aql:self.specializesFromLibrary('Actions::sendActions')", "A SendActionUsage must directly or indirectly specialize the ActionUsage Actions::sendActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSendActionUsage(), "checkSendActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() implies self.specializesFromLibrary('Actions::Action::acceptSubactions')", "A composite SendActionUsage that is a subaction must directly or indirectly specialize the ActionUsage Actions::Action::sendSubactions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateDefinition(), "checkStateDefinitionSpecialization", "aql:self.specializesFromLibrary('States::StateAction')", "A StateDefinition must directly or indirectly specialize the StateDefinition States::StateAction from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateUsage(), "checkStateUsageExclusiveStateSpecialization", "aql:self.isSubstateUsage(false) implies self.specializesFromLibrary('States::StateAction::exclusiveStates')", "A StateUsage that is a substate usage with a non-parallel owning StateDefinition or StateUsage must directly or indirectly specialize the StateUsage States::StateAction::exclusiveStates from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateUsage(), "checkStateUsageOwnedStateSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::PartDefinition) or self.owningType.oclIsKindOf(sysml::PartUsage)) implies self.specializesFromLibrary('Parts::Part::ownedStates')", "A composite StateUsage whose owningType is a PartDefinition or PartUsage must directly or indirectly specialize the StateUsage Parts::Part::ownedStates from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateUsage(), "checkStateUsageSpecialization", "aql:self.specializesFromLibrary('States::stateActions')", "A StateUsage must directly or indirectly specialize the StateUsage States::stateActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateUsage(), "checkStateUsageSubstateSpecialization", "aql:self.isSubstateUsage(true) implies self.specializesFromLibrary('States::StateAction::substates')", "A StateUsage that is a substate usage with a owning StateDefinition or StateUsage that is parallel must directly or indirectly specialize the StateUsage States::StateAction::substates from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStep(), "checkStepEnclosedPerformanceSpecialization", "aql:self.owningType <> null and (self.owningType.oclIsKindOf(sysml::Behavior) or self.owningType.oclIsKindOf(sysml::Step)) implies self.specializesFromLibrary('Performances::Performance::enclosedPerformance')", "AStep whose owningType is a Behavior or another Step must directly or indirectly specialize the Step Performances::Performance::enclosedPerformance."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStep(), "checkStepOwnedPerformanceSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::Structure) or self.owningType.oclIsKindOf(sysml::Feature) and self.owningType.oclAsType(sysml::Feature).type->exists(e | e.oclIsKindOf(sysml::Structure)) implies self.specializesFromLibrary('Objects::Object::ownedPerformance')", "A composite Step whose owningType is a Structure or a Feature typed by a Structure must directly or indirectly specialize the Step Objects::Object::ownedPerformance."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStep(), "checkStepSpecialization", "aql:self.specializesFromLibrary('Performances::performances')", "A Step must directly or indirectly specialize the base Step Performances::performances from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStep(), "checkStepSubperformanceSpecialization", "aql:self.owningType <> null and (self.owningType.oclIsKindOf(sysml::Behavior) or self.owningType.oclIsKindOf(sysml::Step)) and self.isComposite implies self.specializesFromLibrary('Performances::Performance::subperformance')", "AStep whose owningType is a Behavior or another Step, and which is composite, must directly or indirectly specialize the Step Performances::Performance::subperformance."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStructure(), "checkStructureSpecialization", "aql:self.specializesFromLibrary('Objects::Object')", "A Structure must directly or indirectly specialize the base Structure Objects::Object from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSuccessionFlow(), "checkSuccessionFlowSpecialization", "aql:self.specializesFromLibrary('Transfers::flowTransfersBefore')", "A SuccessionFlow must directly or indirectly specialize the Step Transfers::flowTransfersBefore from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSuccessionFlowUsage(), "checkSuccessionFlowUsageSpecialization", "aql:self.specializesFromLibrary('Flows::successionFlows')", "A SuccessionFlowUsage must directly or indirectly specialize the base FlowUsage Flows::successionFlows from the Systems Library model."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSuccession(), "checkSuccessionSpecialization", "aql:self.specializesFromLibrary('Occurrences::happensBeforeLinks')", "A Succession must directly or indirectly specialize the Feature Occurrences::happensBeforeLinks from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTerminateActionUsage(), "checkTerminateActionUsageSpecialization", "aql:self.specializesFromLibrary('Actions::terminateActions')", "A TerminateActionUsage must directly or indirectly specialize the ActionUsage Actions::terminateActions from the Systems Modeling Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTerminateActionUsage(), "checkTerminateActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() implies self.specializesFromLibrary('Actions::Action::terminateSubactions')", "A composite TerminateActionUsage that is a subaction must must directly or indirectly specialize the ActionUsage Actions::Action::terminateSubactions from the Systems Modeling Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageActionSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::ActionDefinition) or self.owningType.oclIsKindOf(sysml::ActionUsage)) and self.source <> null and not self.source.oclIsKindOf(sysml::StateUsage) implies self.specializesFromLibrary('Actions::Action::decisionTransitions')", "A composite TransitionUsage whose owningType is an ActionDefinition or ActionUsage and whose source is not a StateUsage must directly or indirectly specialize the ActionUsage Actions::Action::decisionTransitions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsagePayloadSpecialization", "aql:self.triggerAction->notEmpty() implies let payloadParameter : sysml::Feature = self.inputParameter(2) in payloadParameter <> null and payloadParameter.subsetsChain(triggerAction->at(1), self.triggerPayloadParameter())", "If a TransitionUsage has a triggerAction, then the payload parameter of the TransitionUsage subsets the Feature chain of the triggerAction and its payloadParameter."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageSourceBindingConnector", "aql:self.ownedMember->filter(sysml::BindingConnector)->exists(b | b.relatedFeatures->includes(self.source) and b.relatedFeatures->includes(inputParameter(1)))", "A TransitionUsage must have an ownedMember that is a BindingConnector between its source and its first input parameter (which redefines Actions::TransitionAction::transitionLinkSource)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageSpecialization", "aql:self.specializesFromLibrary('Actions::transitionActions')", "A TransitionUsage must directly or indirectly specialize the ActionUsage Actions::transitionActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageStateSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::StateDefinition) or self.owningType.oclIsKindOf(sysml::StateUsage)) and self.source <> null and self.source.oclIsKindOf(sysml::StateUsage) implies self.specializesFromLibrary('States::StateAction::stateTransitions')", "A composite TransitionUsage whose owningType is a StateDefinition or StateUsage and whose source is a StateUsage must directly or indirectly specialize the ActionUsage States::StateAction::stateTransitions from the Systems Model Library"),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageSuccessionBindingConnector", "aql:self.ownedMember->filter(sysml::BindingConnector)->exists(b | b.relatedFeatures->includes(succession) and b.relatedFeatures->includes(resolveGlobal( 'TransitionPerformances::TransitionPerformance::transitionLink')))", "A TransitionUsage must have an ownedMember that is a BindingConnector between its succession and the inherited Feature TransitionPerformances::TransitionPerformance::transitionLink."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageSuccessionSourceSpecialization", "aql:self.succession.sourceFeature = self.source", "The sourceFeature of the succession of a TransitionUsage must be the source of the TransitionUsage (i.e., the first connectorEnd of the succession must have a ReferenceSubsetting Relationship with the source)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageTransitionFeatureSpecialization", "aql:self.triggerAction->forAll(specializesFromLibrary('Actions::TransitionAction::accepter') and self.guardExpression->forAll(specializesFromLibrary('Actions::TransitionAction::guard') and self.effectAction->forAll(specializesFromLibrary('Actions::TransitionAction::effect'))", "The triggerActions, guardExpressions, and effectActions of a TransitionUsage must specialize, respectively, the accepter, guard, and effect features of the ActionUsage Actions::TransitionActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "checkTypeSpecialization", "aql:self.specializesFromLibrary('Base::Anything')", "A Type must directly or indirectly specialize Base::Anything from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getUseCaseDefinition(), "checkUseCaseDefinitionSpecialization", "aql:self.specializesFromLibrary('UseCases::UseCase')", "A UseCaseDefinition must directly or indirectly specializes the base UseCaseDefinition UseCases::UseCase from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getUseCaseUsage(), "checkUseCaseUsageSpecialization", "aql:self.specializesFromLibrary('UseCases::useCases')", "A UseCaseUsage must directly or indirectly specializes the base UseCaseUsage UseCases::useCases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getUseCaseUsage(), "checkUseCaseUsageSubUseCaseSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::UseCaseDefinition) or self.owningType.oclIsKindOf(sysml::UseCaseUsage)) implies self.specializesFromLibrary('UseCases::UseCase::subUseCases')", "A composite UseCaseUsage whose owningType is a UseCaseDefinition or UseCaseUsage must specialize the UseCaseUsage UseCases::UseCase::subUseCases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getVerificationCaseDefinition(), "checkVerificationCaseSpecialization", "aql:self.specializesFromLibrary('VerificationCases::VerificationCase')", "A VerificationCaseDefinition must directly or indirectly specialize the base VerificationCaseDefinition VerificationCases::VerificationCase from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getVerificationCaseUsage(), "checkVerificationCaseUsageSpecialization", "aql:self.specializesFromLibrary('VerificationCases::verificationCases')", "A VerificationCaseUsage must subset, directly or indirectly, the base VerificationCaseUsage VerificationCases::verificationCases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getVerificationCaseUsage(), "checkVerificationCaseUsageSubVerificationCaseSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::VerificationCaseDefinition) or self.owningType.oclIsKindOf(sysml::VerificationCaseUsage)) implies self.specializesFromLibrary('VerificationCases::VerificationCase::subVerificationCases')", "If it is composite and owned by a VerificationCaseDefinition or VerificationCaseUsage, then it must specialize VerificationCaseUsage VerificationCases::VerificationCase::subVerificationCases."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewDefinition(), "checkViewDefinitionSpecialization", "aql:self.specializesFromLibrary('Views::View')", "A ViewDefinition must directly or indirectly specialize the base ViewDefinition Views::View from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewUsage(), "checkViewUsageSpecialization", "aql:self.specializesFromLibrary('Views::views')", "A ViewUsage must directly or indirectly specialize the base ViewUsage Views::views from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewUsage(), "checkViewUsageSubviewSpecialization", "aql:self.owningType <> null and (self.owningType.oclIsKindOf(sysml::ViewDefinition) or self.owningType.oclIsKindOf(sysml::ViewUsage)) implies self.specializesFromLibrary('Views::View::subviews')", "A ViewUsage whose owningType is a ViewDefinition or ViewUsage must specialize the ViewUsage Views::View::subviews from the Systems Library Model."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewpointDefinition(), "checkViewpointDefinitionSpecialization", "aql:self.specializesFromLibrary('Views::Viewpoint')", "A ViewpointDefinition must directly or indirectly specialize the base ViewpointDefinition Views::Viewpoint from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewpointUsage(), "checkViewpointUsageSpecialization", "aql:self.specializesFromLibrary('Views::viewpoints')", "A ViewpointUsage must directly or indirectly specialize the base ViewpointUsage Views::viewpoints from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewpointUsage(), "checkViewpointUsageViewpointSatisfactionSpecialization", "aql:self.isComposite and self.owningType <> null and (self.owningType.oclIsKindOf(sysml::ViewDefinition) or self.owningType.oclIsKindOf(sysml::ViewUsage)) implies self.specializesFromLibrary('Views::View::viewpointSatisfactions')", "A composite ViewpointUsage whose owningType is a ViewDefinition or ViewUsage must directly or indirectly specialize the ViewpointUsage Views::View::viewpointSatisfactions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getWhileLoopActionUsage(), "checkWhileLoopActionUsageSpecialization", "aql:self.specializesFromLibrary('Actions::whileLoopActions')", "A WhileLoopActionUsage must directly or indirectly specialize the ActionUsage Actions::whileLoopActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getWhileLoopActionUsage(), "checkWhileLoopActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() implies self.specializesFromLibrary('Actions::Action::whileLoops')", "A composite WhileLoopActionUsage that is a subaction usage must directly or indirectly specialize the ActionUsage Actions::Action::whileLoops from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAcceptActionUsage(), "validateAcceptActionUsageParameters", "aql:self.inputParameters()->size() >= 2", "An AcceptUsageAction must have at least two input parameters, corresponding to its payload and receiver, respectively (even if they have no FeatureValue). (Note that the payloadParameter is an input as well as an output.)"),
          new ValidationRule(SysmlPackage.eINSTANCE.getActorMembership(), "validateActorMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::RequirementUsage) or self.owningType.oclIsKindOf(sysml::RequirementDefinition) or self.owningType.oclIsKindOf(sysml::CaseDefinition) or self.owningType.oclIsKindOf(sysml::CaseUsage)", "The owningType of an ActorMembership must be a RequirementDefinition, RequirementUsage, CaseDefinition, or CaseUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAnnotation(), "validateAnnotationAnnotatedElementOwnership", "aql:(self.owningAnnotatedElement <> null) = (self.ownedAnnotatingElement <> null)", "An Annotation owns its annotatingElement if and only if it is owned by its annotatedElement."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAnnotation(), "validateAnnotationAnnotatingElement", "aql:self.ownedAnnotatingElement <> null xor self.owningAnnotatingElement <> null", "Either the ownedAnnotatingElement of an Annotation must be non-null, or the owningAnnotatingElement must be non-null, but not both."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssertConstraintUsage(), "validateAssertConstraintUsageReference", "aql:self.referencedFeatureTarget() <> null implies self.referencedFeatureTarget().oclIsKindOf(sysml::ConstraintUsage)", "If an AssertConstraintUsage has an ownedReferenceSubsetting, then the featureTarget of its referencedFeature must be a ConstraintUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssignmentActionUsage(), "validateAssignmentActionUsage", "aql:self.referent <> null implies self.referent.featureTarget.mayTimeVary", "The featureTarget of the referent of an AssignmentActionUsage must be able to have time-varying values."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssignmentActionUsage(), "validateAssignmentActionUsageReferent", "aql:self.ownedMembership->exists(e | not e.oclIsKindOf(sysml::OwningMembership) and self.memberElement.oclIsKindOf(sysml::Feature))", "An AssignmentActionUsage must have an ownedMembership that is not an OwningMembership and whose memberElement is a Feature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociation(), "validateAssociationBinarySpecialization", "aql:self.associationEnd->size() > 2 implies not self.specializesFromLibrary('Links::BinaryLink')", "If an Association has more than two associationEnds, then it must not specialize, directly or indirectly, the Association BinaryLink from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociation(), "validateAssociationEndTypes", "aql:self.ownedEndFeature->forAll(x | x.type->size() = 1)", "The ownedEndFeatures of an Association must have exactly one type."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociation(), "validateAssociationRelatedTypes", "aql:not self.isAbstract implies self.relatedType->size() >= 2", "If an Association is concrete (not abstract), then it must have at least two relatedTypes."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociation(), "validateAssociationStructureIntersection", "aql:self.oclIsKindOf(sysml::Structure) = self.oclIsKindOf(sysml::AssociationStructure)", "If an Association is also a kind of Structure, then it must be an AssociationStructure."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAttributeDefinition(), "validateAttributeDefinitionFeatures", "aql:self.feature->forAll(i | not i.isComposite)", "All features of an AttributeDefinition must be non-composite."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAttributeUsage(), "validateAttributeUsageFeatures", "aql:self.feature->forAll(i | not i.isComposite)", "All features of an AttributeUsage must be non-composite."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAttributeUsage(), "validateAttributeUsageIsReference", "aql:self.isReference", "An AttributeUsage is always referential."),
          new ValidationRule(SysmlPackage.eINSTANCE.getBehavior(), "validateBehaviorSpecialization", "aql:self.ownedSpecialization.general->forAll(i | not i.oclIsKindOf(sysml::Structure))", "A Behavior must not specialize a Structure."),
          new ValidationRule(SysmlPackage.eINSTANCE.getBindingConnector(), "validateBindingConnectorIsBinary", "aql:self.relatedFeature->size() = 2", "A BindingConnector must be binary."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseDefinition(), "validateCaseDefinitionOnlyOneObjective", "aql:self.featureMembership->filter(sysml::ObjectiveMembership)->size() <= 1", "A CaseDefinition must have at most one featureMembership that is a ObjectiveMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseDefinition(), "validateCaseDefinitionOnlyOneSubject", "aql:self.featureMembership->filter(sysml::SubjectMembership)->size() <= 1", "A CaseDefinition must have at most one featureMembership that is a SubjectMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseDefinition(), "validateCaseDefinitionSubjectParameterPosition", "aql:self.input->notEmpty() and self.input->first() = self.subjectParameter", "The subjectParameter of a CaaseDefinition must be its first input."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseUsage(), "validateCaseUsageOnlyOneObjective", "aql:self.featureMembership->filter(sysml::ObjectiveMembership)->size() <= 1", "A CaseUsage must have at most one featureMembership that is a ObjectiveMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseUsage(), "validateCaseUsageOnlyOneSubject", "aql:self.featureMembership->filter(sysml::SubjectMembership)->size() <= 1", "A CaseUsage must have at most one featureMembership that is a SubjectMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseUsage(), "validateCaseUsageSubjectParameterPosition", "aql:self.input->notEmpty() and self.input->first() = self.subjectParameter", "The subjectParameter of a CaseUsage must be its first input."),
          new ValidationRule(SysmlPackage.eINSTANCE.getClass_(), "validateClassSpecialization", "aql:self.ownedSpecialization.general->forAll(i | not i.oclIsKindOf(sysml::DataType)) and not i.oclIsKindOf(sysml::Association) implies self.ownedSpecialization.general->forAll(i | not i.oclIsKindOf(sysml::Association))", "A Class must not specialize a DataType and it can only specialize an Association if it is also itself a kind of Association (such as an AssociationStructure or Interaction)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getClassifier(), "validateClassifierMultiplicityDomain", "aql:self.multiplicity <> null implies self.multiplicity.featuringType->isEmpty()", "If a Classifier has a multiplicity, then the multiplicity must have no featuringTypes (meaning that its domain is implicitly Base::Anything)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCollectExpression(), "validateCollectExpressionOperator", "aql:self.operator = 'collect'", "The operator of a CollectExpression must be 'collect'."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConjugatedPortDefinition(), "validateConjugatedPortDefinitionConjugatedPortDefinitionIsEmpty", "aql:self.conjugatedPortDefinition = null", "A ConjugatedPortDefinition must not itself have a conjugatedPortDefinition."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConjugatedPortDefinition(), "validateConjugatedPortDefinitionOriginalPortDefinition", "aql:self.ownedPortConjugator.originalPortDefinition = self.originalPortDefinition", "The originalPortDefinition of the ownedPortConjugator of a ConjugatedPortDefinition must be the originalPortDefinition of the ConjugatedPortDefinition."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnectionDefinition(), "validateConnectionDefinitionIsSufficient", "aql:self.isSufficient", "A ConnectionDefinition must have isSufficient = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "validateConnectorBinarySpecialization", "aql:self.connectorEnd->size() > 2 implies not self.specializesFromLibrary('Links::BinaryLink')", "If a Connector has more than two connectorEnds, then it must not specialize, directly or indirectly, the Association BinaryLink from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "validateConnectorRelatedFeatures", "aql:not self.isAbstract implies self.relatedFeature->size() >= 2", "If a Connector is concrete (not abstract), then it must have at least two relatedFeatures."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstructorExpression(), "validateConstructorExpressionNoDuplicateFeatureRedefinition", "aql:let features : OrderedSet(sysml::Feature) = self.instantiatedType.feature->select(visibility = sysml::VisibilityKind::public) in self.result.ownedFeature->forAll(f1 | self.result.ownedFeature->forAll(f2 | f1 <> f2 implies f1.ownedRedefinition.redefinedFeature->intersection(f2.ownedRedefinition.redefinedFeature)->intersection(features)->isEmpty()))", "Two different ownedFeatures of the result of a ConstructorExpression must not redefine the same feature of the instantiatedType of the ConstructorExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstructorExpression(), "validateConstructorExpressionOwnedFeatures", "aql:self.ownedFeatures->excluding(result)->isEmpty()", "A ConstructorExpression must not have any ownedFeatures other than its result."),
          new ValidationRule(SysmlPackage.eINSTANCE.getControlNode(), "validateControlNodeIncomingSuccessions", "aql:self.targetConnector->filter(sysml::Succession)->collect(connectorEnd->at(2).multiplicity)->forAll(targetMult | self.multiplicityHasBounds(targetMult, 1, 1))", "All incoming Successions to a ControlNode must have a target multiplicity of 1..1."),
          new ValidationRule(SysmlPackage.eINSTANCE.getControlNode(), "validateControlNodeIsComposite", "aql:self.isComposite", "A ControlNode must be composite."),
          new ValidationRule(SysmlPackage.eINSTANCE.getControlNode(), "validateControlNodeOutgoingSuccessions", "aql:self.sourceConnector->filter(sysml::Succession)->collect(connectorEnd->at(1).multiplicity)->forAll(sourceMult | self.multiplicityHasBounds(sourceMult, 1, 1))", "All outgoing Successions from a ControlNode must have a source multiplicity of 1..1."),
          new ValidationRule(SysmlPackage.eINSTANCE.getControlNode(), "validateControlNodeOwningType", "aql:self.owningType <> null and (self.owningType.oclIsKindOf(sysml::ActionDefinition) or self.owningType.oclIsKindOf(sysml::ActionUsage))", "The owningType of a ControlNode must be an ActionDefinition or ActionUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCrossSubsetting(), "validateCrossSubsettingCrossedFeature", "aql:self.crossingFeature.isEnd and self.crossingFeature.owningType <> null implies let endFeatures: Sequence(sysml::Feature) = self.crossingFeature.owningType.endFeature in let chainingFeatures: Sequence(sysml::Feature) = self.crossedFeature.chainingFeature in chainingFeatures->size() = 2 and endFeatures->size() = 2 implies chainingFeatures->at(1) = endFeatures->excluding(crossingFeature)->at(1)", "The crossedFeature of a CrossSubsetting must have exactly two chainingFeatures. If the crossingFeature of the CrossSubsetting is one of two end Features, then the first chainingFeature must be the other end Feature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCrossSubsetting(), "validateCrossSubsettingCrossingFeature", "aql:self.crossingFeature.isEnd and self.crossingFeature.owningType<>null and self.crossingFeature.owningType.endFeature ->size() > 1", "The crossingFeature of a CrossSubsetting must be an end Feature that is owned by a Type with at least two end Features."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDataType(), "validateDataTypeSpecialization", "aql:self.ownedSpecialization.general->forAll(i | not i.oclIsKindOf(sysml::Class) and not i.oclIsKindOf(sysml::Association))", "A DataType must not specialize a Class or an Association."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDecisionNode(), "validateDecisionNodeIncomingSuccessions", "aql:self.targetConnector->filter(sysml::Succession)->size() <= 1", "A DecisionNode may have at most one incoming Succession."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDecisionNode(), "validateDecisionNodeOutgoingSuccessions", "aql:self.sourceConnector->selectAsKind(Succession)->collect(connectorEnd->at(2))->forAll(targetMult | self.multiplicityHasBounds(targetMult, 0, 1))", "All outgoing Successions from a DecisionNode must have a target multiplicity of 0..1."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDefinition(), "validateDefinitionVariationIsAbstract", "aql:self.isVariation implies self.isAbstract", "If a Definition is a variation, then it must be abstract."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDefinition(), "validateDefinitionVariationOwnedFeatureMembership", "aql:self.isVariation implies self.ownedFeatureMembership->isEmpty()", "If a Definition is a variation, then all it must not have any ownedFeatureMemberships."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDefinition(), "validateDefinitionVariationSpecialization", "aql:self.isVariation implies not self.ownedSpecialization.specific->exists(e | e.oclIsKindOf(sysml::Definition) and e.oclAsType(sysml::Definition).isVariation)", "A variation Definition may not specialize any other variation Definition."),
          new ValidationRule(SysmlPackage.eINSTANCE.getElementFilterMembership(), "validateElementFilterMembershipConditionIsBoolean", "aql:self.condition.result.specializesFromLibrary('ScalarValues::Boolean')", "The result parameter of the condition Expression must directly or indirectly specialize ScalarValues::Boolean."),
          new ValidationRule(SysmlPackage.eINSTANCE.getElementFilterMembership(), "validateElementFilterMembershipConditionIsModelLevelEvaluable", "aql:self.condition.isModelLevelEvaluable", "The condition Expression must be model-level evaluable."),
          new ValidationRule(SysmlPackage.eINSTANCE.getElement(), "validateElementIsImpliedIncluded", "aql:self.ownedRelationship->exists(e | e.isImplied) implies self.isImpliedIncluded", "If an Element has any ownedRelationships for which isImplied = true, then the Element must also have isImpliedIncluded = true. (Note that an Element can have isImplied = true even if no ownedRelationships have isImplied = true, indicating the Element simply has no implied Relationships."),
          new ValidationRule(SysmlPackage.eINSTANCE.getEndFeatureMembership(), "validateEndFeatureMembershipIsEnd", "aql:self.ownedMemberFeature.isEnd", "The ownedMemberFeature of an EndFeatureMembership must be an end Feature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getEnumerationDefinition(), "validateEnumerationDefinitionIsVariation", "aql:self.isVariation", "An EnumerationDefinition must be a variation."),
          new ValidationRule(SysmlPackage.eINSTANCE.getEventOccurrenceUsage(), "validateEventOccurrenceUsageIsReference", "aql:self.isReference", "An EventOccurrenceUsage must be referential."),
          new ValidationRule(SysmlPackage.eINSTANCE.getEventOccurrenceUsage(), "validateEventOccurrenceUsageReference", "aql:self.referencedFeatureTarget() <> null implies self.referencedFeatureTarget().oclIsKindOf(sysml::OccurrenceUsage)", "If an EventOccurrenceUsage has an ownedReferenceSubsetting, then the featureTarget of the referencedFeature must be an OccurrenceUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExhibitStateUsage(), "validateExhibitStateUsageReference", "aql:self.referencedFeatureTarget() <> null implies self.referencedFeatureTarget().oclIsKindOf(sysml::StateUsage)", "If an ExhibitStateUsage has an ownedReferenceSubsetting, then the featureTarget of the referencedFeature must be a StateUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpose(), "validateExposeIsImportAll", "aql:self.isImportAll", "An Expose always imports all Elements, regardless of visibility."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpose(), "validateExposeOwningNamespace", "aql:self.importOwningNamespace.oclIsTypeOf(sysml::ViewUsage)", "The importOwningNamespace of an Expose must be a ViewUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpose(), "validateExposeVisibility", "aql:self.visibility = sysml::VisibilityKind::protected", "An Expose always has protected visibility."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpression(), "validateExpressionResultExpressionMembership", "aql:self.membership->filter(sysml::ResultExpressionMembership)->size() <= 1", "An Expression must have at most one ResultExpressionMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpression(), "validateExpressionResultParameterMembership", "aql:self.featureMembership->filter(sysml::ReturnParameterMembership)->size() = 1", "An Expression must have exactly one featureMembership (owned or inherited) that is a ResultParameterMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureChainExpression(), "validateFeatureChainExpressionConformance", "aql:self.argument->notEmpty() implies self.targetFeature.isFeaturedWithin(argument->first().result)", "The targetFeature of a FeatureChainExpression must be featured within the result parameter of the argument Expression of the FeatureChainExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureChainExpression(), "validateFeatureChainExpressionOperator", "aql:self.operator = '.'", "The operator of a FeatureChainExpression must be '.'."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureChainingFeatureConformance", "aql:self.interval(2, self.chainingFeature->size())->forAll(i | self.chainingFeature->at(i).isFeaturedWithin(chainingFeature->at(i-1)))", "Each chainingFeature (other than the first) must be featured within the previous chainingFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureChainingFeatureNotOne", "aql:self.chainingFeature->size() <> 1", "A Feature must have either no chainingFeatures or more than one."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureChainingFeaturesNotSelf", "aql:self.chainingFeature->excludes(self)", "A Feature cannot be one of its own chainingFeatures."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureConstantIsVariable", "aql:self.isConstant implies self.isVariable", "A Feature with isConstant = true must have isVariable = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureCrossFeatureSpecialization", "aql:self.crossFeature <> null implies self.ownedRedefinition.redefinedFeature.crossFeature->forAll(f | f <> null implies self.crossFeature.specializes(f))", "If this Feature has a crossFeature, then, for any Feature that is redefined by this Feature, the crossFeature must specialize the crossFeature of the redefined end Feature, if this exists."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureCrossFeatureType", "aql:self.crossFeature <> null implies self.crossFeature.type->asSet() = self.type->asSet()", "The crossFeature of a Feature must have the same types as the Feature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureEndIsConstant", "aql:self.isEnd and self.isVariable implies self.isConstant", "A Feature with isEnd = true and isVariable = true must have isConstant = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureEndMultiplicity", "aql:self.isEnd implies self.multiplicities().allSuperTypes()->flatten()->filter(sysml::MultiplicityRange)->exists(mr | mr.hasBounds(1,1))", "If a Feature has isEnd = true, then it must have multiplicity 1..1."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureEndNoDirection", "aql:self.isEnd implies self.direction = null", "A Feature with isEnd = true must have no direction."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureEndNotDerivedAbstractCompositeOrPortion", "aql:self.isEnd implies not (self.isDerived or self.isAbstract or self.isComposite or self.isPortion)", "A Feature with isEnd = true must have all of isDerived = false, isAbstract = false, isComposite = false, and isPortion = false."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureIsVariable", "aql:self.isVariable implies self.owningType <> null and self.owningType.specializes('Occurrences::Occurrence')", "A Feature with isVariable = true must have an owningType that directly or indirectly specializes the Class Occurrences::Occurrence from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureMultiplicityDomain", "aql:self.multiplicity <> null implies self.multiplicity.featuringType = self.featuringType", "If a Feature has a multiplicity, then the featuringTypes of the multiplicity must be the same as those of the Feature itself."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureOwnedCrossSubsetting", "aql:self.ownedSubsetting->filter(sysml::CrossSubsetting)->size() <= 1", "A Feature must have at most one ownedSubsetting that is a CrossSubsetting."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureOwnedReferenceSubsetting", "aql:self.ownedSubsetting->filter(sysml::ReferenceSubsetting)->size() <= 1", "A Feature must have at most one ownedSubsetting that is an ReferenceSubsetting."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeaturePortionNotVariable", "aql:self.isPortion implies not self.isVariable", ""),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureReferenceExpression(), "validateFeatureReferenceExpressionReferentIsFeature", "aql:let membership : sysml::Membership = self.ownedMembership->reject(m | m.oclIsKindOf(sysml::ParameterMembership)) in self.membership->notEmpty() and self.membership->at(1).memberElement.oclIsKindOf(sysml::Feature)", "The first ownedMembership of a FeatureReferenceExpression that is not a ParameterMembership must have a Feature as its memberElement."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureReferenceExpression(), "validateFeatureReferenceExpressionResult", "aql:self.result.owningType = self", "A FeatureReferenceExpression must own its result parameter."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureValue(), "validateFeatureValueIsInitial", "aql:self.isInitial implies self.featureWithValue.isVariable", "If a FeatureValue has isInitial = true, then its featureWithValue must have isVariable = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFlowDefinition(), "validateFlowDefinitionFlowEnds", "aql:self.flowEnd->size() <= 2", "A FlowDefinition may not have more than two flowEnds."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFlowEnd(), "validateFlowEndIsEnd", "aql:self.isEnd", "A FlowEnd must be an end Feature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFlowEnd(), "validateFlowEndNestedFeature", "aql:self.ownedFeature->size() = 1", "A FlowEnd must have exactly one ownedFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFlowEnd(), "validateFlowEndOwningType", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::Flow)", "The owningType of a FlowEnd must be a Flow."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFlow(), "validateFlowPayloadFeature", "aql:self.ownedFeature->filter(sysml::PayloadFeature)->size() <= 1", "A Flow must have at most one ownedFeature that is an PayloadFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForLoopActionUsage(), "validateForLoopActionUsageLoopVariable", "aql:self.ownedFeature->notEmpty() and self.ownedFeature->at(1).oclIsKindOf(sysml::ReferenceUsage)", "The first ownedFeature of a ForLoopActionUsage must be a ReferenceUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForLoopActionUsage(), "validateForLoopActionUsageParameters", "aql:self.inputParameters()->size() = 2", "A ForLoopActionUsage must have two owned input parameters."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForkNode(), "validateForkNodeIncomingSuccessions", "aql:self.targetConnector->filter(sysml::Succession)->size() <= 1", "A ForkNode may have at most one incoming Succession."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFramedConcernMembership(), "validateFramedConcernMembershipConstraintKind", "aql:self.kind = sysml::RequirementConstraintKind::requirement", "A FramedConcernMembership must have kind = requirement."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFunction(), "validateFunctionResultExpressionMembership", "aql:self.membership->filter(sysml::ResultExpressionMembership)->size() <= 1", "A Function must have at most one ResultExpressionMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFunction(), "validateFunctionResultParameterMembership", "aql:self.featureMembership->filter(sysml::ReturnParameterMembership)->size() = 1", "A Function must have exactly one featureMembership (owned or inherited) that is a ResultParameterMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getIfActionUsage(), "validateIfActionUsageParameters", "aql:self.inputParameters()->size() >= 2", "An IfActionUsage must have at least two owned input parameters."),
          new ValidationRule(SysmlPackage.eINSTANCE.getImport(), "validateImportTopLevelVisibility", "aql:self.importOwningNamespace.owner = null implies self.visibility = sysml::VisibilityKind::private", "A top-level Import (that is, one that is owned by a root Namespace) must have a visibility of private."),
          new ValidationRule(SysmlPackage.eINSTANCE.getIncludeUseCaseUsage(), "validateIncludeUseCaseUsageReference", "aql:self.referencedFeatureTarget() <> null implies self.referencedFeatureTarget().oclIsKindOf(sysml::UseCaseUsage)", "If an IncludeUseCaseUsage has an ownedReferenceSubsetting, then the featureTarget of the referencedFeature must be a UseCaseUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getIndexExpression(), "validateIndexExpressionOperator", "aql:self.operator = '#'", "The operator of an IndexExpression must be '#'."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInstantiationExpression(), "validateInstantiationExpressionInstantiatedType", "aql:self.instantiatedType() <> null", "An InstantiationExpression must have an InstantiatedType."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInstantiationExpression(), "validateInstantiationExpressionResult", "aql:self.result.owningType = self", "An InstantiationExpression must own its result parameter."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInvocationExpression(), "validateInvocationExpressionInstantiatedType", "aql:self.instantiatedType.oclIsKindOf(sysml::Behavior) or self.instantiatedType.oclIsKindOf(sysml::Feature) and self.instantiatedType.type->exists(e | e.oclIsKindOf(sysml::Behavior)) and self.instantiatedType.type->size(1)", "The instantiatedType of an InvocationExpression must be either a Behavior or a Feature with a single type, which is a Behavior."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInvocationExpression(), "validateInvocationExpressionNoDuplicateParameterRedefinition", "aql:let features : OrderedSet(sysml::Feature) = self.instantiatedType.feature in self.input->forAll(inp1 | self.input->forAll(inp2 | inp1 <> inp2 implies inp1.ownedRedefinition.redefinedFeature->intersection(inp2.ownedRedefinition.redefinedFeature)->intersection(features)->isEmpty()))", "Two different ownedFeatures of an InvocationExpression must not redefine the same feature of the instantiatedType of the InvocationExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInvocationExpression(), "validateInvocationExpressionOwnedFeatures", "aql:self.ownedFeature->forAll(f | f <> self.result implies f.direction = sysml::FeatureDirectionKind::_'in')", "Other than its result, all the ownedFeatures of an InvocationExpression must have direction = in."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInvocationExpression(), "validateInvocationExpressionParameterRedefinition", "aql:let parameters : OrderedSet(sysml::Feature) = self.instantiatedType.input in self.input->forAll(inp | inp.ownedRedefinition.redefinedFeature->intersection(parameters)->size() = 1)", "Each input parameter of an InvocationExpression must redefine exactly one input parameter of the instantiatedType of the InvocationExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getJoinNode(), "validateJoinNodeOutgoingSuccessions", "aql:self.sourceConnector->filter(sysml::Succession)->size() <= 1", "A JoinNode may have at most one outgoing Succession."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMergeNode(), "validateMergeNodeIncomingSuccessions", "aql:self.targetConnector->filter(sysml::Succession)->collect(connectorEnd->at(1))->forAll(sourceMult | self.multiplicityHasBounds(sourceMult, 0, 1))", "All incoming Successions to a MergeNode must have a source multiplicity of 0..1."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMergeNode(), "validateMergeNodeOutgoingSuccessions", "aql:self.sourceConnector->selectAsKind(Succession)->size() <= 1", "A MergeNode may have at most one outgoing Succession."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataAccessExpression(), "validateMetadataAccessExpressionReferencedElement", "aql:self.ownedMembership->exists(e | not e.oclIsKindOf(sysml::FeatureMembership))", "A MetadataAccessExpression must have at least one ownedMember that is not a FeatureMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataFeature(), "validateMetadataFeatureAnnotatedElement", "aql:let baseAnnotatedElementFeature : sysml::Feature = self.resolveGlobal('Metaobjects::Metaobject::annotatedElement').memberElement.oclAsType(sysml::Feature) in let annotatedElementFeatures : OrderedSet(sysml::Feature) = self.feature->select(specializes(baseAnnotatedElementFeature))->excluding(baseAnnotatedElementFeature) in self.annotatedElementFeatures->notEmpty() implies let annotatedElementTypes : OrderedSet(sysml::Feature) = self.annotatedElementFeatures.typing.type->asSet() in let metaclasses : OrderedSet(sysml::Metaclass) = self.annotatedElement.oclType().qualifiedName->collect(qn | self.resolveGlobal(qn).memberElement.oclAsType(sysml::Metaclass)) in self.metaclasses->forAll(m | self.annotatedElementTypes->exists(t | m.specializes(t)))", "The annotatedElements of a MetadataFeature must have an abstract syntax metaclass consistent with the annotatedElement declarations for the MetadataFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataFeature(), "validateMetadataFeatureBody", "aql:self.ownedFeature->closure(ownedFeature)->forAll(f | f.declaredName = null and f.declaredShortName = null and f.valuation <> null implies f.valuation.value.isModelLevelEvaluable and f.redefinition.redefinedFeature->size() = 1)", "Each ownedFeature of a MetadataFeature must have no declared name, redefine a single Feature, either have no featureValue or a featureValue with a value Expression that is model-level evaluable, and only have ownedFeatures that also meet these restrictions."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataFeature(), "validateMetadataFeatureMetaclass", "aql:self.type->filter(sysml::Metaclass)->size() = 1", "A MetadataFeature must have exactly one type that is a Metaclass."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataFeature(), "validateMetadataFeatureMetaclassNotAbstract", "aql:not self.metaclass.isAbstract", "The metaclass of a MetadataFeature must not be abstract."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMultiplicityRange(), "validateMultiplicityRangeBoundResultTypes", "aql:self.bound->forAll(b | b.result <> null and b.result.specializesFromLibrary('ScalarValues::Integer') and let value : Integer = self.valueOf(b) in value <> null implies value >= 0 )", "The results of the bound Expression(s) of a MultiplicityRange must be typed by ScalarValues::Intger from the Kernel Data Types Library. If a bound is model-level evaluable, then it must evaluate to a non-negative value."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMultiplicityRange(), "validateMultiplicityRangeBounds", "aql:if self.lowerBound = null then self.ownedMember->notEmpty() and self.ownedMember->at(1) = self.upperBound else self.ownedMember->size() > 1 and self.ownedMember->at(1) = self.lowerBound and self.ownedMember->at(2) = self.upperBound endif", "The lowerBound (if any) and upperBound Expressions must be the first ownedMembers of a MultiplicityRange."),
          new ValidationRule(SysmlPackage.eINSTANCE.getNamespace(), "validateNamespaceDistinguishibility", "aql:self.ownedMembership->forAll(m1 | self.ownedMembership->forAll(m2 | m1 <> m2 implies m1.isDistinguishableFrom(m2)))", "All memberships of a Namespace must be distinguishable from each other."),
          new ValidationRule(SysmlPackage.eINSTANCE.getObjectiveMembership(), "validateObjectiveMembershipIsComposite", "aql:self.ownedObjectiveRequirement.isComposite", "The ownedObjectiveRequirement of an ObjectiveMembership must be composite."),
          new ValidationRule(SysmlPackage.eINSTANCE.getObjectiveMembership(), "validateObjectiveMembershipOwningType", "aql:self.owningType.ocIsTypeOf(sysml::CaseDefinition) or self.owningType.ocIsTypeOf(sysml::CaseUsage)", "The owningType of an ObjectiveMembership must be a CaseDefinition or CaseUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceUsage(), "validateOccurrenceUsageIndividualDefinition", "aql:self.occurrenceDefinition->filter(sysml::OccurrenceDefinition)->select(e | e.isIndividual)->size() <= 1", "An OccurrenceUsage must have at most one occurrenceDefinition with isIndividual = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceUsage(), "validateOccurrenceUsageIndividualUsage", "aql:self.isIndividual implies self.individualDefinition <> null", "If an OccurrenceUsage has isIndividual = true, then it must have an individualDefinition."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceUsage(), "validateOccurrenceUsageIsPortion", "aql:self.portionKind <> null implies self.isPortion", "If an OccurrenceUsage has a non-null portionKind, then it must have isPortion = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceUsage(), "validateOccurrenceUsagePortionKind", "aql:self.portionKind <> null implies self.owningType <> null and (self.owningType.oclIsKindOf(sysml::OccurrenceDefinition) or self.owningType.oclIsKindOf(sysml::OccurrenceUsage))", "If an OccurrenceUsage has a non-null portionKind, then its owningType must be an OccurrenceDefinition or an OccurrenceUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getParameterMembership(), "validateParameterMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::Behavior) or self.owningType.oclIsKindOf(sysml::Step) or self.owningType.owningMembership.oclIsKindOf(sysml::ReturnParameterMembership) and self.owningType.owningNamespace.oclIsKindOf(sysml::ConstructorExpression)", "A ParameterMembership must be owned by a Behavior,Step, or the result parameter of a ConstructorExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getParameterMembership(), "validateParameterMembershipParameterDirection", "aql:self.ownedMemberParameter.direction = self.parameterDirection()", "The ownedMemberParameter of a ParameterMembership must have a  direction equal to the result of the parameterDirection() operation."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPartUsage(), "validatePartUsagePartDefinition", "aql:self.partDefinition->notEmpty()", "At least one of the itemDefinitions of a PartUsage must be a PartDefinition."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPerformActionUsage(), "validatePerformActionUsageReference", "aql:self.referencedFeatureTarget() <> null implies self.referencedFeatureTarget().oclIsKindOf(sysml::ActionUsage)", "If a PerformActionUsage has an ownedReferenceSubsetting, then the featureTarget of the referencedFeature must be an ActionUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortDefinition(), "validatePortDefinitionConjugatedPortDefinition", "aql:not self.oclIsKindOf(sysml::ConjugatedPortDefinition) implies self.ownedMember->filter(sysml::ConjugatedPortDefinition)->size() = 1", "Unless it is a ConjugatedPortDefinition, a PortDefinition must have exactly one ownedMember that is a ConjugatedPortDefinition."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortDefinition(), "validatePortDefinitionOwnedUsagesNotComposite", "aql:self.ownedUsage->reject(i | i.oclIsKindOf(sysml::PortUsage))->forAll(i | not i.isComposite)", "The ownedUsages of a PortDefinition that are not PortUsages must not be composite."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortUsage(), "validatePortUsageIsReference", "aql:self.owningType = null or not self.owningType.oclIsKindOf(sysml::PortDefinition) and not self.owningType.oclIsKindOf(sysml::PortUsage) implies self.isReference", "Unless a PortUsage has an owningType that is a PortDefinition or a PortUsage, it must be referential (non-composite)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortUsage(), "validatePortUsageNestedUsagesNotComposite", "aql:self.nestedUsage->reject(i | i.oclIsKindOf(sysml::PortUsage))->forAll(i | not i.isComposite)", "The nestedUsages of a PortUsage that are not themselves PortUsages must not be composite."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRedefinition(), "validateRedefinitionDirectionConformance", "aql:let featuringTypes : Sequence(sysml::Type) = if self.redefiningFeature.isVariable then Sequence{self.redefiningFeature.owningType} else self.redefiningFeature.featuringType endif in featuringTypes->forAll(t | let direction : sysml::FeatureDirectionKind = t.directionOf(self.redefinedFeature) in ((direction = sysml::FeatureDirectionKind::_in or direction = sysml::FeatureDirectionKind::out) implies self.redefiningFeature.direction = direction) and (direction = sysml::FeatureDirectionKind::inout implies self.redefiningFeature.direction <> null))", "If the redefinedFeature of a Redefinition has a direction of in or out (relative to any featuringType of the redefiningFeature or the owningType, if the redefiningFeature has isVariable = true), then the redefiningFeature must have the same direction. If the redefinedFeature has a direction of inout, then the redefiningFeature must have a non-null direction. (Note: the direction of the redefinedFeature relative to a featuringType of the redefiningFeature is the direction it would have if it had been inherited and not redefined.)"),
          new ValidationRule(SysmlPackage.eINSTANCE.getRedefinition(), "validateRedefinitionEndConformance", "aql:self.redefinedFeature.isEnd implies self.redefiningFeature.isEnd", "If the redefinedFeature of a Redefinition has isEnd = true, then the redefiningFeature must have isEnd = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRedefinition(), "validateRedefinitionFeaturingTypes", "aql:let anythingType: sysml::Type = self.redefiningFeature.resolveGlobal('Base::Anything').modelElement.oclAsType(sysml::Type) in let redefiningFeaturingTypes: OrderedSet(sysml::Type) = if self.redefiningFeature.isVariable then OrderedSet{redefiningFeature.owningType} else self.redefiningFeature.featuringType->asSet()->including(anythingType) endif in let redefinedFeaturingTypes: OrderedSet(sysml::Type) = if self.redefinedFeature.isVariable then OrderedSet{redefinedFeature.owningType} else self.redefinedFeature.featuringType->asSet()->including(anythingType) endif in redefiningFeaturingTypes <> redefinedFeaturingTypes", "The redefiningFeature of a Redefinition must have at least one featuringType that is not also a featuringType of the redefinedFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getReferenceUsage(), "validateReferenceUsageIsReference", "aql:self.isReference", "A ReferenceUsage is always referential."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementConstraintMembership(), "validateRequirementConstraintMembershipIsComposite", "aql:self.ownedConstraint.isComposite", "The ownedConstraint of a RequirementConstraintMembership must be composite."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementConstraintMembership(), "validateRequirementConstraintMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::RequirementDefinition) or self.owningType.oclIsKindOf(sysml::RequirementUsage)", "The owningType of a RequirementConstraintMembership must be a RequirementDefinition or a RequirementUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementDefinition(), "validateRequirementDefinitionOnlyOneSubject", "aql:self.featureMembership-> oclIsKindOf(sysml::SubjectMembership)->size() <= 1", "A RequirementDefinition must have at most one featureMembership that is a SubjectMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementDefinition(), "validateRequirementDefinitionSubjectParameterPosition", "aql:self.input->notEmpty() and self.input->first() = self.subjectParameter", "The subjectParameter of a RequirementDefinition must be its first input."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementUsage(), "validateRequirementUsageOnlyOneSubject", "aql:self.featureMembership->filter(sysml::SubjectMembership)->size() <= 1", "A RequirementDefinition must have at most one featureMembership that is a SubjectMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementUsage(), "validateRequirementUsageSubjectParameterPosition", "aql:self.input->notEmpty() and self.input->first() = self.subjectParameter", "The subjectParameter of a RequirementUsage must be its first input."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementVerificationMembership(), "validateRequirementVerificationMembershipKind", "aql:self.kind = sysml::RequirementConstraintKind::requirement", "A RequirementVerificationMembership must have kind = requirement."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementVerificationMembership(), "validateRequirementVerificationMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::RequirementUsage) and self.owningType.owningFeatureMembership <> null and self.owningType.owningFeatureMembership.oclIsKindOf(sysml::ObjectiveMembership)", "The owningType of a RequirementVerificationMembership must a RequirementUsage that is owned by an ObjectiveMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getResultExpressionMembership(), "validateResultExpressionMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::Function) or self.owningType.oclIsKindOf(sysml::Expression)", "The owningType of a ResultExpressionMembership must be a Function or Expression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getReturnParameterMembership(), "validateReturnParameterMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::Function) or self.owningType.oclIsKindOf(sysml::Expression)", "The owningType of a ReturnParameterMembership must be a Function or Expression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSatisfyRequirementUsage(), "validateSatisfyRequirementUsageReference", "aql:self.referencedFeatureTarget() <> null implies self.referencedFeatureTarget().oclIsKindOf(sysml::RequirementUsage)", "If a SatisfyRequirementUsage has an ownedReferenceSubsetting, then the featureTarget of its referencedFeature must be a RequirementUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSelectExpression(), "validateSelectExpressionOperator", "aql:self.operator = 'select'", "The operator of a SelectExpression must be 'select'."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSendActionUsage(), "validateSendActionParameters", "aql:self.inputParameters()->size() >= 3", "A SendActionUsage must have at least three owned input parameters, corresponding to its payload, sender and receiver, respectively (whether or not they have FeatureValues)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSpecialization(), "validateSpecificationSpecificNotConjugated", "aql:self.specific <> null and not self.specific.isConjugated", "The specific Type of a Specialization cannot be a conjugated Type."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStakeholderMembership(), "validateStakeholderMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::RequirementUsage) or self.owningType.oclIsKindOf(sysml::RequirementDefinition)", "The owningType of a StakeholderMembership must be a RequirementDefinition or RequirementUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateDefinition(), "validateStateDefinitionParallelSubactions", "aql:self.isParallel implies self.ownedAction.incomingTransition->isEmpty() and self.ownedAction.outgoingTransition->isEmpty()", "If a StateDefinition is parallel, then its ownedActions (which includes its ownedStates) must not have any incomingTransitions or outgoingTransitions."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateDefinition(), "validateStateDefinitionStateSubactionKind", "aql:self.ownedMembership->filter(sysml::StateSubactionMembership)->isUnique(i | i.kind)", "A StateDefinition must not have more than one owned StateSubactionMembership of each kind."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateSubactionMembership(), "validateStateSubactionMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::StateDefinition) or self.owningType.oclIsKindOf(sysml::StateUsage)", "The owningType of a StateSubactionMembership must be a StateDefinition or a StateUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateUsage(), "validateStateUsageParallelSubactions", "aql:self.isParallel implies self.nestedAction.incomingTransition->isEmpty() and self.nestedAction.outgoingTransition->isEmpty()", "If a StateUsage is parallel, then its nestedActions (which includes nestedStates) must not have any incomingTransitions or outgoingTransitions."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateUsage(), "validateStateUsageStateSubactionKind", "aql:self.ownedMembership->filter(sysml::StateSubactionMembership)->isUnique(i | i.kind)", "A StateUsage must not have more than one owned StateSubactionMembership of each kind."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStructure(), "validateStructureSpecialization", "aql:self.ownedSpecialization.general->forAll(i | not i.oclIsKindOf(sysml::Behavior))", "A Structure must not specialize a Behavior."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSubjectMembership(), "validateSubjectMembershipOwningType", "aql:self.owningType.ocIsTypeOf(sysml::RequirementDefinition) or self.owningType.ocIsTypeOf(sysml::RequiremenCaseRequirementDefinition) or self.owningType.ocIsTypeOf(sysml::CaseDefinition) or self.owningType.ocIsTypeOf(sysml::CaseUsage)", "The owningType of a SubjectMembership must be a RequirementDefinition, RequirementUsage, CaseDefinition, or CaseUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSubsetting(), "validateSubsettingConstantConformance", "aql:self.subsettedFeature.isConstant and self.subsettingFeature.isVariable implies self.subsettingFeature.isConstant", "If the subsettedFeature of a Subsetting has isConstant = true and the subsettingFeature has isVariable = true, then the subsettingFeature must have isConstant = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSubsetting(), "validateSubsettingFeaturingTypes", "aql:self.subsettingFeature.canAccess(self.subsettedFeature)", "The subsettedFeature must be accessible by the subsettingFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSubsetting(), "validateSubsettingUniquenessConformance", "aql:self.subsettedFeature.isUnique implies self.subsettingFeature.isUnique", "If the subsettedFeature of a Subsetting has isUnique = true, then the subsettingFeature must have isUnique = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionFeatureMembership(), "validateTransitionFeatureMembershipEffectAction", "aql:self.kind = sysml::TransitionFeatureKind::effect implies self.transitionFeature.oclIsKindOf(sysml::ActionUsage)", "If the kind of a TransitionUsage is effect, then its transitionFeature must be a kind of ActionUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionFeatureMembership(), "validateTransitionFeatureMembershipGuardExpression", "aql:self.kind = sysml::TransitionFeatureKind::guard implies self.transitionFeature.oclIsKindOf(sysml::Expression) and let guard : sysml::Expression = self.transitionFeature.oclIsKindOf(sysml::Expression) in guard.result.specializesFromLibrary('ScalarValues::Boolean') and guard.result.multiplicity <> null and guard.result.multiplicity.hasBounds(1,1)", "If the kind of a TransitionUsage is guard, then its transitionFeature must be a kind of Expression whose result is a Boolean value."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionFeatureMembership(), "validateTransitionFeatureMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::TransitionUsage)", "The owningType of a TransitionFeatureMembership must be a TransitionUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionFeatureMembership(), "validateTransitionFeatureMembershipTriggerAction", "aql:self.kind = sysml::TransitionFeatureKind::trigger implies self.transitionFeature.oclIsKindOf(sysml::AcceptActionUsage)", "If the kind of a TransitionUsage is trigger, then its transitionFeature must be a kind of AcceptActionUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "validateTransitionUsageParameters", "aql:if self.triggerAction->isEmpty() then self.inputParameters()->size() >= 1 else self.inputParameters()->size() >= 2 endif", "A TransitionUsage must have at least one owned input parameter and, if it has a triggerAction, it must have at least two."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "validateTransitionUsageSuccession", "aql:let successions : Sequence(sysml::Successions) = self.ownedMember->filter(sysml::Succession) in self.successions->notEmpty() and self.successions->at(1).targetFeature.featureTarget->forAll(oclIsKindOf(sysml::ActionUsage))", "A TransitionUsage must have an ownedMember that is a Succession with an ActionUsage as the featureTarget of its targetFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "validateTransitionUsageTriggerActions", "aql:self.source <> null and not self.source.oclIsKindOf(sysml::StateUsage) implies self.triggerAction->isEmpty()", "If the source of a TransitionUsage is not a StateUsage, then the TransitionUsage must not have any triggerActions."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTriggerInvocationExpression(), "validateTriggerInvocationExpressionAfterArgument", "aql:self.kind = sysml::TriggerKind::after implies self.argument->notEmpty() and self.argument->at(1).result.specializesFromLibrary('Quantities::ScalarQuantityValue') and let mRef : sysml::Element = self.resolveGlobal('Quantities::TensorQuantityValue::mRef').ownedMemberElement in self.argument->at(1).result.feature->select(ownedRedefinition.redefinedFeature->closure(ownedRedefinition.redefinedFeature)->includes(mRef))->exists(specializesFromLibrary('ISQBase::DurationUnit'))", "If a TriggerInvocationExpression has kind = after, then it must have an argument Expression with a result that conforms to the type Quantities::ScalarQuantityValue and a feature that directly or indirectly redefines Quantities::TensorQuantityValue::mRef and directly or indirectly specializes ISQBase::DurationUnit."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTriggerInvocationExpression(), "validateTriggerInvocationExpressionAtArgument", "aql:self.kind = sysml::TriggerKind::at implies self.argument->notEmpty() and self.argument->at(1).result.specializesFromLibrary('Time::TimeInstantValue')", "If a TriggerInvocationExpression has kind = at, then it must have an argument Expression with a result that conforms to the type Time::TimeInstantValue."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTriggerInvocationExpression(), "validateTriggerInvocationExpressionWhenArgument", "aql:self.kind = sysml::TriggerKind::when implies self.argument->notEmpty() and self.argument->at(1).oclIsKindOf(sysml::FeatureReferenceExpression) and let referent : sysml::Feature = self.argument->at(1).oclAsType(sysml::FeatureReferenceExpression).referent in referent.oclIsKindOf(sysml::Expression) and referent.oclAsType(sysml::Expression).result.specializesFromLibrary('ScalarValues::Boolean')", "If a TriggerInvocationExpression has kind = when, then it must have an argument that is a FeatureReferenceExpression whose referent is an Expression with a result that conforms to the type ScalarValues::Boolean."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeAtMostOneConjugator", "aql:self.ownedRelationship->filter(sysml::Conjugation)->size() <= 1", "A Type must have at most one owned Conjugation Relationship."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeDifferencingTypesNotSelf", "aql:self.differencingType->excludes(self)", "A Type cannot be one of its own differencingTypes."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeIntersectingTypesNotSelf", "aql:self.intersectingType->excludes(self)", "A Type cannot be one of its own intersectingTypes."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeOwnedDifferencingNotOne", "aql:self.ownedDifferencing->size() <> 1", "A Type must not have exactly one ownedDifferencing."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeOwnedIntersectingNotOne", "aql:self.ownedIntersecting->size() <> 1", "A Type must not have exactly one ownedIntersecting."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeOwnedMultiplicity", "aql:self.ownedMember->filter(sysml::Multiplicity)->size() <= 1", "A Type may have at most one ownedMember that is a Multiplicity."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeOwnedUnioningNotOne", "aql:self.ownedUnioning->size() <> 1", "A Type must not have exactly one ownedUnioning."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeUnioningTypesNotSelf", "aql:self.unioningType->excludes(self)", "A Type cannot be one of its own unioningTypes."),
          new ValidationRule(SysmlPackage.eINSTANCE.getUsage(), "validateUsageIsReferential", "aql:self.direction <> null or self.isEnd or self.featuringType->isEmpty() implies self.isReference", "A Usage that is directed, an end feature or has no featuringTypes must be referential."),
          new ValidationRule(SysmlPackage.eINSTANCE.getUsage(), "validateUsageVariationIsAbstract", "aql:self.isVariation implies self.isAbstract", "If a Usage is a variation, then it must be abstract."),
          new ValidationRule(SysmlPackage.eINSTANCE.getUsage(), "validateUsageVariationOwnedFeatureMembership", "aql:self.isVariation implies self.ownedFeatureMembership->isEmpty()", "If a Usage is a variation, then it must not have any ownedFeatureMemberships."),
          new ValidationRule(SysmlPackage.eINSTANCE.getUsage(), "validateUsageVariationSpecialization", "aql:self.isVariation implies not self.ownedSpecialization.specific->exists(e | e.oclIsKindOf(sysml::Definition) and e.oclAsType(sysml::Definition).isVariation or e.oclIsKindOf(sysml::Usage) and e.oclAsType(sysml::Usage).isVariation)", "A variation Usage may not specialize any variation Definition or Usage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getVariantMembership(), "validateVariantMembershipOwningNamespace", "aql:self.membershipOwningNamespace.oclIsKindOf(sysml::Definition) and self.membershipOwningNamespace.oclAsType(sysml::Definition).isVariation or self.membershipOwningNamespace.oclIsKindOf(sysml::Usage) and self.membershipOwningNamespace.oclAsType(sysml::Usage).isVariation", "The membershipOwningNamespace of a VariantMembership must be a variation-point Definition or Usage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewDefinition(), "validateViewDefinitionOnlyOneViewRendering", "aql:self.featureMembership->filter(sysml::ViewRenderingMembership)->size() <= 1", "A ViewDefinition must have at most one ViewRenderingMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewRenderingMembership(), "validateViewRenderingMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::ViewDefinition) or self.owningType.oclIsKindOf(sysml::ViewUsage)", "The owningType of a ViewRenderingMembership must be a ViewDefinition or a ViewUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewUsage(), "validateViewUsageOnlyOneViewRendering", "aql:self.featureMembership->filter(sysml::ViewRenderingMembership)->size() <= 1", "A ViewUsage must have at most one ViewRenderingMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getWhileLoopActionUsage(), "validateWhileLoopActionUsage", "aql:self.inputParameters()->size() >= 2", "A WhileLoopActionUsage must have at least two owned input parameters.")
    );

    // @formatter:on

    public static final List<ValidationRule> getValidationRules(EClass eClass) {
        return VALIDATION_RULES.stream()
                .filter(rule -> rule.getEClass().equals(eClass) || rule.getEClass().isSuperTypeOf(eClass))
                .toList();
    }
}
