/*******************************************************************************
 * Copyright (c) 2025 Obeo.
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Obeo - initial API and implementation
 *******************************************************************************/
package org.eclipse.syson.sysml.validation;

import java.util.List;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.syson.sysml.SysmlPackage;

/**
 * Contains all SysMLv2 validation rules from the specification.
 *
 * @author arichard
 */
public class SysMLv2ValidationRules {

    // @formatter:off

    public static final List<ValidationRule> VALIDATION_RULES = List.of(
          new ValidationRule(SysmlPackage.eINSTANCE.getImport(), "validateImportTopLevelVisibility", "aql:self.importOwningNamespace.owningNamespace = null implies self.visibility = VisibilityKind::private", "A top-level Import (that is, one that is owned by a root Namespace) must have a visibility of private."),
          new ValidationRule(SysmlPackage.eINSTANCE.getNamespace(), "validateNamespaceDistinguishibility", "aql:self.membership->forAll(m1 | self.membership->forAll(m2 | m1 <> m2 implies m1.isDistinguishableFrom(m2)))", "All memberships of a Namespace must be distinguishable from each other."),
          new ValidationRule(SysmlPackage.eINSTANCE.getElement(), "validateElementIsImpliedIncluded", "aql:self.ownedRelationship->exists(e | e.isImplied) implies self.isImpliedIncluded", "If an Element has any ownedRelationships for which isImplied = true, then the Element must also have isImpliedIncluded = true. (Note that an Element can have isImplied = true even if no ownedRelationships have isImplied = true, indicating the Element simply has no implied Relationships."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRedefinition(), "validateRedefinitionFeaturingTypes", "aql:let anythingType: sysml::Type = self.redefiningFeature.resolveGlobal('Base::Anything').modelElement.oclAsType(sysml::Type) in let redefiningFeaturingTypes: Set(sysml::Type) = self.redefiningFeature.featuringTypes->asSet()->including(anythingType) in let redefinedFeaturingTypes: Set(sysml::Type) = self.redefinedFeature.featuringTypes->asSet()->including(anythingType) in redefiningFeaturingTypes <> redefinedFeaturingType", "The redefiningFeature of a Redefinition must have at least one featuringType that is not also a featuringType of the redefinedFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRedefinition(), "validateRedefinitionDirectionConformance", "aql:self.featuringType->forAll(t | let direction : sysml::FeatureDirectionKind = t.directionOf(redefinedFeature) in ((direction = sysml::FeatureDirectionKind::_'in' or direction = sysml::FeatureDirectionKind::out) implies self.redefiningFeature.direction = direction) and (direction = sysml::FeatureDirectionKind::inout implies self.redefiningFeature.direction <> null))", "If the redefinedFeature of a Redefinition has a direction of in or out (relative to any featuringType of the redefiningFeature), then the redefiningFeature must have the same direction. If the redefinedFeature has a direction of inout, then the redefiningFeature must have a non-null direction. (Note: the direction of the redefinedFeature relative to a featuringType of the redefiningFeature is the direction it would have if it had been inherited and not redefined.)"),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureMultiplicityDomain", "aql:self.multiplicity <> null implies self.multiplicity.featuringType = self.featuringType", "If a Feature has a multiplicity, then the featuringTypes of the multiplicity must be the same as those of the Feature itself."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureSpecialization", "aql:self.specializesFromLibrary('Base::things')", "A Feature must directly or indirectly specialize Base::things from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureChainingFeaturesNotSelf", "aql:self.chainingFeature->excludes(self)", "A Feature cannot be one of its own chainingFeatures."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureChainingFeatureNotOne", "aql:self.chainingFeature->size() <> 1", "A Feature must have either no chainingFeatures or more than one."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureEndRedefinition", "aql:self.isEnd and self.owningType <> null implies let i : Integer = self.owningType.ownedEndFeature->indexOf(self) in self.owningType.ownedSpecialization.general->forAll(supertype | supertype.endFeature->size() >= i implies self.redefines(supertype.endFeature->at(i)))", "If a Feature has isEnd = true and an owningType that is not empty, then, for each direct supertype of its owningType, it must redefine the endFeature at the same position, if any."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureValuationSpecialization", "aql:self.direction = null and self.ownedSpecialization->forAll(i | i.isImplied) implies self.ownedMembership->filter(sysml::FeatureValue)->forAll(fv | self.specializes(fv.value.result))", "If a Feature has a FeatureValue, no ownedSpecializations that are not implied, and is not directed, then it must specialize the result of the value Expression of the FeatureValue."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureEndSpecialization", "aql:self.isEnd and self.owningType <> null and self.owningType.oclIsKindOf(sysml::Association) or self.owningType.oclIsKindOf(sysml::Connector)) implies self.specializesFromLibrary('Links::Link::participant')", "If a Feature has isEnd = true and an owningType that is an Association or a Connector, then it must directly or indirectly specialize Links::Link::participant from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureSubobjectSpecialization", "aql:self.isComposite and self.ownedTyping.type->exists(i | i.oclIsKindOf(sysml::Structure)) and self.owningType <> null and self.owningType.oclIsKindOf(sysml::Structure) or self.owningType.type->exists(i | i.oclIsKindOf(sysml::Structure))) implies self.specializesFromLibrary('Occurrence::Occurrence::suboccurrences')", "A composite Feature typed by a Structure, and whose ownedType is a Structure or another Feature typed by a Structure must directly or indirectly specialize Objects::Object::subobjects."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureFeatureReferenceResultSpecialization", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::FeatureReferenceExpression) and self = self.owningType.oclAsType(sysml::FeatureReferenceExpression).result implies self.specializes(owningType.oclAsType(sysml::FeatureReferenceExpression).referent)", "If a Feature is the result parameter of a FeatureReferenceExpression, then the Feature must specialize the referent of the FeatureReferenceExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureOccurrenceSpecialization", "aql:self.ownedTyping.type->exists(e | e.oclIsKindOf(sysml::Class)) implies self.specializesFromLibrary('Occurrences::occurrences')", "If a Feature has an ownedTyping relationship to a Class, then it must directly or indirectly specialize Occurrences::occurrences from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureSuboccurrenceSpecialization", "aql:self.isComposite and self.ownedTyping.type->exists(i | i.oclIsKindOf(sysml::Class)) and self.owningType <> null and self.owningType.oclIsKindOf(sysml::Class) or self.owningType.oclIsKindOf(sysml::Feature) and self.owningType.oclAsType(sysml::Feature).type->exists(e | e.oclIsKindOf(sysml::Class))) implies self.specializesFromLibrary('Occurrence::Occurrence::suboccurrences')", "A composite Feature that has an ownedTyping relationship to a Class, and whose ownedType is a Class or another Feature typed by a Class, must directly or indirectly specialize Occurrences::Occurrence::suboccurrences."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureDataValueSpecialization", "aql:self.ownedTyping.type->exists(e | e.oclIsKindOf(sysml::DataType)) implies self.specializesFromLibrary('Base::dataValues')", "If a Feature has an ownedTyping relationship to a DataType, then it must directly or indirectly specialize Base::dataValues from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureItemFlowFeatureRedefinition", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::ItemFlowEnd) and self.owningType.ownedFeature->at(1) = self implies let flowType : sysml::Type = self.owningType.owningType in flowType <> null implies let i : Integer = flowType.ownedFeature.indexOf(owningType) in (i = 1 implies self.redefinesFromLibrary('Transfers::Transfer::source::sourceOutput')) and (i = 2 implies self.redefinesFromLibrary('Transfers::Transfer::source::targetInput'))", "If a Feature is the first ownedFeature of a first or second ItemFlowEnd, then it must directly or indirectly specialize either Transfers::Transfer::source::sourceOutput or Transfers::Transfer::target::targetInput, respectively, from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureParameterRedefinition", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::Behavior) or self.owningType.oclIsKindOf(sysml::Step)) implies let i : Integer = self.owningType.ownedFeature->select(direction <> null) in self.owningType.ownedSpecialization.general->forAll(supertype | let ownedParameters : Sequence(sysml::Feature) = supertype.ownedFeature->select(direction <> null) in ownedParameters->size() >= i implies self.redefines(ownedParameters->at(i)))", "If a Feature is a parameter of an owningType that is a Behavior or Step, other than the result parameter (if any), then, for each direct supertype of its owningType that is also a Behavior or Step, it must redefine the parameter at the same position, if any."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureObjectSpecialization", "aql:self.ownedTyping.type->exists(e | e.oclIsKindOf(sysml::Structure)) implies self.specializesFromLibrary('Objects::objects')", "If a Feature has an ownedTyping relationship to a Structure, then it must directly or indirectly specialize Objects::objects from the Kernel Semantics Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureResultRedefinition", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::Function) and self = self.owningType.oclAsType(sysml::Function).result or self.owningType.oclIsKindOf(sysml::Expression) and self = self.owningType.oclAsType(sysml::Expression).result) implies self.owningType.ownedSpecialization.general->select(oclIsKindOf(sysml::Function) or e.oclIsKindOf(sysml::Expression))->forAll(supertype | self.redefines( if superType.oclIsKindOf(sysml::Function) then superType.oclAsType(sysml::Function).result else superType.oclAsType(sysml::Expression).result endif))", "If a Feature is a result parameter of an owningType that is a Function or Expression, then, for each direct supertype of its owningType that is also a Function or Expression, it must redefine the result parameter."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureOwnedReferenceSubsetting", "aql:self.ownedSubsetting->filter(sysml::ReferenceSubsetting)->size() <= 1", "A Feature must have at most one ownedSubsetting that is an ReferenceSubsetting."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "validateFeatureChainingFeatureConformance", "aql:self.interval(1, self.chainingFeature->size() - 1)->forAll(i | self.chainingFeature->at(i + 1).featuringType->forAll(t | self.chainingFeature->at(i).specializes(t)))", "Each chainingFeature (other than the last) must conform to all the featuringTypes of the next Feature in the chain."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeaturePortionSpecialization", "aql:self.isPortion and self.ownedTyping.type->exists(i | i.oclIsKindOf(sysml::Class)) and self.owningType <> null and self.owningType.oclIsKindOf(sysml::Class) or self.owningType.oclIsKindOf(sysml::Feature) and self.owningType.oclAsType(sysml::Feature).type->exists(e | e.oclIsKindOf(sysml::Class))) implies self.specializesFromLibrary('Occurrence::Occurrence::portions')", "If a Feature has isPortion = true, an ownedTyping  relationship to a Class, and an owningType that is a Class or another Feature typed by a Class, then it must directly or indirectly specialize Occurrences::Occurrence::portions from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeature(), "checkFeatureInvocationExpressionResultSpecialization", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::InvocationExpression) and let owningInvocation: sysml::InvocationExpression = self.owningType.oclAsType(sysml::InvocationExpression) in self = owningInvocation.result and not owningInvocation.ownedTyping->exists(e | e.oclIsKindOf(sysml::Function)) and not owningInvocation.ownedSubsetting->reject(i | i.isImplied).subsettedFeature.type->exists(e | e.oclIsKindOf(sysml::Function)) implies owningInvocation.ownedTyping->forAll(type | self.specializes(type))", "If a Feature is the result parameter of an InvocationExpression that does not have an ownedTyping that is a Function or a non-implied ownedSubsetting of a Function that is typed by a Function, then it must specialize the types of the ownedTypings of the InvocationExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSubsetting(), "validateSubsettingFeaturingTypes", "aql:let subsettingFeaturingTypes: OrderedSet(sysml::Type) = self.subsettingFeature.featuringTypes in let subsettedFeaturingTypes: OrderedSet(sysml::Type) = self.subsettedFeature.featuringTypes in let anythingType: sysml::Element = self.subsettingFeature.resolveGlobal('Base::Anything').memberElement in subsettedFeaturingTypes->forAll(t | subsettingFeaturingTypes->isEmpty() and t = anythingType or subsettingFeaturingTypes->exists(e | e.specializes(t))", "For each featuringType of the subsettedFeature of a Subsetting, there must be a featuringType of the subsettingFeature that conforms to it."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSubsetting(), "validateSubsettingUniquenessConformance", "aql:self.subsettedFeature.isUnique implies self.subsettingFeature.isUnique", "If the subsettedFeature of a Subsetting has isUnique = true, then the subsettedFeature must have isUnique = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getEndFeatureMembership(), "validateEndFeatureMembershipIsEnd", "aql:self.ownedMemberFeature.isEnd", "The ownedMemberFeature of an EndFeatureMembership must be an end Feature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getClassifier(), "validateClassifierMultiplicityDomain", "aql:self.multiplicity <> null implies self.multiplicity.featuringType->isEmpty()", "If a Classifier has a multiplicity, then the multiplicity must have no featuringTypes (meaning that its domain is implicitly Base::Anything)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSpecialization(), "validateSpecificationSpecificNotConjugated", "aql:not self.specific.isConjugated", "The specific Type of a Specialization cannot be a conjugated Type."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "checkTypeSpecialization", "aql:self.specializesFromLibrary('Base::Anything')", "A Type must directly or indirectly specialize Base::Anything from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeIntersectingTypesNotSelf", "aql:self.intersectingType->excludes(self)", "A Type cannot be one of its own intersectingTypes."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeDifferencingTypesNotSelf", "aql:self.differencingType->excludes(self)", "A Type cannot be one of its own differencingTypes."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeUnioningTypesNotSelf", "aql:self.unioningType->excludes(self)", "A Type cannot be one of its own unioningTypes."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeAtMostOneConjugator", "aql:self.ownedRelationship->filter(sysml::Conjugation)->size() <= 1", "A Type must have at most one owned Conjugation Relationship."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeOwnedMultiplicity", "aql:self.ownedMember->filter(sysml::Multiplicity)->size() <= 1", "A Type may have at most one ownedMember that is a Multiplicity."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeOwnedUnioningNotOne", "aql:self.ownedUnioning->size() <> 1", "A Type must not have exactly one ownedUnioning."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeOwnedIntersectingNotOne", "aql:self.ownedIntersecting->size() <> 1", "A Type must not have exactly one ownedIntersecting."),
          new ValidationRule(SysmlPackage.eINSTANCE.getType(), "validateTypeOwnedDifferencingNotOne", "aql:self.ownedDifferencing->size() <> 1", "A Type must not have exactly one ownedDifferencing."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMultiplicity(), "checkMultiplicityTypeFeaturing", "aql:if self.owningType <> null and self.owningType.oclIsKindOf(sysml::Feature) then self.featuringType = self.owningType.oclAsType(sysml::Feature).featuringType else self.featuringType->isEmpty() endif", "If the owningType of a Multiplicity is a Feature, then the Multiplicity must have the same featuringTypes as that Feature. Otherwise, it must have no featuringTypes (meaning that it is implicitly featured by the base Classifier Anything)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMultiplicity(), "checkMultiplicitySpecialization", "aql:self.specializesFromLibrary('Base::naturals')", "A Multiplicity must directly or indirectly specialize the Feature Base::naturals from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLiteralBoolean(), "checkLiteralBooleanSpecialization", "aql:self.specializesFromLibrary('Performances::literalBooleanEvaluations')", "A LiteralBoolean must directly or indirectly specialize Performances::literalBooleanEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLiteralExpression(), "checkLiteralExpressionSpecialization", "aql:self.specializesFromLibrary('Performances::literalEvaluations')", "A LiteralExpression must directly or indirectly specialize the base LiteralExpression Performances::literalEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLiteralRational(), "checkLiteralRationalSpecialization", "aql:self.specializesFromLibrary('Performances::literalRationalEvaluations')", "A LiteralRational must directly or indirectly specialize Performances::literalRationalEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLiteralInfinity(), "checkLiteralInfinitySpecialization", "aql:self.specializesFromLibrary('Performances::literalIntegerEvaluations')", "A LiteralInfinity must directly or indirectly specialize Performances::literalIntegerEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLiteralInteger(), "checkLiteralIntegerSpecialization", "aql:self.specializesFromLibrary('Performances::literalIntegerEvaluations')", "A LiteralInteger must directly or indirectly specialize Performances::literalIntegerEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getNullExpression(), "checkNullExpressionSpecialization", "aql:self.specializesFromLibrary('Performances::nullEvaluations')", "A NullExpression must directly or indirectly specialize the base NullExpression Performances::nullEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLiteralString(), "checkLiteralStringSpecialization", "aql:self.specializesFromLibrary('Performances::literalStringEvaluations')", "A LiteralString must directly or indirectly specialize Performances::literalStringEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInvocationExpression(), "checkInvocationExpressionConstructorBindingConnector", "aql:not self.ownedTyping->exists(e | e.oclIsKindOf(sysml::Function)) and not self.ownedSubsetting->reject(i | i.isImplied).subsettedFeature.type->exists(e | e.oclIsKindOf(sysml::Function)) implies self.ownedFeature.oclIsKindOf(sysml::BindingConnector)->exists( relatedFeature->includes(self) and relatedFeature->includes(self.result))", "If an InvocationExpression does not have an ownedTyping that is a Function or an ownedSubsetting of a Feature  that is typed by a Function, then it must own a BindingConnector between itself and its result parameter."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInvocationExpression(), "validateInvocationExpressionParameterRedefinition", "aql:let features : Set(sysml::Feature) = self.type.feature->asSet() in self.input->forAll(inp | inp.ownedRedefinition.redefinedFeature->intersection(features)->size() = 1)", "Each input parameter of an InvocationExpression must redefine exactly one feature of a type of the InvocationExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInvocationExpression(), "validateInvocationExpressionNoDuplicateParameterRedefinition", "aql:let features : Set(sysml::Feature) = self.type.feature->asSet() in self.input->forAll(inp1 | self.input->forAll(inp2 | inp1 <> inp2 implies inp1.ownedRedefinition.redefinedFeature->intersection(inp2.ownedRedefinition.redefinedFeature)->intersection(features)->isEmpty()))", "Two different input parameters of an InvocationExpression must not redefine the same feature of a type of the InvocationExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureReferenceExpression(), "checkFeatureReferenceExpressionBindingConnector", "aql:self.ownedMember->filter(sysml::BindingConnector)->exists(b | b.relatedFeatures->includes(targetFeature) and b.relatedFeatures->includes(self.result))", "A FeatureReferenceExpression must have an ownedMember that is a BindingConnector between the referent and result of the FeatureReferenceExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureReferenceExpression(), "validateFeatureReferenceExpressionReferentIsFeature", "aql:let membership : sysml::Membership = self.ownedMembership->reject(m | m.oclIsKindOf(sysml::ParameterMembership)) in self.membership->notEmpty() and self.membership->at(1).memberElement.oclIsKindOf(sysml::Feature)", "The first ownedMembership of a FeatureReferenceExpression that is not a ParameterMembership must have a Feature as its memberElement."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSelectExpression(), "validateSelectExpressionOperator", "aql:self.operator = 'select'", "The operator of a SelectExpression must be 'select'."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOperatorExpression(), "checkOperatorExpressionSpecialization", "aql:let libFunctions : Sequence(sysml::Element) = Sequence{'BaseFunctions', 'DataFunctions', 'ControlFunctions'}->collect(ns | self.resolveGlobal(ns + '::'' + self.operator + ''').memberElement) in libFunctions->includes(function)", "The function of an OperatorExpression must be the resolution of the operator from one of the packages BaseFunctions, DataFunctions, or ControlFunctions from the Kernel Function Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCollectExpression(), "validateCollectExpressionOperator", "aql:self.operator = 'collect'", "The operator of a CollectExpression must be 'collect'."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureChainExpression(), "checkFeatureChainExpressionTargetRedefinition", "aql:let sourceParameter : sysml::Feature = self.sourceTargetFeature() in self.sourceTargetFeature <> null and self.sourceTargetFeature.redefinesFromLibrary('ControlFunctions::\'.\'::source::target')", "The first ownedFeature of the first owned input parameter of a FeatureChainExpression must redefine the Feature ControlFunctions::'.'::source::target from the Kernel Functions Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureChainExpression(), "checkFeatureChainExpressionSourceTargetRedefinition", "aql:let sourceParameter : sysml::Feature = self.sourceTargetFeature() in self.sourceTargetFeature <> null and self.sourceTargetFeature.redefines(targetFeature)", "The first ownedFeature of the first owned input parameter of a FeatureChainExpression must redefine its targetFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureChainExpression(), "validateFeatureChainExpressionConformance", "aql:self.argument->notEmpty() implies self.targetFeature.featuringType->forAll(t | t.specializes(argument->at(1).result))", "The featuringTypes of the targetFeature of a FeatureChainExpression must conform to the result parameter of the argument Expression of the FeatureChainExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataAccessExpression(), "checkMetadataAccessExpressionSpecialization", "aql:self.specializesFromLibrary('Performances::metadataAccessEvaluations')", "A MetadataAccessExpression must directly or indirectly specialize the base MetadataAccessExpression Performances::metadataAccessEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getItemFlow(), "checkItemFlowSpecialization", "aql:if self.itemFlowEnds->isEmpty() then self.specializesFromLibrary('Transfers::transfers') else self.specializesFromLibrary('Transfers::flowTransfers') endif", "An ItemFlow must directly or indirectly specialize the Step Transfers::transfers from the Kernel Semantic Library. In addition, if the ItemFlow has ItemFlowEnds, it must specialize Transfers::flowTransfers."),
          new ValidationRule(SysmlPackage.eINSTANCE.getItemFlow(), "validateItemFlowItemFeature", "aql:self.ownedFeature->filter(sysml::ItemFeature)->size() <= 1", "An ItemFlow must have at most one ownedFeature that is an ItemFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSuccessionItemFlow(), "checkSuccessionItemFlowSpecialization", "aql:self.specializesFromLibrary('Transfers::flowTransfersBefore')", "A SuccessionItemFlow must directly or indirectly specialize the Step Transfers::flowTransfersBefore from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getItemFeature(), "checkItemFeatureRedefinition", "aql:self.ownedRedefinition.redefinedFeature->redefinesFromLibrary('Transfers::Transfer::item')", "An ItemFeature must redefine the Feature Transfers::Transfer::item from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getItemFlowEnd(), "validateItemFlowEndIsEnd", "aql:self.isEnd", "An ItemFlowEnd must be an end Feature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getItemFlowEnd(), "validateItemFlowEndNestedFeature", "aql:self.ownedFeature->size() = 1", "An ItemFlowEnd must have exactly one ownedFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getItemFlowEnd(), "validateItemFlowEndOwningType", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::ItemFlow)", "The owningType of an ItemFlow must be an ItemFlow."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStep(), "checkStepSpecialization", "aql:self.specializesFromLibrary('Performances::performances')", "A Step must directly or indirectly specialize the base Step Performances::performances from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStep(), "checkStepEnclosedPerformanceSpecialization", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::Behavior) or self.owningType.oclIsKindOf(sysml::Step)) implies self.specializesFromLibrary('Performances::Performance::enclosedPerformance')", "AStep whose owningType is a Behavior or another Step must directly or indirectly specialize the Step Performances::Performance::enclosedPerformance."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStep(), "checkStepOwnedPerformanceSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::Structure) or self.owningType.oclIsKindOf(sysml::Feature) and self.owningType.oclAsType(sysml::Feature).type->exists(e | e.oclIsKindOf(sysml::Structure)) implies self.specializesFromLibrary('Objects::Object::ownedPerformance')", "A composite Step whose owningType is a Structure or a Feature typed by a Structure must directly or indirectly specialize the Step Objects::Object::ownedPerformance."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStep(), "checkStepSubperformanceSpecialization", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::Behavior) or self.owningType.oclIsKindOf(sysml::Step)) and self.isComposite implies self.specializesFromLibrary('Performances::Performance::subperformance')", "AStep whose owningType is a Behavior or another Step, and which is composite, must directly or indirectly specialize the Step Performances::Performance::subperformance."),
          new ValidationRule(SysmlPackage.eINSTANCE.getBehavior(), "checkBehaviorSpecialization", "aql:self.specializesFromLibrary('Performances::Performance')", "A Behavior must directly or indirectly specialize the base Behavior Performances::Performance from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getBehavior(), "validateBehaviorSpecialization", "aql:self.ownedSpecialization.general->forAll(i | not i.oclIsKindOf(sysml::Structure))", "A Behavior must not specialize a Structure."),
          new ValidationRule(SysmlPackage.eINSTANCE.getParameterMembership(), "validateParameterMembershipParameterDirection", "aql:self.ownedMemberParameter.direction = self.parameterDirection()", "The ownedMemberParameter of a ParameterMembership must have a  direction equal to the result of the parameterDirection() operation."),
          new ValidationRule(SysmlPackage.eINSTANCE.getParameterMembership(), "validateParameterMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::Behavior) or self.owningType.oclIsKindOf(sysml::Step)", "A ParameterMembership must be owned by a Behavior or a Step."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "checkConnectorTypeFeaturing", "aql:self.relatedFeature->forAll(f | if self.featuringType->isEmpty() then f.isFeaturedWithin(null) else self.featuringType->forAll(t | f.isFeaturedWithin(t)) endif)", "Each relatedFeature of a Connector must have each featuringType of the Connector as a direct or indirect featuringType (where a Feature with no featuringType is treated as if the Classifier Base::Anything was its featuringType)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "validateConnectorRelatedFeatures", "aql:not self.isAbstract implies self.relatedFeature->size() >= 2", "If a Connector is concrete (not abstract), then it must have at least two relatedFeatures."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "checkConnectorSpecialization", "aql:self.specializesFromLibrary('Links::links')", "A Connector must directly or indirectly specialize the base Connector Links::links from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "checkConnectorObjectSpecialization", "aql:self.association->exists(e | e.oclIsKindOf(sysml::AssociationStructure)) implies self.specializesFromLibrary('Objects::linkObjects')", "A Connector for an AssociationStructure must directly or indirectly specialize the base Connector Objects::linkObjects from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "checkConnectorBinaryObjectSpecialization", "aql:self.connectorEnd->size() = 2 and self.association->exists(e | e.oclIsKindOf(sysml::AssociationStructure)) implies self.specializesFromLibrary('Objects::binaryLinkObjects')", "A binary Connector for an AssociationStructure  must directly or indirectly specialize the base Connector Objects::binaryLinkObjects from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "checkConnectorBinarySpecialization", "aql:self.connectorEnd->size() = 2 implies self.specializesFromLibrary('Links::binaryLinks')", "A binary Connector must directly or indirectly specialize the base Connector Links::binaryLinks from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnector(), "validateConnectorBinarySpecialization", "aql:self.connectorEnd->size() > 2 implies not self.specializesFromLibrary('Links::BinaryLink')", "If a Connector has more than two connectorEnds, then it must not specialize, directly or indirectly, the Association BinaryLink from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getBindingConnector(), "checkBindingConnectorSpecialization", "aql:self.specializesFromLibrary('Links::selfLinks')", "A BindingConnector must directly or indirectly specialize the base BindingConnector Links::selfLinks from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getBindingConnector(), "validateBindingConnectorIsBinary", "aql:self.relatedFeature->size() = 2", "A BindingConnector must be binary."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSuccession(), "checkSuccessionSpecialization", "aql:self.specializesFromLibrary('Occurences::happensBeforeLinks')", "A Succession must directly or indirectly specialize the Feature Occurrences::happensBeforeLinks from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociation(), "checkAssociationSpecialization", "aql:self.specializesFromLibrary('Links::Link')", "An Association must directly or indirectly specialize the base Association Links::Link from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociation(), "validateAssociationStructureIntersection", "aql:self.oclIsKindOf(sysml::Structure) = self.oclIsKindOf(sysml::AssociationStructure)", "If an Association is also a kind of Structure, then it must be an AssociationStructure."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociation(), "checkAssociationBinarySpecialization", "aql:self.associationEnd->size() = 2 implies self.specializesFromLibrary('Links::BinaryLink')", "A binary Association must directly or indirectly specialize the base Association Links::binaryLink from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociation(), "validateAssociationRelatedTypes", "aql:not self.isAbstract implies self.relatedType->size() >= 2", "If an Association is concrete (not abstract), then it must have at least two relatedTypes."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociation(), "validateAssociationBinarySpecialization", "aql:self.associationEnd->size() > 2 implies not self.specializesFromLibrary('Links::BinaryLink')", "If an Association has more than two associationEnds, then it must not specialize, directly or indirectly, the Association BinaryLink from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociationStructure(), "checkAssociationStructureSpecialization", "aql:self.specializesFromLibrary('Objects::LinkObject')", "An AssociationStructure must directly or indirectly specialize the base AssociationStructure Objects::LinkObject from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssociationStructure(), "checkAssociationStructureBinarySpecialization", "aql:self.endFeature->size() = 2 implies self.specializesFromLibrary('Objects::BinaryLinkObject')", "A binary AssociationStructure must directly or indirectly specialize the base AssociationStructure Objects::BinaryLinkObject from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDataType(), "checkDataTypeSpecialization", "aql:self.specializesFromLibrary('Base::DataValue')", "A DataType must directly or indirectly specialize the base DataType Base::DataValue from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDataType(), "validateDataTypeSpecialization", "aql:self.ownedSpecialization.general->forAll(i | not i.oclIsKindOf(sysml::Class) and not i.oclIsKindOf(sysml::Association))", "A DataType must not specialize a Class or an Association."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureValue(), "checkFeatureValueBindingConnector", "aql:not self.isDefault implies self.featureWithValue.ownedMember->filter(sysml::BindingConnector)->exists(b | b.relatedFeature->includes(featureWithValue) and b.relatedFeature->includes(value.result) and if not self.isInitial then b.featuringType = self.featureWithValue.featuringType else b.featuringType->exists(t | t.oclIsKindOf(sysml::Feature) and t.oclAsType(sysml::Feature).chainingFeature = Sequence{ self.resolveGlobal('Base::things::that').memberElement, self.resolveGlobal('Occurrences::Occurrence::startShot').memberElement } ) endif)", "If isDefault = false, then the featureWithValue must have an ownedMember that is a BindingConnector whose relatedElements are the featureWithValue and the result of the value Expression. If isInitial = false, then this BindingConnector must have featuringTypes that are the same as those of the featureWithValue. If isInitial = true, then the BindingConnector must have that.startShot as its featuringType."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFeatureValue(), "validateFeatureValueOverriding", "aql:self.featureWithValue.redefinition.redefinedFeature->closure(redefinition.redefinedFeature).valuation->forAll(isDefault)", "All Features directly or indirectly redefined by the featureWithValue of a FeatureValue must have only default FeatureValues."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMultiplicityRange(), "checkMultiplicityRangeExpressionTypeFeaturing", "aql:self.bound->forAll(b | b.featuringType = self.featuringType)", "The bounds of a MultiplicityRange must have the same featuringTypes as the MultiplicityRange."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMultiplicityRange(), "validateMultiplicityRangeBoundResultTypes", "aql:self.bound->forAll(b | b.result.specializesFromLibrary('ScalarValues::Integer') and let value : UnlimitedNatural = self.valueOf(b) in value <> null implies value >= 0 )", "The results of the bound Expression(s) of a MultiplicityRange must be typed by ScalarValues::Intger from the Kernel Data Types Library. If a bound is model-level evaluable, then it must evaluate to a non-negative value."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFunction(), "checkFunctionResultBindingConnector", "aql:self.ownedMembership.oclIsKindOf(sysml::ResultExpressionMembership)->forAll(mem | self.ownedFeature.oclIsKindOf(sysml::BindingConnector)->exists(binding | binding.relatedFeature->includes(self.result) and binding.relatedFeature->includes(mem.ownedResultExpression.result)))", "If a Function has an Expression owned via a ResultExpressionMembership, then the owning Function must also own a BindingConnector between its result parameter and the result parameter of the result Expression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFunction(), "checkFunctionSpecialization", "aql:self.specializesFromLibrary('Performances::Evaluation')", "A Function must directly or indirectly specialize the base Function Performances::Evaluation from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFunction(), "validateFunctionResultParameterMembership", "aql:self.ownedFeatureMembership->filter(sysml::ReturnParameterMembership)->size() <= 1", "A Function must own at most one ResultParameterMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFunction(), "validateFunctionResultExpressionMembership", "aql:self.membership->filter(sysml::ResultExpressionMembership)->size() <= 1", "A Function must have at most one ResultExpressionMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpression(), "checkExpressionSpecialization", "aql:self.specializesFromLibrary('Performances::evaluations')", "An Expression must directly or indirectly specialize the base Expression Performances::evaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpression(), "checkExpressionTypeFeaturing", "aql:self.owningMembership <> null and self.owningMembership.oclIsKindOf(sysml::FeatureValue) implies let featureWithValue : sysml::Feature = self.owningMembership.oclAsType(sysml::FeatureValue).featureWithValue in self.featuringType = self.featureWithValue.featuringType", "If this Expression is owned by a FeatureValue, then it must have the same featuringTypes as the featureWithValue of the FeatureValue."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpression(), "checkExpressionResultBindingConnector", "aql:self.ownedMembership.oclIsKindOf(sysml::ResultExpressionMembership)->forAll(mem | self.ownedFeature.oclIsKindOf(sysml::BindingConnector)->exists(binding | binding.relatedFeature->includes(self.result) and binding.relatedFeature->includes(mem.ownedResultExpression.result)))", "If an Expression has an Expression owned via a ResultExpressionMembership, then the owning Expression must also own a BindingConnector between its result parameter and the result parameter of the result Expression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpression(), "validateExpressionResultParameterMembership", "aql:self.ownedFeatureMembership->filter(sysml::ReturnParameterMembership)->size() <= 1", "An Expression must own at most one ResultParameterMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpression(), "validateExpressionResultExpressionMembership", "aql:self.membership->filter(sysml::ResultExpressionMembership)->size() <= 1", "An Expression must have at most one ResultExpressionMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInvariant(), "checkInvariantSpecialization", "aql:if self.isNegated then self.specializesFromLibrary('Performances::falseEvaluations') else self.specializesFromLibrary('Performances::trueEvaluations') endif", "An Invariant must directly or indirectly specialize either of the following BooleanExpressions from the Kernel Semantic Library: Performances::trueEvaluations, if isNegated = false, or  Performances::falseEvaluations, if isNegated = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPredicate(), "checkPredicateSpecialization", "aql:self.specializesFromLibrary('Performances::BooleanEvaluation')", "A Predicate must directly or indirectly specialize the base Predicate Performances::BooleanEvaluation from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getBooleanExpression(), "checkBooleanExpressionSpecialization", "aql:self.specializesFromLibrary('Performances::booleanEvaluations')", "A BooleanExpression must directly or indirectly specialize the base BooleanExpression Performances::booleanEvaluations from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getResultExpressionMembership(), "validateResultExpressionMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::Function) or self.owningType.oclIsKindOf(sysml::Expression)", "The owningType of a ResultExpressionMembership must be a Function or Expression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getReturnParameterMembership(), "validateReturnParameterMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::Function) or self.owningType.oclIsKindOf(sysml::Expression)", "The owningType of a ReturnParameterMembership must be a Function or Expression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getElementFilterMembership(), "validateElementFilterMembershipConditionIsModelLevelEvaluable", "aql:self.condition.isModelLevelEvaluable", "The condition Expression must be model-level evaluable."),
          new ValidationRule(SysmlPackage.eINSTANCE.getElementFilterMembership(), "validateElementFilterMembershipConditionIsBoolean", "aql:self.condition.result.specializesFromLibrary('ScalarValues::Boolean')", "The result parameter of the condition Expression must directly or indirectly specialize ScalarValues::Boolean."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataFeature(), "checkMetadataFeatureSpecialization", "aql:self.specializesFromLibrary('Metaobjects::metaobjects')", "A MetadataFeature must directly or indirectly specialize the base MetadataFeature Metaobjects::metaobjects from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataFeature(), "checkMetadataFeatureSemanticSpecialization", "aql:self.isSemantic() implies let annotatedTypes : Sequence(sysml::Type) = self.annotatedElement->selectAsKind(Type) in let baseTypes : Sequence(sysml::MetadataFeature) = self.evaluateFeature(resolveGlobal( 'Metaobjects::SemanticMetadata::baseType').memberElement.oclAsType(sysml::Feature))->selectAsKind(MetadataFeature) in annotatedTypes->notEmpty() and baseTypes()->notEmpty() and baseTypes()->first().isSyntactic() implies let annotatedType : sysml::Type = annotatedTypes->first() in let baseType : sysml::Element = baseTypes->first().syntaxElement() in if annotatedType.oclIsKindOf(sysml::Classifier) and baseType.oclIsKindOf(sysml::Feature) then baseType.oclAsType(sysml::Feature).type->forAll(t | annotatedType.specializes(t)) else if baseType.oclIsKindOf(sysml::Type) then annotatedType.specializes(baseType.oclAsType(sysml::Type)) else true endif", "If this MetadataFeature is an application of SemanticMetadata, then its annotatingElement must be a Type. The annotated Type must then directly or indirectly specialize the specified value of the baseType, unless the Type is a Classifier and the baseType represents a kind of Feature, in which case the Classifier must directly or indirectly specialize each of the types of the Feature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataFeature(), "validateMetadataFeatureMetaclassNotAbstract", "aql:not self.metaclass.isAbstract", "The metaclass of a MetadataFeature must not be abstract."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataFeature(), "validateMetadataFeatureAnnotatedElement", "aql:let baseAnnotatedElementFeature : sysml::Feature = self.resolveGlobal('Metaobjects::Metaobject::annotatedElement').memberElement.oclAsType(sysml::Feature) in let annotatedElementFeatures : OrderedSet(sysml::Feature) = self.feature->select(specializes(baseAnnotatedElementFeature))->excluding(baseAnnotatedElementFeature) in self.annotatedElementFeatures->notEmpty() implies let annotatedElementTypes : Set(sysml::Feature) = self.annotatedElementFeatures.typing.type->asSet() in let metaclasses : Set(sysml::Metaclass) = self.annotatedElement.oclType().qualifiedName->collect(qn | self.resolveGlobal(qn).memberElement.oclAsType(sysml::Metaclass)) in self.metaclasses->forAll(m | self.annotatedElementTypes->exists(t | m.specializes(t)))", "The annotatedElements of a MetadataFeature must have an abstract syntax metaclass consistent with the annotatedElement declarations for the MetadataFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataFeature(), "validateMetadataFeatureBody", "aql:self.ownedFeature->closure(ownedFeature)->forAll(f | f.declaredName = null and f.declaredShortName = null and f.valuation <> null implies f.valuation.value.isModelLevelEvaluable and f.redefinition.redefinedFeature->size() = 1)", "Each ownedFeature of a MetadataFeature must have no declared name, redefine a single Feature, either have no featureValue or a featureValue with a value Expression that is model-level evaluable, and only have ownedFeatures that also meet these restrictions."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataFeature(), "validateMetadataFeatureMetaclass", "aql:self.type->filter(sysml::Metaclass)->size() = 1", "A MetadataFeature must have exactly one type that is a Metaclass."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetaclass(), "checkMetaclassSpecialization", "aql:self.specializesFromLibrary('Metaobjects::Metaobject')", "A Metaclass must directly or indirectly specialize the base Metaclass Metaobjects::Metaobject from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStructure(), "checkStructureSpecialization", "aql:self.specializesFromLibrary('Objects::Object')", "A Structure must directly or indirectly specialize the base Structure Objects::Object from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStructure(), "validateStructureSpecialization", "aql:self.ownedSpecialization.general->forAll(i | not i.oclIsKindOf(sysml::Behavior))", "A Structure must not specialize a Behavior."),
          new ValidationRule(SysmlPackage.eINSTANCE.getClass_(), "checkClassSpecialization", "aql:self.specializesFromLibrary('Occurrences::Occurrence')", "A Class must directly or indirectly specialize the base Class Occurrences::Occurrence from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getClass_(), "validateClassSpecialization", "aql:self.ownedSpecialization.general->forAll(i | not i.oclIsKindOf(sysml::DataType)) and not i.oclIsKindOf(sysml::Association) implies self.ownedSpecialization.general->forAll(i | not i.oclIsKindOf(sysml::Association))", "A Class must not specialize a DataType and it can only specialize an Association if it is also itself a kind of Association (such as an AssociationStructure or Interaction)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortUsage(), "validatePortUsageNestedUsagesNotComposite", "aql:self.nestedUsage->reject(i | i.oclIsKindOf(sysml::PortUsage))->forAll(i | not i.isComposite)", "The nestedUsages of a PortUsage that are not themselves PortUsages must not be composite."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortUsage(), "checkPortUsageSpecialization", "aql:self.specializesFromLibrary('Ports::ports')", "A PortUsage must directly or indirectly specialize the PortUsage Ports::ports from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortUsage(), "checkPortUsageSubportSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::PortDefinition) or self.owningType.oclIsKindOf(sysml::PortUsage)) implies self.specializesFromLibrary('Ports::Port::subports')", "A composite PortUsage with an owningType that is a PortDefinition or PortUsage must directly or indirectly specialize the PortUsage Ports::Port::subports from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortUsage(), "validatePortUsageIsReference", "aql:self.owningType = null or not self.owningType.oclIsKindOf(sysml::PortDefinition) and not self.owningType.oclIsKindOf(sysml::PortUsage) implies self.isReference", "Unless a PortUsage has an owningType that is a PortDefinition or a PortUsage, it must be referential (non-composite)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortDefinition(), "validatePortDefinitionOwnedUsagesNotComposite", "aql:self.ownedUsage->reject(i | i.oclIsKindOf(sysml::PortUsage))->forAll(i | not i.isComposite)", "The ownedUsages of a PortDefinition that are not PortUsages must not be composite."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortDefinition(), "validatePortDefinitionConjugatedPortDefinition", "aql:not self.oclIsKindOf(sysml::ConjugatedPortDefinition) implies self.ownedMember->filter(sysml::ConjugatedPortDefinition)->size() = 1", "Unless it is a ConjugatedPortDefinition, a PortDefinition must have exactly one ownedMember that is a ConjugatedPortDefinition."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPortDefinition(), "checkPortDefinitionSpecialization", "aql:self.specializesFromLibrary('Ports::Port')", "A PortDefinition must directly or indirectly specialize the PortDefinition Ports::Port from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConjugatedPortDefinition(), "validateConjugatedPortDefinitionOriginalPortDefinition", "aql:self.ownedPortConjugator.originalPortDefinition = self.originalPortDefinition", "The originalPortDefinition of the ownedPortConjugator of a ConjugatedPortDefinition must be the originalPortDefinition of the ConjugatedPortDefinition."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConjugatedPortDefinition(), "validateConjugatedPortDefinitionConjugatedPortDefinitionIsEmpty", "aql:self.conjugatedPortDefinition = null", "A ConjugatedPortDefinition must not itself have a conjugatedPortDefinition."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAttributeDefinition(), "validateAttributeDefinitionFeatures", "aql:self.feature->forAll(i | not i.isComposite)", "All features of an AttributeDefinition must be non-composite."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAttributeUsage(), "validateAttributeUsageIsReference", "aql:self.isReference", "An AttributeUsage is always referential."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAttributeUsage(), "validateAttributeUsageFeatures", "aql:self.feature->forAll(i | not i.isComposite)", "All features of an AttributeUsage must be non-composite."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAttributeUsage(), "checkAttributeUsageSpecialization", "aql:self.specializesFromLibrary('Base::dataValues')", "An AttributeUsage must directly or indirectly specialize Base::dataValues from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAcceptActionUsage(), "validateAcceptActionUsageParameters", "aql:self.inputParameters()->size() >= 2", "An AcceptUsageAction must have at least two input parameters, corresponding to its payload and receiver, respectively (even if they have no FeatureValue). (Note that the payloadParameter is an input as well as an output.)"),
          new ValidationRule(SysmlPackage.eINSTANCE.getAcceptActionUsage(), "checkAcceptActionUsageSpecialization", "aql:not self.isTriggerAction() implies self.specializesFromLibrary('Actions::acceptActions')", "An AcceptActionUsage that is not the triggerAction of a TransitionUsage must directly or indirectly specialize the ActionUsage Actions::acceptActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAcceptActionUsage(), "checkAcceptActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() and not self.isTriggerAction() implies self.specializesFromLibrary('Actions::Action::acceptSubactions')", "A composite AcceptActionUsage that is a subaction usage, but is not the triggerAction of a TransitionUsage, must directly or indirectly specialize the ActionUsage Actions::Action::acceptSubactions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAcceptActionUsage(), "checkAcceptActionUsageTriggerActionSpecialization", "aql:self.isTriggerAction() implies self.specializesFromLibrary('Actions::TransitionAction::accepter')", "An AcceptActionUsage that is the triggerAction of TransitionUsage must directly or indirectly specialize the ActionUsage Actions::TransitionAction::accepter from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAcceptActionUsage(), "checkAcceptActionUsageReceiverBindingConnector", "aql:self.payloadArgument <> null and self.payloadArgument.oclIsKindOf(sysml::TriggerInvocationExpression) implies let invocation : sysml::Expression = self.payloadArgument.oclAsType(sysml::Expression) in self.parameter->size() >= 2 and invocation.parameter->size() >= 2 and self.ownedFeature->filter(sysml::BindingConnector)->exists(b | b.relatedFeatures->includes(parameter->at(2)) and b.relatedFeatures->includes(invocation.parameter->at(2)))", "If the payloadArgument of an AcceptActionUsage is a TriggerInvocationExpression, then the AcceptActionusage must have an ownedFeature that is a BindingConnector between its receiver parameter and the receiver parameter of the TriggerInvocationExpression."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSendActionUsage(), "validateSendActionParameters", "aql:self.inputParameters()->size() >= 3", "A SendActionUsage must have at least three owned input parameters, corresponding to its payload, sender and receiver, respectively (whether or not they have FeatureValues)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSendActionUsage(), "checkSendActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() implies self.specializesFromLibrary('Actions::Action::acceptSubactions')", "A composite SendActionUsage that is a subaction must directly or indirectly specialize the ActionUsage Actions::Action::sendSubactions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSendActionUsage(), "checkSendActionUsageSpecialization", "aql:self.specializesFromLibrary('Actions::sendActions')", "A SendActionUsage must directly or indirectly specialize the ActionUsage Actions::sendActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPerformActionUsage(), "validatePerformActionUsageReference", "aql:self.ownedReferenceSubsetting <> null implies self.ownedReferenceSubsetting.referencedFeature.oclIsKindOf(sysml::ActionUsage)", "If a PerformActionUsage has an ownedReferenceSubsetting, then its referencedFeature must be a ActionUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPerformActionUsage(), "checkPerformActionUsageSpecialization", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::PartDefinition) or self.owningType.oclIsKindOf(sysml::PartUsage)) implies self.specializesFromLibrary('Parts::Part::performedActions')", "If a PerformActionUsage has an owningType that is a PartDefinition or PartUsage, then it must directly or indirectly specialize the ActionUsage Parts::Part::performedActions."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForkNode(), "validateForkNodeIncomingSuccessions", "aql:self.targetConnector->filter(sysml::Succession)->size() <= 1", "A ForkNode may have at most one incoming Succession."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForkNode(), "checkForkNodeSpecialization", "aql:self.specializesFromLibrary('Actions::Action::forks')", "A ForkNode must directly or indirectly specialize the ActionUsage Actions::Action::forks from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getJoinNode(), "validateJoinNodeOutgoingSuccessions", "aql:self.sourceConnector->filter(sysml::Succession)->size() <= 1", "A JoinNode may have at most one outgoing Succession."),
          new ValidationRule(SysmlPackage.eINSTANCE.getJoinNode(), "checkJoinNodeSpecialization", "aql:self.specializesFromLibrary('Actions::Action::join')", "A JoinNode must directly or indirectly specialize the ActionUsage Actions::Action::joins from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getControlNode(), "validateControlNodeOutgoingSuccessions", "aql:self.sourceConnector->filter(sysml::Succession)->collect(connectorEnd->at(1).multiplicity)->forAll(sourceMult | self.multiplicityHasBounds(sourceMult, 1, 1))", "All outgoing Successions from a ControlNode must have a source multiplicity of 1..1."),
          new ValidationRule(SysmlPackage.eINSTANCE.getControlNode(), "validateControlNodeOwningType", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::ActionDefinition) or self.owningType.oclIsKindOf(sysml::ActionUsage))", "The owningType of a ControlNode must be an ActionDefinition or ActionUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getControlNode(), "validateControlNodeIncomingSuccessions", "aql:self.targetConnector->filter(sysml::Succession)->collect(connectorEnd->at(2).multiplicity)->forAll(targetMult | self.multiplicityHasBounds(targetMult, 1, 1))", "All incoming Successions to a ControlNode must have a target multiplicity of 1..1."),
          new ValidationRule(SysmlPackage.eINSTANCE.getControlNode(), "checkControlNodeSpecialization", "aql:self.specializesFromLibrary('Action::Action::controls')", "A ControlNode must directly or indirectly specialize the ActionUsage Actions::Action::control from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getActionUsage(), "checkActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() implies self.specializesFromLibrary('Actions::Action::subactions')", "A composite ActionUsage that is a subaction usage must directly or indirectly specialize the ActionUsage Actions::Action::subactions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getActionUsage(), "checkActionUsageSpecialization", "aql:self.specializesFromLibrary('Actions::actions')", "An ActionUsage must directly or indirectly specialize the ActionUsage Actions::actions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getActionUsage(), "checkActionUsageOwnedActionSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::PartDefinition) or self.owningType.oclIsKindOf(sysml::PartUsage)) implies self.specializesFromLibrary('Parts::Part::ownedActions')", "A composite ActionUsage whose owningType is  PartDefinition or PartUsage must directly or indirectly specialize the ActionUsage Parts::Part::ownedActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getActionUsage(), "checkActionUsageStateActionRedefinition", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::StateSubactionMembership) implies let kind : StateSubactionKind = self.owningFeatureMembership.oclAsType(sysml::StateSubactionMembership).kind in if kind = StateSubactionKind::entry then self.redefinesFromLibrary('States::StateAction::entryAction') else if kind = StateSubactionKind::do then self.redefinesFromLibrary('States::StateAction::doAction') else self.redefinesFromLibrary('States::StateAction::exitAction') endif endif", "An ActionUsage that is the entry, do, or exit Action of a StateDefinition or StateUsage must redefine the entryAction, doAction, or exitAction feature, respectively, of the StateDefinition States::StateAction from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDecisionNode(), "validateDecisionNodeIncomingSuccessions", "aql:self.targetConnector->filter(sysml::Succession)->size() <= 1", "A DecisionNode may have at most one incoming Succession."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDecisionNode(), "validateDecisionNodeOutgoingSuccessions", "aql:self.sourceConnector->selectAsKind(Succession)->collect(connectorEnd->at(2))->forAll(targetMult | self.multiplicityHasBounds(targetMult, 0, 1))", "All outgoing Successions from a DecisionNode must have a target multiplicity of 0..1."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDecisionNode(), "checkDecisionNodeSpecialization", "aql:self.specializesFromLibrary('Actions::Action::decisions')", "A DecisionNode must directly or indirectly specialize the ActionUsage Actions::Action::decisions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDecisionNode(), "checkDecisionNodeOutgoingSuccessionSpecialization", "aql:self.sourceConnector->filter(sysml::Succession)->forAll(subsetsChain(self, self.resolveGlobal('ControlPerformances::MergePerformance::outgoingHBLink')))", "All outgoing Successions from a DecisionNode must subset the inherited outgoingHBLink feature of the DecisionNode."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMergeNode(), "validateMergeNodeOutgoingSuccessions", "aql:self.sourceConnector->selectAsKind(Succession)->size() <= 1", "A MergeNode may have at most one outgoing Succession."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMergeNode(), "validateMergeNodeIncomingSuccessions", "aql:self.targetConnector->filter(sysml::Succession)->collect(connectorEnd->at(1))->forAll(sourceMult | self.multiplicityHasBounds(sourceMult, 0, 1))", "All incoming Successions to a MergeNode must have a source multiplicity of 0..1."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMergeNode(), "checkMergeNodeIncomingSuccessionSpecialization", "aql:self.targetConnector->filter(sysml::Succession)->forAll(subsetsChain(self, self.resolveGlobal('ControlPerformances::MergePerformance::incomingHBLink')))", "All incoming Successions to a MergeNode must subset the inherited incomingHBLink feature of the MergeNode."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMergeNode(), "checkMergeNodeSpecialization", "aql:self.specializesFromLibrary('Actions::Action::merges')", "A MergeNode must directly or indirectly specialize the ActionUsage Actions::Action::merges from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getActionDefinition(), "checkActionDefinitionSpecialization", "aql:self.specializesFromLibrary('Actions::Action')", "An ActionDefinition must directly or indirectly specialize the ActionDefinition Actions::Action from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getIfActionUsage(), "checkIfActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() implies self.specializesFromLibrary('Actions::Action::ifSubactions')", "A composite IfActionUsage that is a subaction usage must directly or indirectly specialize the ActionUsage Actions::Action::ifSubactions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getIfActionUsage(), "checkIfActionUsageSpecialization", "aql:if self.elseAction = null then self.specializesFromLibrary('Actions::ifThenActions') else self.specializesFromLibrary('Actions::ifThenElseActions') endif", "A IfActionUsage must directly or indirectly specialize the ActionUsage Actions::ifThenActions from the Systems Model Library. If it has an elseAction, then it must directly or indirectly specialize Actions::ifThenElseActions."),
          new ValidationRule(SysmlPackage.eINSTANCE.getIfActionUsage(), "validateIfActionUsageParameters", "aql:self.inputParameters()->size() >= 2", "An IfActionUsage must have at least two owned input parameters."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForLoopActionUsage(), "checkForLoopActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() implies self.specializesFromLibrary('Actions::Action::forLoops')", "A composite ForLoopActionUsage that is a subaction usage must directly or indirectly specialize the ActionUsage Actions::Action::forLoops from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForLoopActionUsage(), "checkForLoopActionUsageVarRedefinition", "aql:self.loopVariable <> null and self.loopVariable.redefinesFromLibrary('Actions::ForLoopAction::var')", "The loopVariable of a ForLoopActionUsage must redefine the ActionUsage Actions::ForLoopAction::var."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForLoopActionUsage(), "checkForLoopActionUsageSpecialization", "aql:self.specializesFromLibrary('Actions::forLoopActions')", "A ForLoopActionUsage must directly or indirectly specialize the ActionUsage Actions::forLoopActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForLoopActionUsage(), "validateForLoopActionUsageLoopVariable", "aql:self.ownedFeature->notEmpty() and self.ownedFeature->at(1).oclIsKindOf(sysml::ReferenceUsage)", "The first ownedFeature of a ForLoopActionUsage must be a ReferenceUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getForLoopActionUsage(), "validateForLoopActionUsageParameters", "aql:self.inputParameters()->size() = 2", "A ForLoopActionUsage must have two owned input parameters."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssignmentActionUsage(), "checkAssignmentActionUsageSpecialization", "aql:self.specializesFromLibrary('Actions::assignmentActions')", "An AssignmentActionUsage must directly or indirectly specialize the ActionUsage Actions::assignmentActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssignmentActionUsage(), "checkAssignmentActionUsageStartingAtRedefinition", "aql:let targetParameter : sysml::Feature = self.inputParameter(1) in targetParameter <> null and targetParameter.ownedFeature->notEmpty() and targetParameter.ownedFeature->first().redefines('AssignmentAction::target::startingAt')", "The first ownedFeature of the first parameter of an AssignmentActionUsage must redefine AssignmentAction::target::startingAt."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssignmentActionUsage(), "checkAssignmentActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() implies self.specializesFromLibrary('Actions::Action::assignments')", "A composite AssignmentActionUsage that is a subaction usage must directly or indirectly specialize the ActionUsage Actions::Action::assignments from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssignmentActionUsage(), "checkAssignmentActionUsageAccessedFeatureRedefinition", "aql:let targetParameter : sysml::Feature = self.inputParameter(1) in targetParameter <> null and targetParameter.ownedFeature->notEmpty() and targetParameter->first().ownedFeature->notEmpty() and targetParameter->first().ownedFeature->first().redefines('AssigmentAction::target::startingAt::accessedFeature')", "The first ownedFeature of the first ownedFeature of the first parameter of an AssignmentActionUsage must redefine AssignmentAction::target::startingAt::accessedFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssignmentActionUsage(), "checkAssignmentActionUsageReferentRedefinition", "aql:let targetParameter : sysml::Feature = self.inputParameter(1) in targetParameter <> null and targetParameter.ownedFeature->notEmpty() and targetParameter->first().ownedFeature->notEmpty() and targetParameter->first().ownedFeature->first().redefines(referent)", "The first ownedFeature of the first ownedFeature of the first parameter of an AssignmentActionUsage must redefine the referent of the AssignmentActionUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssignmentActionUsage(), "validateAssignmentActionUsageReferent", "aql:self.ownedMembership->exists(e | not e.oclIsKindOf(sysml::OwningMembership) and self.memberElement.oclIsKindOf(sysml::Feature))", "An AssignmentActionUsage must have an ownedMembership that is not an OwningMembership and whose memberElement is a Feature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getWhileLoopActionUsage(), "checkWhileLoopActionUsageSubactionSpecialization", "aql:self.isSubactionUsage() implies self.specializesFromLibrary('Actions::Action::whileLoops')", "A composite WhileLoopActionUsage that is a subaction usage must directly or indirectly specialize the ActionUsage Actions::Action::whileLoops from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getWhileLoopActionUsage(), "checkWhileLoopActionUsageSpecialization", "aql:self.specializesFromLibrary('Actions::whileLoopActions')", "A WhileLoopActionUsage must directly or indirectly specialize the ActionUsage Actions::whileLoopActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getWhileLoopActionUsage(), "validateWhileLoopActionUsage", "aql:self.inputParameters()->size() >= 2", "A WhileLoopActionUsage must have at least two owned input parameters."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTriggerInvocationExpression(), "checkTriggerInvocationExpressionSpecialization", "aql:self.specializesFromLibrary( if self.kind = TriggerKind::when then 'Triggers::TriggerWhen' else if self.kind = TriggerKind::at then 'Triggers::TriggerAt' else 'Triggers::TriggerAfter' endif endif )", "A TriggerInvocationExpression must directly or indirectly specialize one of the Functions TriggerWhen, TriggerAt or TriggerAfter, from the Kernel Semantic Library Triggers package, depending on whether its kind is when, at or after, respectively."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTriggerInvocationExpression(), "validateTriggerInvocationExpressionAfterArgument", "aql:self.kind = TriggerKind::after implies self.argument->notEmpty() and self.argument->at(1).result.specializesFromLibrary('Quantities::ScalarQuantityValue') and let mRef : sysml::Element = self.resolveGlobal('Quantities::TensorQuantityValue::mRef').ownedMemberElement in self.argument->at(1).result.feature->select(ownedRedefinition.redefinedFeature->closure(ownedRedefinition.redefinedFeature)->includes(mRef))->exists(specializesFromLibrary('ISQBase::DurationUnit'))", "If a TriggerInvocationExpression has kind = after, then it must have an argument Expression with a result that conforms to the type Quantities::ScalarQuantityValue and a feature that directly or indirectly redefines Quantities::TensorQuantityValue::mRef and directly or indirectly specializes ISQBase::DurationUnit."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTriggerInvocationExpression(), "validateTriggerInvocationExpressionAtArgument", "aql:self.kind = TriggerKind::at implies self.argument->notEmpty() and self.argument->at(1).result.specializesFromLibrary('Time::TimeInstantValue')", "If a TriggerInvocationExpression has kind = at, then it must have an argument Expression with a result that conforms to the type Time::TimeInstantValue."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTriggerInvocationExpression(), "validateTriggerInvocationExpressionWhenArgument", "aql:self.kind = TriggerKind::when implies self.argument->notEmpty() and self.argument->at(1).oclIsKindOf(sysml::FeatureReferenceExpression) and let referent : sysml::Feature = self.argument->at(1).oclAsType(sysml::FeatureReferenceExpression).referent in referent.oclIsKindOf(sysml::Expression) and referent.oclAsType(sysml::Expression).result.specializesFromLibrary('ScalarValues::Boolean')", "If a TriggerInvocationExpression has kind = when, then it must have an argument that is a FeatureReferenceExpression whose referent is an Expression with a result that conforms to the type ScalarValues::Boolean."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDefinition(), "validateDefinitionVariationOwnedFeatureMembership", "aql:self.isVariation implies self.ownedFeatureMembership->isEmpty()", "If a Definition is a variation, then all it must not have any ownedFeatureMemberships."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDefinition(), "validateDefinitionVariationSpecialization", "aql:self.isVariation implies not self.ownedSpecialization.specific->exists(e | e.oclIsKindOf(sysml::Definition) and e.oclAsType(sysml::Definition).isVariation)", "A variation Definition may not specialize any other variation Definition."),
          new ValidationRule(SysmlPackage.eINSTANCE.getDefinition(), "validateDefinitionVariationIsAbstract", "aql:self.isVariation implies self.isAbstract", "If a Definition is a variation, then it must be abstract."),
          new ValidationRule(SysmlPackage.eINSTANCE.getUsage(), "validateUsageVariationOwnedFeatureMembership", "aql:self.isVariation implies self.ownedFeatureMembership->isEmpty()", "If a Usage is a variation, then it must not have any ownedFeatureMemberships."),
          new ValidationRule(SysmlPackage.eINSTANCE.getUsage(), "validateUsageVariationSpecialization", "aql:self.isVariation implies not self.ownedSpecialization.specific->exists(e | e.oclIsKindOf(sysml::Definition) and e.oclAsType(sysml::Definition).isVariation or e.oclIsKindOf(sysml::Usage) and e.oclAsType(sysml::Usage).isVariation)", "A variation Usage may not specialize any variation Definition or Usage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getUsage(), "validateUsageIsReferential", "aql:self.direction <> null or self.isEnd or self.featuringType->isEmpty() implies self.isReference", "A Usage that is directed, an end feature or has no featuringTypes must be referential."),
          new ValidationRule(SysmlPackage.eINSTANCE.getReferenceUsage(), "validateReferenceUsageIsReference", "aql:self.isReference", "A ReferenceUsage is always referential."),
          new ValidationRule(SysmlPackage.eINSTANCE.getVariantMembership(), "validateVariantMembershipOwningNamespace", "aql:self.membershipOwningNamespace.oclIsKindOf(sysml::Definition) and self.membershipOwningNamespace.oclAsType(sysml::Definition).isVariation or self.membershipOwningNamespace.oclIsKindOf(sysml::Usage) and self.membershipOwningNamespace.oclAsType(sysml::Usage).isVariation", "The membershipOwningNamespace of a VariantMembership must be a variation-point Definition or Usage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPartDefinition(), "checkPartDefinitionSpecialization", "aql:self.specializesFromLibrary('Parts::Part')", "A PartDefinition must directly or indirectly specialize the base PartDefinition Parts::Part from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPartUsage(), "validatePartUsagePartDefinition", "aql:self.partDefinition->notEmpty()", "At least one of the itemDefinitions of a PartUsage must be a PartDefinition."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPartUsage(), "checkPartUsageSpecialization", "aql:self.specializesFromLibrary('Parts::parts')", "A PartUsage must directly or indirectly specialize the PartUsage Parts::parts from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPartUsage(), "checkPartUsageSubpartSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::ItemDefinition) or self.owningType.oclIsKindOf(sysml::ItemUsage)) implies self.specializesFromLibrary('Items::Item::subparts')", "A composite PartUsage whose owningType is a ItemDefinition or ItemUsage must directly or indirectly specialize the  PartUsage Items::Item::subparts from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPartUsage(), "checkPartUsageActorSpecialization", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::ActorMembership) implies if self.owningType.oclIsKindOf(sysml::RequirementDefinition) or self.owningType.oclIsKindOf(sysml::RequirementUsage) then self.specializesFromLibrary('Requirements::RequirementCheck::actors') else self.specializesFromLibrary('Cases::Case::actors') endif", "If a PartUsage is owned via an ActorMembership, then it must directly or indirectly specialize either Requirements::RequirementCheck::actors (if its owningType is a RequirementDefinition or RequirementUsage or Cases::Case::actors (otherwise)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getPartUsage(), "checkPartUsageStakeholderSpecialization", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::StakeholderMembership) implies self.specializesFromLibrary('Requirements::RequirementCheck::stakeholders')", "If a PartUsage is owned via a StakeholderMembership, then it must directly or indirectly specialize either Requirements::RequirementCheck::stakeholders."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInterfaceUsage(), "checkInterfaceUsageBinarySpecialization", "aql:self.ownedEndFeature->size() = 2 implies self.specializesFromLibrary('Interfaces::binaryInterfaces')", "A binary InterfaceUsage must directly or indirectly specialize the InterfaceUsage Interfaces::binaryInterfaces from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInterfaceUsage(), "checkInterfaceUsageSpecialization", "aql:self.specializesFromLibrary('Interfaces::interfaces')", "An InterfaceUsage must directly or indirectly specialize the InterfaceUsage Interfaces::interfaces from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInterfaceDefinition(), "checkInterfaceDefinitionSpecialization", "aql:self.specializesFromLibrary('Interfaces::Interface')", "An InterfaceDefinition must directly or indirectly specialize the InterfaceDefinition Interfaces::Interface from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getInterfaceDefinition(), "checkInterfaceDefinitionBinarySpecialization", "aql:self.ownedEndFeature->size() = 2 implies self.specializesFromLibrary('Interfaces::BinaryInterface')", "A binary InterfaceDefinition must directly or indirectly specialize the InterfaceDefinition Interfaces::BinaryInterface from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateUsage(), "validateStateUsageParallelSubactions", "aql:self.isParallel implies self.nestedAction.incomingTransition->isEmpty() and self.nestedAction.outgoingTransition->isEmpty()", "If a StateUsage is parallel, then its nestedActions (which includes nestedStates) must not have any incomingTransitions or outgoingTransitions."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateUsage(), "checkStateUsageExclusiveStateSpecialization", "aql:self.isSubstateUsage(false) implies self.specializesFromLibrary('States::StateAction::exclusiveStates')", "A StateUsage that is a substate usage with a non-parallel owning StateDefinition or StateUsage must directly or indirectly specialize the StateUsage States::StateAction::exclusiveStates from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateUsage(), "checkStateUsageSpecialization", "aql:self.specializesFromLibrary('States::stateActions')", "A StateUsage must directly or indirectly specialize the StateUsage States::stateActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateUsage(), "validateStateUsageStateSubactionKind", "aql:self.ownedMembership->filter(sysml::StateSubactionMembership)->isUnique(i | i.kind)", "A StateUsage must not have more than one owned StateSubactionMembership of each kind."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateUsage(), "checkStateUsageSubstateSpecialization", "aql:self.isSubstateUsage(true) implies self.specializesFromLibrary('States::StateAction::substates')", "A StateUsage that is a substate usage with a owning StateDefinition or StateUsage that is parallel must directly or indirectly specialize the StateUsage States::StateAction::substates from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateSubactionMembership(), "validateStateSubactionMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::StateDefinition) or self.owningType.oclIsKindOf(sysml::StateUsage)", "The owningType of a StateSubactionMembership must be a StateDefinition or a StateUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateDefinition(), "checkStateDefinitionSpecialization", "aql:self.specializesFromLibrary('States::StateAction')", "A StateDefinition must directly or indirectly specialize the StateDefinition States::StateAction from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateDefinition(), "validateStateDefinitionStateSubactionKind", "aql:self.ownedMembership->filter(sysml::StateSubactionMembership)->isUnique(i | i.kind)", "A StateDefinition must not have more than one owned StateSubactionMembership of each kind."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStateDefinition(), "validateStateDefinitionParallelSubactions", "aql:self.isParallel implies self.ownedAction.incomingTransition->isEmpty() and self.ownedAction.outgoingTransition->isEmpty()", "If a StateDefinition is parallel, then its ownedActions (which includes its ownedStates) must not have any incomingTransitions or outgoingTransitions."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageActionSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::ActionDefinition) or self.owningType.oclIsKindOf(sysml::ActionUsage)) and not self.owningType.oclIsKindOf(sysml::StateDefinition) or self.owningType.oclIsKindOf(sysml::StateUsage)) implies self.specializesFromLibrary('Actions::Action::decisionTransitions')", "A composite TransitionUsage whose owningType is a ActionDefinition or ActionUsage, but not a StateDefinition or StateUsage, must directly or indirectly specialize the ActionUsage Actions::Action::decisionTransitions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageStateSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::StateDefinition) or self.owningType.oclIsKindOf(sysml::StateUsage)) implies self.specializesFromLibrary('States::State::stateTransitions')", "A composite TransitionUsage whose owningType is a StateDefinition or StateUsage must directly or indirectly specialize the ActionUsage States::State::stateTransitions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageSpecialization", "aql:self.specializesFromLibrary('Actions::transitionActions')", "A TransitionUsage must directly or indirectly specialize the ActionUsage Actions::transitionActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "validateTransitionUsageSuccession", "aql:let successions : Sequence(sysml::Successions) = self.ownedMember->filter(sysml::Succession) in self.successions->notEmpty() and self.successions->at(1).targetFeature->forAll(oclIsKindOf(sysml::ActionUsage))", "A TransitionUsage must have an ownedMember that is a Succession with a ActionUsage as its targetFeature."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageTransitionFeatureSpecialization", "aql:self.triggerAction->forAll(specializesFromLibrary('Actions::TransitionAction::accepter') and self.guardExpression->forAll(specializesFromLibrary('Actions::TransitionAction::guard') and self.effectAction->forAll(specializesFromLibrary('Actions::TransitionAction::effect'))", "The triggerActions, guardExpressions, and effectActions of a TransitionUsage must specialize, respectively, the accepter, guard, and effect features of the ActionUsage Actions::TransitionActions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageSuccessionSourceSpecialization", "aql:self.succession.sourceFeature = self.source", "The sourceFeature of the succession of a TransitionUsage must be the source of the TransitionUsage (i.e., the first connectorEnd of the succession must have a ReferenceSubsetting Relationship with the source)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageSourceBindingConnector", "aql:self.ownedMember->filter(sysml::BindingConnector)->exists(b | b.relatedFeatures->includes(self.source) and b.relatedFeatures->includes(inputParameter(1)))", "A TransitionUsage must have an ownedMember that is a BindingConnector between its source and its first input parameter (which redefines Actions::TransitionAction::transitionLinkSource)."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsagePayloadSpecialization", "aql:self.triggerAction->notEmpty() implies let payloadParameter : sysml::Feature = self.inputParameter(2) in payloadParameter <> null and payloadParameter.subsetsChain(triggerAction->at(1), self.triggerPayloadParameter())", "If a TransitionUsage has a triggerAction, then the payload parameter of the TransitionUsage subsets the Feature chain of the triggerAction and its payloadParameter."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "checkTransitionUsageSuccessionBindingConnector", "aql:self.ownedMember->filter(sysml::BindingConnector)->exists(b | b.relatedFeatures->includes(succession) and b.relatedFeatures->includes(resolveGlobal( 'TransitionPerformances::TransitionPerformance::transitionLink')))", "A TransitionUsage must have an ownedMember that is a BindingConnector between its succession and the inherited Feature TransitionPerformances::TransitionPerformance::transitionLink."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionUsage(), "validateTransitionUsageParameters", "aql:if self.triggerAction->isEmpty() then self.inputParameters()->size() >= 1 else self.inputParameters()->size() >= 2 endif", "A TransitionUsage must have at least one owned input parameter and, if it has a triggerAction, it must have at least two."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionFeatureMembership(), "validateTransitionFeatureMembershipTriggerAction", "aql:self.kind = TransitionFeatureKind::trigger implies self.transitionFeature.oclIsKindOf(sysml::AcceptActionUsage)", "If the kind of a TransitionUsage is trigger, then its transitionFeature must be a kind of AcceptActionUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionFeatureMembership(), "validateTransitionFeatureMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::TransitionUsage)", "The owningType of a TransitionFeatureMembership must be a TransitionUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionFeatureMembership(), "validateTransitionFeatureMembershipGuardExpression", "aql:self.kind = TransitionFeatureKind::guard implies self.transitionFeature.oclIsKindOf(sysml::Expression) and let guard : sysml::Expression = self.transitionFeature.oclIsKindOf(sysml::Expression) in guard.result.specializesFromLibrary('ScalarValues::Boolean') and guard.result.multiplicity <> null and guard.result.multiplicity.hasBounds(1,1)", "If the kind of a TransitionUsage is guard, then its transitionFeature must be a kind of Expression whose result is a Boolean value."),
          new ValidationRule(SysmlPackage.eINSTANCE.getTransitionFeatureMembership(), "validateTransitionFeatureMembershipEffectAction", "aql:self.kind = TransitionFeatureKind::effect implies self.transitionFeature.oclIsKindOf(sysml::ActionUsage)", "If the kind of a TransitionUsage is effect, then its transitionFeature must be a kind of ActionUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExhibitStateUsage(), "checkExhibitStateUsageSpecialization", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::PartDefinition) or self.owningType.oclIsKindOf(sysml::PartUsage)) implies self.specializesFromLibrary('Parts::Part::exhibitedStates')", "If an ExhibitStateUsage has an owningType that is a PartDefinition or PartUsage, then it must directly or indirectly specialize the StateUsage Parts::Part::exhibitedStates."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExhibitStateUsage(), "validateExhibitStateUsageReference", "aql:self.ownedReferenceSubsetting <> null implies self.ownedReferenceSubsetting.referencedFeature.oclIsKindOf(sysml::StateUsage)", "If an ExhibitStateUsage has an ownedReferenceSubsetting, then its referencedFeature must be a StateUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstraintUsage(), "checkConstraintUsageRequirementConstraintSpecialization", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::RequirementConstraintMembership) implies if self.owningFeatureMembership.oclAsType(sysml::RequirementConstraintMembership).kind = RequirementConstraintKind::assumption then self.specializesFromLibrary('Requirements::RequirementCheck::assumptions') else self.specializesFromLibrary('Requirements::RequirementCheck::constraints') endif", "A ConstraintUsage whose owningFeatureMembership is a RequirementConstraintMembership must directly or indirectly specialize on the ConstraintUsages assumptions or constraints from the ConstraintDefinition Requirements::RequirementCheck in the Systems Model Library, depending on whether the kind of the RequirementConstraintMembership is assumption or requirement, respectively."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstraintUsage(), "checkConstraintUsageSpecialization", "aql:self.specializesFromLibrary('Constraints::constraintChecks')", "A ConstraintUsage must directly or indirectly specialize the base ConstraintUsage Constraints::constraintChecks from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstraintUsage(), "checkConstraintUsageCheckedConstraintSpecialization", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::ItemDefinition) or self.owningType.oclIsKindOf(sysml::ItemUsage)) implies self.specializesFromLibrary('Items::Item::checkedConstraints')", "A ConstraintUsage whose owningType is an ItemDefinition or ItemUsage must directly or indirectly specialize the ConstraintUsage Items::Item::checkedConstraints."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConstraintDefinition(), "checkConstraintDefinitionSpecialization", "aql:self.specializesFromLibrary('Constraints::ConstraintCheck')", "A ConstraintDefinition must directly or indirectly specialize the base ConstraintDefinition Constraints::ConstraintCheck from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssertConstraintUsage(), "checkAssertConstraintUsageSpecialization", "aql:if self.isNegated then self.specializesFromLibrary('Constraints::negatedConstraints') else self.specializesFromLibrary('Constraints::assertedConstraints') endif", "If a AssertConstraintUsage is negated, then it must directly or indirectly specialize the ConstraintUsage Constraints::negatedConstraints. Otherwise, it must directly or indirectly specialize the ConstraintUsage Constraints::assertedConstraints."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAssertConstraintUsage(), "validateAssertConstraintUsageReference", "aql:self.ownedReferenceSubsetting <> null implies self.ownedReferenceSubsetting.referencedFeature.oclIsKindOf(sysml::ConstraintUsage)", "If an AssertConstraintUsage has an ownedReferenceSubsetting, then its referencedFeature must be a ConstraintUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementDefinition(), "validateRequirementDefinitionOnlyOneSubject", "aql:self.featureMembership-> oclIsKindOf(sysml::SubjectMembership)->size() <= 1", "A RequirementDefinition must have at most one featureMembership that is a SubjectMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementDefinition(), "validateRequirementDefinitionSubjectParameterPosition", "aql:self.input->notEmpty() and self.input->first() = self.subjectParameter", "The subjectParameter of a RequirementDefinition must be its first input."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementDefinition(), "checkRequirementDefinitionSpecialization", "aql:self.specializesFromLibrary('Requirements::RequirementCheck')", "A RequirementDefinition must directly or indirectly specialize the base RequirementDefinition Requirements::RequirementCheck from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSatisfyRequirementUsage(), "checkSatisfyRequirementUsageBindingConnector", "aql:self.ownedMember->filter(sysml::BindingConnector)->select(b | b.relatedElement->includes(subjectParameter) and b.relatedElement->exists(r | r <> self.subjectParameter))->size() = 1", "A SatisfyRequirementUsage must have exactly one ownedMember that is a BindingConnector between its subjectParameter and some Feature other than the subjectParameter."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSatisfyRequirementUsage(), "validateSatisfyRequirementUsageReference", "aql:self.ownedReferenceSubsetting <> null implies self.ownedReferenceSubsetting.referencedFeature.oclIsKindOf(sysml::RequirementUsage)", "If a SatisfyRequirementUsage has an ownedReferenceSubsetting, then its referencedFeature must be a RequirementUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementUsage(), "validateRequirementUsageOnlyOneSubject", "aql:self.featureMembership->filter(sysml::SubjectMembership)->size() <= 1", "A RequirementDefinition must have at most one featureMembership that is a SubjectMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementUsage(), "validateRequirementUsageSubjectParameterPosition", "aql:self.input->notEmpty() and self.input->first() = self.subjectParameter", "The subjectParameter of a RequirementUsage must be its first input."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementUsage(), "checkRequirementUsageSpecialization", "aql:self.specializesFromLibrary('Requirements::requirementChecks')", "A RequirementUsage must directly or indirectly specialize the base RequirementUsage Requirements::requirementChecks from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementUsage(), "checkRequirementUsageSubrequirementSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::RequirementDefinition) or self.owningType.oclIsKindOf(sysml::RequirementUsage)) implies self.specializesFromLibrary('Requirements::RequirementCheck::subrequirements')", "A composite RequirementUsage whose owningType is a RequirementDefinition or ,code>RequirementUsage must directly or indirectly specialize the RequirementUsage Requirements::RequirementCheck::subrequirements from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementUsage(), "checkRequirementUsageObjectiveRedefinition", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::ObjectiveMembership) implies self.owningType.ownedSpecialization.general->forAll(gen | (gen.oclIsKindOf(sysml::CaseDefinition) implies self.redefines(gen.oclAsType(sysml::CaseDefinition).objectiveRequirement)) and (gen.oclIsKindOf(sysml::CaseUsage) implies self.redefines(gen.oclAsType(sysml::CaseUsage).objectiveRequirement)))", "A RequirementUsage whose owningFeatureMembership is a ObjectiveMembership must redefine the objectiveRequirement of each CaseDefinition or CaseUsage that is specialized by the owningType of the RequirementUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementUsage(), "checkRequirementUsageRequirementVerificationSpecialization", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::RequirementVerificationMembership) implies self.specializesFromLibrary('VerificationCases::VerificationCase::obj::requirementVerifications')", "A RequirementUsage whose owningFeatureMembership is a RequirementVerificationMembership must directly or indirectly specialize the RequirementUsage VerificationCases::VerificationCase::obj::requirementVerifications."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementConstraintMembership(), "validateRequirementConstraintMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::RequirementDefinition) or self.owningType.oclIsKindOf(sysml::RequirementUsage)", "The owningType of a RequirementConstraintMembership must be a RequirementDefinition or a RequirementUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementConstraintMembership(), "validateRequirementConstraintMembershipIsComposite", "aql:self.ownedConstraint.isComposite", "The ownedConstraint of a RequirementConstraintMembership must be composite."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSubjectMembership(), "validateSubjectMembershipOwningType", "aql:self.owningType.ocIsTypeOf(sysml::RequirementDefinition) or self.owningType.ocIsTypeOf(sysml::RequiremenCaseRequirementDefinition) or self.owningType.ocIsTypeOf(sysml::CaseDefinition) or self.owningType.ocIsTypeOf(sysml::CaseUsage)", "The owningType of a SubjectMembership must be a RequirementDefinition, RequirementUsage, CaseDefinition, or CaseUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFramedConcernMembership(), "validateFramedConcernMembershipConstraintKind", "aql:self.kind = RequirementConstraintKind::requirement", "A FramedConcernMembership must have kind = requirement."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConcernDefinition(), "checkConcernDefinitionSpecialization", "aql:self.specializesFromLibrary('Requirements::ConcernCheck')", "A ConcernDefinition must directly or indirectly specialize the base ConcernDefinition Requirements::ConcernCheck from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConcernUsage(), "checkConcernUsageSpecialization", "aql:self.specializesFromLibrary('Requirements::concernChecks')", "A ConcernUsage must directly or indirectly specialize the base ConcernUsage Requirements::concernChecks from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConcernUsage(), "checkConcernUsageFramedConcernSpecialization", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::FramedConcernMembership) implies self.specializesFromLibrary('Requirements::RequirementCheck::concerns')", "If a ConcernUsage is owned via a FramedConcernMembership, then it must directly or indirectly specialize the ConcernUsage Requirements::RequirementCheck::concerns from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getStakeholderMembership(), "validateStakeholderMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::RequirementUsage) or self.owningType.oclIsKindOf(sysml::RequirementDefinition)", "The owningType of a StakeholderMembership must be a RequirementDefinition or RequirementUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getActorMembership(), "validateActorMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::RequirementUsage) or self.owningType.oclIsKindOf(sysml::RequirementDefinition) or self.owningType.oclIsKindOf(sysml::CaseDefinition) or self.owningType.oclIsKindOf(sysml::CaseUsage)", "The owningType of an ActorMembership must be a RequirementDefinition, RequirementUsage, CaseDefinition, or CaseUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCalculationDefinition(), "checkCalculationDefinitionSpecialization", "aql:self.specializesFromLibrary('Calculations::Calculation')", "A CalculationDefinition must directly or indirectly specialize the CalculationDefinition Calculations::Calculation from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCalculationUsage(), "checkCalculationUsageSpecialization", "aql:self.specializesFromLibrary('Calculations::calculations')", "A CalculationUsage must specialize directly or indirectly the CalculationUsage Calculations::calculations from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCalculationUsage(), "checkCalculationUsageSubcalculationSpecialization", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::CalculationDefinition) or self.owningType.oclIsKindOf(sysml::CalculationUsage)) implies self.specializesFromLibrary('Calculations::Calculation::subcalculations')", ""),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnectionDefinition(), "checkConnectionDefinitionSpecializations", "aql:self.specializesFromLibrary('Connections::Connection')", "A ConnectionDefinition must directly or indirectly specialize the ConnectionDefinition Connections::Connection from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnectionDefinition(), "checkConnectionDefinitionBinarySpecialization", "aql:self.ownedEndFeature->size() = 2 implies self.specializesFromLibrary('Connections::BinaryConnections')", "A binary ConnectionDefinition must directly or indirectly specialize the ConnectionDefinition Connections::BinaryConnection from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnectionUsage(), "checkConnectionUsageSpecialization", "aql:self.specializesFromLibrary('Connections::connections')", "A ConnectionUsage must directly or indirectly specialize the ConnectionUsage Connections::connections from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getConnectionUsage(), "checkConnectionUsageBinarySpecialization", "aql:self.ownedEndFeature->size() = 2 implies self.specializesFromLibrary('Connections::binaryConnections')", "A binary ConnectionUsage must directly or indirectly specialize the ConnectionUsage Connections::binaryConnections from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getSuccessionFlowConnectionUsage(), "checkSuccessionFlowConnectionUsageSpecialization", "aql:self.specializesFromLibrary('Connections::successionFlowConnections')", "A SuccessionFlowConnectionUsage must directly or indirectly specialize the base FlowConnectionUsage Connections::successionFlowConnections from the Systems Library model."),
          new ValidationRule(SysmlPackage.eINSTANCE.getFlowConnectionUsage(), "checkFlowConnectionUsageSpecialization", "aql:if self.ownedEndFeatures->isEmpty() then self.specializesFromLibrary('Connections::messageConnections') else self.specializesFromLibrary('Connections::flowConnections') endif", "If a FlowConnectionUsage has no ownedEndFeatures, then it must directly or indirectly specialize the base FlowConnectionUsage Connections::messageConnections from the Systems Library model. Otherwise, it must directly or indirectly specialize the FlowConnectionUsage Connections::flowConnections. "),
          new ValidationRule(SysmlPackage.eINSTANCE.getFlowConnectionDefinition(), "checkFlowConnectionDefinitionSpecialization", "aql:self.specializesFromLibrary('Connections::MessageConnection')", "A FlowConnectionDefinition must directly or indirectly specialize the base FlowConnectionDefinition MessageConnectionDefinition from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseUsage(), "validateCaseUsageOnlyOneObjective", "aql:self.featureMembership->filter(sysml::ObjectiveMembership)->size() <= 1", "A CaseUsage must have at most one featureMembership that is a ObjectiveMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseUsage(), "validateCaseUsageOnlyOneSubject", "aql:self.featureMembership->filter(sysml::SubjectMembership)->size() <= 1", "A CaseUsage must have at most one featureMembership that is a SubjectMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseUsage(), "validateCaseUsageSubjectParameterPosition", "aql:self.input->notEmpty() and self.input->first() = self.subjectParameter", "The subjectParameter of a CaseUsage must be its first input."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseUsage(), "checkCaseUsageSpecialization", "aql:self.specializesFromLibrary('Cases::cases')", "A CaseUsage must directly or indirectly specialize the base CaseUsage Cases::cases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseUsage(), "checkCaseUsageSubcaseSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::CaseDefinition) or self.owningType.oclIsKindOf(sysml::CaseUsage)) implies self.specializesFromLibrary('Cases::Case::subcases')", "A composite CaseUsage whose owningType is a CaseDefinition or CaseUsage must directly or indirectly specialize the CaseUsage Cases::Case::subcases."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseDefinition(), "validateCaseDefinitionOnlyOneObjective", "aql:self.featureMembership->filter(sysml::ObjectiveMembership)->size() <= 1", "A CaseDefinition must have at most one featureMembership that is a ObjectiveMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseDefinition(), "validateCaseDefinitionOnlyOneSubject", "aql:self.featureMembership->filter(sysml::SubjectMembership)->size() <= 1", "A CaseDefinition must have at most one featureMembership that is a SubjectMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseDefinition(), "validateCaseDefinitionSubjectParameterPosition", "aql:self.input->notEmpty() and self.input->first() = self.subjectParameter", "The subjectParameter of a CaaseDefinition must be its first input."),
          new ValidationRule(SysmlPackage.eINSTANCE.getCaseDefinition(), "checkCaseDefinitionSpecialization", "aql:self.specializesFromLibrary('Cases::Case')", "A CaseDefinition must directly or indirectly specialize the base CaseDefinition Cases::Case> from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getObjectiveMembership(), "validateObjectiveMembershipOwningType", "aql:self.owningType.ocIsTypeOf(sysml::CaseDefinition) or self.owningType.ocIsTypeOf(sysml::CaseUsage)", "The owningType of an ObjectiveMembership must be a CaseDefinition or CaseUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getObjectiveMembership(), "validateObjectiveMembershipIsComposite", "aql:self.ownedObjectiveRequirement.isComposite", "The ownedObjectiveRequirement of an ObjectiveMembership must be composite."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAnalysisCaseUsage(), "checkAnalysisCaseUsageSpecialization", "aql:self.specializesFromLibrary('AnalysisCases::analysisCases')", "An AnalysisCaseUsage must directly or indirectly specialize the base AnalysisCaseUsage AnalysisCases::analysisCases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAnalysisCaseUsage(), "checkAnalysisCaseUsageSubAnalysisCaseSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::AnalysisCaseDefinition) or self.owningType.oclIsKindOf(sysml::AnalysisCaseUsage)) implies self.specializesFromLibrary('AnalysisCases::AnalysisCase::subAnalysisCases')", "A composite AnalysisCaseUsage whose owningType is an AnalysisCaseDefinition or AnalysisCaseUsage must specialize the AnalysisCaseUsage AnalysisCases::AnalysisCase::subAnalysisCases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAnalysisCaseDefinition(), "checkAnalysisCaseDefinitionSpecialization", "aql:self.specializesFromLibrary('AnalysisCases::AnalysisCase')", "An AnalysisCaseDefinition must directly or indirectly specialize the base AnalysisCaseDefinition AnalysisCases::AnalysisCase from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getItemUsage(), "checkItemUsageSpecialization", "aql:self.specializesFromLibrary('Items::items')", "An ItemUsage must directly or indirectly specialize the Systems Model Library ItemUsage items."),
          new ValidationRule(SysmlPackage.eINSTANCE.getItemUsage(), "checkItemUsageSubitemSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::ItemDefinition) or self.owningType.oclIsKindOf(sysml::ItemUsage)) implies self.specializesFromLibrary('Items::Item::subitem')", ""),
          new ValidationRule(SysmlPackage.eINSTANCE.getItemDefinition(), "checkItemDefinitionSpecialization", "aql:self.specializesFromLibrary('Items::Item')", "An ItemDefinition must directly or indirectly specialize the Systems Library Model ItemDefinition Items::Item."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewpointDefinition(), "checkViewpointDefinitionSpecialization", "aql:self.specializesFromLibrary('Views::Viewpoint')", "A ViewpointDefinition must directly or indirectly specialize the base ViewpointDefinition Views::Viewpoint from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewUsage(), "validateViewUsageOnlyOneViewRendering", "aql:self.featureMembership->filter(sysml::ViewRenderingMembership)->size() <= 1", "A ViewUsage must have at most one ViewRenderingMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewUsage(), "checkViewUsageSpecialization", "aql:self.specializesFromLibrary('Views::views')", "A ViewUsage must directly or indirectly specialize the base ViewUsage Views::views from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewUsage(), "checkViewUsageSubviewSpecialization", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::ViewDefinition) or self.owningType.oclIsKindOf(sysml::ViewUsage)) implies self.specializesFromLibrary('Views::View::subviews')", "A ViewUsage whose owningType is a ViewDefinition or ViewUsage must specialize the ViewUsage Views::View::subviews from the Systems Library Model."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRenderingDefinition(), "checkRenderingDefinitionSpecialization", "aql:self.specializesFromLibrary('Views::Rendering')", "A RenderingDefinition must directly or indirectly specialize the base RenderingDefinition Views::Rendering from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewpointUsage(), "checkViewpointUsageSpecialization", "aql:self.specializesFromLibrary('Views::viewpoints')", "A ViewpointUsage must directly or indirectly specialize the base ViewpointUsage Views::viewpoints from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewpointUsage(), "checkViewpointUsageViewpointSatisfactionSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::ViewDefinition) or self.owningType.oclIsKindOf(sysml::ViewUsage)) implies self.specializesFromLibrary('Views::View::viewpointSatisfactions')", "A composite ViewpointUsage whose owningType is a ViewDefinition or ViewUsage must directly or indirectly specialize the ViewpointUsage Views::View::viewpointSatisfactions from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewDefinition(), "validateViewDefinitionOnlyOneViewRendering", "aql:self.featureMembership->filter(sysml::ViewRenderingMembership)->size() <= 1", "A ViewDefinition must have at most one ViewRenderingMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewDefinition(), "checkViewDefinitionSpecialization", "aql:self.specializesFromLibrary('Views::View')", "A ViewDefinition must directly or indirectly specialize the base ViewDefinition Views::View from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpose(), "validateExposeIsImportAll", "aql:self.isImportAll", "An Expose always imports all Elements, regardless of visibility."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpose(), "validateExposeOwningNamespace", "aql:self.importOwningNamespace.ocIsTypeOf(sysml::ViewUsage)", "The importOwningNamespace of an Expose must be a ViewUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getExpose(), "validateExposeVisibility", "aql:self.visibility = VisibilityKind::protected", "An Expose always has protected visibility."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRenderingUsage(), "checkRenderingUsageSpecialization", "aql:self.specializesFromLibrary('Views::renderings')", "A RenderingUsage must directly or indirectly specialize the base RenderingUsage Views::renderings from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRenderingUsage(), "checkRenderingUsageSubrenderingSpecialization", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::RenderingDefinition) or self.owningType.oclIsKindOf(sysml::RenderingUsage)) implies self.specializesFromLibrary('Views::Rendering::subrenderings')", "A RenderingUsage whose owningType is a RenderingDefinition or RenderingUsage must directly or indirectly specialize the RenderingUsage Views::Rendering::subrenderings from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRenderingUsage(), "checkRenderingUsageRedefinition", "aql:self.owningFeatureMembership <> null and self.owningFeatureMembership.oclIsKindOf(sysml::ViewRenderingMembership) implies self.redefinesFromLibrary('Views::View::viewRendering')", "A RenderingUsage whose owningFeatureMembership is a ViewRenderingMembership must redefine the RenderingUsage Views::View::viewRendering."),
          new ValidationRule(SysmlPackage.eINSTANCE.getViewRenderingMembership(), "validateViewRenderingMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::ViewDefinition) or self.owningType.oclIsKindOf(sysml::ViewUsage)", "The owningType of a ViewRenderingMembership must be a ViewDefinition or a ViewUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getVerificationCaseDefinition(), "checkVerificationCaseSpecialization", "aql:self.specializesFromLibrary('VerificationCases::VerificationCase')", "A VerificationCaseDefinition must directly or indirectly specialize the base VerificationCaseDefinition VerificationCases::VerificationCase from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getVerificationCaseUsage(), "checkVerificationCaseUsageSpecialization", "aql:self.specializesFromLibrary('VerificationCases::verificationCases')", "A VerificationCaseUsage must subset, directly or indirectly, the base VerificationCaseUsage VerificationCases::verificationCases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getVerificationCaseUsage(), "checkVerificationCaseUsageSubVerificationCaseSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::VerificationCaseDefinition) or self.owningType.oclIsKindOf(sysml::VerificationCaseUsage)) implies self.specializesFromLibrary('VerificationCases::VerificationCase::subVerificationCases')", "If it is composite and owned by a VerificationCaseDefinition or VerificationCaseUsage, then it must specialize VerificationCaseUsage VerificationCases::VerificationCase::subVerificationCases."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementVerificationMembership(), "validateRequirementVerificationMembershipKind", "aql:self.kind = RequirementConstraintKind::requirement", "A RequirementVerificationMembership must have kind = requirement."),
          new ValidationRule(SysmlPackage.eINSTANCE.getRequirementVerificationMembership(), "validateRequirementVerificationMembershipOwningType", "aql:self.owningType.oclIsKindOf(sysml::RequirementUsage) and self.owningType.owningFeatureMembership <> null and self.owningType.owningFeatureMembership.oclIsKindOf(sysml::ObjectiveMembership)", "The owningType of a RequirementVerificationMembership must a RequirementUsage that is owned by an ObjectiveMembership."),
          new ValidationRule(SysmlPackage.eINSTANCE.getEnumerationDefinition(), "validateEnumerationDefinitionIsVariation", "aql:self.isVariation", "An EnumerationDefinition must be a variation."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAllocationDefinition(), "checkAllocationDefinitionSpecialization", "aql:self.specializesFromLibrary('Allocations::Allocation')", "An AllocationDefinition must directly or indirectly specialize the AllocationDefinition Allocations::Allocation from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getAllocationUsage(), "checkAllocationUsageSpecialization", "aql:self.specializesFromLibrary('Allocations::allocations')", "An AllocationUsage must directly or indirectly specialize the AllocationUsage Allocations::allocations from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLifeClass(), "checkLifeClassLifeSpecialization", "aql:self.specializesFromLibrary('Occurrences::Life')", "A LifeClass must specialize the Class Occurrences::Life from the Kernel Semantic Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLifeClass(), "checkLifeClassMultiplicitySpecialization", "aql:self.multiplicity <> null and self.multiplicity.specializesFromLibrary('Base::zeroOrOne')", "The multiplicity of a LifeClass is zeroOrOne."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLifeClass(), "checkLifeClassOccurrenceSpecialization", "aql:self.specializes(individualDefinition)", "A LifeClass must specialize its individualDefinition."),
          new ValidationRule(SysmlPackage.eINSTANCE.getLifeClass(), "validateLifeClassIsSufficient", "aql:self.isSufficient", "A LifeClass always has isSufficient = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceUsage(), "validateOccurrenceUsageIndividualUsage", "aql:self.isIndividual implies self.individualDefinition <> null", "If an OccurrenceUsage has isIndividual = true, then it must have an individualDefinition."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceUsage(), "checkOccurrenceUsageSpecialization", "aql:self.specializesFromLibrary('Occurrences::occurrences')", "An OccurrenceUsage must directly or indirectly specialize Occurrences::occurrences from the Kernel Semantic Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceUsage(), "checkOccurrenceUsageSuboccurrenceSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::Class) or self.owningType.oclIsKindOf(sysml::OccurrenceUsage) or self.owningType.oclIsKindOf(sysml::Feature) and self.owningType.oclAsType(sysml::Feature).type->exists(e | e.oclIsKindOf(sysml::Class))) implies self.specializesFromLibrary('Occurrences::Occurrence::suboccurrences')", "A composite OccurrenceUsage, whose ownedType is a Class, another OccurrenceUsage, or any kind of Feature typed by a Class, must directly or indirectly specialize Occurrences::Occurrence::suboccurrences."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceUsage(), "validateOccurrenceUsageIndividualDefinition", "aql:self.occurrenceDefinition->filter(sysml::OccurrenceDefinition)->select(e | e.isIndividual)->size() <= 1", "An OccurrenceUsage must have at most one occurrenceDefinition with isIndividual = true."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceUsage(), "checkOccurrenceUsageTypeFeaturing", "aql:self.portionKind <> null implies self.occurrenceDefinition->forAll(occ | self.featuringType->exists(e | e.specializes(occ)))", "If the portionKind of an OccurrenceUsage is not empty, then, for each occurrenceDefinition of the OccurrenceUsage, there must be a featuringType of the OccurrenceUsage which either is the occurrenceDefinition or directly or indirectly specializes it."),
          new ValidationRule(SysmlPackage.eINSTANCE.getOccurrenceDefinition(), "validateOccurrenceDefinitionLifeClass", "aql:let n : Integer = self.ownedMember->filter(sysml::LifeClass) in if self.isIndividual then n = 1 else n = 0 endif", "If an OccurrenceDefinition has isIndividual = true, then it has exactly one ownedMember that is a LifeClass. Otherwise it has none."),
          new ValidationRule(SysmlPackage.eINSTANCE.getEventOccurrenceUsage(), "validateEventOccurrenceUsageReference", "aql:self.ownedReferenceSubsetting <> null implies self.ownedReferenceSubsetting.referencedFeature.oclIsKindOf(sysml::OccurrenceUsage)", "If an EventOccurrenceUsage has an ownedReferenceSubsetting, then its referencedFeature must be an OccurrenceUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getEventOccurrenceUsage(), "checkEventOccurrenceUsageSpecialization", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::OccurrenceDefinition) or self.owningType.oclIsKindOf(sysml::OccurrenceUsage)) implies self.specializesFromLibrary('Occurrences::Occurrence::timeEnclosedOccurrences')", "If an EventOccurrenceUsage has an owningType that is an OccurrenceDefinition or OccurrenceUsage, then it must directly or indirectly specialize the Feature Occurrences::Occurrence::timeEnclosedOccurrences."),
          new ValidationRule(SysmlPackage.eINSTANCE.getEventOccurrenceUsage(), "validateEventOccurrenceUsageIsReference", "aql:self.isReference", "An EventOccurrenceUsage must be referential."),
          new ValidationRule(SysmlPackage.eINSTANCE.getIncludeUseCaseUsage(), "checkIncludeUseCaseSpecialization", "aql:self.owningType <> null and self.owningType.oclIsKindOf(sysml::UseCaseDefinition) or self.owningType.oclIsKindOf(sysml::UseCaseUsage) implies self.specializesFromLibrary('UseCases::UseCase::includedUseCases')", "A IncludeUseCaseUsage whose owningType is a UseCaseDefinition or UseCaseUsage must directly or indirectly specialize the UseCaseUsage UseCases::UseCase::includedUseCases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getIncludeUseCaseUsage(), "validateIncludeUseCaseUsageReference", "aql:self.ownedReferenceSubsetting <> null implies self.ownedReferenceSubsetting.referencedFeature.oclIsKindOf(sysml::UseCaseUsage)", "If an IncludeUseCaseUsage has an ownedReferenceSubsetting, then its referencedFeature must be a UseCaseUsage."),
          new ValidationRule(SysmlPackage.eINSTANCE.getUseCaseUsage(), "checkUseCaseUsageSpecialization", "aql:self.specializesFromLibrary('UseCases::useCases')", "A UseCaseUsage must directly or indirectly specializes the base UseCaseUsage UseCases::useCases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getUseCaseUsage(), "checkUseCaseUsageSubUseCaseSpecialization", "aql:self.isComposite and self.owningType <> null and self.owningType.oclIsKindOf(sysml::UseCaseDefinition) or self.owningType.oclIsKindOf(sysml::UseCaseUsage)) implies self.specializesFromLibrary('UseCases::UseCase::subUseCases')", "A composite UseCaseUsage whose owningType is a UseCaseDefinition or UseCaseUsage must specialize the UseCaseUsage UseCases::UseCase::subUseCases from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getUseCaseDefinition(), "checkUseCaseDefinitionSpecialization", "aql:self.specializesFromLibrary('UseCases::UseCase')", "A UseCaseDefinition must directly or indirectly specializes the base UseCaseDefinition UseCases::UseCase from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataDefinition(), "checkMetadataDefinitionSpecialization", "aql:self.specializesFromLibrary('Metadata::MetadataItem')", "A MetadataDefinition must directly or indirectly specialize the base MetadataDefinition Metadata::MetadataItem from the Systems Model Library."),
          new ValidationRule(SysmlPackage.eINSTANCE.getMetadataUsage(), "checkMetadataUsageSpecialization", "aql:self.specializesFromLibrary('Metadata::metadataItems')", "A MetadataUsage must directly or indirectly specialize the base MetadataUsage Metadata::metadataItems from the Systems Model Library.")
    );

    // @formatter:on

    public static final List<ValidationRule> getValidationRules(EClass eClass) {
        return VALIDATION_RULES.stream()
                .filter(rule -> rule.getEClass().equals(eClass) || rule.getEClass().isSuperTypeOf(eClass))
                .toList();
    }
}
