#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// ../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/lib/error.js
var require_error = __commonJS({
  "../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/lib/error.js"(exports2) {
    var CommanderError2 = class extends Error {
      /**
       * Constructs the CommanderError class
       * @param {number} exitCode suggested exit code which could be used with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @constructor
       */
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError2 = class extends CommanderError2 {
      /**
       * Constructs the InvalidArgumentError class
       * @param {string} [message] explanation of why argument is invalid
       * @constructor
       */
      constructor(message) {
        super(1, "commander.invalidArgument", message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports2.CommanderError = CommanderError2;
    exports2.InvalidArgumentError = InvalidArgumentError2;
  }
});

// ../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  "../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/lib/argument.js"(exports2) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Argument2 = class {
      /**
       * Initialize a new command argument with the given name and description.
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @param {string} name
       * @param {string} [description]
       */
      constructor(name, description) {
        this.description = description || "";
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case "<":
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case "[":
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === "...") {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      /**
       * Return argument name.
       *
       * @return {string}
       */
      name() {
        return this._name;
      }
      /**
       * @api private
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {any} value
       * @param {string} [description]
       * @return {Argument}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Set the custom handler for processing CLI command arguments into argument values.
       *
       * @param {Function} [fn]
       * @return {Argument}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Only allow argument value to be one of choices.
       *
       * @param {string[]} values
       * @return {Argument}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Make argument required.
       */
      argRequired() {
        this.required = true;
        return this;
      }
      /**
       * Make argument optional.
       */
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    exports2.Argument = Argument2;
    exports2.humanReadableArgName = humanReadableArgName;
  }
});

// ../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/lib/help.js
var require_help = __commonJS({
  "../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/lib/help.js"(exports2) {
    var { humanReadableArgName } = require_argument();
    var Help2 = class {
      constructor() {
        this.helpWidth = void 0;
        this.sortSubcommands = false;
        this.sortOptions = false;
        this.showGlobalOptions = false;
      }
      /**
       * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
       *
       * @param {Command} cmd
       * @returns {Command[]}
       */
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        if (cmd._hasImplicitHelpCommand()) {
          const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
          const helpCommand = cmd.createCommand(helpName).helpOption(false);
          helpCommand.description(cmd._helpCommandDescription);
          if (helpArgs)
            helpCommand.arguments(helpArgs);
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a, b) => {
            return a.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }
      /**
       * Compare options for sort.
       *
       * @param {Option} a
       * @param {Option} b
       * @returns number
       */
      compareOptions(a, b) {
        const getSortKey = (option) => {
          return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
        };
        return getSortKey(a).localeCompare(getSortKey(b));
      }
      /**
       * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
        const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
        if (showShortHelpFlag || showLongHelpFlag) {
          let helpOption;
          if (!showShortHelpFlag) {
            helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
          } else if (!showLongHelpFlag) {
            helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
          } else {
            helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
          }
          visibleOptions.push(helpOption);
        }
        if (this.sortOptions) {
          visibleOptions.sort(this.compareOptions);
        }
        return visibleOptions;
      }
      /**
       * Get an array of the visible global options. (Not including help.)
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */
      visibleGlobalOptions(cmd) {
        if (!this.showGlobalOptions)
          return [];
        const globalOptions = [];
        for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
          const visibleOptions = parentCmd.options.filter((option) => !option.hidden);
          globalOptions.push(...visibleOptions);
        }
        if (this.sortOptions) {
          globalOptions.sort(this.compareOptions);
        }
        return globalOptions;
      }
      /**
       * Get an array of the arguments if any have a description.
       *
       * @param {Command} cmd
       * @returns {Argument[]}
       */
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd._args.forEach((argument) => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
          });
        }
        if (cmd._args.find((argument) => argument.description)) {
          return cmd._args;
        }
        return [];
      }
      /**
       * Get the command term to show in the list of subcommands.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandTerm(cmd) {
        const args = cmd._args.map((arg) => humanReadableArgName(arg)).join(" ");
        return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + // simplistic check for non-help option
        (args ? " " + args : "");
      }
      /**
       * Get the option term to show in the list of options.
       *
       * @param {Option} option
       * @returns {string}
       */
      optionTerm(option) {
        return option.flags;
      }
      /**
       * Get the argument term to show in the list of arguments.
       *
       * @param {Argument} argument
       * @returns {string}
       */
      argumentTerm(argument) {
        return argument.name();
      }
      /**
       * Get the longest command term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, helper.subcommandTerm(command).length);
        }, 0);
      }
      /**
       * Get the longest option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest global option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestGlobalOptionTermLength(cmd, helper) {
        return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      /**
       * Get the longest argument term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, helper.argumentTerm(argument).length);
        }, 0);
      }
      /**
       * Get the command usage to be displayed at the top of the built-in help.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + "|" + cmd._aliases[0];
        }
        let parentCmdNames = "";
        for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
          parentCmdNames = parentCmd.name() + " " + parentCmdNames;
        }
        return parentCmdNames + cmdName + " " + cmd.usage();
      }
      /**
       * Get the description for the command.
       *
       * @param {Command} cmd
       * @returns {string}
       */
      commandDescription(cmd) {
        return cmd.description();
      }
      /**
       * Get the subcommand summary to show in the list of subcommands.
       * (Fallback to description for backwards compatibility.)
       *
       * @param {Command} cmd
       * @returns {string}
       */
      subcommandDescription(cmd) {
        return cmd.summary() || cmd.description();
      }
      /**
       * Get the option description to show in the list of options.
       *
       * @param {Option} option
       * @return {string}
       */
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (option.defaultValue !== void 0) {
          const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
          if (showDefault) {
            extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
          }
        }
        if (option.presetArg !== void 0 && option.optional) {
          extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(", ")})`;
        }
        return option.description;
      }
      /**
       * Get the argument description to show in the list of arguments.
       *
       * @param {Argument} argument
       * @return {string}
       */
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
        }
        if (extraInfo.length > 0) {
          const extraDescripton = `(${extraInfo.join(", ")})`;
          if (argument.description) {
            return `${argument.description} ${extraDescripton}`;
          }
          return extraDescripton;
        }
        return argument.description;
      }
      /**
       * Generate the built-in help text.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {string}
       */
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth || 80;
        const itemIndentWidth = 2;
        const itemSeparatorWidth = 2;
        function formatItem(term, description) {
          if (description) {
            const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
            return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
          }
          return term;
        }
        function formatList(textArray) {
          return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
        }
        let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([helper.wrap(commandDescription, helpWidth, 0), ""]);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
        });
        if (argumentList.length > 0) {
          output = output.concat(["Arguments:", formatList(argumentList), ""]);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return formatItem(helper.optionTerm(option), helper.optionDescription(option));
        });
        if (optionList.length > 0) {
          output = output.concat(["Options:", formatList(optionList), ""]);
        }
        if (this.showGlobalOptions) {
          const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
            return formatItem(helper.optionTerm(option), helper.optionDescription(option));
          });
          if (globalOptionList.length > 0) {
            output = output.concat(["Global Options:", formatList(globalOptionList), ""]);
          }
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
        });
        if (commandList.length > 0) {
          output = output.concat(["Commands:", formatList(commandList), ""]);
        }
        return output.join("\n");
      }
      /**
       * Calculate the pad width from the maximum term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */
      padWidth(cmd, helper) {
        return Math.max(
          helper.longestOptionTermLength(cmd, helper),
          helper.longestGlobalOptionTermLength(cmd, helper),
          helper.longestSubcommandTermLength(cmd, helper),
          helper.longestArgumentTermLength(cmd, helper)
        );
      }
      /**
       * Wrap the given string to width characters per line, with lines after the first indented.
       * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
       *
       * @param {string} str
       * @param {number} width
       * @param {number} indent
       * @param {number} [minColumnWidth=40]
       * @return {string}
       *
       */
      wrap(str, width, indent, minColumnWidth = 40) {
        const indents = " \\f\\t\\v\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF";
        const manualIndent = new RegExp(`[\\n][${indents}]+`);
        if (str.match(manualIndent))
          return str;
        const columnWidth = width - indent;
        if (columnWidth < minColumnWidth)
          return str;
        const leadingStr = str.slice(0, indent);
        const columnText = str.slice(indent).replace("\r\n", "\n");
        const indentString = " ".repeat(indent);
        const zeroWidthSpace = "\u200B";
        const breaks = `\\s${zeroWidthSpace}`;
        const regex2 = new RegExp(`
|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`, "g");
        const lines = columnText.match(regex2) || [];
        return leadingStr + lines.map((line, i) => {
          if (line === "\n")
            return "";
          return (i > 0 ? indentString : "") + line.trimEnd();
        }).join("\n");
      }
    };
    exports2.Help = Help2;
  }
});

// ../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/lib/option.js
var require_option = __commonJS({
  "../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/lib/option.js"(exports2) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Option2 = class {
      /**
       * Initialize a new `Option` with the given `flags` and `description`.
       *
       * @param {string} flags
       * @param {string} [description]
       */
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || "";
        this.required = flags.includes("<");
        this.optional = flags.includes("[");
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith("--no-");
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.presetArg = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
        this.conflictsWith = [];
        this.implied = void 0;
      }
      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {any} value
       * @param {string} [description]
       * @return {Option}
       */
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      /**
       * Preset to use when option used without option-argument, especially optional but also boolean and negated.
       * The custom processing (parseArg) is called.
       *
       * @example
       * new Option('--color').default('GREYSCALE').preset('RGB');
       * new Option('--donate [amount]').preset('20').argParser(parseFloat);
       *
       * @param {any} arg
       * @return {Option}
       */
      preset(arg) {
        this.presetArg = arg;
        return this;
      }
      /**
       * Add option name(s) that conflict with this option.
       * An error will be displayed if conflicting options are found during parsing.
       *
       * @example
       * new Option('--rgb').conflicts('cmyk');
       * new Option('--js').conflicts(['ts', 'jsx']);
       *
       * @param {string | string[]} names
       * @return {Option}
       */
      conflicts(names) {
        this.conflictsWith = this.conflictsWith.concat(names);
        return this;
      }
      /**
       * Specify implied option values for when this option is set and the implied options are not.
       *
       * The custom processing (parseArg) is not called on the implied values.
       *
       * @example
       * program
       *   .addOption(new Option('--log', 'write logging information to file'))
       *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
       *
       * @param {Object} impliedOptionValues
       * @return {Option}
       */
      implies(impliedOptionValues) {
        let newImplied = impliedOptionValues;
        if (typeof impliedOptionValues === "string") {
          newImplied = { [impliedOptionValues]: true };
        }
        this.implied = Object.assign(this.implied || {}, newImplied);
        return this;
      }
      /**
       * Set environment variable to check for option value.
       *
       * An environment variable is only used if when processed the current option value is
       * undefined, or the source of the current value is 'default' or 'config' or 'env'.
       *
       * @param {string} name
       * @return {Option}
       */
      env(name) {
        this.envVar = name;
        return this;
      }
      /**
       * Set the custom handler for processing CLI option arguments into option values.
       *
       * @param {Function} [fn]
       * @return {Option}
       */
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      /**
       * Whether the option is mandatory and must have a value after parsing.
       *
       * @param {boolean} [mandatory=true]
       * @return {Option}
       */
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      /**
       * Hide option in help.
       *
       * @param {boolean} [hide=true]
       * @return {Option}
       */
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      /**
       * @api private
       */
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      /**
       * Only allow option value to be one of choices.
       *
       * @param {string[]} values
       * @return {Option}
       */
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      /**
       * Return option name.
       *
       * @return {string}
       */
      name() {
        if (this.long) {
          return this.long.replace(/^--/, "");
        }
        return this.short.replace(/^-/, "");
      }
      /**
       * Return option name, in a camelcase format that can be used
       * as a object attribute key.
       *
       * @return {string}
       * @api private
       */
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      /**
       * Check if `arg` matches the short or long flag.
       *
       * @param {string} arg
       * @return {boolean}
       * @api private
       */
      is(arg) {
        return this.short === arg || this.long === arg;
      }
      /**
       * Return whether a boolean option.
       *
       * Options are one of boolean, negated, required argument, or optional argument.
       *
       * @return {boolean}
       * @api private
       */
      isBoolean() {
        return !this.required && !this.optional && !this.negate;
      }
    };
    var DualOptions = class {
      /**
       * @param {Option[]} options
       */
      constructor(options) {
        this.positiveOptions = /* @__PURE__ */ new Map();
        this.negativeOptions = /* @__PURE__ */ new Map();
        this.dualOptions = /* @__PURE__ */ new Set();
        options.forEach((option) => {
          if (option.negate) {
            this.negativeOptions.set(option.attributeName(), option);
          } else {
            this.positiveOptions.set(option.attributeName(), option);
          }
        });
        this.negativeOptions.forEach((value, key) => {
          if (this.positiveOptions.has(key)) {
            this.dualOptions.add(key);
          }
        });
      }
      /**
       * Did the value come from the option, and not from possible matching dual option?
       *
       * @param {any} value
       * @param {Option} option
       * @returns {boolean}
       */
      valueFromOption(value, option) {
        const optionKey = option.attributeName();
        if (!this.dualOptions.has(optionKey))
          return true;
        const preset = this.negativeOptions.get(optionKey).presetArg;
        const negativeValue = preset !== void 0 ? preset : false;
        return option.negate === (negativeValue === value);
      }
    };
    function camelcase(str) {
      return str.split("-").reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
        shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    exports2.Option = Option2;
    exports2.splitOptionFlags = splitOptionFlags;
    exports2.DualOptions = DualOptions;
  }
});

// ../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  "../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/lib/suggestSimilar.js"(exports2) {
    var maxDistance = 3;
    function editDistance(a, b) {
      if (Math.abs(a.length - b.length) > maxDistance)
        return Math.max(a.length, b.length);
      const d = [];
      for (let i = 0; i <= a.length; i++) {
        d[i] = [i];
      }
      for (let j = 0; j <= b.length; j++) {
        d[0][j] = j;
      }
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          let cost = 1;
          if (a[i - 1] === b[j - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d[i][j] = Math.min(
            d[i - 1][j] + 1,
            // deletion
            d[i][j - 1] + 1,
            // insertion
            d[i - 1][j - 1] + cost
            // substitution
          );
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
          }
        }
      }
      return d[a.length][b.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0)
        return "";
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith("--");
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1)
          return;
        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a, b) => a.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(", ")}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return "";
    }
    exports2.suggestSimilar = suggestSimilar;
  }
});

// ../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/lib/command.js
var require_command = __commonJS({
  "../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/lib/command.js"(exports2) {
    var EventEmitter = require("events").EventEmitter;
    var childProcess = require("child_process");
    var path2 = require("path");
    var fs2 = require("fs");
    var process3 = require("process");
    var { Argument: Argument2, humanReadableArgName } = require_argument();
    var { CommanderError: CommanderError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2, splitOptionFlags, DualOptions } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command2 = class extends EventEmitter {
      /**
       * Initialize a new `Command`.
       *
       * @param {string} [name]
       */
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = true;
        this._args = [];
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || "";
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._executableDir = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = "";
        this._summary = "";
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = true;
        this._outputConfiguration = {
          writeOut: (str) => process3.stdout.write(str),
          writeErr: (str) => process3.stderr.write(str),
          getOutHelpWidth: () => process3.stdout.isTTY ? process3.stdout.columns : void 0,
          getErrHelpWidth: () => process3.stderr.isTTY ? process3.stderr.columns : void 0,
          outputError: (str, write) => write(str)
        };
        this._hidden = false;
        this._hasHelpOption = true;
        this._helpFlags = "-h, --help";
        this._helpDescription = "display help for command";
        this._helpShortFlag = "-h";
        this._helpLongFlag = "--help";
        this._addImplicitHelpCommand = void 0;
        this._helpCommandName = "help";
        this._helpCommandnameAndArgs = "help [command]";
        this._helpCommandDescription = "display help for command";
        this._helpConfiguration = {};
      }
      /**
       * Copy settings that are useful to have in common across root command and subcommands.
       *
       * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
       *
       * @param {Command} sourceCommand
       * @return {Command} `this` command for chaining
       */
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._hasHelpOption = sourceCommand._hasHelpOption;
        this._helpFlags = sourceCommand._helpFlags;
        this._helpDescription = sourceCommand._helpDescription;
        this._helpShortFlag = sourceCommand._helpShortFlag;
        this._helpLongFlag = sourceCommand._helpLongFlag;
        this._helpCommandName = sourceCommand._helpCommandName;
        this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
        this._helpCommandDescription = sourceCommand._helpCommandDescription;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
        return this;
      }
      /**
       * Define a command.
       *
       * There are two styles of command: pay attention to where to put the description.
       *
       * @example
       * // Command implemented using action handler (description is supplied separately to `.command`)
       * program
       *   .command('clone <source> [destination]')
       *   .description('clone a repository into a newly created directory')
       *   .action((source, destination) => {
       *     console.log('clone command called');
       *   });
       *
       * // Command implemented using separate executable file (description is second parameter to `.command`)
       * program
       *   .command('start <service>', 'start named service')
       *   .command('stop [service]', 'stop named service, or all if no name supplied');
       *
       * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
       * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
       * @param {Object} [execOpts] - configuration options (for executable)
       * @return {Command} returns new command for action handler, or `this` for executable command
       */
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === "object" && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args)
          cmd.arguments(args);
        this.commands.push(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc)
          return this;
        return cmd;
      }
      /**
       * Factory routine to create a new unattached command.
       *
       * See .command() for creating an attached subcommand, which uses this routine to
       * create the command. You can override createCommand to customise subcommands.
       *
       * @param {string} [name]
       * @return {Command} new command
       */
      createCommand(name) {
        return new Command2(name);
      }
      /**
       * You can customise the help with a subclass of Help by overriding createHelp,
       * or by overriding Help properties using configureHelp().
       *
       * @return {Help}
       */
      createHelp() {
        return Object.assign(new Help2(), this.configureHelp());
      }
      /**
       * You can customise the help by overriding Help properties using configureHelp(),
       * or with a subclass of Help by overriding createHelp().
       *
       * @param {Object} [configuration] - configuration options
       * @return {Command|Object} `this` command for chaining, or stored configuration
       */
      configureHelp(configuration) {
        if (configuration === void 0)
          return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      /**
       * The default output goes to stdout and stderr. You can customise this for special
       * applications. You can also customise the display of errors by overriding outputError.
       *
       * The configuration properties are all functions:
       *
       *     // functions to change where being written, stdout and stderr
       *     writeOut(str)
       *     writeErr(str)
       *     // matching functions to specify width for wrapping help
       *     getOutHelpWidth()
       *     getErrHelpWidth()
       *     // functions based on what is being written out
       *     outputError(str, write) // used for displaying errors, and not used for displaying help
       *
       * @param {Object} [configuration] - configuration options
       * @return {Command|Object} `this` command for chaining, or stored configuration
       */
      configureOutput(configuration) {
        if (configuration === void 0)
          return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      /**
       * Display the help or a custom message after an error occurs.
       *
       * @param {boolean|string} [displayHelp]
       * @return {Command} `this` command for chaining
       */
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== "string")
          displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      /**
       * Display suggestion of similar commands for unknown commands, or options for unknown options.
       *
       * @param {boolean} [displaySuggestion]
       * @return {Command} `this` command for chaining
       */
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      /**
       * Add a prepared subcommand.
       *
       * See .command() for creating an attached subcommand which inherits settings from its parent.
       *
       * @param {Command} cmd - new subcommand
       * @param {Object} [opts] - configuration options
       * @return {Command} `this` command for chaining
       */
      addCommand(cmd, opts) {
        if (!cmd._name) {
          throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
        }
        opts = opts || {};
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden)
          cmd._hidden = true;
        this.commands.push(cmd);
        cmd.parent = this;
        return this;
      }
      /**
       * Factory routine to create a new unattached argument.
       *
       * See .argument() for creating an attached argument, which uses this routine to
       * create the argument. You can override createArgument to return a custom argument.
       *
       * @param {string} name
       * @param {string} [description]
       * @return {Argument} new argument
       */
      createArgument(name, description) {
        return new Argument2(name, description);
      }
      /**
       * Define argument syntax for command.
       *
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @example
       * program.argument('<input-file>');
       * program.argument('[output-file]');
       *
       * @param {string} name
       * @param {string} [description]
       * @param {Function|*} [fn] - custom argument processing function
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === "function") {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      /**
       * Define argument syntax for command, adding multiple at once (without descriptions).
       *
       * See also .argument().
       *
       * @example
       * program.arguments('<cmd> [env]');
       *
       * @param {string} names
       * @return {Command} `this` command for chaining
       */
      arguments(names) {
        names.split(/ +/).forEach((detail) => {
          this.argument(detail);
        });
        return this;
      }
      /**
       * Define argument syntax for command, adding a prepared argument.
       *
       * @param {Argument} argument
       * @return {Command} `this` command for chaining
       */
      addArgument(argument) {
        const previousArgument = this._args.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
        }
        if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
          throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
        }
        this._args.push(argument);
        return this;
      }
      /**
       * Override default decision whether to add implicit help command.
       *
       *    addHelpCommand() // force on
       *    addHelpCommand(false); // force off
       *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
       *
       * @return {Command} `this` command for chaining
       */
      addHelpCommand(enableOrNameAndArgs, description) {
        if (enableOrNameAndArgs === false) {
          this._addImplicitHelpCommand = false;
        } else {
          this._addImplicitHelpCommand = true;
          if (typeof enableOrNameAndArgs === "string") {
            this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
            this._helpCommandnameAndArgs = enableOrNameAndArgs;
          }
          this._helpCommandDescription = description || this._helpCommandDescription;
        }
        return this;
      }
      /**
       * @return {boolean}
       * @api private
       */
      _hasImplicitHelpCommand() {
        if (this._addImplicitHelpCommand === void 0) {
          return this.commands.length && !this._actionHandler && !this._findCommand("help");
        }
        return this._addImplicitHelpCommand;
      }
      /**
       * Add hook for life cycle event.
       *
       * @param {string} event
       * @param {Function} listener
       * @return {Command} `this` command for chaining
       */
      hook(event, listener) {
        const allowedValues = ["preSubcommand", "preAction", "postAction"];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      /**
       * Register callback to use as replacement for calling process.exit.
       *
       * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
       * @return {Command} `this` command for chaining
       */
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== "commander.executeSubCommandAsync") {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      /**
       * Call process.exit, and _exitCallback if defined.
       *
       * @param {number} exitCode exit code for using with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @return never
       * @api private
       */
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError2(exitCode, code, message));
        }
        process3.exit(exitCode);
      }
      /**
       * Register callback `fn` for the command.
       *
       * @example
       * program
       *   .command('serve')
       *   .description('start service')
       *   .action(function() {
       *      // do work here
       *   });
       *
       * @param {Function} fn
       * @return {Command} `this` command for chaining
       */
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this._args.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      /**
       * Factory routine to create a new unattached option.
       *
       * See .option() for creating an attached option, which uses this routine to
       * create the option. You can override createOption to return a custom option.
       *
       * @param {string} flags
       * @param {string} [description]
       * @return {Option} new option
       */
      createOption(flags, description) {
        return new Option2(flags, description);
      }
      /**
       * Add an option.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addOption(option) {
        const oname = option.name();
        const name = option.attributeName();
        if (option.negate) {
          const positiveLongFlag = option.long.replace(/^--no-/, "--");
          if (!this._findOption(positiveLongFlag)) {
            this.setOptionValueWithSource(name, option.defaultValue === void 0 ? true : option.defaultValue, "default");
          }
        } else if (option.defaultValue !== void 0) {
          this.setOptionValueWithSource(name, option.defaultValue, "default");
        }
        this.options.push(option);
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          if (val == null && option.presetArg !== void 0) {
            val = option.presetArg;
          }
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            try {
              val = option.parseArg(val, oldValue);
            } catch (err) {
              if (err.code === "commander.invalidArgument") {
                const message = `${invalidValueMessage} ${err.message}`;
                this.error(message, { exitCode: err.exitCode, code: err.code });
              }
              throw err;
            }
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (val == null) {
            if (option.negate) {
              val = false;
            } else if (option.isBoolean() || option.optional) {
              val = true;
            } else {
              val = "";
            }
          }
          this.setOptionValueWithSource(name, val, valueSource);
        };
        this.on("option:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "cli");
        });
        if (option.envVar) {
          this.on("optionEnv:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "env");
          });
        }
        return this;
      }
      /**
       * Internal implementation shared by .option() and .requiredOption()
       *
       * @api private
       */
      _optionEx(config, flags, description, fn, defaultValue) {
        if (typeof flags === "object" && flags instanceof Option2) {
          throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
        }
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config.mandatory);
        if (typeof fn === "function") {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex2 = fn;
          fn = (val, def) => {
            const m = regex2.exec(val);
            return m ? m[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      /**
       * Define option with `flags`, `description` and optional
       * coercion `fn`.
       *
       * The `flags` string contains the short and/or long flags,
       * separated by comma, a pipe or space. The following are all valid
       * all will output this way when `--help` is used.
       *
       *     "-p, --pepper"
       *     "-p|--pepper"
       *     "-p --pepper"
       *
       * @example
       * // simple boolean defaulting to undefined
       * program.option('-p, --pepper', 'add pepper');
       *
       * program.pepper
       * // => undefined
       *
       * --pepper
       * program.pepper
       * // => true
       *
       * // simple boolean defaulting to true (unless non-negated option is also defined)
       * program.option('-C, --no-cheese', 'remove cheese');
       *
       * program.cheese
       * // => true
       *
       * --no-cheese
       * program.cheese
       * // => false
       *
       * // required argument
       * program.option('-C, --chdir <path>', 'change the working directory');
       *
       * --chdir /tmp
       * program.chdir
       * // => "/tmp"
       *
       * // optional argument
       * program.option('-c, --cheese [type]', 'add cheese [marble]');
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {Function|*} [fn] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      option(flags, description, fn, defaultValue) {
        return this._optionEx({}, flags, description, fn, defaultValue);
      }
      /**
      * Add a required option which must have a value after parsing. This usually means
      * the option must be specified on the command line. (Otherwise the same as .option().)
      *
      * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
      *
      * @param {string} flags
      * @param {string} [description]
      * @param {Function|*} [fn] - custom option processing function or default value
      * @param {*} [defaultValue]
      * @return {Command} `this` command for chaining
      */
      requiredOption(flags, description, fn, defaultValue) {
        return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);
      }
      /**
       * Alter parsing of short flags with optional values.
       *
       * @example
       * // for `.option('-f,--flag [value]'):
       * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
       * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
       *
       * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
       */
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      /**
       * Allow unknown options on the command line.
       *
       * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
       * for unknown options.
       */
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      /**
       * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
       *
       * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
       * for excess arguments.
       */
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      /**
       * Enable positional options. Positional means global options are specified before subcommands which lets
       * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
       * The default behaviour is non-positional and global options may appear anywhere on the command line.
       *
       * @param {Boolean} [positional=true]
       */
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      /**
       * Pass through options that come after command-arguments rather than treat them as command-options,
       * so actual command-options come before command-arguments. Turning this on for a subcommand requires
       * positional options to have been enabled on the program (parent commands).
       * The default behaviour is non-positional and options may appear before or after command-arguments.
       *
       * @param {Boolean} [passThrough=true]
       * for unknown options.
       */
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
          throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
        }
        return this;
      }
      /**
        * Whether to store option values as properties on command object,
        * or store separately (specify false). In both cases the option values can be accessed using .opts().
        *
        * @param {boolean} [storeAsProperties=true]
        * @return {Command} `this` command for chaining
        */
      storeOptionsAsProperties(storeAsProperties = true) {
        this._storeOptionsAsProperties = !!storeAsProperties;
        if (this.options.length) {
          throw new Error("call .storeOptionsAsProperties() before adding options");
        }
        return this;
      }
      /**
       * Retrieve option value.
       *
       * @param {string} key
       * @return {Object} value
       */
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      /**
       * Store option value.
       *
       * @param {string} key
       * @param {Object} value
       * @return {Command} `this` command for chaining
       */
      setOptionValue(key, value) {
        return this.setOptionValueWithSource(key, value, void 0);
      }
      /**
        * Store option value and where the value came from.
        *
        * @param {string} key
        * @param {Object} value
        * @param {string} source - expected values are default/config/env/cli/implied
        * @return {Command} `this` command for chaining
        */
      setOptionValueWithSource(key, value, source) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        this._optionValueSources[key] = source;
        return this;
      }
      /**
        * Get source of option value.
        * Expected values are default | config | env | cli | implied
        *
        * @param {string} key
        * @return {string}
        */
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      /**
        * Get source of option value. See also .optsWithGlobals().
        * Expected values are default | config | env | cli | implied
        *
        * @param {string} key
        * @return {string}
        */
      getOptionValueSourceWithGlobals(key) {
        let source;
        getCommandAndParents(this).forEach((cmd) => {
          if (cmd.getOptionValueSource(key) !== void 0) {
            source = cmd.getOptionValueSource(key);
          }
        });
        return source;
      }
      /**
       * Get user arguments from implied or explicit arguments.
       * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
       *
       * @api private
       */
      _prepareUserArgs(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error("first parameter to parse must be array or undefined");
        }
        parseOptions = parseOptions || {};
        if (argv === void 0) {
          argv = process3.argv;
          if (process3.versions && process3.versions.electron) {
            parseOptions.from = "electron";
          }
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case "node":
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case "electron":
            if (process3.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case "user":
            userArgs = argv.slice(0);
            break;
          default:
            throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
        }
        if (!this._name && this._scriptPath)
          this.nameFromFilename(this._scriptPath);
        this._name = this._name || "program";
        return userArgs;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * The default expectation is that the arguments are from node and have the application as argv[0]
       * and the script being run in argv[1], with user parameters after that.
       *
       * @example
       * program.parse(process.argv);
       * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
       * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv] - optional, defaults to process.argv
       * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
       * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
       * @return {Command} `this` command for chaining
       */
      parse(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
       *
       * The default expectation is that the arguments are from node and have the application as argv[0]
       * and the script being run in argv[1], with user parameters after that.
       *
       * @example
       * await program.parseAsync(process.argv);
       * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
       * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv]
       * @param {Object} [parseOptions]
       * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
       * @return {Promise}
       */
      async parseAsync(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        await this._parseCommand([], userArgs);
        return this;
      }
      /**
       * Execute a sub-command executable.
       *
       * @api private
       */
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
        function findFile(baseDir, baseName) {
          const localBin = path2.resolve(baseDir, baseName);
          if (fs2.existsSync(localBin))
            return localBin;
          if (sourceExt.includes(path2.extname(baseName)))
            return void 0;
          const foundExt = sourceExt.find((ext) => fs2.existsSync(`${localBin}${ext}`));
          if (foundExt)
            return `${localBin}${foundExt}`;
          return void 0;
        }
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
        let executableDir = this._executableDir || "";
        if (this._scriptPath) {
          let resolvedScriptPath;
          try {
            resolvedScriptPath = fs2.realpathSync(this._scriptPath);
          } catch (err) {
            resolvedScriptPath = this._scriptPath;
          }
          executableDir = path2.resolve(path2.dirname(resolvedScriptPath), executableDir);
        }
        if (executableDir) {
          let localFile = findFile(executableDir, executableFile);
          if (!localFile && !subcommand._executableFile && this._scriptPath) {
            const legacyName = path2.basename(this._scriptPath, path2.extname(this._scriptPath));
            if (legacyName !== this._name) {
              localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
            }
          }
          executableFile = localFile || executableFile;
        }
        launchWithNode = sourceExt.includes(path2.extname(executableFile));
        let proc;
        if (process3.platform !== "win32") {
          if (launchWithNode) {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process3.execArgv).concat(args);
            proc = childProcess.spawn(process3.argv[0], args, { stdio: "inherit" });
          } else {
            proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
          }
        } else {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process3.execArgv).concat(args);
          proc = childProcess.spawn(process3.execPath, args, { stdio: "inherit" });
        }
        if (!proc.killed) {
          const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
          signals.forEach((signal) => {
            process3.on(signal, () => {
              if (proc.killed === false && proc.exitCode === null) {
                proc.kill(signal);
              }
            });
          });
        }
        const exitCallback = this._exitCallback;
        if (!exitCallback) {
          proc.on("close", process3.exit.bind(process3));
        } else {
          proc.on("close", () => {
            exitCallback(new CommanderError2(process3.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
          });
        }
        proc.on("error", (err) => {
          if (err.code === "ENOENT") {
            const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
            const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
            throw new Error(executableMissing);
          } else if (err.code === "EACCES") {
            throw new Error(`'${executableFile}' not executable`);
          }
          if (!exitCallback) {
            process3.exit(1);
          } else {
            const wrappedError = new CommanderError2(1, "commander.executeSubCommandAsync", "(error)");
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      /**
       * @api private
       */
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand)
          this.help({ error: true });
        let hookResult;
        hookResult = this._chainOrCallSubCommandHook(hookResult, subCommand, "preSubcommand");
        hookResult = this._chainOrCall(hookResult, () => {
          if (subCommand._executableHandler) {
            this._executeSubCommand(subCommand, operands.concat(unknown));
          } else {
            return subCommand._parseCommand(operands, unknown);
          }
        });
        return hookResult;
      }
      /**
       * Check this.args against expected this._args.
       *
       * @api private
       */
      _checkNumberOfArguments() {
        this._args.forEach((arg, i) => {
          if (arg.required && this.args[i] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
          return;
        }
        if (this.args.length > this._args.length) {
          this._excessArguments(this.args);
        }
      }
      /**
       * Process this.args using this._args and save as this.processedArgs!
       *
       * @api private
       */
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            try {
              parsedValue = argument.parseArg(value, previous);
            } catch (err) {
              if (err.code === "commander.invalidArgument") {
                const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;
                this.error(message, { exitCode: err.exitCode, code: err.code });
              }
              throw err;
            }
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this._args.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v) => {
                  return myParseArg(declaredArg, v, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      /**
       * Once we have a promise we chain, but call synchronously until then.
       *
       * @param {Promise|undefined} promise
       * @param {Function} fn
       * @return {Promise|undefined}
       * @api private
       */
      _chainOrCall(promise, fn) {
        if (promise && promise.then && typeof promise.then === "function") {
          return promise.then(() => fn());
        }
        return fn();
      }
      /**
       *
       * @param {Promise|undefined} promise
       * @param {string} event
       * @return {Promise|undefined}
       * @api private
       */
      _chainOrCallHooks(promise, event) {
        let result = promise;
        const hooks = [];
        getCommandAndParents(this).reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
          hookedCommand._lifeCycleHooks[event].forEach((callback) => {
            hooks.push({ hookedCommand, callback });
          });
        });
        if (event === "postAction") {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      /**
       *
       * @param {Promise|undefined} promise
       * @param {Command} subCommand
       * @param {string} event
       * @return {Promise|undefined}
       * @api private
       */
      _chainOrCallSubCommandHook(promise, subCommand, event) {
        let result = promise;
        if (this._lifeCycleHooks[event] !== void 0) {
          this._lifeCycleHooks[event].forEach((hook) => {
            result = this._chainOrCall(result, () => {
              return hook(this, subCommand);
            });
          });
        }
        return result;
      }
      /**
       * Process arguments in context of this command.
       * Returns action result, in case it is a promise.
       *
       * @api private
       */
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        this._parseOptionsImplied();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
          if (operands.length === 1) {
            this.help();
          }
          return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
        }
        if (this._defaultCommandName) {
          outputHelpIfRequested(this, unknown);
          return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          this.help({ error: true });
        }
        outputHelpIfRequested(this, parsed.unknown);
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let actionResult;
          actionResult = this._chainOrCallHooks(actionResult, "preAction");
          actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));
          if (this.parent) {
            actionResult = this._chainOrCall(actionResult, () => {
              this.parent.emit(commandEvent, operands, unknown);
            });
          }
          actionResult = this._chainOrCallHooks(actionResult, "postAction");
          return actionResult;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand("*")) {
            return this._dispatchSubcommand("*", operands, unknown);
          }
          if (this.listenerCount("command:*")) {
            this.emit("command:*", operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      /**
       * Find matching command.
       *
       * @api private
       */
      _findCommand(name) {
        if (!name)
          return void 0;
        return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
      }
      /**
       * Return an option matching `arg` if any.
       *
       * @param {string} arg
       * @return {Option}
       * @api private
       */
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      /**
       * Display an error message if a mandatory option does not have a value.
       * Called after checking for help flags in leaf subcommand.
       *
       * @api private
       */
      _checkForMissingMandatoryOptions() {
        for (let cmd = this; cmd; cmd = cmd.parent) {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        }
      }
      /**
       * Display an error message if conflicting options are used together in this.
       *
       * @api private
       */
      _checkForConflictingLocalOptions() {
        const definedNonDefaultOptions = this.options.filter(
          (option) => {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0) {
              return false;
            }
            return this.getOptionValueSource(optionKey) !== "default";
          }
        );
        const optionsWithConflicting = definedNonDefaultOptions.filter(
          (option) => option.conflictsWith.length > 0
        );
        optionsWithConflicting.forEach((option) => {
          const conflictingAndDefined = definedNonDefaultOptions.find(
            (defined) => option.conflictsWith.includes(defined.attributeName())
          );
          if (conflictingAndDefined) {
            this._conflictingOption(option, conflictingAndDefined);
          }
        });
      }
      /**
       * Display an error message if conflicting options are used together.
       * Called after checking for help flags in leaf subcommand.
       *
       * @api private
       */
      _checkForConflictingOptions() {
        for (let cmd = this; cmd; cmd = cmd.parent) {
          cmd._checkForConflictingLocalOptions();
        }
      }
      /**
       * Parse options from `argv` removing known options,
       * and return argv split into operands and unknown arguments.
       *
       * Examples:
       *
       *     argv => operands, unknown
       *     --known kkk op => [op], []
       *     op --known kkk => [op], []
       *     sub --unknown uuu op => [sub], [--unknown uuu op]
       *     sub -- --unknown uuu op => [sub --unknown uuu op], []
       *
       * @param {String[]} argv
       * @return {{operands: String[], unknown: String[]}}
       */
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === "-";
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === "--") {
            if (dest === unknown)
              dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0)
                  this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf("=");
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
              operands.push(arg);
              if (args.length > 0)
                operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0)
              dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      /**
       * Return an object containing local option values as key-value pairs.
       *
       * @return {Object}
       */
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i = 0; i < len; i++) {
            const key = this.options[i].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      /**
       * Return an object containing merged local and global option values as key-value pairs.
       *
       * @return {Object}
       */
      optsWithGlobals() {
        return getCommandAndParents(this).reduce(
          (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
          {}
        );
      }
      /**
       * Display error message and exit (or call exitOverride).
       *
       * @param {string} message
       * @param {Object} [errorOptions]
       * @param {string} [errorOptions.code] - an id string representing the error
       * @param {number} [errorOptions.exitCode] - used with process.exit
       */
      error(message, errorOptions) {
        this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
        if (typeof this._showHelpAfterError === "string") {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr("\n");
          this.outputHelp({ error: true });
        }
        const config = errorOptions || {};
        const exitCode = config.exitCode || 1;
        const code = config.code || "commander.error";
        this._exit(exitCode, code, message);
      }
      /**
       * Apply any option related environment variables, if option does
       * not have a value from cli or client code.
       *
       * @api private
       */
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process3.env) {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
              if (option.required || option.optional) {
                this.emit(`optionEnv:${option.name()}`, process3.env[option.envVar]);
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      /**
       * Apply any implied option values, if option is undefined or default value.
       *
       * @api private
       */
      _parseOptionsImplied() {
        const dualHelper = new DualOptions(this.options);
        const hasCustomOptionValue = (optionKey) => {
          return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
        };
        this.options.filter((option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
          Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
            this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
          });
        });
      }
      /**
       * Argument `name` is missing.
       *
       * @param {string} name
       * @api private
       */
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this.error(message, { code: "commander.missingArgument" });
      }
      /**
       * `Option` is missing an argument.
       *
       * @param {Option} option
       * @api private
       */
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this.error(message, { code: "commander.optionMissingArgument" });
      }
      /**
       * `Option` does not have a value, and is a mandatory option.
       *
       * @param {Option} option
       * @api private
       */
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this.error(message, { code: "commander.missingMandatoryOptionValue" });
      }
      /**
       * `Option` conflicts with another option.
       *
       * @param {Option} option
       * @param {Option} conflictingOption
       * @api private
       */
      _conflictingOption(option, conflictingOption) {
        const findBestOptionFromValue = (option2) => {
          const optionKey = option2.attributeName();
          const optionValue = this.getOptionValue(optionKey);
          const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
          const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
          if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) {
            return negativeOption;
          }
          return positiveOption || option2;
        };
        const getErrorMessage = (option2) => {
          const bestOption = findBestOptionFromValue(option2);
          const optionKey = bestOption.attributeName();
          const source = this.getOptionValueSource(optionKey);
          if (source === "env") {
            return `environment variable '${bestOption.envVar}'`;
          }
          return `option '${bestOption.flags}'`;
        };
        const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
        this.error(message, { code: "commander.conflictingOption" });
      }
      /**
       * Unknown option `flag`.
       *
       * @param {string} flag
       * @api private
       */
      unknownOption(flag) {
        if (this._allowUnknownOption)
          return;
        let suggestion = "";
        if (flag.startsWith("--") && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this.error(message, { code: "commander.unknownOption" });
      }
      /**
       * Excess arguments, more than expected.
       *
       * @param {string[]} receivedArgs
       * @api private
       */
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments)
          return;
        const expected = this._args.length;
        const s = expected === 1 ? "" : "s";
        const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
        this.error(message, { code: "commander.excessArguments" });
      }
      /**
       * Unknown command.
       *
       * @api private
       */
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = "";
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp().visibleCommands(this).forEach((command) => {
            candidateNames.push(command.name());
            if (command.alias())
              candidateNames.push(command.alias());
          });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this.error(message, { code: "commander.unknownCommand" });
      }
      /**
       * Set the program version to `str`.
       *
       * This method auto-registers the "-V, --version" flag
       * which will print the version number when passed.
       *
       * You can optionally supply the  flags and description to override the defaults.
       *
       * @param {string} str
       * @param {string} [flags]
       * @param {string} [description]
       * @return {this | string} `this` command for chaining, or version string if no arguments
       */
      version(str, flags, description) {
        if (str === void 0)
          return this._version;
        this._version = str;
        flags = flags || "-V, --version";
        description = description || "output the version number";
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this.options.push(versionOption);
        this.on("option:" + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, "commander.version", str);
        });
        return this;
      }
      /**
       * Set the description.
       *
       * @param {string} [str]
       * @param {Object} [argsDescription]
       * @return {string|Command}
       */
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0)
          return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      /**
       * Set the summary. Used when listed as subcommand of parent.
       *
       * @param {string} [str]
       * @return {string|Command}
       */
      summary(str) {
        if (str === void 0)
          return this._summary;
        this._summary = str;
        return this;
      }
      /**
       * Set an alias for the command.
       *
       * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
       *
       * @param {string} [alias]
       * @return {string|Command}
       */
      alias(alias) {
        if (alias === void 0)
          return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name)
          throw new Error("Command alias can't be the same as its name");
        command._aliases.push(alias);
        return this;
      }
      /**
       * Set aliases for the command.
       *
       * Only the first alias is shown in the auto-generated help.
       *
       * @param {string[]} [aliases]
       * @return {string[]|Command}
       */
      aliases(aliases) {
        if (aliases === void 0)
          return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      /**
       * Set / get the command usage `str`.
       *
       * @param {string} [str]
       * @return {String|Command}
       */
      usage(str) {
        if (str === void 0) {
          if (this._usage)
            return this._usage;
          const args = this._args.map((arg) => {
            return humanReadableArgName(arg);
          });
          return [].concat(
            this.options.length || this._hasHelpOption ? "[options]" : [],
            this.commands.length ? "[command]" : [],
            this._args.length ? args : []
          ).join(" ");
        }
        this._usage = str;
        return this;
      }
      /**
       * Get or set the name of the command.
       *
       * @param {string} [str]
       * @return {string|Command}
       */
      name(str) {
        if (str === void 0)
          return this._name;
        this._name = str;
        return this;
      }
      /**
       * Set the name of the command from script filename, such as process.argv[1],
       * or require.main.filename, or __filename.
       *
       * (Used internally and public although not documented in README.)
       *
       * @example
       * program.nameFromFilename(require.main.filename);
       *
       * @param {string} filename
       * @return {Command}
       */
      nameFromFilename(filename) {
        this._name = path2.basename(filename, path2.extname(filename));
        return this;
      }
      /**
       * Get or set the directory for searching for executable subcommands of this command.
       *
       * @example
       * program.executableDir(__dirname);
       * // or
       * program.executableDir('subcommands');
       *
       * @param {string} [path]
       * @return {string|Command}
       */
      executableDir(path3) {
        if (path3 === void 0)
          return this._executableDir;
        this._executableDir = path3;
        return this;
      }
      /**
       * Return program help documentation.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
       * @return {string}
       */
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        if (helper.helpWidth === void 0) {
          helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
        }
        return helper.formatHelp(this, helper);
      }
      /**
       * @api private
       */
      _getHelpContext(contextOptions) {
        contextOptions = contextOptions || {};
        const context = { error: !!contextOptions.error };
        let write;
        if (context.error) {
          write = (arg) => this._outputConfiguration.writeErr(arg);
        } else {
          write = (arg) => this._outputConfiguration.writeOut(arg);
        }
        context.write = contextOptions.write || write;
        context.command = this;
        return context;
      }
      /**
       * Output help information for this command.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === "function") {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const context = this._getHelpContext(contextOptions);
        getCommandAndParents(this).reverse().forEach((command) => command.emit("beforeAllHelp", context));
        this.emit("beforeHelp", context);
        let helpInformation = this.helpInformation(context);
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
            throw new Error("outputHelp callback must return a string or a Buffer");
          }
        }
        context.write(helpInformation);
        this.emit(this._helpLongFlag);
        this.emit("afterHelp", context);
        getCommandAndParents(this).forEach((command) => command.emit("afterAllHelp", context));
      }
      /**
       * You can pass in flags and a description to override the help
       * flags and help description for your command. Pass in false to
       * disable the built-in help option.
       *
       * @param {string | boolean} [flags]
       * @param {string} [description]
       * @return {Command} `this` command for chaining
       */
      helpOption(flags, description) {
        if (typeof flags === "boolean") {
          this._hasHelpOption = flags;
          return this;
        }
        this._helpFlags = flags || this._helpFlags;
        this._helpDescription = description || this._helpDescription;
        const helpFlags = splitOptionFlags(this._helpFlags);
        this._helpShortFlag = helpFlags.shortFlag;
        this._helpLongFlag = helpFlags.longFlag;
        return this;
      }
      /**
       * Output help information and exit.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = process3.exitCode || 0;
        if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
          exitCode = 1;
        }
        this._exit(exitCode, "commander.help", "(outputHelp)");
      }
      /**
       * Add additional text to be displayed with the built-in help.
       *
       * Position is 'before' or 'after' to affect just this command,
       * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
       *
       * @param {string} position - before or after built-in help
       * @param {string | Function} text - string to add, or a function returning a string
       * @return {Command} `this` command for chaining
       */
      addHelpText(position, text) {
        const allowedValues = ["beforeAll", "before", "after", "afterAll"];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context) => {
          let helpStr;
          if (typeof text === "function") {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context.write(`${helpStr}
`);
          }
        });
        return this;
      }
    };
    function outputHelpIfRequested(cmd, args) {
      const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
      if (helpOption) {
        cmd.outputHelp();
        cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
      }
    }
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith("--inspect")) {
          return arg;
        }
        let debugOption;
        let debugHost = "127.0.0.1";
        let debugPort = "9229";
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== "0") {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    function getCommandAndParents(startCommand) {
      const result = [];
      for (let command = startCommand; command; command = command.parent) {
        result.push(command);
      }
      return result;
    }
    exports2.Command = Command2;
  }
});

// ../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/index.js
var require_commander = __commonJS({
  "../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/index.js"(exports2, module2) {
    var { Argument: Argument2 } = require_argument();
    var { Command: Command2 } = require_command();
    var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2 } = require_option();
    exports2 = module2.exports = new Command2();
    exports2.program = exports2;
    exports2.Argument = Argument2;
    exports2.Command = Command2;
    exports2.CommanderError = CommanderError2;
    exports2.Help = Help2;
    exports2.InvalidArgumentError = InvalidArgumentError2;
    exports2.InvalidOptionArgumentError = InvalidArgumentError2;
    exports2.Option = Option2;
  }
});

// ../../node_modules/.pnpm/vscode-uri@3.0.7/node_modules/vscode-uri/lib/umd/index.js
var require_umd = __commonJS({
  "../../node_modules/.pnpm/vscode-uri@3.0.7/node_modules/vscode-uri/lib/umd/index.js"(exports2, module2) {
    !function(t, e) {
      if ("object" == typeof exports2 && "object" == typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var r = e();
        for (var n in r)
          ("object" == typeof exports2 ? exports2 : t)[n] = r[n];
      }
    }(exports2, () => (() => {
      "use strict";
      var t = { 470: (t2) => {
        function e2(t3) {
          if ("string" != typeof t3)
            throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
        }
        function r2(t3, e3) {
          for (var r3, n3 = "", o = 0, i = -1, a = 0, s = 0; s <= t3.length; ++s) {
            if (s < t3.length)
              r3 = t3.charCodeAt(s);
            else {
              if (47 === r3)
                break;
              r3 = 47;
            }
            if (47 === r3) {
              if (i === s - 1 || 1 === a)
                ;
              else if (i !== s - 1 && 2 === a) {
                if (n3.length < 2 || 2 !== o || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                  if (n3.length > 2) {
                    var h = n3.lastIndexOf("/");
                    if (h !== n3.length - 1) {
                      -1 === h ? (n3 = "", o = 0) : o = (n3 = n3.slice(0, h)).length - 1 - n3.lastIndexOf("/"), i = s, a = 0;
                      continue;
                    }
                  } else if (2 === n3.length || 1 === n3.length) {
                    n3 = "", o = 0, i = s, a = 0;
                    continue;
                  }
                }
                e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", o = 2);
              } else
                n3.length > 0 ? n3 += "/" + t3.slice(i + 1, s) : n3 = t3.slice(i + 1, s), o = s - i - 1;
              i = s, a = 0;
            } else
              46 === r3 && -1 !== a ? ++a : a = -1;
          }
          return n3;
        }
        var n2 = { resolve: function() {
          for (var t3, n3 = "", o = false, i = arguments.length - 1; i >= -1 && !o; i--) {
            var a;
            i >= 0 ? a = arguments[i] : (void 0 === t3 && (t3 = process.cwd()), a = t3), e2(a), 0 !== a.length && (n3 = a + "/" + n3, o = 47 === a.charCodeAt(0));
          }
          return n3 = r2(n3, !o), o ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
        }, normalize: function(t3) {
          if (e2(t3), 0 === t3.length)
            return ".";
          var n3 = 47 === t3.charCodeAt(0), o = 47 === t3.charCodeAt(t3.length - 1);
          return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && o && (t3 += "/"), n3 ? "/" + t3 : t3;
        }, isAbsolute: function(t3) {
          return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
        }, join: function() {
          if (0 === arguments.length)
            return ".";
          for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
            var o = arguments[r3];
            e2(o), o.length > 0 && (void 0 === t3 ? t3 = o : t3 += "/" + o);
          }
          return void 0 === t3 ? "." : n2.normalize(t3);
        }, relative: function(t3, r3) {
          if (e2(t3), e2(r3), t3 === r3)
            return "";
          if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3)))
            return "";
          for (var o = 1; o < t3.length && 47 === t3.charCodeAt(o); ++o)
            ;
          for (var i = t3.length, a = i - o, s = 1; s < r3.length && 47 === r3.charCodeAt(s); ++s)
            ;
          for (var h = r3.length - s, c = a < h ? a : h, f = -1, u = 0; u <= c; ++u) {
            if (u === c) {
              if (h > c) {
                if (47 === r3.charCodeAt(s + u))
                  return r3.slice(s + u + 1);
                if (0 === u)
                  return r3.slice(s + u);
              } else
                a > c && (47 === t3.charCodeAt(o + u) ? f = u : 0 === u && (f = 0));
              break;
            }
            var l = t3.charCodeAt(o + u);
            if (l !== r3.charCodeAt(s + u))
              break;
            47 === l && (f = u);
          }
          var p = "";
          for (u = o + f + 1; u <= i; ++u)
            u !== i && 47 !== t3.charCodeAt(u) || (0 === p.length ? p += ".." : p += "/..");
          return p.length > 0 ? p + r3.slice(s + f) : (s += f, 47 === r3.charCodeAt(s) && ++s, r3.slice(s));
        }, _makeLong: function(t3) {
          return t3;
        }, dirname: function(t3) {
          if (e2(t3), 0 === t3.length)
            return ".";
          for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, o = -1, i = true, a = t3.length - 1; a >= 1; --a)
            if (47 === (r3 = t3.charCodeAt(a))) {
              if (!i) {
                o = a;
                break;
              }
            } else
              i = false;
          return -1 === o ? n3 ? "/" : "." : n3 && 1 === o ? "//" : t3.slice(0, o);
        }, basename: function(t3, r3) {
          if (void 0 !== r3 && "string" != typeof r3)
            throw new TypeError('"ext" argument must be a string');
          e2(t3);
          var n3, o = 0, i = -1, a = true;
          if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
            if (r3.length === t3.length && r3 === t3)
              return "";
            var s = r3.length - 1, h = -1;
            for (n3 = t3.length - 1; n3 >= 0; --n3) {
              var c = t3.charCodeAt(n3);
              if (47 === c) {
                if (!a) {
                  o = n3 + 1;
                  break;
                }
              } else
                -1 === h && (a = false, h = n3 + 1), s >= 0 && (c === r3.charCodeAt(s) ? -1 == --s && (i = n3) : (s = -1, i = h));
            }
            return o === i ? i = h : -1 === i && (i = t3.length), t3.slice(o, i);
          }
          for (n3 = t3.length - 1; n3 >= 0; --n3)
            if (47 === t3.charCodeAt(n3)) {
              if (!a) {
                o = n3 + 1;
                break;
              }
            } else
              -1 === i && (a = false, i = n3 + 1);
          return -1 === i ? "" : t3.slice(o, i);
        }, extname: function(t3) {
          e2(t3);
          for (var r3 = -1, n3 = 0, o = -1, i = true, a = 0, s = t3.length - 1; s >= 0; --s) {
            var h = t3.charCodeAt(s);
            if (47 !== h)
              -1 === o && (i = false, o = s + 1), 46 === h ? -1 === r3 ? r3 = s : 1 !== a && (a = 1) : -1 !== r3 && (a = -1);
            else if (!i) {
              n3 = s + 1;
              break;
            }
          }
          return -1 === r3 || -1 === o || 0 === a || 1 === a && r3 === o - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, o);
        }, format: function(t3) {
          if (null === t3 || "object" != typeof t3)
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
          return function(t4, e3) {
            var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
            return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
          }(0, t3);
        }, parse: function(t3) {
          e2(t3);
          var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (0 === t3.length)
            return r3;
          var n3, o = t3.charCodeAt(0), i = 47 === o;
          i ? (r3.root = "/", n3 = 1) : n3 = 0;
          for (var a = -1, s = 0, h = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f)
            if (47 !== (o = t3.charCodeAt(f)))
              -1 === h && (c = false, h = f + 1), 46 === o ? -1 === a ? a = f : 1 !== u && (u = 1) : -1 !== a && (u = -1);
            else if (!c) {
              s = f + 1;
              break;
            }
          return -1 === a || -1 === h || 0 === u || 1 === u && a === h - 1 && a === s + 1 ? -1 !== h && (r3.base = r3.name = 0 === s && i ? t3.slice(1, h) : t3.slice(s, h)) : (0 === s && i ? (r3.name = t3.slice(1, a), r3.base = t3.slice(1, h)) : (r3.name = t3.slice(s, a), r3.base = t3.slice(s, h)), r3.ext = t3.slice(a, h)), s > 0 ? r3.dir = t3.slice(0, s - 1) : i && (r3.dir = "/"), r3;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        n2.posix = n2, t2.exports = n2;
      }, 674: (t2, e2) => {
        if (Object.defineProperty(e2, "__esModule", { value: true }), e2.isWindows = void 0, "object" == typeof process)
          e2.isWindows = "win32" === process.platform;
        else if ("object" == typeof navigator) {
          var r2 = navigator.userAgent;
          e2.isWindows = r2.indexOf("Windows") >= 0;
        }
      }, 796: function(t2, e2, r2) {
        var n2, o, i = this && this.__extends || (n2 = function(t3, e3) {
          return n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
            t4.__proto__ = e4;
          } || function(t4, e4) {
            for (var r3 in e4)
              Object.prototype.hasOwnProperty.call(e4, r3) && (t4[r3] = e4[r3]);
          }, n2(t3, e3);
        }, function(t3, e3) {
          if ("function" != typeof e3 && null !== e3)
            throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
          function r3() {
            this.constructor = t3;
          }
          n2(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (r3.prototype = e3.prototype, new r3());
        });
        Object.defineProperty(e2, "__esModule", { value: true }), e2.uriToFsPath = e2.URI = void 0;
        var a = r2(674), s = /^\w[\w\d+.-]*$/, h = /^\//, c = /^\/\//;
        function f(t3, e3) {
          if (!t3.scheme && e3)
            throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(t3.authority, '", path: "').concat(t3.path, '", query: "').concat(t3.query, '", fragment: "').concat(t3.fragment, '"}'));
          if (t3.scheme && !s.test(t3.scheme))
            throw new Error("[UriError]: Scheme contains illegal characters.");
          if (t3.path) {
            if (t3.authority) {
              if (!h.test(t3.path))
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            } else if (c.test(t3.path))
              throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
          }
        }
        var u = "", l = "/", p = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, d = function() {
          function t3(t4, e3, r3, n3, o2, i2) {
            void 0 === i2 && (i2 = false), "object" == typeof t4 ? (this.scheme = t4.scheme || u, this.authority = t4.authority || u, this.path = t4.path || u, this.query = t4.query || u, this.fragment = t4.fragment || u) : (this.scheme = function(t5, e4) {
              return t5 || e4 ? t5 : "file";
            }(t4, i2), this.authority = e3 || u, this.path = function(t5, e4) {
              switch (t5) {
                case "https":
                case "http":
                case "file":
                  e4 ? e4[0] !== l && (e4 = l + e4) : e4 = l;
              }
              return e4;
            }(this.scheme, r3 || u), this.query = n3 || u, this.fragment = o2 || u, f(this, i2));
          }
          return t3.isUri = function(e3) {
            return e3 instanceof t3 || !!e3 && "string" == typeof e3.authority && "string" == typeof e3.fragment && "string" == typeof e3.path && "string" == typeof e3.query && "string" == typeof e3.scheme && "string" == typeof e3.fsPath && "function" == typeof e3.with && "function" == typeof e3.toString;
          }, Object.defineProperty(t3.prototype, "fsPath", { get: function() {
            return C(this, false);
          }, enumerable: false, configurable: true }), t3.prototype.with = function(t4) {
            if (!t4)
              return this;
            var e3 = t4.scheme, r3 = t4.authority, n3 = t4.path, o2 = t4.query, i2 = t4.fragment;
            return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = u), void 0 === r3 ? r3 = this.authority : null === r3 && (r3 = u), void 0 === n3 ? n3 = this.path : null === n3 && (n3 = u), void 0 === o2 ? o2 = this.query : null === o2 && (o2 = u), void 0 === i2 ? i2 = this.fragment : null === i2 && (i2 = u), e3 === this.scheme && r3 === this.authority && n3 === this.path && o2 === this.query && i2 === this.fragment ? this : new v(e3, r3, n3, o2, i2);
          }, t3.parse = function(t4, e3) {
            void 0 === e3 && (e3 = false);
            var r3 = p.exec(t4);
            return r3 ? new v(r3[2] || u, x(r3[4] || u), x(r3[5] || u), x(r3[7] || u), x(r3[9] || u), e3) : new v(u, u, u, u, u);
          }, t3.file = function(t4) {
            var e3 = u;
            if (a.isWindows && (t4 = t4.replace(/\\/g, l)), t4[0] === l && t4[1] === l) {
              var r3 = t4.indexOf(l, 2);
              -1 === r3 ? (e3 = t4.substring(2), t4 = l) : (e3 = t4.substring(2, r3), t4 = t4.substring(r3) || l);
            }
            return new v("file", e3, t4, u, u);
          }, t3.from = function(t4) {
            var e3 = new v(t4.scheme, t4.authority, t4.path, t4.query, t4.fragment);
            return f(e3, true), e3;
          }, t3.prototype.toString = function(t4) {
            return void 0 === t4 && (t4 = false), A(this, t4);
          }, t3.prototype.toJSON = function() {
            return this;
          }, t3.revive = function(e3) {
            if (e3) {
              if (e3 instanceof t3)
                return e3;
              var r3 = new v(e3);
              return r3._formatted = e3.external, r3._fsPath = e3._sep === g ? e3.fsPath : null, r3;
            }
            return e3;
          }, t3;
        }();
        e2.URI = d;
        var g = a.isWindows ? 1 : void 0, v = function(t3) {
          function e3() {
            var e4 = null !== t3 && t3.apply(this, arguments) || this;
            return e4._formatted = null, e4._fsPath = null, e4;
          }
          return i(e3, t3), Object.defineProperty(e3.prototype, "fsPath", { get: function() {
            return this._fsPath || (this._fsPath = C(this, false)), this._fsPath;
          }, enumerable: false, configurable: true }), e3.prototype.toString = function(t4) {
            return void 0 === t4 && (t4 = false), t4 ? A(this, true) : (this._formatted || (this._formatted = A(this, false)), this._formatted);
          }, e3.prototype.toJSON = function() {
            var t4 = { $mid: 1 };
            return this._fsPath && (t4.fsPath = this._fsPath, t4._sep = g), this._formatted && (t4.external = this._formatted), this.path && (t4.path = this.path), this.scheme && (t4.scheme = this.scheme), this.authority && (t4.authority = this.authority), this.query && (t4.query = this.query), this.fragment && (t4.fragment = this.fragment), t4;
          }, e3;
        }(d), y = ((o = {})[58] = "%3A", o[47] = "%2F", o[63] = "%3F", o[35] = "%23", o[91] = "%5B", o[93] = "%5D", o[64] = "%40", o[33] = "%21", o[36] = "%24", o[38] = "%26", o[39] = "%27", o[40] = "%28", o[41] = "%29", o[42] = "%2A", o[43] = "%2B", o[44] = "%2C", o[59] = "%3B", o[61] = "%3D", o[32] = "%20", o);
        function m(t3, e3, r3) {
          for (var n3 = void 0, o2 = -1, i2 = 0; i2 < t3.length; i2++) {
            var a2 = t3.charCodeAt(i2);
            if (a2 >= 97 && a2 <= 122 || a2 >= 65 && a2 <= 90 || a2 >= 48 && a2 <= 57 || 45 === a2 || 46 === a2 || 95 === a2 || 126 === a2 || e3 && 47 === a2 || r3 && 91 === a2 || r3 && 93 === a2 || r3 && 58 === a2)
              -1 !== o2 && (n3 += encodeURIComponent(t3.substring(o2, i2)), o2 = -1), void 0 !== n3 && (n3 += t3.charAt(i2));
            else {
              void 0 === n3 && (n3 = t3.substr(0, i2));
              var s2 = y[a2];
              void 0 !== s2 ? (-1 !== o2 && (n3 += encodeURIComponent(t3.substring(o2, i2)), o2 = -1), n3 += s2) : -1 === o2 && (o2 = i2);
            }
          }
          return -1 !== o2 && (n3 += encodeURIComponent(t3.substring(o2))), void 0 !== n3 ? n3 : t3;
        }
        function b(t3) {
          for (var e3 = void 0, r3 = 0; r3 < t3.length; r3++) {
            var n3 = t3.charCodeAt(r3);
            35 === n3 || 63 === n3 ? (void 0 === e3 && (e3 = t3.substr(0, r3)), e3 += y[n3]) : void 0 !== e3 && (e3 += t3[r3]);
          }
          return void 0 !== e3 ? e3 : t3;
        }
        function C(t3, e3) {
          var r3;
          return r3 = t3.authority && t3.path.length > 1 && "file" === t3.scheme ? "//".concat(t3.authority).concat(t3.path) : 47 === t3.path.charCodeAt(0) && (t3.path.charCodeAt(1) >= 65 && t3.path.charCodeAt(1) <= 90 || t3.path.charCodeAt(1) >= 97 && t3.path.charCodeAt(1) <= 122) && 58 === t3.path.charCodeAt(2) ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, a.isWindows && (r3 = r3.replace(/\//g, "\\")), r3;
        }
        function A(t3, e3) {
          var r3 = e3 ? b : m, n3 = "", o2 = t3.scheme, i2 = t3.authority, a2 = t3.path, s2 = t3.query, h2 = t3.fragment;
          if (o2 && (n3 += o2, n3 += ":"), (i2 || "file" === o2) && (n3 += l, n3 += l), i2) {
            var c2 = i2.indexOf("@");
            if (-1 !== c2) {
              var f2 = i2.substr(0, c2);
              i2 = i2.substr(c2 + 1), -1 === (c2 = f2.lastIndexOf(":")) ? n3 += r3(f2, false, false) : (n3 += r3(f2.substr(0, c2), false, false), n3 += ":", n3 += r3(f2.substr(c2 + 1), false, true)), n3 += "@";
            }
            -1 === (c2 = (i2 = i2.toLowerCase()).lastIndexOf(":")) ? n3 += r3(i2, false, true) : (n3 += r3(i2.substr(0, c2), false, true), n3 += i2.substr(c2));
          }
          if (a2) {
            if (a2.length >= 3 && 47 === a2.charCodeAt(0) && 58 === a2.charCodeAt(2))
              (u2 = a2.charCodeAt(1)) >= 65 && u2 <= 90 && (a2 = "/".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(3)));
            else if (a2.length >= 2 && 58 === a2.charCodeAt(1)) {
              var u2;
              (u2 = a2.charCodeAt(0)) >= 65 && u2 <= 90 && (a2 = "".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(2)));
            }
            n3 += r3(a2, true, false);
          }
          return s2 && (n3 += "?", n3 += r3(s2, false, false)), h2 && (n3 += "#", n3 += e3 ? h2 : m(h2, false, false)), n3;
        }
        function w(t3) {
          try {
            return decodeURIComponent(t3);
          } catch (e3) {
            return t3.length > 3 ? t3.substr(0, 3) + w(t3.substr(3)) : t3;
          }
        }
        e2.uriToFsPath = C;
        var _ = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
        function x(t3) {
          return t3.match(_) ? t3.replace(_, function(t4) {
            return w(t4);
          }) : t3;
        }
      }, 679: function(t2, e2, r2) {
        var n2 = this && this.__spreadArray || function(t3, e3, r3) {
          if (r3 || 2 === arguments.length)
            for (var n3, o2 = 0, i2 = e3.length; o2 < i2; o2++)
              !n3 && o2 in e3 || (n3 || (n3 = Array.prototype.slice.call(e3, 0, o2)), n3[o2] = e3[o2]);
          return t3.concat(n3 || Array.prototype.slice.call(e3));
        };
        Object.defineProperty(e2, "__esModule", { value: true }), e2.Utils = void 0;
        var o, i = r2(470), a = i.posix || i, s = "/";
        (o = e2.Utils || (e2.Utils = {})).joinPath = function(t3) {
          for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
            e3[r3 - 1] = arguments[r3];
          return t3.with({ path: a.join.apply(a, n2([t3.path], e3, false)) });
        }, o.resolvePath = function(t3) {
          for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
            e3[r3 - 1] = arguments[r3];
          var o2 = t3.path, i2 = false;
          o2[0] !== s && (o2 = s + o2, i2 = true);
          var h = a.resolve.apply(a, n2([o2], e3, false));
          return i2 && h[0] === s && !t3.authority && (h = h.substring(1)), t3.with({ path: h });
        }, o.dirname = function(t3) {
          if (0 === t3.path.length || t3.path === s)
            return t3;
          var e3 = a.dirname(t3.path);
          return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t3.with({ path: e3 });
        }, o.basename = function(t3) {
          return a.basename(t3.path);
        }, o.extname = function(t3) {
          return a.extname(t3.path);
        };
      } }, e = {};
      function r(n2) {
        var o = e[n2];
        if (void 0 !== o)
          return o.exports;
        var i = e[n2] = { exports: {} };
        return t[n2].call(i.exports, i, i.exports, r), i.exports;
      }
      var n = {};
      return (() => {
        var t2 = n;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Utils = t2.URI = void 0;
        var e2 = r(796);
        Object.defineProperty(t2, "URI", { enumerable: true, get: function() {
          return e2.URI;
        } });
        var o = r(679);
        Object.defineProperty(t2, "Utils", { enumerable: true, get: function() {
          return o.Utils;
        } });
      })(), n;
    })());
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports2.thenable = thenable;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable = exports2.Disposable || (exports2.Disposable = {}));
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders() {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
          while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column:
              while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                  case CR:
                    switch (state) {
                      case 0:
                        state = 1;
                        break;
                      case 2:
                        state = 3;
                        break;
                      default:
                        state = 0;
                    }
                    break;
                  case LF:
                    switch (state) {
                      case 1:
                        state = 2;
                        break;
                      case 3:
                        state = 4;
                        offset++;
                        break row;
                      default:
                        state = 0;
                    }
                    break;
                  default:
                    state = 0;
                }
                offset++;
              }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ral_1 = require_ral();
    var util_1 = require("util");
    var disposable_1 = require_disposable();
    var messageBuffer_1 = require_messageBuffer();
    var MessageBuffer = class extends messageBuffer_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return disposable_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        ral_1.default.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
    var ResponseError = class extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message = exports2.Message || (exports2.Message = {}));
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch = exports2.Touch || (exports2.Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event = exports2.Event || (exports2.Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken = exports2.CancellationToken || (exports2.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader = exports2.MessageReader || (exports2.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            const headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            const contentLength = headers.get("Content-Length");
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            const length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          const body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === void 0) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          let p;
          if (this.options.contentDecoder !== void 0) {
            p = this.options.contentDecoder.decode(body);
          } else {
            p = Promise.resolve(body);
          }
          p.then((value) => {
            this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
              this.callback(msg);
            }, (error) => {
              this.fireError(error);
            });
          }, (error) => {
            this.fireError(error);
          });
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter = exports2.MessageWriter || (exports2.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken = exports2.ProgressToken || (exports2.ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues = exports2.TraceValues || (exports2.TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
    var ConnectionError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.createCancellationTokenSource);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy = exports2.CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy = exports2.CancellationSenderStrategy || (exports2.CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy = exports2.CancellationStrategy || (exports2.CancellationStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions = exports2.ConnectionOptions || (exports2.ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
          } else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
          } else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch(() => logger.error(`Sending notification failed.`));
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const result = new Promise((resolve, reject) => {
            const requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage).catch(() => logger.error(`Sending request failed.`));
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises.set(id, responsePromise);
            }
          });
          return result;
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var api_1 = require_api();
    var path2 = require("path");
    var os2 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    __exportStar(require_api(), exports2);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process3) {
        super();
        this.process = process3;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process3) {
        super();
        this.process = process3;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readble, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readble), encoding);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path2.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path2.join(os2.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length >= limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.2/node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-types@3.17.2/node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-types@3.17.2/node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0)
          module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = exports3.EOL = exports3.WorkspaceFolder = exports3.InlayHint = exports3.InlayHintLabelPart = exports3.InlayHintKind = exports3.InlineValueContext = exports3.InlineValueEvaluatableExpression = exports3.InlineValueVariableLookup = exports3.InlineValueText = exports3.SemanticTokens = exports3.SemanticTokenModifiers = exports3.SemanticTokenTypes = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionTriggerKind = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.WorkspaceSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.CompletionItemLabelDetails = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = exports3.URI = exports3.DocumentUri = void 0;
      var DocumentUri;
      (function(DocumentUri2) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri = exports3.DocumentUri || (exports3.DocumentUri = {}));
      var URI2;
      (function(URI3) {
        function is(value) {
          return typeof value === "string";
        }
        URI3.is = is;
      })(URI2 = exports3.URI || (exports3.URI = {}));
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
        }
        integer2.is = is;
      })(integer = exports3.integer || (exports3.integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger = exports3.uinteger || (exports3.uinteger = {}));
      var Position;
      (function(Position2) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position2.is = is;
      })(Position = exports3.Position || (exports3.Position = {}));
      var Range;
      (function(Range2) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
          } else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range2.is = is;
      })(Range = exports3.Range || (exports3.Range = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location = exports3.Location || (exports3.Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink = exports3.LocationLink || (exports3.LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color = exports3.Color || (exports3.Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation = exports3.ColorInformation || (exports3.ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation = exports3.ColorPresentation || (exports3.ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind = exports3.FoldingRangeKind || (exports3.FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange = exports3.FoldingRange || (exports3.FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation = exports3.DiagnosticRelatedInformation || (exports3.DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity;
      (function(DiagnosticSeverity2) {
        DiagnosticSeverity2.Error = 1;
        DiagnosticSeverity2.Warning = 2;
        DiagnosticSeverity2.Information = 3;
        DiagnosticSeverity2.Hint = 4;
      })(DiagnosticSeverity = exports3.DiagnosticSeverity || (exports3.DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag = exports3.DiagnosticTag || (exports3.DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription = exports3.CodeDescription || (exports3.CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic = exports3.Diagnostic || (exports3.Diagnostic = {}));
      var Command2;
      (function(Command3) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command3.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command3.is = is;
      })(Command2 = exports3.Command || (exports3.Command = {}));
      var TextEdit;
      (function(TextEdit2) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit2.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit2.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
        }
        TextEdit2.is = is;
      })(TextEdit = exports3.TextEdit || (exports3.TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation = exports3.ChangeAnnotation || (exports3.ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier = exports3.ChangeAnnotationIdentifier || (exports3.ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit = exports3.AnnotatedTextEdit || (exports3.AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit = exports3.TextDocumentEdit || (exports3.TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile = exports3.CreateFile || (exports3.CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile = exports3.RenameFile || (exports3.RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile = exports3.DeleteFile || (exports3.DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit = exports3.WorkspaceEdit || (exports3.WorkspaceEdit = {}));
      var TextEditChangeImpl = (
        /** @class */
        function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.replace(range, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.del(range);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        }()
      );
      var ChangeAnnotations = (
        /** @class */
        function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        }()
      );
      var WorkspaceChange = (
        /** @class */
        function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            /**
             * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        }()
      );
      exports3.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier = exports3.TextDocumentIdentifier || (exports3.TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier || (exports3.VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier = exports3.OptionalVersionedTextDocumentIdentifier || (exports3.OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem = exports3.TextDocumentItem || (exports3.TextDocumentItem = {}));
      var MarkupKind;
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind = exports3.MarkupKind || (exports3.MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent = exports3.MarkupContent || (exports3.MarkupContent = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind = exports3.CompletionItemKind || (exports3.CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat = exports3.InsertTextFormat || (exports3.InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag = exports3.CompletionItemTag || (exports3.CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit = exports3.InsertReplaceEdit || (exports3.InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode = exports3.InsertTextMode || (exports3.InsertTextMode = {}));
      var CompletionItemLabelDetails;
      (function(CompletionItemLabelDetails2) {
        function is(value) {
          var candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails = exports3.CompletionItemLabelDetails || (exports3.CompletionItemLabelDetails = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem = exports3.CompletionItem || (exports3.CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList = exports3.CompletionList || (exports3.CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString = exports3.MarkedString || (exports3.MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
        }
        Hover2.is = is;
      })(Hover = exports3.Hover || (exports3.Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation = exports3.ParameterInformation || (exports3.ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation = exports3.SignatureInformation || (exports3.SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind = exports3.DocumentHighlightKind || (exports3.DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight = exports3.DocumentHighlight || (exports3.DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind = exports3.SymbolKind || (exports3.SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag = exports3.SymbolTag || (exports3.SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation = exports3.SymbolInformation || (exports3.SymbolInformation = {}));
      var WorkspaceSymbol;
      (function(WorkspaceSymbol2) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol2.create = create;
      })(WorkspaceSymbol = exports3.WorkspaceSymbol || (exports3.WorkspaceSymbol = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol = exports3.DocumentSymbol || (exports3.DocumentSymbol = {}));
      var CodeActionKind;
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind = exports3.CodeActionKind || (exports3.CodeActionKind = {}));
      var CodeActionTriggerKind;
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind = exports3.CodeActionTriggerKind || (exports3.CodeActionTriggerKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext = exports3.CodeActionContext || (exports3.CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command2.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command2.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction = exports3.CodeAction || (exports3.CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command2.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens = exports3.CodeLens || (exports3.CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions = exports3.FormattingOptions || (exports3.FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink = exports3.DocumentLink || (exports3.DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange = exports3.SelectionRange || (exports3.SelectionRange = {}));
      var SemanticTokenTypes;
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes = exports3.SemanticTokenTypes || (exports3.SemanticTokenTypes = {}));
      var SemanticTokenModifiers;
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers = exports3.SemanticTokenModifiers || (exports3.SemanticTokenModifiers = {}));
      var SemanticTokens;
      (function(SemanticTokens2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens = exports3.SemanticTokens || (exports3.SemanticTokens = {}));
      var InlineValueText;
      (function(InlineValueText2) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText = exports3.InlineValueText || (exports3.InlineValueText = {}));
      var InlineValueVariableLookup;
      (function(InlineValueVariableLookup2) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup = exports3.InlineValueVariableLookup || (exports3.InlineValueVariableLookup = {}));
      var InlineValueEvaluatableExpression;
      (function(InlineValueEvaluatableExpression2) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression = exports3.InlineValueEvaluatableExpression || (exports3.InlineValueEvaluatableExpression = {}));
      var InlineValueContext;
      (function(InlineValueContext2) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext = exports3.InlineValueContext || (exports3.InlineValueContext = {}));
      var InlayHintKind;
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind = exports3.InlayHintKind || (exports3.InlayHintKind = {}));
      var InlayHintLabelPart;
      (function(InlayHintLabelPart2) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command2.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart = exports3.InlayHintLabelPart || (exports3.InlayHintLabelPart = {}));
      var InlayHint;
      (function(InlayHint2) {
        function create(position, label, kind) {
          var result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint = exports3.InlayHint || (exports3.InlayHint = {}));
      var WorkspaceFolder;
      (function(WorkspaceFolder2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && URI2.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder2.is = is;
      })(WorkspaceFolder = exports3.WorkspaceFolder || (exports3.WorkspaceFolder = {}));
      exports3.EOL = ["\n", "\r\n", "\r"];
      var TextDocument;
      (function(TextDocument2) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument2.is = is;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument2.applyEdits = applyEdits;
        function mergeSort(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort(left, compare);
          mergeSort(right, compare);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument = exports3.TextDocument || (exports3.TextDocument = {}));
      var FullTextDocument = (
        /** @class */
        function() {
          function FullTextDocument2(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument2.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument2.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument2.prototype.update = function(event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = void 0;
          };
          FullTextDocument2.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument2.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument2.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument2;
        }()
      );
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is2.numberRange = numberRange;
        function integer2(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection = exports2.MessageDirection || (exports2.MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat = exports2.TokenFormat || (exports2.TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType = exports2.SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest = exports2.SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest = exports2.SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest = exports2.ShowDocumentRequest || (exports2.ShowDocumentRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest = exports2.LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind = exports2.FileOperationPatternKind || (exports2.FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest = exports2.WillCreateFilesRequest || (exports2.WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification = exports2.DidCreateFilesNotification || (exports2.DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest = exports2.WillRenameFilesRequest || (exports2.WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification = exports2.DidRenameFilesNotification || (exports2.DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification = exports2.DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest = exports2.WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel = exports2.UniquenessLevel || (exports2.UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind = exports2.MonikerKind || (exports2.MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest = exports2.MonikerRequest || (exports2.MonikerRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest = exports2.TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest = exports2.TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest = exports2.TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest = exports2.InlineValueRequest || (exports2.InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest = exports2.InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest = exports2.InlayHintRequest || (exports2.InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest = exports2.InlayHintResolveRequest || (exports2.InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest = exports2.InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData = exports2.DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind = exports2.DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest = exports2.DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest = exports2.WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest = exports2.DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind = exports2.NotebookCellKind || (exports2.NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary = exports2.ExecutionSummary || (exports2.ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell = exports2.NotebookCell || (exports2.NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument = exports2.NotebookDocument || (exports2.NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType = exports2.NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification = exports2.DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange = exports2.NotebookCellArrayChange || (exports2.NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification = exports2.DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter = exports2.TextDocumentFilter || (exports2.TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter = exports2.NotebookDocumentFilter || (exports2.NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter = exports2.NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind = exports2.PositionEncodingKind || (exports2.PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes = exports2.InitializeErrorCodes || (exports2.InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification = exports2.ExitNotification || (exports2.ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
    })(DidChangeConfigurationNotification = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
    })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent = exports2.TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType = exports2.FileChangeType || (exports2.FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern = exports2.RelativePattern || (exports2.RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind = exports2.WatchKind || (exports2.WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest = exports2.HoverRequest || (exports2.HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest = exports2.CodeActionResolveRequest || (exports2.CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest = exports2.WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest = exports2.CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior = exports2.PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest = exports2.RenameRequest || (exports2.RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar(require_main2(), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes = exports2.LSPErrorCodes || (exports2.LSPErrorCodes = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports2);
    __exportStar(require_api2(), exports2);
    function createProtocolConnection(input, output, logger, options) {
      return (0, node_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class extends ValueUUID {
      constructor() {
        super([
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          "4",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._oneOf(V4UUID._timeHighBits),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex()
        ].join(""));
      }
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports2.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports2.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports2.parse = parse;
    function generateUuid() {
      return v4().asHex();
    }
    exports2.generateUuid = generateUuid;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection, token) {
        super(connection, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection, token);
    }
    exports2.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          if (capabilities?.window?.workDoneProgress === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = (0, uuid_1.generateUuid)();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports2.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection, token);
    }
    exports2.attachPartialResult = attachPartialResult;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            if (Array.isArray(result)) {
              return Array.isArray(arg) ? result : result[0];
            } else {
              return Array.isArray(arg) ? [] : null;
            }
          });
        }
      };
    };
    exports2.ConfigurationFeature = ConfigurationFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        fillServerCapabilities(capabilities) {
          super.fillServerCapabilities(capabilities);
          const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
          this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._notificationIsAutoRegistered && !this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onDelta: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onRange: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensDiff = class {
      constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
      }
      computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
            originalEndIndex++;
            modifiedEndIndex++;
          }
          const deleteCount = originalEndIndex - startIndex + 1;
          const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
          if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
            return [
              { start: startIndex, deleteCount: deleteCount - 1 }
            ];
          } else {
            return [
              { start: startIndex, deleteCount, data: newData }
            ];
          }
        } else if (startIndex < modifiedLength) {
          return [
            { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
          ];
        } else if (startIndex < originalLength) {
          return [
            { start: startIndex, deleteCount: originalLength - startIndex }
          ];
        } else {
          return [];
        }
      }
    };
    exports2.SemanticTokensDiff = SemanticTokensDiff;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          return {
            resultId: this.id,
            edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
          };
        } else {
          return this.build();
        }
      }
    };
    exports2.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports2.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports2.FileOperationsFeature = FileOperationsFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TypeHierarchyFeature = (Base) => {
      return class extends Base {
        get typeHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onSupertypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onSubtypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineValueFeature = (Base) => {
      return class extends Base {
        get inlineValue() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineValueFeature = InlineValueFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlayHintFeature = (Base) => {
      return class extends Base {
        get inlayHint() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            },
            resolve: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                return handler(params, cancel);
              });
            }
          };
        }
      };
    };
    exports2.InlayHintFeature = InlayHintFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var DiagnosticFeature = (Base) => {
      return class extends Base {
        get diagnostics() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
              });
            },
            onWorkspace: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
              });
            }
          };
        }
      };
    };
    exports2.DiagnosticFeature = DiagnosticFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/textDocuments.js
var require_textDocuments = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TextDocuments = class {
      /**
       * Create a new text document manager.
       */
      constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened.
       */
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened or the content changes.
       */
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * will be saved.
       */
      get onWillSave() {
        return this._onWillSave.event;
      }
      /**
       * Sets a handler that will be called if a participant wants to provide
       * edits during a text document save.
       */
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been saved.
       */
      get onDidSave() {
        return this._onDidSave.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been closed.
       */
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Returns the document for the given URI. Returns undefined if
       * the document is not managed by this instance.
       *
       * @param uri The text document's URI to retrieve.
       * @return the text document or `undefined`.
       */
      get(uri) {
        return this._syncedDocuments.get(uri);
      }
      /**
       * Returns all text documents managed by this instance.
       *
       * @return all text documents.
       */
      all() {
        return Array.from(this._syncedDocuments.values());
      }
      /**
       * Returns the URIs of all text documents managed by this instance.
       *
       * @return the URI's of all text documents.
       */
      keys() {
        return Array.from(this._syncedDocuments.keys());
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the text documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
       * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
       *
       * Use the corresponding events on the TextDocuments instance instead.
       *
       * @param connection The connection to listen on.
       */
      listen(connection) {
        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection.onDidOpenTextDocument((event) => {
          const td = event.textDocument;
          const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._syncedDocuments.set(td.uri, document);
          const toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection.onDidChangeTextDocument((event) => {
          const td = event.textDocument;
          const changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          const { version } = td;
          if (version === null || version === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          let syncedDocument = this._syncedDocuments.get(td.uri);
          if (syncedDocument !== void 0) {
            syncedDocument = this._configuration.update(syncedDocument, changes, version);
            this._syncedDocuments.set(td.uri, syncedDocument);
            this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection.onDidCloseTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._syncedDocuments.delete(event.textDocument.uri);
            this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection.onWillSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
          }
        }));
        disposables.push(connection.onWillSaveTextDocumentWaitUntil((event, token) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
          } else {
            return [];
          }
        }));
        disposables.push(connection.onDidSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
    };
    exports2.TextDocuments = TextDocuments;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/notebook.js
var require_notebook = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var textDocuments_1 = require_textDocuments();
    var NotebookSyncFeature = (Base) => {
      return class extends Base {
        get synchronization() {
          return {
            onDidOpenNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidChangeNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidSaveNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidCloseNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            }
          };
        }
      };
    };
    exports2.NotebookSyncFeature = NotebookSyncFeature;
    var CellTextDocumentConnection = class {
      onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.openHandler = void 0;
        });
      }
      openTextDocument(params) {
        this.openHandler && this.openHandler(params);
      }
      onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.changeHandler = handler;
        });
      }
      changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
      }
      onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.closeHandler = void 0;
        });
      }
      closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
      }
      onWillSaveTextDocument() {
        return CellTextDocumentConnection.NULL_DISPOSE;
      }
      onWillSaveTextDocumentWaitUntil() {
        return CellTextDocumentConnection.NULL_DISPOSE;
      }
      onDidSaveTextDocument() {
        return CellTextDocumentConnection.NULL_DISPOSE;
      }
    };
    CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
    } });
    var NotebookDocuments = class {
      constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
          this._cellTextDocuments = configurationOrTextDocuments;
        } else {
          this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = /* @__PURE__ */ new Map();
        this.notebookCellMap = /* @__PURE__ */ new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
      }
      get cellTextDocuments() {
        return this._cellTextDocuments;
      }
      getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
      }
      getNotebookDocument(uri) {
        return this.notebookDocuments.get(uri);
      }
      getNotebookCell(uri) {
        const value = this.notebookCellMap.get(uri);
        return value && value[0];
      }
      findNotebookDocumentForCell(cell) {
        const key = typeof cell === "string" ? cell : cell.document;
        const value = this.notebookCellMap.get(key);
        return value && value[1];
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidChange() {
        return this._onDidChange.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the notebook documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
       *  and `onDidCloseNotebookDocument`.
       *
       * @param connection The connection to listen on.
       */
      listen(connection) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
          this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
          }
          this.updateCellMap(params.notebookDocument);
          this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          notebookDocument.version = params.notebookDocument.version;
          const oldMetadata = notebookDocument.metadata;
          let metadataChanged = false;
          const change = params.change;
          if (change.metadata !== void 0) {
            metadataChanged = true;
            notebookDocument.metadata = change.metadata;
          }
          const opened = [];
          const closed = [];
          const data = [];
          const text = [];
          if (change.cells !== void 0) {
            const changedCells = change.cells;
            if (changedCells.structure !== void 0) {
              const array = changedCells.structure.array;
              notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
              if (changedCells.structure.didOpen !== void 0) {
                for (const open of changedCells.structure.didOpen) {
                  cellTextDocumentConnection.openTextDocument({ textDocument: open });
                  opened.push(open.uri);
                }
              }
              if (changedCells.structure.didClose) {
                for (const close of changedCells.structure.didClose) {
                  cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                  closed.push(close.uri);
                }
              }
            }
            if (changedCells.data !== void 0) {
              const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
              for (let i = 0; i <= notebookDocument.cells.length; i++) {
                const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                if (change2 !== void 0) {
                  const old = notebookDocument.cells.splice(i, 1, change2);
                  data.push({ old: old[0], new: change2 });
                  cellUpdates.delete(change2.document);
                  if (cellUpdates.size === 0) {
                    break;
                  }
                }
              }
            }
            if (changedCells.textContent !== void 0) {
              for (const cellTextDocument of changedCells.textContent) {
                cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                text.push(cellTextDocument.document.uri);
              }
            }
          }
          this.updateCellMap(notebookDocument);
          const changeEvent = { notebookDocument };
          if (metadataChanged) {
            changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
          }
          const added = [];
          for (const open of opened) {
            added.push(this.getNotebookCell(open));
          }
          const removed = [];
          for (const close of closed) {
            removed.push(this.getNotebookCell(close));
          }
          const textContent = [];
          for (const change2 of text) {
            textContent.push(this.getNotebookCell(change2));
          }
          if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
            changeEvent.cells = { added, removed, changed: { data, textContent } };
          }
          if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
            this._onDidChange.fire(changeEvent);
          }
        }));
        disposables.push(connection.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidClose.fire(notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
          }
          this.notebookDocuments.delete(params.notebookDocument.uri);
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.delete(cell.document);
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
      updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
          this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
      }
    };
    exports2.NotebookDocuments = NotebookDocuments;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.MonikerRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.MonikerFeature = MonikerFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolder_1 = require_workspaceFolder();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var inlayHint_1 = require_inlayHint();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var moniker_1 = require_moniker();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Add a message to the tracker.
       *
       * @param message The message to add.
       */
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      /**
       * Send all tracked messages to the connection's window.
       *
       * @param connection The connection established between client and server.
       */
      sendErrors(connection) {
        Object.keys(this._messages).forEach((message) => {
          connection.window.showErrorMessage(message);
        });
      }
    };
    exports2.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection) {
        this._rawConnection = connection;
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      send(type, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
            (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
          });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration = exports2.BulkRegistration || (exports2.BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration = exports2.BulkUnregistration || (exports2.BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection) {
        this._connection = connection;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method).catch(() => {
              this.connection.console.info(`Un-registering capability with id ${id} failed.`);
            });
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        }).catch(() => {
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
          this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = (0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl))))))));
    var _NotebooksImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._NotebooksImpl = _NotebooksImpl;
    var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineNotebooksFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineNotebooksFeatures = combineNotebooksFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
      };
      return result;
    }
    exports2.combineFeatures = combineFeatures;
    function createConnection(connectionFactory, watchDog, factories) {
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection = connectionFactory(logger);
      logger.rawAttach(connection);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is.thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(type, handler),
        sendNotification: (type, param) => {
          const method = Is.string(type) ? type : type.method;
          if (arguments.length === 1) {
            return connection.sendNotification(method);
          } else {
            return connection.sendNotification(method, param);
          }
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        onInitialize: (handler) => {
          initializeHandler = handler;
          return {
            dispose: () => {
              initializeHandler = void 0;
            }
          };
        },
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
          shutdownHandler = handler;
          return {
            dispose: () => {
              shutdownHandler = void 0;
            }
          };
        },
        onExit: (handler) => {
          exitHandler = handler;
          return {
            dispose: () => {
              exitHandler = void 0;
            }
          };
        },
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        get notebooks() {
          return notebooks;
        },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        dispose: () => connection.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports2.createConnection = createConnection;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/node/files.js
var require_files = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/node/files.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveModulePath = exports2.FileSystem = exports2.resolveGlobalYarnPath = exports2.resolveGlobalNodePath = exports2.resolve = exports2.uriToFilePath = void 0;
    var url = require("url");
    var path2 = require("path");
    var fs2 = require("fs");
    var child_process_1 = require("child_process");
    function uriToFilePath(uri) {
      let parsed = url.parse(uri);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        if (first.length === 0 && second.length > 1 && second[1] === ":") {
          segments.shift();
        }
      }
      return path2.normalize(segments.join("/"));
    }
    exports2.uriToFilePath = uriToFilePath;
    function isWindows() {
      return process.platform === "win32";
    }
    function resolve(moduleName, nodePath, cwd, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve2, reject) => {
        let env2 = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env2).forEach((key) => newEnv[key] = env2[key]);
        if (nodePath && fs2.existsSync(nodePath)) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path2.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ELECTRON_RUN_AS_NODE"] = "1";
        try {
          let cp = (0, child_process_1.fork)("", [], {
            cwd,
            env: newEnv,
            execArgv: ["-e", app]
          });
          if (cp.pid === void 0) {
            reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
            return;
          }
          cp.on("error", (error) => {
            reject(error);
          });
          cp.on("message", (message2) => {
            if (message2.c === "r") {
              cp.send({ c: "e" });
              if (message2.s) {
                resolve2(message2.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message = {
            c: "rs",
            a: moduleName
          };
          cp.send(message);
        } catch (error) {
          reject(error);
        }
      });
    }
    exports2.resolve = resolve;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = "npm";
      const env2 = /* @__PURE__ */ Object.create(null);
      Object.keys(process.env).forEach((key) => env2[key] = process.env[key]);
      env2["NO_UPDATE_NOTIFIER"] = "true";
      const options = {
        encoding: "utf8",
        env: env2
      };
      if (isWindows()) {
        npmCommand = "npm.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let stdout = (0, child_process_1.spawnSync)(npmCommand, ["config", "get", "prefix"], options).stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'npm config get prefix' didn't return a value.`);
          }
          return void 0;
        }
        let prefix = stdout.trim();
        if (tracer) {
          tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
          if (isWindows()) {
            return path2.join(prefix, "node_modules");
          } else {
            return path2.join(prefix, "lib", "node_modules");
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = "yarn";
      let options = {
        encoding: "utf8"
      };
      if (isWindows()) {
        yarnCommand = "yarn.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let results = (0, child_process_1.spawnSync)(yarnCommand, ["global", "dir", "--json"], options);
        let stdout = results.stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'yarn global dir' didn't return a value.`);
            if (results.stderr) {
              tracer(results.stderr);
            }
          }
          return void 0;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
          try {
            let yarn = JSON.parse(line);
            if (yarn.type === "log") {
              return path2.join(yarn.data, "node_modules");
            }
          } catch (e) {
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs2.existsSync(__filename.toUpperCase()) || !fs2.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent, child) {
        if (isCaseSensitive()) {
          return path2.normalize(child).indexOf(path2.normalize(parent)) === 0;
        } else {
          return path2.normalize(child).toLowerCase().indexOf(path2.normalize(parent).toLowerCase()) === 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem = exports2.FileSystem || (exports2.FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path2.isAbsolute(nodePath)) {
          nodePath = path2.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
          if (FileSystem.isParent(nodePath, value)) {
            return value;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports2.resolveModulePath = resolveModulePath;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.2/node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
      return semanticTokens_1.SemanticTokensBuilder;
    } });
    __exportStar(require_main3(), exports2);
    var textDocuments_1 = require_textDocuments();
    Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
      return textDocuments_1.TextDocuments;
    } });
    var notebook_1 = require_notebook();
    Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
      return notebook_1.NotebookDocuments;
    } });
    __exportStar(require_server(), exports2);
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      ProposedFeatures2.all = {
        __brand: "features"
      };
    })(ProposedFeatures = exports2.ProposedFeatures || (exports2.ProposedFeatures = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/node/main.js
var require_main4 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.Files = void 0;
    var Is = require_is();
    var server_1 = require_server();
    var fm = require_files();
    var node_1 = require_node2();
    __exportStar(require_node2(), exports2);
    __exportStar(require_api3(), exports2);
    var Files;
    (function(Files2) {
      Files2.uriToFilePath = fm.uriToFilePath;
      Files2.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files2.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files2.resolve = fm.resolve;
      Files2.resolveModulePath = fm.resolveModulePath;
    })(Files = exports2.Files || (exports2.Files = {}));
    var _protocolConnection;
    function endProtocolConnection() {
      if (_protocolConnection === void 0) {
        return;
      }
      try {
        _protocolConnection.end();
      } catch (_err) {
      }
    }
    var _shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value) {
        try {
          let processId = parseInt(value);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                endProtocolConnection();
                process.exit(_shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    var watchDog = {
      initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              process.exit(_shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value) {
        _shutdownReceived = value;
      },
      exit: (code) => {
        endProtocolConnection();
        process.exit(code);
      }
    };
    function createConnection(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        input = arg1;
        output = arg2;
        options = arg3;
      }
      return _createConnection(input, output, options, factories);
    }
    exports2.createConnection = createConnection;
    function _createConnection(input, output, options, factories) {
      if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
          let arg = argv[i];
          if (arg === "--node-ipc") {
            input = new node_1.IPCMessageReader(process);
            output = new node_1.IPCMessageWriter(process);
            break;
          } else if (arg === "--stdio") {
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port = parseInt(argv[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port) {
          let transport = (0, node_1.createServerSocketTransport)(port);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = (0, node_1.createServerPipeTransport)(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
      }
      const connectionFactory = (logger) => {
        const result = (0, node_1.createProtocolConnection)(input, output, logger, options);
        return result;
      };
      return (0, server_1.createConnection)(connectionFactory, watchDog, factories);
    }
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-textdocument@1.0.11/node_modules/vscode-languageserver-textdocument/lib/umd/main.js
var require_main5 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-textdocument@1.0.11/node_modules/vscode-languageserver-textdocument/lib/umd/main.js"(exports2, module2) {
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0)
          module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = void 0;
      var FullTextDocument = (
        /** @class */
        function() {
          function FullTextDocument2(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument2.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument2.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument2.prototype.update = function(changes, version) {
            for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
              var change = changes_1[_i];
              if (FullTextDocument2.isIncremental(change)) {
                var range = getWellformedRange(change.range);
                var startOffset = this.offsetAt(range.start);
                var endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                var startLine = Math.max(range.start.line, 0);
                var endLine = Math.max(range.end.line, 0);
                var lineOffsets = this._lineOffsets;
                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                  for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                    lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                  }
                } else {
                  if (addedLineOffsets.length < 1e4) {
                    lineOffsets.splice.apply(lineOffsets, __spreadArray([startLine + 1, endLine - startLine], addedLineOffsets, false));
                  } else {
                    this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                  }
                }
                var diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                  for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                    lineOffsets[i] = lineOffsets[i] + diff;
                  }
                }
              } else if (FullTextDocument2.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = void 0;
              } else {
                throw new Error("Unknown change event received");
              }
            }
            this._version = version;
          };
          FullTextDocument2.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              this._lineOffsets = computeLineOffsets(this._content, true);
            }
            return this._lineOffsets;
          };
          FullTextDocument2.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return { line: 0, character: offset };
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return { line, character: offset - lineOffsets[line] };
          };
          FullTextDocument2.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument2.isIncremental = function(event) {
            var candidate = event;
            return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
          };
          FullTextDocument2.isFull = function(event) {
            var candidate = event;
            return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
          };
          return FullTextDocument2;
        }()
      );
      var TextDocument;
      (function(TextDocument2) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument2.create = create;
        function update(document, changes, version) {
          if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
          } else {
            throw new Error("TextDocument.update: document must be created by TextDocument.create");
          }
        }
        TextDocument2.update = update;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = 0;
          var spans = [];
          for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {
            var e = sortedEdits_1[_i];
            var startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
              throw new Error("Overlapping edit");
            } else if (startOffset > lastModifiedOffset) {
              spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
              spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
          }
          spans.push(text.substr(lastModifiedOffset));
          return spans.join("");
        }
        TextDocument2.applyEdits = applyEdits;
      })(TextDocument || (exports3.TextDocument = TextDocument = {}));
      function mergeSort(data, compare) {
        if (data.length <= 1) {
          return data;
        }
        var p = data.length / 2 | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          var ret = compare(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
      function computeLineOffsets(text, isAtLineStart, textOffset) {
        if (textOffset === void 0) {
          textOffset = 0;
        }
        var result = isAtLineStart ? [textOffset] : [];
        for (var i = 0; i < text.length; i++) {
          var ch = text.charCodeAt(i);
          if (ch === 13 || ch === 10) {
            if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
              i++;
            }
            result.push(textOffset + i + 1);
          }
        }
        return result;
      }
      function getWellformedRange(range) {
        var start = range.start;
        var end = range.end;
        if (start.line > end.line || start.line === end.line && start.character > end.character) {
          return { start: end, end: start };
        }
        return range;
      }
      function getWellformedEdit(textEdit) {
        var range = getWellformedRange(textEdit.range);
        if (range !== textEdit.range) {
          return { newText: textEdit.newText, range };
        }
        return textEdit;
      }
    });
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/syntax-tree.js
var require_syntax_tree = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/syntax-tree.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isRootCstNode = exports2.isLeafCstNode = exports2.isCompositeCstNode = exports2.AbstractAstReflection = exports2.isLinkingError = exports2.isAstNodeDescription = exports2.isReference = exports2.isAstNode = void 0;
    function isAstNode(obj) {
      return typeof obj === "object" && obj !== null && typeof obj.$type === "string";
    }
    exports2.isAstNode = isAstNode;
    function isReference(obj) {
      return typeof obj === "object" && obj !== null && typeof obj.$refText === "string";
    }
    exports2.isReference = isReference;
    function isAstNodeDescription(obj) {
      return typeof obj === "object" && obj !== null && typeof obj.name === "string" && typeof obj.type === "string" && typeof obj.path === "string";
    }
    exports2.isAstNodeDescription = isAstNodeDescription;
    function isLinkingError(obj) {
      return typeof obj === "object" && obj !== null && isAstNode(obj.container) && isReference(obj.reference) && typeof obj.message === "string";
    }
    exports2.isLinkingError = isLinkingError;
    var AbstractAstReflection = class {
      constructor() {
        this.subtypes = {};
        this.allSubtypes = {};
      }
      isInstance(node, type) {
        return isAstNode(node) && this.isSubtype(node.$type, type);
      }
      isSubtype(subtype, supertype) {
        if (subtype === supertype) {
          return true;
        }
        let nested = this.subtypes[subtype];
        if (!nested) {
          nested = this.subtypes[subtype] = {};
        }
        const existing = nested[supertype];
        if (existing !== void 0) {
          return existing;
        } else {
          const result = this.computeIsSubtype(subtype, supertype);
          nested[supertype] = result;
          return result;
        }
      }
      getAllSubTypes(type) {
        const existing = this.allSubtypes[type];
        if (existing) {
          return existing;
        } else {
          const allTypes = this.getAllTypes();
          const types = [];
          for (const possibleSubType of allTypes) {
            if (this.isSubtype(possibleSubType, type)) {
              types.push(possibleSubType);
            }
          }
          this.allSubtypes[type] = types;
          return types;
        }
      }
    };
    exports2.AbstractAstReflection = AbstractAstReflection;
    function isCompositeCstNode(node) {
      return typeof node === "object" && node !== null && "children" in node;
    }
    exports2.isCompositeCstNode = isCompositeCstNode;
    function isLeafCstNode(node) {
      return typeof node === "object" && node !== null && "tokenType" in node;
    }
    exports2.isLeafCstNode = isLeafCstNode;
    function isRootCstNode(node) {
      return isCompositeCstNode(node) && "fullText" in node;
    }
    exports2.isRootCstNode = isRootCstNode;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/stream.js
var require_stream = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Reduction = exports2.TreeStreamImpl = exports2.stream = exports2.DONE_RESULT = exports2.EMPTY_STREAM = exports2.StreamImpl = void 0;
    var StreamImpl = class {
      constructor(startFn, nextFn) {
        this.startFn = startFn;
        this.nextFn = nextFn;
      }
      iterator() {
        const iterator = {
          state: this.startFn(),
          next: () => this.nextFn(iterator.state),
          [Symbol.iterator]: () => iterator
        };
        return iterator;
      }
      [Symbol.iterator]() {
        return this.iterator();
      }
      isEmpty() {
        const iterator = this.iterator();
        return Boolean(iterator.next().done);
      }
      count() {
        const iterator = this.iterator();
        let count = 0;
        let next = iterator.next();
        while (!next.done) {
          count++;
          next = iterator.next();
        }
        return count;
      }
      toArray() {
        const result = [];
        const iterator = this.iterator();
        let next;
        do {
          next = iterator.next();
          if (next.value !== void 0) {
            result.push(next.value);
          }
        } while (!next.done);
        return result;
      }
      toSet() {
        return new Set(this);
      }
      toMap(keyFn, valueFn) {
        const entryStream = this.map((element) => [
          keyFn ? keyFn(element) : element,
          valueFn ? valueFn(element) : element
        ]);
        return new Map(entryStream);
      }
      toString() {
        return this.join();
      }
      concat(other) {
        const iterator = other[Symbol.iterator]();
        return new StreamImpl(() => ({ first: this.startFn(), firstDone: false }), (state) => {
          let result;
          if (!state.firstDone) {
            do {
              result = this.nextFn(state.first);
              if (!result.done) {
                return result;
              }
            } while (!result.done);
            state.firstDone = true;
          }
          do {
            result = iterator.next();
            if (!result.done) {
              return result;
            }
          } while (!result.done);
          return exports2.DONE_RESULT;
        });
      }
      join(separator = ",") {
        const iterator = this.iterator();
        let value = "";
        let result;
        let addSeparator = false;
        do {
          result = iterator.next();
          if (!result.done) {
            if (addSeparator) {
              value += separator;
            }
            value += toString(result.value);
          }
          addSeparator = true;
        } while (!result.done);
        return value;
      }
      indexOf(searchElement, fromIndex = 0) {
        const iterator = this.iterator();
        let index = 0;
        let next = iterator.next();
        while (!next.done) {
          if (index >= fromIndex && next.value === searchElement) {
            return index;
          }
          next = iterator.next();
          index++;
        }
        return -1;
      }
      every(predicate) {
        const iterator = this.iterator();
        let next = iterator.next();
        while (!next.done) {
          if (!predicate(next.value)) {
            return false;
          }
          next = iterator.next();
        }
        return true;
      }
      some(predicate) {
        const iterator = this.iterator();
        let next = iterator.next();
        while (!next.done) {
          if (predicate(next.value)) {
            return true;
          }
          next = iterator.next();
        }
        return false;
      }
      forEach(callbackfn) {
        const iterator = this.iterator();
        let index = 0;
        let next = iterator.next();
        while (!next.done) {
          callbackfn(next.value, index);
          next = iterator.next();
          index++;
        }
      }
      map(callbackfn) {
        return new StreamImpl(this.startFn, (state) => {
          const { done, value } = this.nextFn(state);
          if (done) {
            return exports2.DONE_RESULT;
          } else {
            return { done: false, value: callbackfn(value) };
          }
        });
      }
      filter(predicate) {
        return new StreamImpl(this.startFn, (state) => {
          let result;
          do {
            result = this.nextFn(state);
            if (!result.done && predicate(result.value)) {
              return result;
            }
          } while (!result.done);
          return exports2.DONE_RESULT;
        });
      }
      nonNullable() {
        return this.filter((e) => e !== void 0 && e !== null);
      }
      reduce(callbackfn, initialValue) {
        const iterator = this.iterator();
        let previousValue = initialValue;
        let next = iterator.next();
        while (!next.done) {
          if (previousValue === void 0) {
            previousValue = next.value;
          } else {
            previousValue = callbackfn(previousValue, next.value);
          }
          next = iterator.next();
        }
        return previousValue;
      }
      reduceRight(callbackfn, initialValue) {
        return this.recursiveReduce(this.iterator(), callbackfn, initialValue);
      }
      recursiveReduce(iterator, callbackfn, initialValue) {
        const next = iterator.next();
        if (next.done) {
          return initialValue;
        }
        const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);
        if (previousValue === void 0) {
          return next.value;
        }
        return callbackfn(previousValue, next.value);
      }
      find(predicate) {
        const iterator = this.iterator();
        let next = iterator.next();
        while (!next.done) {
          if (predicate(next.value)) {
            return next.value;
          }
          next = iterator.next();
        }
        return void 0;
      }
      findIndex(predicate) {
        const iterator = this.iterator();
        let index = 0;
        let next = iterator.next();
        while (!next.done) {
          if (predicate(next.value)) {
            return index;
          }
          next = iterator.next();
          index++;
        }
        return -1;
      }
      includes(searchElement) {
        const iterator = this.iterator();
        let next = iterator.next();
        while (!next.done) {
          if (next.value === searchElement) {
            return true;
          }
          next = iterator.next();
        }
        return false;
      }
      flatMap(callbackfn) {
        return new StreamImpl(() => ({ this: this.startFn() }), (state) => {
          do {
            if (state.iterator) {
              const next = state.iterator.next();
              if (next.done) {
                state.iterator = void 0;
              } else {
                return next;
              }
            }
            const { done, value } = this.nextFn(state.this);
            if (!done) {
              const mapped = callbackfn(value);
              if (isIterable(mapped)) {
                state.iterator = mapped[Symbol.iterator]();
              } else {
                return { done: false, value: mapped };
              }
            }
          } while (state.iterator);
          return exports2.DONE_RESULT;
        });
      }
      flat(depth) {
        if (depth === void 0) {
          depth = 1;
        }
        if (depth <= 0) {
          return this;
        }
        const stream2 = depth > 1 ? this.flat(depth - 1) : this;
        return new StreamImpl(() => ({ this: stream2.startFn() }), (state) => {
          do {
            if (state.iterator) {
              const next = state.iterator.next();
              if (next.done) {
                state.iterator = void 0;
              } else {
                return next;
              }
            }
            const { done, value } = stream2.nextFn(state.this);
            if (!done) {
              if (isIterable(value)) {
                state.iterator = value[Symbol.iterator]();
              } else {
                return { done: false, value };
              }
            }
          } while (state.iterator);
          return exports2.DONE_RESULT;
        });
      }
      head() {
        const iterator = this.iterator();
        const result = iterator.next();
        if (result.done) {
          return void 0;
        }
        return result.value;
      }
      tail(skipCount = 1) {
        return new StreamImpl(() => {
          const state = this.startFn();
          for (let i = 0; i < skipCount; i++) {
            const next = this.nextFn(state);
            if (next.done) {
              return state;
            }
          }
          return state;
        }, this.nextFn);
      }
      limit(maxSize) {
        return new StreamImpl(() => ({ size: 0, state: this.startFn() }), (state) => {
          state.size++;
          if (state.size > maxSize) {
            return exports2.DONE_RESULT;
          }
          return this.nextFn(state.state);
        });
      }
      distinct(by) {
        const set = /* @__PURE__ */ new Set();
        return this.filter((e) => {
          const value = by ? by(e) : e;
          if (set.has(value)) {
            return false;
          } else {
            set.add(value);
            return true;
          }
        });
      }
      exclude(other, key) {
        const otherKeySet = /* @__PURE__ */ new Set();
        for (const item of other) {
          const value = key ? key(item) : item;
          otherKeySet.add(value);
        }
        return this.filter((e) => {
          const ownKey = key ? key(e) : e;
          return !otherKeySet.has(ownKey);
        });
      }
    };
    exports2.StreamImpl = StreamImpl;
    function toString(item) {
      if (typeof item === "string") {
        return item;
      }
      if (typeof item === "undefined") {
        return "undefined";
      }
      if (typeof item.toString === "function") {
        return item.toString();
      }
      return Object.prototype.toString.call(item);
    }
    function isIterable(obj) {
      return !!obj && typeof obj[Symbol.iterator] === "function";
    }
    exports2.EMPTY_STREAM = new StreamImpl(() => void 0, () => exports2.DONE_RESULT);
    exports2.DONE_RESULT = Object.freeze({ done: true, value: void 0 });
    function stream(...collections) {
      if (collections.length === 1) {
        const collection = collections[0];
        if (collection instanceof StreamImpl) {
          return collection;
        }
        if (isIterable(collection)) {
          return new StreamImpl(() => collection[Symbol.iterator](), (iterator) => iterator.next());
        }
        if (typeof collection.length === "number") {
          return new StreamImpl(() => ({ index: 0 }), (state) => {
            if (state.index < collection.length) {
              return { done: false, value: collection[state.index++] };
            } else {
              return exports2.DONE_RESULT;
            }
          });
        }
      }
      if (collections.length > 1) {
        return new StreamImpl(() => ({ collIndex: 0, arrIndex: 0 }), (state) => {
          do {
            if (state.iterator) {
              const next = state.iterator.next();
              if (!next.done) {
                return next;
              }
              state.iterator = void 0;
            }
            if (state.array) {
              if (state.arrIndex < state.array.length) {
                return { done: false, value: state.array[state.arrIndex++] };
              }
              state.array = void 0;
              state.arrIndex = 0;
            }
            if (state.collIndex < collections.length) {
              const collection = collections[state.collIndex++];
              if (isIterable(collection)) {
                state.iterator = collection[Symbol.iterator]();
              } else if (collection && typeof collection.length === "number") {
                state.array = collection;
              }
            }
          } while (state.iterator || state.array || state.collIndex < collections.length);
          return exports2.DONE_RESULT;
        });
      }
      return exports2.EMPTY_STREAM;
    }
    exports2.stream = stream;
    var TreeStreamImpl = class extends StreamImpl {
      constructor(root, children, options) {
        super(() => ({
          iterators: (options === null || options === void 0 ? void 0 : options.includeRoot) ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],
          pruned: false
        }), (state) => {
          if (state.pruned) {
            state.iterators.pop();
            state.pruned = false;
          }
          while (state.iterators.length > 0) {
            const iterator = state.iterators[state.iterators.length - 1];
            const next = iterator.next();
            if (next.done) {
              state.iterators.pop();
            } else {
              state.iterators.push(children(next.value)[Symbol.iterator]());
              return next;
            }
          }
          return exports2.DONE_RESULT;
        });
      }
      iterator() {
        const iterator = {
          state: this.startFn(),
          next: () => this.nextFn(iterator.state),
          prune: () => {
            iterator.state.pruned = true;
          },
          [Symbol.iterator]: () => iterator
        };
        return iterator;
      }
    };
    exports2.TreeStreamImpl = TreeStreamImpl;
    var Reduction;
    (function(Reduction2) {
      function sum(stream2) {
        return stream2.reduce((a, b) => a + b, 0);
      }
      Reduction2.sum = sum;
      function product(stream2) {
        return stream2.reduce((a, b) => a * b, 0);
      }
      Reduction2.product = product;
      function min(stream2) {
        return stream2.reduce((a, b) => Math.min(a, b));
      }
      Reduction2.min = min;
      function max(stream2) {
        return stream2.reduce((a, b) => Math.max(a, b));
      }
      Reduction2.max = max;
    })(Reduction = exports2.Reduction || (exports2.Reduction = {}));
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/cst-util.js
var require_cst_util = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/cst-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getInteriorNodes = exports2.getStartlineNode = exports2.getNextNode = exports2.getPreviousNode = exports2.findLeafNodeAtOffset = exports2.isCommentNode = exports2.findCommentNode = exports2.findDeclarationNodeAtOffset = exports2.DefaultNameRegexp = exports2.inRange = exports2.compareRange = exports2.RangeComparison = exports2.toDocumentSegment = exports2.tokenToRange = exports2.isCstChildNode = exports2.flattenCst = exports2.streamCst = void 0;
    var syntax_tree_1 = require_syntax_tree();
    var stream_1 = require_stream();
    function streamCst(node) {
      return new stream_1.TreeStreamImpl(node, (element) => {
        if ((0, syntax_tree_1.isCompositeCstNode)(element)) {
          return element.children;
        } else {
          return [];
        }
      }, { includeRoot: true });
    }
    exports2.streamCst = streamCst;
    function flattenCst(node) {
      return streamCst(node).filter(syntax_tree_1.isLeafCstNode);
    }
    exports2.flattenCst = flattenCst;
    function isCstChildNode(child, parent) {
      while (child.parent) {
        child = child.parent;
        if (child === parent) {
          return true;
        }
      }
      return false;
    }
    exports2.isCstChildNode = isCstChildNode;
    function tokenToRange(token) {
      return {
        start: {
          character: token.startColumn - 1,
          line: token.startLine - 1
        },
        end: {
          character: token.endColumn,
          line: token.endLine - 1
        }
      };
    }
    exports2.tokenToRange = tokenToRange;
    function toDocumentSegment(node) {
      if (!node) {
        return void 0;
      }
      const { offset, end, range } = node;
      return {
        range,
        offset,
        end,
        length: end - offset
      };
    }
    exports2.toDocumentSegment = toDocumentSegment;
    var RangeComparison;
    (function(RangeComparison2) {
      RangeComparison2[RangeComparison2["Before"] = 0] = "Before";
      RangeComparison2[RangeComparison2["After"] = 1] = "After";
      RangeComparison2[RangeComparison2["OverlapFront"] = 2] = "OverlapFront";
      RangeComparison2[RangeComparison2["OverlapBack"] = 3] = "OverlapBack";
      RangeComparison2[RangeComparison2["Inside"] = 4] = "Inside";
    })(RangeComparison = exports2.RangeComparison || (exports2.RangeComparison = {}));
    function compareRange(range, to) {
      if (range.end.line < to.start.line || range.end.line === to.start.line && range.end.character < range.start.character) {
        return RangeComparison.Before;
      } else if (range.start.line > to.end.line || range.start.line === to.end.line && range.start.character > to.end.character) {
        return RangeComparison.After;
      }
      const startInside = range.start.line > to.start.line || range.start.line === to.start.line && range.start.character >= to.start.character;
      const endInside = range.end.line < to.end.line || range.end.line === to.end.line && range.end.character <= to.end.character;
      if (startInside && endInside) {
        return RangeComparison.Inside;
      } else if (startInside) {
        return RangeComparison.OverlapBack;
      } else {
        return RangeComparison.OverlapFront;
      }
    }
    exports2.compareRange = compareRange;
    function inRange(range, to) {
      const comparison = compareRange(range, to);
      return comparison > RangeComparison.After;
    }
    exports2.inRange = inRange;
    exports2.DefaultNameRegexp = /^[\w\p{L}]$/u;
    function findDeclarationNodeAtOffset(cstNode, offset, nameRegexp = exports2.DefaultNameRegexp) {
      if (cstNode) {
        if (offset > 0) {
          const localOffset = offset - cstNode.offset;
          const textAtOffset = cstNode.text.charAt(localOffset);
          if (!nameRegexp.test(textAtOffset)) {
            offset--;
          }
        }
        return findLeafNodeAtOffset(cstNode, offset);
      }
      return void 0;
    }
    exports2.findDeclarationNodeAtOffset = findDeclarationNodeAtOffset;
    function findCommentNode(cstNode, commentNames) {
      if (cstNode) {
        const previous = getPreviousNode(cstNode, true);
        if (previous && isCommentNode(previous, commentNames)) {
          return previous;
        }
        if ((0, syntax_tree_1.isRootCstNode)(cstNode)) {
          const endIndex = cstNode.children.findIndex((e) => !e.hidden);
          for (let i = endIndex - 1; i >= 0; i--) {
            const child = cstNode.children[i];
            if (isCommentNode(child, commentNames)) {
              return child;
            }
          }
        }
      }
      return void 0;
    }
    exports2.findCommentNode = findCommentNode;
    function isCommentNode(cstNode, commentNames) {
      return (0, syntax_tree_1.isLeafCstNode)(cstNode) && commentNames.includes(cstNode.tokenType.name);
    }
    exports2.isCommentNode = isCommentNode;
    function findLeafNodeAtOffset(node, offset) {
      if ((0, syntax_tree_1.isLeafCstNode)(node)) {
        return node;
      } else if ((0, syntax_tree_1.isCompositeCstNode)(node)) {
        let firstChild = 0;
        let lastChild = node.children.length - 1;
        while (firstChild < lastChild) {
          const middleChild = Math.floor((firstChild + lastChild) / 2);
          const n = node.children[middleChild];
          if (n.offset > offset) {
            lastChild = middleChild - 1;
          } else if (n.end <= offset) {
            firstChild = middleChild + 1;
          } else {
            return findLeafNodeAtOffset(n, offset);
          }
        }
        if (firstChild === lastChild) {
          return findLeafNodeAtOffset(node.children[firstChild], offset);
        }
      }
      return void 0;
    }
    exports2.findLeafNodeAtOffset = findLeafNodeAtOffset;
    function getPreviousNode(node, hidden = true) {
      while (node.parent) {
        const parent = node.parent;
        let index = parent.children.indexOf(node);
        while (index > 0) {
          index--;
          const previous = parent.children[index];
          if (hidden || !previous.hidden) {
            return previous;
          }
        }
        node = parent;
      }
      return void 0;
    }
    exports2.getPreviousNode = getPreviousNode;
    function getNextNode(node, hidden = true) {
      while (node.parent) {
        const parent = node.parent;
        let index = parent.children.indexOf(node);
        const last = parent.children.length - 1;
        while (index < last) {
          index++;
          const next = parent.children[index];
          if (hidden || !next.hidden) {
            return next;
          }
        }
        node = parent;
      }
      return void 0;
    }
    exports2.getNextNode = getNextNode;
    function getStartlineNode(node) {
      if (node.range.start.character === 0) {
        return node;
      }
      const line = node.range.start.line;
      let last = node;
      let index;
      while (node.parent) {
        const parent = node.parent;
        const selfIndex = index !== null && index !== void 0 ? index : parent.children.indexOf(node);
        if (selfIndex === 0) {
          node = parent;
          index = void 0;
        } else {
          index = selfIndex - 1;
          node = parent.children[index];
        }
        if (node.range.start.line !== line) {
          break;
        }
        last = node;
      }
      return last;
    }
    exports2.getStartlineNode = getStartlineNode;
    function getInteriorNodes(start, end) {
      const commonParent = getCommonParent(start, end);
      if (!commonParent) {
        return [];
      }
      return commonParent.parent.children.slice(commonParent.a + 1, commonParent.b);
    }
    exports2.getInteriorNodes = getInteriorNodes;
    function getCommonParent(a, b) {
      const aParents = getParentChain(a);
      const bParents = getParentChain(b);
      let current;
      for (let i = 0; i < aParents.length && i < bParents.length; i++) {
        const aParent = aParents[i];
        const bParent = bParents[i];
        if (aParent.parent === bParent.parent) {
          current = {
            parent: aParent.parent,
            a: aParent.index,
            b: bParent.index
          };
        } else {
          break;
        }
      }
      return current;
    }
    function getParentChain(node) {
      const chain = [];
      while (node.parent) {
        const parent = node.parent;
        const index = parent.children.indexOf(node);
        chain.push({
          parent,
          index
        });
        node = parent;
      }
      return chain.reverse();
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/dependency-injection.js
var require_dependency_injection = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/dependency-injection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.eagerLoad = exports2.inject = void 0;
    function inject(module1, module22, module3, module4) {
      const module5 = [module1, module22, module3, module4].reduce(_merge, {});
      return _inject(module5);
    }
    exports2.inject = inject;
    var isProxy = Symbol("isProxy");
    function eagerLoad(item) {
      if (item && item[isProxy]) {
        for (const value of Object.values(item)) {
          eagerLoad(value);
        }
      }
      return item;
    }
    exports2.eagerLoad = eagerLoad;
    function _inject(module3, injector) {
      const proxy = new Proxy({}, {
        deleteProperty: () => false,
        get: (obj, prop) => _resolve(obj, prop, module3, injector || proxy),
        getOwnPropertyDescriptor: (obj, prop) => (_resolve(obj, prop, module3, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)),
        has: (_, prop) => prop in module3,
        ownKeys: () => [...Reflect.ownKeys(module3), isProxy]
        // used by for..in
      });
      proxy[isProxy] = true;
      return proxy;
    }
    var __requested__ = Symbol();
    function _resolve(obj, prop, module3, injector) {
      if (prop in obj) {
        if (obj[prop] instanceof Error) {
          throw new Error("Construction failure. Please make sure that your dependencies are constructable.", { cause: obj[prop] });
        }
        if (obj[prop] === __requested__) {
          throw new Error('Cycle detected. Please make "' + String(prop) + '" lazy. See https://langium.org/docs/di/cyclic-dependencies');
        }
        return obj[prop];
      } else if (prop in module3) {
        const value = module3[prop];
        obj[prop] = __requested__;
        try {
          obj[prop] = typeof value === "function" ? value(injector) : _inject(value, injector);
        } catch (error) {
          obj[prop] = error instanceof Error ? error : void 0;
          throw error;
        }
        return obj[prop];
      } else {
        return void 0;
      }
    }
    function _merge(target, source) {
      if (source) {
        for (const [key, value2] of Object.entries(source)) {
          if (value2 !== void 0) {
            const value1 = target[key];
            if (value1 !== null && value2 !== null && typeof value1 === "object" && typeof value2 === "object") {
              target[key] = _merge(value1, value2);
            } else {
              target[key] = value2;
            }
          }
        }
      }
      return target;
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/collections.js
var require_collections = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/collections.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiMap = void 0;
    var stream_1 = require_stream();
    var MultiMap = class {
      constructor(elements) {
        this.map = /* @__PURE__ */ new Map();
        if (elements) {
          for (const [key, value] of elements) {
            this.add(key, value);
          }
        }
      }
      /**
       * The total number of values in the multimap.
       */
      get size() {
        return stream_1.Reduction.sum((0, stream_1.stream)(this.map.values()).map((a) => a.length));
      }
      /**
       * Clear all entries in the multimap.
       */
      clear() {
        this.map.clear();
      }
      /**
       * Operates differently depending on whether a `value` is given:
       *  * With a value, this method deletes the specific key / value pair from the multimap.
       *  * Without a value, all values associated with the given key are deleted.
       *
       * @returns `true` if a value existed and has been removed, or `false` if the specified
       *     key / value does not exist.
       */
      delete(key, value) {
        if (value === void 0) {
          return this.map.delete(key);
        } else {
          const values = this.map.get(key);
          if (values) {
            const index = values.indexOf(value);
            if (index >= 0) {
              if (values.length === 1) {
                this.map.delete(key);
              } else {
                values.splice(index, 1);
              }
              return true;
            }
          }
          return false;
        }
      }
      /**
       * Returns an array of all values associated with the given key. If no value exists,
       * an empty array is returned.
       *
       * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a
       * value and `delete` to remove a value from the multimap.
       */
      get(key) {
        var _a;
        return (_a = this.map.get(key)) !== null && _a !== void 0 ? _a : [];
      }
      /**
       * Operates differently depending on whether a `value` is given:
       *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.
       *  * Without a value, this method returns `true` if the given key is present in the multimap.
       */
      has(key, value) {
        if (value === void 0) {
          return this.map.has(key);
        } else {
          const values = this.map.get(key);
          if (values) {
            return values.indexOf(value) >= 0;
          }
          return false;
        }
      }
      /**
       * Add the given key / value pair to the multimap.
       */
      add(key, value) {
        if (this.map.has(key)) {
          this.map.get(key).push(value);
        } else {
          this.map.set(key, [value]);
        }
        return this;
      }
      /**
       * Add the given set of key / value pairs to the multimap.
       */
      addAll(key, values) {
        if (this.map.has(key)) {
          this.map.get(key).push(...values);
        } else {
          this.map.set(key, Array.from(values));
        }
        return this;
      }
      /**
       * Invokes the given callback function for every key / value pair in the multimap.
       */
      forEach(callbackfn) {
        this.map.forEach((array, key) => array.forEach((value) => callbackfn(value, key, this)));
      }
      /**
       * Returns an iterator of key, value pairs for every entry in the map.
       */
      [Symbol.iterator]() {
        return this.entries().iterator();
      }
      /**
       * Returns a stream of key, value pairs for every entry in the map.
       */
      entries() {
        return (0, stream_1.stream)(this.map.entries()).flatMap(([key, array]) => array.map((value) => [key, value]));
      }
      /**
       * Returns a stream of keys in the map.
       */
      keys() {
        return (0, stream_1.stream)(this.map.keys());
      }
      /**
       * Returns a stream of values in the map.
       */
      values() {
        return (0, stream_1.stream)(this.map.values()).flat();
      }
      /**
       * Returns a stream of key, value set pairs for every key in the map.
       */
      entriesGroupedByKey() {
        return (0, stream_1.stream)(this.map.entries());
      }
    };
    exports2.MultiMap = MultiMap;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/generated/ast.js
var require_ast = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/generated/ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTypeAttribute = exports2.TypeAttribute = exports2.isType = exports2.Type = exports2.isTerminalRule = exports2.TerminalRule = exports2.isSimpleType = exports2.SimpleType = exports2.isReturnType = exports2.ReturnType = exports2.isReferenceType = exports2.ReferenceType = exports2.isParserRule = exports2.ParserRule = exports2.isParameterReference = exports2.ParameterReference = exports2.isParameter = exports2.Parameter = exports2.isNegation = exports2.Negation = exports2.isNamedArgument = exports2.NamedArgument = exports2.isLiteralCondition = exports2.LiteralCondition = exports2.isInterface = exports2.Interface = exports2.isInferredType = exports2.InferredType = exports2.isGrammarImport = exports2.GrammarImport = exports2.isGrammar = exports2.Grammar = exports2.isDisjunction = exports2.Disjunction = exports2.isConjunction = exports2.Conjunction = exports2.isArrayType = exports2.ArrayType = exports2.isAbstractElement = exports2.AbstractElement = exports2.isTypeDefinition = exports2.TypeDefinition = exports2.isPrimitiveType = exports2.isFeatureName = exports2.isCondition = exports2.Condition = exports2.isAbstractType = exports2.AbstractType = exports2.isAbstractRule = exports2.AbstractRule = void 0;
    exports2.reflection = exports2.LangiumGrammarAstReflection = exports2.isWildcard = exports2.Wildcard = exports2.isUntilToken = exports2.UntilToken = exports2.isUnorderedGroup = exports2.UnorderedGroup = exports2.isTerminalRuleCall = exports2.TerminalRuleCall = exports2.isTerminalGroup = exports2.TerminalGroup = exports2.isTerminalAlternatives = exports2.TerminalAlternatives = exports2.isRuleCall = exports2.RuleCall = exports2.isRegexToken = exports2.RegexToken = exports2.isNegatedToken = exports2.NegatedToken = exports2.isKeyword = exports2.Keyword = exports2.isGroup = exports2.Group = exports2.isCrossReference = exports2.CrossReference = exports2.isCharacterRange = exports2.CharacterRange = exports2.isAssignment = exports2.Assignment = exports2.isAlternatives = exports2.Alternatives = exports2.isAction = exports2.Action = exports2.isUnionType = exports2.UnionType = void 0;
    var syntax_tree_1 = require_syntax_tree();
    exports2.AbstractRule = "AbstractRule";
    function isAbstractRule(item) {
      return exports2.reflection.isInstance(item, exports2.AbstractRule);
    }
    exports2.isAbstractRule = isAbstractRule;
    exports2.AbstractType = "AbstractType";
    function isAbstractType(item) {
      return exports2.reflection.isInstance(item, exports2.AbstractType);
    }
    exports2.isAbstractType = isAbstractType;
    exports2.Condition = "Condition";
    function isCondition(item) {
      return exports2.reflection.isInstance(item, exports2.Condition);
    }
    exports2.isCondition = isCondition;
    function isFeatureName(item) {
      return isPrimitiveType(item) || item === "current" || item === "entry" || item === "extends" || item === "false" || item === "fragment" || item === "grammar" || item === "hidden" || item === "import" || item === "interface" || item === "returns" || item === "terminal" || item === "true" || item === "type" || item === "infer" || item === "infers" || item === "with" || typeof item === "string" && /\^?[_a-zA-Z][\w_]*/.test(item);
    }
    exports2.isFeatureName = isFeatureName;
    function isPrimitiveType(item) {
      return item === "string" || item === "number" || item === "boolean" || item === "Date" || item === "bigint";
    }
    exports2.isPrimitiveType = isPrimitiveType;
    exports2.TypeDefinition = "TypeDefinition";
    function isTypeDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.TypeDefinition);
    }
    exports2.isTypeDefinition = isTypeDefinition;
    exports2.AbstractElement = "AbstractElement";
    function isAbstractElement(item) {
      return exports2.reflection.isInstance(item, exports2.AbstractElement);
    }
    exports2.isAbstractElement = isAbstractElement;
    exports2.ArrayType = "ArrayType";
    function isArrayType(item) {
      return exports2.reflection.isInstance(item, exports2.ArrayType);
    }
    exports2.isArrayType = isArrayType;
    exports2.Conjunction = "Conjunction";
    function isConjunction(item) {
      return exports2.reflection.isInstance(item, exports2.Conjunction);
    }
    exports2.isConjunction = isConjunction;
    exports2.Disjunction = "Disjunction";
    function isDisjunction(item) {
      return exports2.reflection.isInstance(item, exports2.Disjunction);
    }
    exports2.isDisjunction = isDisjunction;
    exports2.Grammar = "Grammar";
    function isGrammar(item) {
      return exports2.reflection.isInstance(item, exports2.Grammar);
    }
    exports2.isGrammar = isGrammar;
    exports2.GrammarImport = "GrammarImport";
    function isGrammarImport(item) {
      return exports2.reflection.isInstance(item, exports2.GrammarImport);
    }
    exports2.isGrammarImport = isGrammarImport;
    exports2.InferredType = "InferredType";
    function isInferredType(item) {
      return exports2.reflection.isInstance(item, exports2.InferredType);
    }
    exports2.isInferredType = isInferredType;
    exports2.Interface = "Interface";
    function isInterface(item) {
      return exports2.reflection.isInstance(item, exports2.Interface);
    }
    exports2.isInterface = isInterface;
    exports2.LiteralCondition = "LiteralCondition";
    function isLiteralCondition(item) {
      return exports2.reflection.isInstance(item, exports2.LiteralCondition);
    }
    exports2.isLiteralCondition = isLiteralCondition;
    exports2.NamedArgument = "NamedArgument";
    function isNamedArgument(item) {
      return exports2.reflection.isInstance(item, exports2.NamedArgument);
    }
    exports2.isNamedArgument = isNamedArgument;
    exports2.Negation = "Negation";
    function isNegation(item) {
      return exports2.reflection.isInstance(item, exports2.Negation);
    }
    exports2.isNegation = isNegation;
    exports2.Parameter = "Parameter";
    function isParameter(item) {
      return exports2.reflection.isInstance(item, exports2.Parameter);
    }
    exports2.isParameter = isParameter;
    exports2.ParameterReference = "ParameterReference";
    function isParameterReference(item) {
      return exports2.reflection.isInstance(item, exports2.ParameterReference);
    }
    exports2.isParameterReference = isParameterReference;
    exports2.ParserRule = "ParserRule";
    function isParserRule(item) {
      return exports2.reflection.isInstance(item, exports2.ParserRule);
    }
    exports2.isParserRule = isParserRule;
    exports2.ReferenceType = "ReferenceType";
    function isReferenceType(item) {
      return exports2.reflection.isInstance(item, exports2.ReferenceType);
    }
    exports2.isReferenceType = isReferenceType;
    exports2.ReturnType = "ReturnType";
    function isReturnType(item) {
      return exports2.reflection.isInstance(item, exports2.ReturnType);
    }
    exports2.isReturnType = isReturnType;
    exports2.SimpleType = "SimpleType";
    function isSimpleType(item) {
      return exports2.reflection.isInstance(item, exports2.SimpleType);
    }
    exports2.isSimpleType = isSimpleType;
    exports2.TerminalRule = "TerminalRule";
    function isTerminalRule(item) {
      return exports2.reflection.isInstance(item, exports2.TerminalRule);
    }
    exports2.isTerminalRule = isTerminalRule;
    exports2.Type = "Type";
    function isType(item) {
      return exports2.reflection.isInstance(item, exports2.Type);
    }
    exports2.isType = isType;
    exports2.TypeAttribute = "TypeAttribute";
    function isTypeAttribute(item) {
      return exports2.reflection.isInstance(item, exports2.TypeAttribute);
    }
    exports2.isTypeAttribute = isTypeAttribute;
    exports2.UnionType = "UnionType";
    function isUnionType(item) {
      return exports2.reflection.isInstance(item, exports2.UnionType);
    }
    exports2.isUnionType = isUnionType;
    exports2.Action = "Action";
    function isAction(item) {
      return exports2.reflection.isInstance(item, exports2.Action);
    }
    exports2.isAction = isAction;
    exports2.Alternatives = "Alternatives";
    function isAlternatives(item) {
      return exports2.reflection.isInstance(item, exports2.Alternatives);
    }
    exports2.isAlternatives = isAlternatives;
    exports2.Assignment = "Assignment";
    function isAssignment(item) {
      return exports2.reflection.isInstance(item, exports2.Assignment);
    }
    exports2.isAssignment = isAssignment;
    exports2.CharacterRange = "CharacterRange";
    function isCharacterRange(item) {
      return exports2.reflection.isInstance(item, exports2.CharacterRange);
    }
    exports2.isCharacterRange = isCharacterRange;
    exports2.CrossReference = "CrossReference";
    function isCrossReference(item) {
      return exports2.reflection.isInstance(item, exports2.CrossReference);
    }
    exports2.isCrossReference = isCrossReference;
    exports2.Group = "Group";
    function isGroup(item) {
      return exports2.reflection.isInstance(item, exports2.Group);
    }
    exports2.isGroup = isGroup;
    exports2.Keyword = "Keyword";
    function isKeyword(item) {
      return exports2.reflection.isInstance(item, exports2.Keyword);
    }
    exports2.isKeyword = isKeyword;
    exports2.NegatedToken = "NegatedToken";
    function isNegatedToken(item) {
      return exports2.reflection.isInstance(item, exports2.NegatedToken);
    }
    exports2.isNegatedToken = isNegatedToken;
    exports2.RegexToken = "RegexToken";
    function isRegexToken(item) {
      return exports2.reflection.isInstance(item, exports2.RegexToken);
    }
    exports2.isRegexToken = isRegexToken;
    exports2.RuleCall = "RuleCall";
    function isRuleCall(item) {
      return exports2.reflection.isInstance(item, exports2.RuleCall);
    }
    exports2.isRuleCall = isRuleCall;
    exports2.TerminalAlternatives = "TerminalAlternatives";
    function isTerminalAlternatives(item) {
      return exports2.reflection.isInstance(item, exports2.TerminalAlternatives);
    }
    exports2.isTerminalAlternatives = isTerminalAlternatives;
    exports2.TerminalGroup = "TerminalGroup";
    function isTerminalGroup(item) {
      return exports2.reflection.isInstance(item, exports2.TerminalGroup);
    }
    exports2.isTerminalGroup = isTerminalGroup;
    exports2.TerminalRuleCall = "TerminalRuleCall";
    function isTerminalRuleCall(item) {
      return exports2.reflection.isInstance(item, exports2.TerminalRuleCall);
    }
    exports2.isTerminalRuleCall = isTerminalRuleCall;
    exports2.UnorderedGroup = "UnorderedGroup";
    function isUnorderedGroup(item) {
      return exports2.reflection.isInstance(item, exports2.UnorderedGroup);
    }
    exports2.isUnorderedGroup = isUnorderedGroup;
    exports2.UntilToken = "UntilToken";
    function isUntilToken(item) {
      return exports2.reflection.isInstance(item, exports2.UntilToken);
    }
    exports2.isUntilToken = isUntilToken;
    exports2.Wildcard = "Wildcard";
    function isWildcard(item) {
      return exports2.reflection.isInstance(item, exports2.Wildcard);
    }
    exports2.isWildcard = isWildcard;
    var LangiumGrammarAstReflection = class extends syntax_tree_1.AbstractAstReflection {
      getAllTypes() {
        return ["AbstractElement", "AbstractRule", "AbstractType", "Action", "Alternatives", "ArrayType", "Assignment", "CharacterRange", "Condition", "Conjunction", "CrossReference", "Disjunction", "Grammar", "GrammarImport", "Group", "InferredType", "Interface", "Keyword", "LiteralCondition", "NamedArgument", "NegatedToken", "Negation", "Parameter", "ParameterReference", "ParserRule", "ReferenceType", "RegexToken", "ReturnType", "RuleCall", "SimpleType", "TerminalAlternatives", "TerminalGroup", "TerminalRule", "TerminalRuleCall", "Type", "TypeAttribute", "TypeDefinition", "UnionType", "UnorderedGroup", "UntilToken", "Wildcard"];
      }
      computeIsSubtype(subtype, supertype) {
        switch (subtype) {
          case exports2.Action: {
            return this.isSubtype(exports2.AbstractElement, supertype) || this.isSubtype(exports2.AbstractType, supertype);
          }
          case exports2.Alternatives:
          case exports2.Assignment:
          case exports2.CharacterRange:
          case exports2.CrossReference:
          case exports2.Group:
          case exports2.Keyword:
          case exports2.NegatedToken:
          case exports2.RegexToken:
          case exports2.RuleCall:
          case exports2.TerminalAlternatives:
          case exports2.TerminalGroup:
          case exports2.TerminalRuleCall:
          case exports2.UnorderedGroup:
          case exports2.UntilToken:
          case exports2.Wildcard: {
            return this.isSubtype(exports2.AbstractElement, supertype);
          }
          case exports2.ArrayType:
          case exports2.ReferenceType:
          case exports2.SimpleType:
          case exports2.UnionType: {
            return this.isSubtype(exports2.TypeDefinition, supertype);
          }
          case exports2.Conjunction:
          case exports2.Disjunction:
          case exports2.LiteralCondition:
          case exports2.Negation:
          case exports2.ParameterReference: {
            return this.isSubtype(exports2.Condition, supertype);
          }
          case exports2.Interface:
          case exports2.Type: {
            return this.isSubtype(exports2.AbstractType, supertype);
          }
          case exports2.ParserRule: {
            return this.isSubtype(exports2.AbstractRule, supertype) || this.isSubtype(exports2.AbstractType, supertype);
          }
          case exports2.TerminalRule: {
            return this.isSubtype(exports2.AbstractRule, supertype);
          }
          default: {
            return false;
          }
        }
      }
      getReferenceType(refInfo) {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
          case "Action:type":
          case "CrossReference:type":
          case "Interface:superTypes":
          case "ParserRule:returnType":
          case "SimpleType:typeRef": {
            return exports2.AbstractType;
          }
          case "Grammar:hiddenTokens":
          case "ParserRule:hiddenTokens":
          case "RuleCall:rule": {
            return exports2.AbstractRule;
          }
          case "Grammar:usedGrammars": {
            return exports2.Grammar;
          }
          case "NamedArgument:parameter":
          case "ParameterReference:parameter": {
            return exports2.Parameter;
          }
          case "TerminalRuleCall:rule": {
            return exports2.TerminalRule;
          }
          default: {
            throw new Error(`${referenceId} is not a valid reference id.`);
          }
        }
      }
      getTypeMetaData(type) {
        switch (type) {
          case "Grammar": {
            return {
              name: "Grammar",
              mandatory: [
                { name: "definesHiddenTokens", type: "boolean" },
                { name: "hiddenTokens", type: "array" },
                { name: "imports", type: "array" },
                { name: "interfaces", type: "array" },
                { name: "isDeclared", type: "boolean" },
                { name: "rules", type: "array" },
                { name: "types", type: "array" },
                { name: "usedGrammars", type: "array" }
              ]
            };
          }
          case "Interface": {
            return {
              name: "Interface",
              mandatory: [
                { name: "attributes", type: "array" },
                { name: "superTypes", type: "array" }
              ]
            };
          }
          case "LiteralCondition": {
            return {
              name: "LiteralCondition",
              mandatory: [
                { name: "true", type: "boolean" }
              ]
            };
          }
          case "NamedArgument": {
            return {
              name: "NamedArgument",
              mandatory: [
                { name: "calledByName", type: "boolean" }
              ]
            };
          }
          case "ParserRule": {
            return {
              name: "ParserRule",
              mandatory: [
                { name: "definesHiddenTokens", type: "boolean" },
                { name: "entry", type: "boolean" },
                { name: "fragment", type: "boolean" },
                { name: "hiddenTokens", type: "array" },
                { name: "parameters", type: "array" },
                { name: "wildcard", type: "boolean" }
              ]
            };
          }
          case "TerminalRule": {
            return {
              name: "TerminalRule",
              mandatory: [
                { name: "fragment", type: "boolean" },
                { name: "hidden", type: "boolean" }
              ]
            };
          }
          case "TypeAttribute": {
            return {
              name: "TypeAttribute",
              mandatory: [
                { name: "isOptional", type: "boolean" }
              ]
            };
          }
          case "UnionType": {
            return {
              name: "UnionType",
              mandatory: [
                { name: "types", type: "array" }
              ]
            };
          }
          case "Alternatives": {
            return {
              name: "Alternatives",
              mandatory: [
                { name: "elements", type: "array" }
              ]
            };
          }
          case "CrossReference": {
            return {
              name: "CrossReference",
              mandatory: [
                { name: "deprecatedSyntax", type: "boolean" }
              ]
            };
          }
          case "Group": {
            return {
              name: "Group",
              mandatory: [
                { name: "elements", type: "array" }
              ]
            };
          }
          case "RuleCall": {
            return {
              name: "RuleCall",
              mandatory: [
                { name: "arguments", type: "array" }
              ]
            };
          }
          case "TerminalAlternatives": {
            return {
              name: "TerminalAlternatives",
              mandatory: [
                { name: "elements", type: "array" }
              ]
            };
          }
          case "TerminalGroup": {
            return {
              name: "TerminalGroup",
              mandatory: [
                { name: "elements", type: "array" }
              ]
            };
          }
          case "UnorderedGroup": {
            return {
              name: "UnorderedGroup",
              mandatory: [
                { name: "elements", type: "array" }
              ]
            };
          }
          default: {
            return {
              name: type,
              mandatory: []
            };
          }
        }
      }
    };
    exports2.LangiumGrammarAstReflection = LangiumGrammarAstReflection;
    exports2.reflection = new LangiumGrammarAstReflection();
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/ast-util.js
var require_ast_util = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/ast-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.copyAstNode = exports2.findLocalReferences = exports2.streamReferences = exports2.streamAst = exports2.streamAllContents = exports2.streamContents = exports2.findRootNode = exports2.getDocument = exports2.hasContainerOfType = exports2.getContainerOfType = exports2.linkContentToContainer = void 0;
    var syntax_tree_1 = require_syntax_tree();
    var stream_1 = require_stream();
    var cst_util_1 = require_cst_util();
    function linkContentToContainer(node) {
      for (const [name, value] of Object.entries(node)) {
        if (!name.startsWith("$")) {
          if (Array.isArray(value)) {
            value.forEach((item, index) => {
              if ((0, syntax_tree_1.isAstNode)(item)) {
                item.$container = node;
                item.$containerProperty = name;
                item.$containerIndex = index;
              }
            });
          } else if ((0, syntax_tree_1.isAstNode)(value)) {
            value.$container = node;
            value.$containerProperty = name;
          }
        }
      }
    }
    exports2.linkContentToContainer = linkContentToContainer;
    function getContainerOfType(node, typePredicate) {
      let item = node;
      while (item) {
        if (typePredicate(item)) {
          return item;
        }
        item = item.$container;
      }
      return void 0;
    }
    exports2.getContainerOfType = getContainerOfType;
    function hasContainerOfType(node, predicate) {
      let item = node;
      while (item) {
        if (predicate(item)) {
          return true;
        }
        item = item.$container;
      }
      return false;
    }
    exports2.hasContainerOfType = hasContainerOfType;
    function getDocument(node) {
      const rootNode = findRootNode(node);
      const result = rootNode.$document;
      if (!result) {
        throw new Error("AST node has no document.");
      }
      return result;
    }
    exports2.getDocument = getDocument;
    function findRootNode(node) {
      while (node.$container) {
        node = node.$container;
      }
      return node;
    }
    exports2.findRootNode = findRootNode;
    function streamContents(node, options) {
      if (!node) {
        throw new Error("Node must be an AstNode.");
      }
      const range = options === null || options === void 0 ? void 0 : options.range;
      return new stream_1.StreamImpl(() => ({
        keys: Object.keys(node),
        keyIndex: 0,
        arrayIndex: 0
      }), (state) => {
        while (state.keyIndex < state.keys.length) {
          const property = state.keys[state.keyIndex];
          if (!property.startsWith("$")) {
            const value = node[property];
            if ((0, syntax_tree_1.isAstNode)(value)) {
              state.keyIndex++;
              if (isAstNodeInRange(value, range)) {
                return { done: false, value };
              }
            } else if (Array.isArray(value)) {
              while (state.arrayIndex < value.length) {
                const index = state.arrayIndex++;
                const element = value[index];
                if ((0, syntax_tree_1.isAstNode)(element) && isAstNodeInRange(element, range)) {
                  return { done: false, value: element };
                }
              }
              state.arrayIndex = 0;
            }
          }
          state.keyIndex++;
        }
        return stream_1.DONE_RESULT;
      });
    }
    exports2.streamContents = streamContents;
    function streamAllContents(root, options) {
      if (!root) {
        throw new Error("Root node must be an AstNode.");
      }
      return new stream_1.TreeStreamImpl(root, (node) => streamContents(node, options));
    }
    exports2.streamAllContents = streamAllContents;
    function streamAst(root, options) {
      if (!root) {
        throw new Error("Root node must be an AstNode.");
      } else if ((options === null || options === void 0 ? void 0 : options.range) && !isAstNodeInRange(root, options.range)) {
        return new stream_1.TreeStreamImpl(root, () => []);
      }
      return new stream_1.TreeStreamImpl(root, (node) => streamContents(node, options), { includeRoot: true });
    }
    exports2.streamAst = streamAst;
    function isAstNodeInRange(astNode, range) {
      var _a;
      if (!range) {
        return true;
      }
      const nodeRange = (_a = astNode.$cstNode) === null || _a === void 0 ? void 0 : _a.range;
      if (!nodeRange) {
        return false;
      }
      return (0, cst_util_1.inRange)(nodeRange, range);
    }
    function streamReferences(node) {
      return new stream_1.StreamImpl(() => ({
        keys: Object.keys(node),
        keyIndex: 0,
        arrayIndex: 0
      }), (state) => {
        while (state.keyIndex < state.keys.length) {
          const property = state.keys[state.keyIndex];
          if (!property.startsWith("$")) {
            const value = node[property];
            if ((0, syntax_tree_1.isReference)(value)) {
              state.keyIndex++;
              return { done: false, value: { reference: value, container: node, property } };
            } else if (Array.isArray(value)) {
              while (state.arrayIndex < value.length) {
                const index = state.arrayIndex++;
                const element = value[index];
                if ((0, syntax_tree_1.isReference)(element)) {
                  return { done: false, value: { reference: element, container: node, property, index } };
                }
              }
              state.arrayIndex = 0;
            }
          }
          state.keyIndex++;
        }
        return stream_1.DONE_RESULT;
      });
    }
    exports2.streamReferences = streamReferences;
    function findLocalReferences(targetNode, lookup = getDocument(targetNode).parseResult.value) {
      const refs = [];
      streamAst(lookup).forEach((node) => {
        streamReferences(node).forEach((refInfo) => {
          if (refInfo.reference.ref === targetNode) {
            refs.push(refInfo.reference);
          }
        });
      });
      return (0, stream_1.stream)(refs);
    }
    exports2.findLocalReferences = findLocalReferences;
    function copyAstNode(node, buildReference) {
      const copy = { $type: node.$type };
      for (const [name, value] of Object.entries(node)) {
        if (!name.startsWith("$")) {
          if ((0, syntax_tree_1.isAstNode)(value)) {
            copy[name] = copyAstNode(value, buildReference);
          } else if ((0, syntax_tree_1.isReference)(value)) {
            copy[name] = buildReference(copy, name, value.$refNode, value.$refText);
          } else if (Array.isArray(value)) {
            const copiedArray = [];
            for (const element of value) {
              if ((0, syntax_tree_1.isAstNode)(element)) {
                copiedArray.push(copyAstNode(element, buildReference));
              } else if ((0, syntax_tree_1.isReference)(element)) {
                copiedArray.push(buildReference(copy, name, element.$refNode, element.$refText));
              } else {
                copiedArray.push(element);
              }
            }
            copy[name] = copiedArray;
          } else {
            copy[name] = value;
          }
        }
      }
      linkContentToContainer(copy);
      return copy;
    }
    exports2.copyAstNode = copyAstNode;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/generator-tracing.js
var require_generator_tracing = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/generator-tracing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSourceRegion = void 0;
    var ast_util_1 = require_ast_util();
    var grammar_util_1 = require_grammar_util();
    var stream_1 = require_stream();
    function getSourceRegion(sourceSpec) {
      var _a, _b;
      if (!sourceSpec) {
        return void 0;
      } else if ("astNode" in sourceSpec) {
        return getSourceRegionOfAstNode(sourceSpec);
      } else if (Array.isArray(sourceSpec)) {
        return sourceSpec.reduce(mergeDocumentSegment, void 0);
      } else {
        const sourceRegion = sourceSpec;
        const sourceFileURIviaCstNode = isCstNode(sourceRegion) ? getDocumentURIOrUndefined((_b = (_a = sourceRegion === null || sourceRegion === void 0 ? void 0 : sourceRegion.root) === null || _a === void 0 ? void 0 : _a.element) !== null && _b !== void 0 ? _b : sourceRegion === null || sourceRegion === void 0 ? void 0 : sourceRegion.element) : void 0;
        return copyDocumentSegment(sourceRegion, sourceFileURIviaCstNode);
      }
    }
    exports2.getSourceRegion = getSourceRegion;
    function isCstNode(segment) {
      return typeof segment !== "undefined" && "element" in segment && "text" in segment;
    }
    function getDocumentURIOrUndefined(astNode) {
      try {
        return (0, ast_util_1.getDocument)(astNode).uri.toString();
      } catch (e) {
        return void 0;
      }
    }
    function getSourceRegionOfAstNode(sourceSpec) {
      var _a, _b;
      const { astNode, property, index } = sourceSpec !== null && sourceSpec !== void 0 ? sourceSpec : {};
      const textRegion = (_a = astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) !== null && _a !== void 0 ? _a : astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion;
      if (astNode === void 0 || textRegion === void 0) {
        return void 0;
      } else if (property === void 0) {
        return copyDocumentSegment(textRegion, getDocumentURI(astNode));
      } else {
        const getSingleOrCompoundRegion = (regions) => {
          if (index !== void 0 && index > -1 && Array.isArray(astNode[property])) {
            return index < regions.length ? regions[index] : void 0;
          } else {
            return regions.reduce(mergeDocumentSegment, void 0);
          }
        };
        if ((_b = textRegion.assignments) === null || _b === void 0 ? void 0 : _b[property]) {
          const region = getSingleOrCompoundRegion(textRegion.assignments[property]);
          return region && copyDocumentSegment(region, getDocumentURI(astNode));
        } else if (astNode.$cstNode) {
          const region = getSingleOrCompoundRegion((0, grammar_util_1.findNodesForProperty)(astNode.$cstNode, property));
          return region && copyDocumentSegment(region, getDocumentURI(astNode));
        } else {
          return void 0;
        }
      }
    }
    function getDocumentURI(astNode) {
      var _a, _b, _c, _d;
      if (astNode.$cstNode) {
        return (_b = (_a = (0, ast_util_1.getDocument)(astNode)) === null || _a === void 0 ? void 0 : _a.uri) === null || _b === void 0 ? void 0 : _b.toString();
      } else if (astNode.$textRegion) {
        return astNode.$textRegion.documentURI || ((_d = (_c = new stream_1.TreeStreamImpl(astNode, (n) => n.$container ? [n.$container] : []).find((n) => {
          var _a2;
          return (_a2 = n.$textRegion) === null || _a2 === void 0 ? void 0 : _a2.documentURI;
        })) === null || _c === void 0 ? void 0 : _c.$textRegion) === null || _d === void 0 ? void 0 : _d.documentURI);
      } else {
        return void 0;
      }
    }
    function copyDocumentSegment(region, fileURI) {
      var _a, _b;
      const result = {
        offset: region.offset,
        end: (_a = region.end) !== null && _a !== void 0 ? _a : region.offset + region.length,
        length: (_b = region.length) !== null && _b !== void 0 ? _b : region.end - region.offset
      };
      if (region.range) {
        result.range = region.range;
      }
      fileURI !== null && fileURI !== void 0 ? fileURI : fileURI = region.fileURI;
      if (fileURI) {
        result.fileURI = fileURI;
      }
      return result;
    }
    function mergeDocumentSegment(prev, curr) {
      var _a, _b;
      if (!prev) {
        return curr && copyDocumentSegment(curr);
      } else if (!curr) {
        return prev && copyDocumentSegment(prev);
      }
      const prevEnd = (_a = prev.end) !== null && _a !== void 0 ? _a : prev.offset + prev.length;
      const currEnd = (_b = curr.end) !== null && _b !== void 0 ? _b : curr.offset + curr.length;
      const offset = Math.min(prev.offset, curr.offset);
      const end = Math.max(prevEnd, currEnd);
      const length = end - offset;
      const result = {
        offset,
        end,
        length
      };
      if (prev.range && curr.range) {
        result.range = {
          start: curr.range.start.line < prev.range.start.line || curr.range.start.line === prev.range.start.line && curr.range.start.character < prev.range.start.character ? curr.range.start : prev.range.start,
          end: curr.range.end.line > prev.range.end.line || curr.range.end.line === prev.range.end.line && curr.range.end.character > prev.range.end.character ? curr.range.end : prev.range.end
        };
      }
      if (prev.fileURI || curr.fileURI) {
        const prevURI = prev.fileURI;
        const currURI = curr.fileURI;
        const fileURI = prevURI && currURI && prevURI !== currURI ? `<unmergable text regions of ${prevURI}, ${currURI}>` : prevURI !== null && prevURI !== void 0 ? prevURI : currURI;
        result.fileURI = fileURI;
      }
      return result;
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/node-processor.js
var require_node_processor = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/node-processor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processGeneratorNode = void 0;
    var generator_node_1 = require_generator_node();
    var generator_tracing_1 = require_generator_tracing();
    var Context = class {
      constructor(defaultIndent) {
        this.defaultIndentation = "    ";
        this.pendingIndent = true;
        this.currentIndents = [];
        this.recentNonImmediateIndents = [];
        this.traceData = [];
        this.lines = [[]];
        if (typeof defaultIndent === "string") {
          this.defaultIndentation = defaultIndent;
        } else if (typeof defaultIndent === "number") {
          this.defaultIndentation = "".padStart(defaultIndent);
        }
      }
      get content() {
        return this.lines.map((e) => e.join("")).join("");
      }
      get currentLineNumber() {
        return this.lines.length - 1;
      }
      get currentLineContent() {
        return this.lines[this.currentLineNumber].join("");
      }
      get currentPosition() {
        return {
          offset: this.content.length,
          line: this.currentLineNumber,
          character: this.currentLineContent.length
        };
      }
      append(value, isIndent) {
        if (value.length > 0) {
          const beforePos = isIndent && this.currentPosition;
          this.lines[this.currentLineNumber].push(value);
          if (beforePos) {
            this.indentPendingTraceRegions(beforePos);
          }
        }
      }
      indentPendingTraceRegions(before) {
        for (let i = this.traceData.length - 1; i >= 0; i--) {
          const tr = this.traceData[i];
          if (tr.targetStart && tr.targetStart.offset === before.offset)
            tr.targetStart = this.currentPosition;
        }
      }
      increaseIndent(node) {
        this.currentIndents.push(node);
        if (!node.indentImmediately) {
          this.recentNonImmediateIndents.push(node);
        }
      }
      decreaseIndent() {
        this.currentIndents.pop();
      }
      get relevantIndents() {
        return this.currentIndents.filter((i) => !this.recentNonImmediateIndents.includes(i));
      }
      resetCurrentLine() {
        this.lines[this.currentLineNumber] = [];
      }
      addNewLine() {
        this.pendingIndent = true;
        this.lines.push([]);
        this.recentNonImmediateIndents.length = 0;
      }
      pushTraceRegion(sourceRegion) {
        const region = createTraceRegion(sourceRegion, this.currentPosition, (it) => {
          var _a, _b;
          return (_b = (_a = this.traceData[this.traceData.length - 1]) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.push(it);
        });
        this.traceData.push(region);
        return region;
      }
      popTraceRegion(expected) {
        const traceRegion = this.traceData.pop();
        this.assertTrue(traceRegion === expected, "Trace region mismatch!");
        return traceRegion;
      }
      getParentTraceSourceFileURI() {
        var _a;
        for (let i = this.traceData.length - 1; i > -1; i--) {
          const fileUri = (_a = this.traceData[i].sourceRegion) === null || _a === void 0 ? void 0 : _a.fileURI;
          if (fileUri)
            return fileUri;
        }
        return void 0;
      }
      assertTrue(condition, msg) {
        if (!condition) {
          throw new Error(msg);
        }
      }
    };
    function createTraceRegion(sourceRegion, targetStart, accept) {
      const result = {
        sourceRegion,
        targetRegion: void 0,
        children: [],
        targetStart,
        complete: (targetEnd) => {
          var _a, _b;
          result.targetRegion = {
            offset: result.targetStart.offset,
            end: targetEnd.offset,
            length: targetEnd.offset - result.targetStart.offset,
            range: {
              start: {
                line: result.targetStart.line,
                character: result.targetStart.character
              },
              end: {
                line: targetEnd.line,
                character: targetEnd.character
              }
            }
          };
          delete result.targetStart;
          if (((_a = result.children) === null || _a === void 0 ? void 0 : _a.length) === 0) {
            delete result.children;
          }
          if ((_b = result.targetRegion) === null || _b === void 0 ? void 0 : _b.length) {
            accept(result);
          }
          delete result.complete;
          return result;
        }
      };
      return result;
    }
    function processGeneratorNode(node, defaultIndentation) {
      const context = new Context(defaultIndentation);
      const trace = context.pushTraceRegion(void 0);
      processNodeInternal(node, context);
      context.popTraceRegion(trace);
      trace.complete && trace.complete(context.currentPosition);
      const singleChild = trace.children && trace.children.length === 1 ? trace.children[0] : void 0;
      const singleChildTargetRegion = singleChild === null || singleChild === void 0 ? void 0 : singleChild.targetRegion;
      const rootTargetRegion = trace.targetRegion;
      if (singleChildTargetRegion && singleChild.sourceRegion && singleChildTargetRegion.offset === rootTargetRegion.offset && singleChildTargetRegion.length === rootTargetRegion.length) {
        return { text: context.content, trace: singleChild };
      } else {
        return { text: context.content, trace };
      }
    }
    exports2.processGeneratorNode = processGeneratorNode;
    function processNodeInternal(node, context) {
      if (typeof node === "string") {
        processStringNode(node, context);
      } else if (node instanceof generator_node_1.IndentNode) {
        processIndentNode(node, context);
      } else if (node instanceof generator_node_1.CompositeGeneratorNode) {
        processCompositeNode(node, context);
      } else if (node instanceof generator_node_1.NewLineNode) {
        processNewLineNode(node, context);
      }
    }
    function hasContent(node, ctx) {
      if (typeof node === "string") {
        return node.length !== 0;
      } else if (node instanceof generator_node_1.CompositeGeneratorNode) {
        return node.contents.some((e) => hasContent(e, ctx));
      } else if (node instanceof generator_node_1.NewLineNode) {
        return !(node.ifNotEmpty && ctx.currentLineContent.length === 0);
      } else {
        return false;
      }
    }
    function processStringNode(node, context) {
      if (node) {
        if (context.pendingIndent) {
          handlePendingIndent(context, false);
        }
        context.append(node);
      }
    }
    function handlePendingIndent(ctx, endOfLine) {
      var _a;
      let indent = "";
      for (const indentNode of ctx.relevantIndents.filter((e) => e.indentEmptyLines || !endOfLine)) {
        indent += (_a = indentNode.indentation) !== null && _a !== void 0 ? _a : ctx.defaultIndentation;
      }
      ctx.append(indent, true);
      ctx.pendingIndent = false;
    }
    function processCompositeNode(node, context) {
      let traceRegion = void 0;
      const sourceRegion = (0, generator_tracing_1.getSourceRegion)(node.tracedSource);
      if (sourceRegion) {
        traceRegion = context.pushTraceRegion(sourceRegion);
      }
      for (const child of node.contents) {
        processNodeInternal(child, context);
      }
      if (traceRegion) {
        context.popTraceRegion(traceRegion);
        const parentsFileURI = context.getParentTraceSourceFileURI();
        if (parentsFileURI && (sourceRegion === null || sourceRegion === void 0 ? void 0 : sourceRegion.fileURI) === parentsFileURI) {
          delete sourceRegion.fileURI;
        }
        traceRegion.complete && traceRegion.complete(context.currentPosition);
      }
    }
    function processIndentNode(node, context) {
      var _a;
      if (hasContent(node, context)) {
        if (node.indentImmediately && !context.pendingIndent) {
          context.append((_a = node.indentation) !== null && _a !== void 0 ? _a : context.defaultIndentation, true);
        }
        try {
          context.increaseIndent(node);
          processCompositeNode(node, context);
        } finally {
          context.decreaseIndent();
        }
      }
    }
    function processNewLineNode(node, context) {
      if (node.ifNotEmpty && !hasNonWhitespace(context.currentLineContent)) {
        context.resetCurrentLine();
      } else {
        if (context.pendingIndent) {
          handlePendingIndent(context, true);
        }
        context.append(node.lineDelimiter);
        context.addNewLine();
      }
    }
    function hasNonWhitespace(text) {
      return text.trimStart() !== "";
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/template-string.js
var require_template_string = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/template-string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalizeEOL = exports2.findIndentation = exports2.NEWLINE_REGEXP = exports2.SNLE = exports2.expandToString = exports2.expandToStringWithNL = void 0;
    var generator_node_1 = require_generator_node();
    function expandToStringWithNL(staticParts, ...substitutions) {
      return expandToString(staticParts, ...substitutions) + generator_node_1.EOL;
    }
    exports2.expandToStringWithNL = expandToStringWithNL;
    function expandToString(staticParts, ...substitutions) {
      let lines = substitutions.reduce((acc, subst, i) => {
        var _a;
        return acc + (subst === void 0 ? exports2.SNLE : align((0, generator_node_1.toString)(subst), acc)) + ((_a = staticParts[i + 1]) !== null && _a !== void 0 ? _a : "");
      }, staticParts[0]).split(exports2.NEWLINE_REGEXP).filter((l) => l.trim() !== exports2.SNLE).map((l) => l.replace(exports2.SNLE, "").trimRight());
      const containsLeadingLinebreak = lines.length > 1 && lines[0].trim().length === 0;
      lines = containsLeadingLinebreak ? lines.slice(1) : lines;
      const containsTrailingLinebreak = lines.length !== 0 && lines[lines.length - 1].trimRight().length === 0;
      lines = containsTrailingLinebreak ? lines.slice(0, lines.length - 1) : lines;
      const indent = findIndentation(lines);
      return lines.map((line) => line.slice(indent).trimRight()).join(generator_node_1.EOL);
    }
    exports2.expandToString = expandToString;
    exports2.SNLE = Object.freeze("__\xABSKIP^NEW^LINE^IF^EMPTY\xBB__");
    exports2.NEWLINE_REGEXP = /\r?\n/g;
    var nonWhitespace = /\S|$/;
    function align(subst, acc) {
      const length = Math.max(0, acc.length - acc.lastIndexOf("\n") - 1);
      const indent = " ".repeat(length);
      return subst.replace(exports2.NEWLINE_REGEXP, generator_node_1.EOL + indent);
    }
    function findIndentation(lines) {
      const indents = lines.filter((line) => line.length > 0).map((line) => line.search(nonWhitespace));
      const min = indents.length === 0 ? 0 : Math.min(...indents);
      return Math.max(0, min);
    }
    exports2.findIndentation = findIndentation;
    function normalizeEOL(input) {
      return input.replace(exports2.NEWLINE_REGEXP, generator_node_1.EOL);
    }
    exports2.normalizeEOL = normalizeEOL;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/template-node.js
var require_template_node = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/template-node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.expandTracedToNodeIf = exports2.expandTracedToNode = exports2.expandToNode = void 0;
    var generator_node_1 = require_generator_node();
    var template_string_1 = require_template_string();
    function expandToNode(staticParts, ...substitutions) {
      const templateProps = findIndentationAndTemplateStructure(staticParts);
      const splitAndMerged = splitTemplateLinesAndMergeWithSubstitutions(staticParts, substitutions, templateProps);
      return composeFinalGeneratorNode(splitAndMerged);
    }
    exports2.expandToNode = expandToNode;
    function expandTracedToNode(source, property, index) {
      return (staticParts, ...substitutions) => {
        return (0, generator_node_1.traceToNode)(source, property, index)(expandToNode(staticParts, ...substitutions));
      };
    }
    exports2.expandTracedToNode = expandTracedToNode;
    function expandTracedToNodeIf(condition, source, property, index) {
      return condition ? expandTracedToNode(typeof source === "function" ? source() : source, property, index) : () => void 0;
    }
    exports2.expandTracedToNodeIf = expandTracedToNodeIf;
    function findIndentationAndTemplateStructure(staticParts) {
      const lines = staticParts.join("_").split(template_string_1.NEWLINE_REGEXP);
      const omitFirstLine = lines.length > 1 && lines[0].trim().length === 0;
      const omitLastLine = omitFirstLine && lines.length > 1 && lines[lines.length - 1].trim().length === 0;
      if (lines.length === 1 || lines.length !== 0 && lines[0].trim().length !== 0 || lines.length === 2 && lines[1].trim().length === 0) {
        return {
          indentation: 0,
          omitFirstLine,
          omitLastLine,
          trimLastLine: lines.length !== 1 && lines[lines.length - 1].trim().length === 0
        };
      } else {
        let sliced = omitFirstLine ? lines.slice(1) : lines;
        sliced = omitLastLine ? sliced.slice(0, sliced.length - 1) : sliced;
        sliced = sliced.filter((e) => e.length !== 0);
        const indentation = (0, template_string_1.findIndentation)(sliced);
        return {
          indentation,
          omitFirstLine,
          // in the subsequent steps omit the last line only if it is empty or if it only contains white space of which the common indentation is not a valid prefix;
          //  in other words: keep the last line if it matches the common indentation (and maybe contains non-whitespace), a non-match may be due to mistaken usage of tabs and spaces
          omitLastLine: omitLastLine && (lines[lines.length - 1].length < indentation || !lines[lines.length - 1].startsWith(sliced[0].substring(0, indentation)))
        };
      }
    }
    function splitTemplateLinesAndMergeWithSubstitutions(staticParts, substitutions, { indentation, omitFirstLine, omitLastLine, trimLastLine }) {
      const splitAndMerged = [];
      staticParts.forEach((part, i) => {
        splitAndMerged.push(...part.split(template_string_1.NEWLINE_REGEXP).map((e, j) => j === 0 || e.length < indentation ? e : e.substring(indentation)).reduce(
          // treat the particular (potentially multiple) lines of the <i>th template segment (part),
          //  s.t. all the effective lines are collected and separated by the NEWLINE node
          // note: different reduce functions are provided for the initial template segment vs. the remaining segments
          i === 0 ? (result, line, j) => (
            // special handling of the initial template segment, which may contain line-breaks;
            //  suppresses the injection of unintended NEWLINE indicators for templates like
            //   expandToNode`
            //    someText
            //    ${something}
            //   `
            j === 0 ? omitFirstLine ? [] : [line] : j === 1 && result.length === 0 ? [line] : result.concat(NEWLINE, line)
          ) : (result, line, j) => (
            // handling of the remaining template segments
            j === 0 ? [line] : result.concat(NEWLINE, line)
          ),
          []
          // start with an empty array
        ).filter(
          (e) => !(typeof e === "string" && e.length === 0)
          // drop empty strings, they don't contribute anything but might confuse subsequent processing
        ).concat(
          // append the corresponding substitution after each segment (part),
          //  note that 'substitutions[i]' will be undefined for the last segment
          (0, generator_node_1.isGeneratorNode)(substitutions[i]) ? substitutions[i] : substitutions[i] !== void 0 ? { content: String(substitutions[i]) } : i < substitutions.length ? UNDEFINED_SEGMENT : []
          /* don't concat anything as we passed behind the last substitution, since 'i' enumerates the indices of 'staticParts',
                  but 'substitutions' has one entry less and 'substitutions[staticParts.length -1 ]' will always be undefined */
        ));
      });
      const splitAndMergedLength = splitAndMerged.length;
      const lastItem = splitAndMergedLength !== 0 ? splitAndMerged[splitAndMergedLength - 1] : void 0;
      if ((omitLastLine || trimLastLine) && typeof lastItem === "string" && lastItem.trim().length === 0) {
        if (omitFirstLine && splitAndMergedLength !== 1 && splitAndMerged[splitAndMergedLength - 2] === NEWLINE) {
          return splitAndMerged.slice(0, splitAndMergedLength - 2);
        } else {
          return splitAndMerged.slice(0, splitAndMergedLength - 1);
        }
      } else {
        return splitAndMerged;
      }
    }
    var NEWLINE = { isNewLine: true };
    var UNDEFINED_SEGMENT = { isUndefinedSegment: true };
    var isNewLineMarker = (nl) => nl === NEWLINE;
    var isUndefinedSegmentMarker = (us) => us === UNDEFINED_SEGMENT;
    var isSubstitutionWrapper = (s) => s.content !== void 0;
    function composeFinalGeneratorNode(splitAndMerged) {
      const result = splitAndMerged.reduce((res, segment, i) => isUndefinedSegmentMarker(segment) ? res : isNewLineMarker(segment) ? {
        // in case of a newLine marker append an 'ifNotEmpty' newLine by default, but
        //  append an unconditional newLine if and only if:
        //   * the template starts with the current line break, i.e. the first line is empty
        //   * the current newLine marker directly follows another one, i.e. the current line is empty
        //   * the current newline marker directly follows a substitution contributing a string (or some non-GeneratorNode being converted to a string)
        //   * the current newline marker directly follows a (template static) string that
        //      * is the initial token of the template
        //      * is the initial token of the line, maybe just indentation
        //      * follows a a substitution contributing a string (or some non-GeneratorNode being converted to a string), maybe is just irrelevant trailing whitespace
        // in particular do _not_ append an unconditional newLine if the last substitution of a line contributes 'undefined' or an instance of 'GeneratorNode'
        //  which may be a newline itself or be empty or (transitively) contain a trailing newline itself
        // node: i === 0
        //     || isNewLineMarker(splitAndMerged[i - 1]) || isSubstitutionWrapper(splitAndMerged[i - 1]) /* implies: typeof content === 'string', esp. !undefined */
        //     || typeof splitAndMerged[i - 1] === 'string' && (
        //         i === 1 || isNewLineMarker(splitAndMerged[i - 2]) || isSubstitutionWrapper(splitAndMerged[i - 2]) /* implies: typeof content === 'string', esp. !undefined */
        //     )
        //     ? res.node.appendNewLine() : res.node.appendNewLineIfNotEmpty()
        //
        // UPDATE cs: inverting the logic leads to the following, I hope I didn't miss anything:
        // in case of a newLine marker append an unconditional newLine by default, but
        //  append an 'ifNotEmpty' newLine if and only if:
        //   * the template doesn't start with a newLine marker and
        //      * the current newline marker directly follows a substitution contributing an `undefined` or an instance of 'GeneratorNode', or
        //      * the current newline marker directly follows a (template static) string (containing potentially unintended trailing whitespace)
        //          that in turn directly follows a substitution contributing an `undefined` or an instance of 'GeneratorNode'
        node: i !== 0 && (isUndefinedSegmentMarker(splitAndMerged[i - 1]) || (0, generator_node_1.isGeneratorNode)(splitAndMerged[i - 1])) || i > 1 && typeof splitAndMerged[i - 1] === "string" && (isUndefinedSegmentMarker(splitAndMerged[i - 2]) || (0, generator_node_1.isGeneratorNode)(splitAndMerged[i - 2])) ? res.node.appendNewLineIfNotEmpty() : res.node.appendNewLine()
      } : (() => {
        var _a;
        const indent = (i === 0 || isNewLineMarker(splitAndMerged[i - 1])) && typeof segment === "string" && segment.length !== 0 ? "".padStart(segment.length - segment.trimStart().length) : "";
        const content = isSubstitutionWrapper(segment) ? segment.content : segment;
        let indented;
        return {
          node: res.indented ? res.node : indent.length !== 0 ? res.node.indent({ indentation: indent, indentImmediately: false, indentedChildren: (ind) => indented = ind.append(content) }) : res.node.append(content),
          indented: (
            // if an indentNode has been created in this cycle, just register it,
            //  otherwise check for a earlier registered indentNode and add the current segment to that one
            indented !== null && indented !== void 0 ? indented : (_a = res.indented) === null || _a === void 0 ? void 0 : _a.append(content)
          )
        };
      })(), { node: new generator_node_1.CompositeGeneratorNode() });
      return result.node;
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/generator-node.js
var require_generator_node = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/generator-node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NLEmpty = exports2.NL = exports2.NewLineNode = exports2.IndentNode = exports2.traceToNodeIf = exports2.traceToNode = exports2.CompositeGeneratorNode = exports2.toStringAndTrace = exports2.toString = exports2.isNewLineNode = exports2.isGeneratorNode = exports2.EOL = void 0;
    var syntax_tree_1 = require_syntax_tree();
    var node_processor_1 = require_node_processor();
    var template_node_1 = require_template_node();
    exports2.EOL = typeof process === "undefined" ? "\n" : process.platform === "win32" ? "\r\n" : "\n";
    function isGeneratorNode(node) {
      return node instanceof CompositeGeneratorNode || node instanceof IndentNode || node instanceof NewLineNode;
    }
    exports2.isGeneratorNode = isGeneratorNode;
    function isNewLineNode(node) {
      return node instanceof NewLineNode;
    }
    exports2.isNewLineNode = isNewLineNode;
    function toString(input, defaultIndentation) {
      if (isGeneratorNode(input))
        return (0, node_processor_1.processGeneratorNode)(input, defaultIndentation).text;
      else
        return String(input);
    }
    exports2.toString = toString;
    function toStringAndTrace(input, defaultIndentation) {
      return (0, node_processor_1.processGeneratorNode)(input, defaultIndentation);
    }
    exports2.toStringAndTrace = toStringAndTrace;
    var CompositeGeneratorNode = class {
      /**
       * Constructor.
       *
       * @param content a var arg mixture of `strings` and {@link GeneratorNode GeneratorNodes}
       *   describing the initial content of this {@link CompositeGeneratorNode}
       *
       * @example
       *   new CompositeGeneratorNode(
       *      'Hello World!', NL
       *   );
       */
      constructor(...content) {
        this.contents = [];
        this.append(...content);
      }
      isEmpty() {
        return this.contents.length === 0;
      }
      trace(source, property, index) {
        if ((0, syntax_tree_1.isAstNode)(source)) {
          this.tracedSource = { astNode: source, property, index };
          if (this.tracedSource.property === void 0 && this.tracedSource.index !== void 0 && this.tracedSource.index > -1) {
            throw new Error("Generation support: 'property' argument must not be 'undefined' if a non-negative value is assigned to 'index' in 'CompositeGeneratorNode.trace(...)'.");
          }
        } else {
          this.tracedSource = source;
        }
        return this;
      }
      /**
       * Appends `strings` and instances of {@link GeneratorNode} to `this` generator node.
       *
       * @param content a var arg mixture of `strings`, {@link GeneratorNode GeneratorNodes}, or single param
       *  functions that are immediately called with `this` node as argument, and which may append elements themselves.
       *
       * @returns `this` {@link CompositeGeneratorNode} for convenience.
       *
       * @example
       *   new CompositeGeneratorNode().append(
       *      'Hello', ' ', `${name}!`, NL, someOtherNode, 'NL', node => generateContent(node)
       *   ).append(
       *      'The end!'
       *   );
       */
      append(...content) {
        for (const arg of content) {
          if (typeof arg === "function") {
            arg(this);
          } else if (arg) {
            this.contents.push(arg);
          }
        }
        return this;
      }
      /**
       * Appends `strings` and instances of {@link GeneratorNode} to `this` generator node, if `condition` is equal to `true`.
       *
       * If `condition` is satisfied this method delegates to {@link append}, otherwise it returns just `this`.
       *
       * @param condition a boolean value indicating whether to append the elements of `args` to `this`.
       *
       * @param content a var arg mixture of `strings`, {@link GeneratorNode GeneratorNodes}, or single param
       *  functions that are immediately called with `this` node as argument, and which may append elements themselves.
       *
       * @returns `this` {@link CompositeGeneratorNode} for convenience.
       *
       * @example
       *   new CompositeGeneratorNode().append(
       *      'Hello World!'
       *   ).appendNewLine().appendIf(
       *      entity !== undefined, `Hello ${entity?.name}!`
       *   ).appendNewLineIfNotEmpty();
       */
      appendIf(condition, ...content) {
        return condition ? this.append(...content) : this;
      }
      /**
       * Appends a strict {@link NewLineNode} to `this` node.
       * Strict {@link NewLineNode}s yield mandatory linebreaks in the derived generated text.
       *
       * @returns `this` {@link CompositeGeneratorNode} for convenience.
       *
       * @example
       *   new CompositeGeneratorNode().append(
       *      'Hello World!'
       *   ).appendNewLine();
       */
      appendNewLine() {
        return this.append(exports2.NL);
      }
      /**
       * Appends a strict {@link NewLineNode} to `this` node, if `condition` is equal to `true`.
       * Strict {@link NewLineNode}s yield mandatory linebreaks in the derived generated text.
       *
       * @param condition a boolean value indicating whether to append a {@link NewLineNode} to `this`.
       *
       * @returns `this` {@link CompositeGeneratorNode} for convenience.
       *
       * @example
       *   new CompositeGeneratorNode().append(
       *      'Hello World!'
       *   ).appendNewLineIf(entity !== undefined).appendIf(
       *      entity !== undefined, `Hello ${entity?.name}!`
       *   )
       */
      appendNewLineIf(condition) {
        return condition ? this.append(exports2.NL) : this;
      }
      /**
       * Appends a soft {@link NewLineNode} to `this` node.
       * Soft {@link NewLineNode}s yield linebreaks in the derived generated text only if the preceding line is non-empty,
       * i.e. there are non-whitespace characters added to the generated text since the last linebreak.
       *
       * @returns `this` {@link CompositeGeneratorNode} for convenience.
       *
       * @example
       *   new CompositeGeneratorNode().appendIf(
       *      entity !== undefined, `Hello ${entity?.name}!`
       *   ).appendNewLineIfNotEmpty();
       */
      appendNewLineIfNotEmpty() {
        return this.append(exports2.NLEmpty);
      }
      /**
       * Appends a soft {@link NewLineNode} to `this` node, if `condition` is equal to `true`.
       * Soft {@link NewLineNode}s yield linebreaks in the derived generated text only if the preceding line is non-empty,
       * i.e. there are non-whitespace characters added to the generated text since the last linebreak.
       *
       * @param condition a boolean value indicating whether to append a {@link NewLineNode} to `this`.
       *
       * @returns `this` {@link CompositeGeneratorNode} for convenience.
       *
       * @example
       *   new CompositeGeneratorNode().append(
       *      entity.label ?? ''
       *   ).appendNewLineIfNotEmptyIf(entity.description !== undefined).append(
       *      entity.description
       *   )
       */
      appendNewLineIfNotEmptyIf(condition) {
        return condition ? this.appendNewLineIfNotEmpty() : this;
      }
      /**
       * Convenience method for appending content in form of a template to `this` generation node.
       *
       * See {@link expandToNode} for details.
       *
       * @returns `this` {@link CompositeGeneratorNode} for convenience.
       *
       * @example
       *   new CompositeGeneratorNode().appendTemplate
       *       `Hello World!`
       *   .appendNewLine()
       */
      appendTemplate(staticParts, ...substitutions) {
        return this.append((0, template_node_1.expandToNode)(staticParts, ...substitutions));
      }
      /**
       * Convenience method for appending content in form of a template to `this` generator node, if `condition` is equal to `true`.
       *
       * This method returns a tag function that takes the desired template and does the processing.
       *
       * If `condition` is satisfied the tagged template delegates to {@link appendTemplate}, otherwise it returns just `this`.
       *
       * See {@link expandToNode} for details.
       *
       * @param condition a boolean value indicating whether to append the template content to `this`.
       *
       * @returns a tag function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.
       *
       * @example
       *   new CompositeGeneratorNode().appendTemplate
       *       `Hello World!`
       *   .appendNewLine().appendTemplateIf(entity !== undefined)
       *       `Hello ${entity?.name}!`
       *   .appendNewLineIfNotEmpty()
       */
      appendTemplateIf(condition) {
        return condition ? (staticParts, ...substitutions) => this.appendTemplate(staticParts, ...substitutions) : () => this;
      }
      /**
       * Adds an area of indented text output.
       * The content to be indented can be provided as an array consisting of strings and/or generation nodes
       * (undefined is permitted), or via a callback offering the `indentingNode` to which the content shall be appended.
       * Alternatively, an object satisfying {@link IndentConfig} can be provided taking the children as Array or via
       * a callback as described previously via the `indentedChildren` property.
       *
       * The remaining properties of {@link IndentConfig} have the following effects:
       *  - `indentation`: a specific indentation length or string, defaults to the global indentation setting if omitted, see {@link toString},
       *  - `indentEmptyLines`: apply indentation to empty lines, defaults to `false`
       *  - `indentImmediately`: apply the indentation immediately starting at the first line, defaults to `true`, might be set to `false`
       *    if preceding content is not terminated by any `newline`. If `false` the indentation is inserted only after child `newline` nodes
       *    followed by further content.
       *
       * @param childrenOrConfig an {@link Array} or callback contributing the children, or a config object satisfying {@link IndentConfig} alternatively.
       *
       * @returns `this` {@link CompositeGeneratorNode} for convenience.
       *
       * @example
       *   new CompositeGeneratorNode().append(
       *       '{'
       *   ).indent(indentingNode =>
       *       indentingNode.append(
       *           'name:', name, ','
       *       ).appendNewLine().appendIf(description !== undefined,
       *           'description:', description
       *       ).appendNewLineIfNotEmpty()
       *   ).append(
       *       '}'
       *   );
       */
      indent(childrenOrConfig) {
        const { indentedChildren, indentation, indentEmptyLines, indentImmediately } = Array.isArray(childrenOrConfig) || typeof childrenOrConfig === "function" ? { indentedChildren: childrenOrConfig } : typeof childrenOrConfig === "object" ? childrenOrConfig : {};
        const node = new IndentNode(indentation, indentImmediately, indentEmptyLines);
        this.contents.push(node);
        if (Array.isArray(indentedChildren)) {
          node.append(...indentedChildren);
        } else if (indentedChildren) {
          node.append(indentedChildren);
        }
        return this;
      }
      // implementation:
      appendTraced(source, property, index) {
        return (content) => {
          return this.append(new CompositeGeneratorNode().trace(source, property, index).append(content));
        };
      }
      // implementation:
      appendTracedIf(condition, source, property, index) {
        return condition ? this.appendTraced(typeof source === "function" ? source() : source, property, index) : () => this;
      }
      // implementation:
      appendTracedTemplate(source, property, index) {
        return (staticParts, ...substitutions) => {
          return this.append((0, template_node_1.expandTracedToNode)(source, property, index)(staticParts, ...substitutions));
        };
      }
      // implementation:
      appendTracedTemplateIf(condition, source, property, index) {
        return condition ? this.appendTracedTemplate(typeof source === "function" ? source() : source, property, index) : () => this;
      }
    };
    exports2.CompositeGeneratorNode = CompositeGeneratorNode;
    function traceToNode(astNode, property, index) {
      return (content) => {
        if (content instanceof CompositeGeneratorNode && content.tracedSource === void 0) {
          return content.trace(astNode, property, index);
        } else {
          return new CompositeGeneratorNode().trace(astNode, property, index).append(content);
        }
      };
    }
    exports2.traceToNode = traceToNode;
    function traceToNodeIf(condition, source, property, index) {
      return condition ? traceToNode(typeof source === "function" ? source() : source, property, index) : () => void 0;
    }
    exports2.traceToNodeIf = traceToNodeIf;
    var IndentNode = class extends CompositeGeneratorNode {
      constructor(indentation, indentImmediately = true, indentEmptyLines = false) {
        super();
        this.indentImmediately = true;
        this.indentEmptyLines = false;
        if (typeof indentation === "string") {
          this.indentation = indentation;
        } else if (typeof indentation === "number") {
          this.indentation = "".padStart(indentation);
        }
        this.indentImmediately = indentImmediately;
        this.indentEmptyLines = indentEmptyLines;
      }
    };
    exports2.IndentNode = IndentNode;
    var NewLineNode = class {
      constructor(lineDelimiter, ifNotEmpty = false) {
        this.ifNotEmpty = false;
        this.lineDelimiter = lineDelimiter !== null && lineDelimiter !== void 0 ? lineDelimiter : exports2.EOL;
        this.ifNotEmpty = ifNotEmpty;
      }
    };
    exports2.NewLineNode = NewLineNode;
    exports2.NL = new NewLineNode();
    exports2.NLEmpty = new NewLineNode(void 0, true);
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/type-collector/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/type-collector/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMandatoryPropertyType = exports2.propertyTypeToString = exports2.isTypeAssignable = exports2.TypeResolutionError = exports2.InterfaceType = exports2.UnionType = exports2.isInterfaceType = exports2.isUnionType = exports2.isStringType = exports2.isPrimitiveType = exports2.isValueType = exports2.flattenPropertyUnion = exports2.isPropertyUnion = exports2.isArrayType = exports2.isReferenceType = void 0;
    var generator_node_1 = require_generator_node();
    var types_util_1 = require_types_util();
    function isReferenceType(propertyType) {
      return "referenceType" in propertyType;
    }
    exports2.isReferenceType = isReferenceType;
    function isArrayType(propertyType) {
      return "elementType" in propertyType;
    }
    exports2.isArrayType = isArrayType;
    function isPropertyUnion(propertyType) {
      return "types" in propertyType;
    }
    exports2.isPropertyUnion = isPropertyUnion;
    function flattenPropertyUnion(propertyType) {
      if (isPropertyUnion(propertyType)) {
        const items = [];
        for (const type of propertyType.types) {
          items.push(...flattenPropertyUnion(type));
        }
        return items;
      } else {
        return [propertyType];
      }
    }
    exports2.flattenPropertyUnion = flattenPropertyUnion;
    function isValueType(propertyType) {
      return "value" in propertyType;
    }
    exports2.isValueType = isValueType;
    function isPrimitiveType(propertyType) {
      return "primitive" in propertyType;
    }
    exports2.isPrimitiveType = isPrimitiveType;
    function isStringType(propertyType) {
      return "string" in propertyType;
    }
    exports2.isStringType = isStringType;
    function isUnionType(type) {
      return type && "type" in type;
    }
    exports2.isUnionType = isUnionType;
    function isInterfaceType(type) {
      return type && "properties" in type;
    }
    exports2.isInterfaceType = isInterfaceType;
    var UnionType = class {
      constructor(name, options) {
        var _a;
        this.superTypes = /* @__PURE__ */ new Set();
        this.subTypes = /* @__PURE__ */ new Set();
        this.containerTypes = /* @__PURE__ */ new Set();
        this.typeNames = /* @__PURE__ */ new Set();
        this.name = name;
        this.declared = (_a = options === null || options === void 0 ? void 0 : options.declared) !== null && _a !== void 0 ? _a : false;
        this.dataType = options === null || options === void 0 ? void 0 : options.dataType;
      }
      toAstTypesString(reflectionInfo) {
        const unionNode = new generator_node_1.CompositeGeneratorNode();
        unionNode.append(`export type ${this.name} = ${propertyTypeToString(this.type, "AstType")};`, generator_node_1.NL);
        if (reflectionInfo) {
          unionNode.append(generator_node_1.NL);
          pushReflectionInfo(unionNode, this.name);
        }
        if (this.dataType) {
          pushDataTypeReflectionInfo(unionNode, this);
        }
        return (0, generator_node_1.toString)(unionNode);
      }
      toDeclaredTypesString(reservedWords) {
        const unionNode = new generator_node_1.CompositeGeneratorNode();
        unionNode.append(`type ${escapeReservedWords(this.name, reservedWords)} = ${propertyTypeToString(this.type, "DeclaredType")};`, generator_node_1.NL);
        return (0, generator_node_1.toString)(unionNode);
      }
    };
    exports2.UnionType = UnionType;
    var InterfaceType = class {
      get superProperties() {
        return this.getSuperProperties(/* @__PURE__ */ new Set());
      }
      getSuperProperties(visited) {
        if (visited.has(this.name)) {
          return [];
        } else {
          visited.add(this.name);
        }
        const map = /* @__PURE__ */ new Map();
        for (const property of this.properties) {
          map.set(property.name, property);
        }
        for (const superType of this.interfaceSuperTypes) {
          const allSuperProperties = superType.getSuperProperties(visited);
          for (const superProp of allSuperProperties) {
            if (!map.has(superProp.name)) {
              map.set(superProp.name, superProp);
            }
          }
        }
        return Array.from(map.values());
      }
      get allProperties() {
        const map = new Map(this.superProperties.map((e) => [e.name, e]));
        for (const subType of this.subTypes) {
          this.getSubTypeProperties(subType, map, /* @__PURE__ */ new Set());
        }
        const superProps = Array.from(map.values());
        return superProps;
      }
      getSubTypeProperties(type, map, visited) {
        if (visited.has(this.name)) {
          return;
        } else {
          visited.add(this.name);
        }
        const props = isInterfaceType(type) ? type.properties : [];
        for (const prop of props) {
          if (!map.has(prop.name)) {
            map.set(prop.name, prop);
          }
        }
        for (const subType of type.subTypes) {
          this.getSubTypeProperties(subType, map, visited);
        }
      }
      get interfaceSuperTypes() {
        return Array.from(this.superTypes).filter((e) => e instanceof InterfaceType);
      }
      constructor(name, declared, abstract) {
        this.superTypes = /* @__PURE__ */ new Set();
        this.subTypes = /* @__PURE__ */ new Set();
        this.containerTypes = /* @__PURE__ */ new Set();
        this.typeNames = /* @__PURE__ */ new Set();
        this.declared = false;
        this.abstract = false;
        this.properties = [];
        this.name = name;
        this.declared = declared;
        this.abstract = abstract;
      }
      toAstTypesString(reflectionInfo) {
        const interfaceNode = new generator_node_1.CompositeGeneratorNode();
        const interfaceSuperTypes = this.interfaceSuperTypes.map((e) => e.name);
        const superTypes = interfaceSuperTypes.length > 0 ? (0, types_util_1.distinctAndSorted)([...interfaceSuperTypes]) : ["AstNode"];
        interfaceNode.append(`export interface ${this.name} extends ${superTypes.join(", ")} {`, generator_node_1.NL);
        interfaceNode.indent((body) => {
          if (this.containerTypes.size > 0) {
            body.append(`readonly $container: ${(0, types_util_1.distinctAndSorted)([...this.containerTypes].map((e) => e.name)).join(" | ")};`, generator_node_1.NL);
          }
          if (this.typeNames.size > 0) {
            body.append(`readonly $type: ${(0, types_util_1.distinctAndSorted)([...this.typeNames]).map((e) => `'${e}'`).join(" | ")};`, generator_node_1.NL);
          }
          pushProperties(body, this.properties, "AstType");
        });
        interfaceNode.append("}", generator_node_1.NL);
        if (reflectionInfo) {
          interfaceNode.append(generator_node_1.NL);
          pushReflectionInfo(interfaceNode, this.name);
        }
        return (0, generator_node_1.toString)(interfaceNode);
      }
      toDeclaredTypesString(reservedWords) {
        const interfaceNode = new generator_node_1.CompositeGeneratorNode();
        const name = escapeReservedWords(this.name, reservedWords);
        const superTypes = (0, types_util_1.distinctAndSorted)(this.interfaceSuperTypes.map((e) => e.name)).join(", ");
        interfaceNode.append(`interface ${name}${superTypes.length > 0 ? ` extends ${superTypes}` : ""} {`, generator_node_1.NL);
        interfaceNode.indent((body) => pushProperties(body, this.properties, "DeclaredType", reservedWords));
        interfaceNode.append("}", generator_node_1.NL);
        return (0, generator_node_1.toString)(interfaceNode);
      }
    };
    exports2.InterfaceType = InterfaceType;
    var TypeResolutionError = class extends Error {
      constructor(message, target) {
        super(message);
        this.name = "TypeResolutionError";
        this.target = target;
      }
    };
    exports2.TypeResolutionError = TypeResolutionError;
    function isTypeAssignable(from, to) {
      if (isPropertyUnion(from)) {
        return from.types.every((fromType) => isTypeAssignable(fromType, to));
      } else if (isPropertyUnion(to)) {
        return to.types.some((toType) => isTypeAssignable(from, toType));
      } else if (isValueType(to) && isUnionType(to.value)) {
        if (isValueType(from) && isUnionType(from.value) && to.value.name === from.value.name) {
          return true;
        }
        return isTypeAssignable(from, to.value.type);
      } else if (isReferenceType(from)) {
        return isReferenceType(to) && isTypeAssignable(from.referenceType, to.referenceType);
      } else if (isArrayType(from)) {
        return isArrayType(to) && isTypeAssignable(from.elementType, to.elementType);
      } else if (isValueType(from)) {
        if (isUnionType(from.value)) {
          return isTypeAssignable(from.value.type, to);
        }
        if (!isValueType(to)) {
          return false;
        }
        if (isUnionType(to.value)) {
          return isTypeAssignable(from, to.value.type);
        } else {
          return isInterfaceAssignable(from.value, to.value, /* @__PURE__ */ new Set());
        }
      } else if (isPrimitiveType(from)) {
        return isPrimitiveType(to) && from.primitive === to.primitive;
      } else if (isStringType(from)) {
        return isPrimitiveType(to) && to.primitive === "string" || isStringType(to) && to.string === from.string;
      }
      return false;
    }
    exports2.isTypeAssignable = isTypeAssignable;
    function isInterfaceAssignable(from, to, visited) {
      if (visited.has(from.name)) {
        return true;
      } else {
        visited.add(from.name);
      }
      if (from.name === to.name) {
        return true;
      }
      for (const superType of from.superTypes) {
        if (isInterfaceType(superType) && isInterfaceAssignable(superType, to, visited)) {
          return true;
        }
      }
      return false;
    }
    function propertyTypeToString(type, mode = "AstType") {
      if (isReferenceType(type)) {
        const refType = propertyTypeToString(type.referenceType, mode);
        return mode === "AstType" ? `Reference<${refType}>` : `@${typeParenthesis(type.referenceType, refType)}`;
      } else if (isArrayType(type)) {
        const arrayType = propertyTypeToString(type.elementType, mode);
        return mode === "AstType" ? `Array<${arrayType}>` : `${typeParenthesis(type.elementType, arrayType)}[]`;
      } else if (isPropertyUnion(type)) {
        const types = type.types.map((e) => typeParenthesis(e, propertyTypeToString(e, mode)));
        return (0, types_util_1.distinctAndSorted)(types).join(" | ");
      } else if (isValueType(type)) {
        return type.value.name;
      } else if (isPrimitiveType(type)) {
        return type.primitive;
      } else if (isStringType(type)) {
        const delimiter = mode === "AstType" ? "'" : '"';
        return `${delimiter}${type.string}${delimiter}`;
      }
      throw new Error("Invalid type");
    }
    exports2.propertyTypeToString = propertyTypeToString;
    function typeParenthesis(type, name) {
      const needsParenthesis = isPropertyUnion(type);
      if (needsParenthesis) {
        name = `(${name})`;
      }
      return name;
    }
    function pushProperties(node, properties, mode, reserved = /* @__PURE__ */ new Set()) {
      function propertyToString(property) {
        const name = mode === "AstType" ? property.name : escapeReservedWords(property.name, reserved);
        const optional = property.optional && !isMandatoryPropertyType(property.type);
        const propType = propertyTypeToString(property.type, mode);
        return `${name}${optional ? "?" : ""}: ${propType}`;
      }
      (0, types_util_1.distinctAndSorted)(properties, (a, b) => a.name.localeCompare(b.name)).forEach((property) => node.append(propertyToString(property), generator_node_1.NL));
    }
    function isMandatoryPropertyType(propertyType) {
      if (isArrayType(propertyType)) {
        return true;
      } else if (isReferenceType(propertyType)) {
        return false;
      } else if (isPropertyUnion(propertyType)) {
        return propertyType.types.every((e) => isMandatoryPropertyType(e));
      } else if (isPrimitiveType(propertyType)) {
        const value = propertyType.primitive;
        return value === "boolean";
      } else {
        return false;
      }
    }
    exports2.isMandatoryPropertyType = isMandatoryPropertyType;
    function pushReflectionInfo(node, name) {
      node.append(`export const ${name} = '${name}';`, generator_node_1.NL);
      node.append(generator_node_1.NL);
      node.append(`export function is${name}(item: unknown): item is ${name} {`, generator_node_1.NL);
      node.indent((body) => body.append(`return reflection.isInstance(item, ${name});`, generator_node_1.NL));
      node.append("}", generator_node_1.NL);
    }
    function pushDataTypeReflectionInfo(node, union) {
      switch (union.dataType) {
        case "string":
          if (containsOnlyStringTypes(union.type)) {
            const subTypes = Array.from(union.subTypes).map((e) => e.name);
            const strings = collectStringValuesFromDataType(union.type);
            const regexes = collectRegexesFromDataType(union.type);
            if (subTypes.length === 0 && strings.length === 0 && regexes.length === 0) {
              generateIsDataTypeFunction(node, union.name, `typeof item === '${union.dataType}'`);
            } else {
              const returnString = createDataTypeCheckerFunctionReturnString(subTypes, strings, regexes);
              generateIsDataTypeFunction(node, union.name, returnString);
            }
          }
          break;
        case "number":
        case "boolean":
        case "bigint":
          generateIsDataTypeFunction(node, union.name, `typeof item === '${union.dataType}'`);
          break;
        case "Date":
          generateIsDataTypeFunction(node, union.name, "item instanceof Date");
          break;
        default:
          return;
      }
    }
    function containsOnlyStringTypes(propertyType) {
      let result = true;
      if (isPrimitiveType(propertyType)) {
        if (propertyType.primitive === "string") {
          return true;
        } else {
          return false;
        }
      } else if (isStringType(propertyType)) {
        return true;
      } else if (!isPropertyUnion(propertyType)) {
        return false;
      } else {
        for (const type of propertyType.types) {
          if (isValueType(type)) {
            if (isUnionType(type.value)) {
              if (!containsOnlyStringTypes(type.value.type)) {
                return false;
              }
            } else {
              return false;
            }
          } else if (isPrimitiveType(type)) {
            if (type.primitive !== "string" || !type.regex) {
              return false;
            }
          } else if (isPropertyUnion(type)) {
            result = containsOnlyStringTypes(type);
          } else if (!isStringType(type)) {
            return false;
          }
        }
      }
      return result;
    }
    function createDataTypeCheckerFunctionReturnString(subTypes, strings, regexes) {
      const allArray = [
        ...subTypes.map((e) => `is${e}(item)`),
        ...strings.map((e) => `item === '${e}'`)
      ];
      if (regexes.length > 0) {
        const joinedRegexes = regexes.map((e) => `/${e}/.test(item)`).join(" || ");
        allArray.push(`(typeof item === 'string' && (${joinedRegexes}))`);
      }
      return allArray.join(" || ");
    }
    function escapeReservedWords(name, reserved) {
      return reserved.has(name) ? `^${name}` : name;
    }
    function collectStringValuesFromDataType(propertyType) {
      const values = [];
      if (isStringType(propertyType)) {
        return [propertyType.string];
      }
      if (isPropertyUnion(propertyType)) {
        for (const type of propertyType.types) {
          if (isStringType(type)) {
            values.push(type.string);
          } else if (isPropertyUnion(type)) {
            values.push(...collectStringValuesFromDataType(type));
          }
        }
      }
      return values;
    }
    function collectRegexesFromDataType(propertyType) {
      const regexes = [];
      if (isPrimitiveType(propertyType) && propertyType.primitive === "string" && propertyType.regex) {
        regexes.push(propertyType.regex);
      }
      if (isPropertyUnion(propertyType)) {
        for (const type of propertyType.types) {
          if (isPrimitiveType(type) && type.primitive === "string" && type.regex) {
            regexes.push(type.regex);
          } else if (isPropertyUnion(type)) {
            regexes.push(...collectRegexesFromDataType(type));
          }
        }
      }
      return regexes;
    }
    function generateIsDataTypeFunction(node, unionName, returnString) {
      node.append(generator_node_1.NL, `export function is${unionName}(item: unknown): item is ${unionName} {`, generator_node_1.NL);
      node.indent((body) => body.append(`return ${returnString};`, generator_node_1.NL));
      node.append("}", generator_node_1.NL);
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/types-util.js
var require_types_util = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/types-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAstType = exports2.findReferenceTypes = exports2.hasBooleanType = exports2.hasArrayType = exports2.sortInterfacesTopologically = exports2.mergeTypesAndInterfaces = exports2.mergeInterfaces = exports2.collectSuperTypes = exports2.collectTypeHierarchy = exports2.collectChildrenTypes = exports2.distinctAndSorted = exports2.collectAllPlainProperties = void 0;
    var collections_1 = require_collections();
    var ast_1 = require_ast();
    var types_1 = require_types();
    function collectAllPlainProperties(interfaces) {
      const map = new collections_1.MultiMap();
      for (const interfaceType of interfaces) {
        map.addAll(interfaceType.name, interfaceType.properties);
      }
      for (const interfaceType of interfaces) {
        for (const superType of interfaceType.superTypes) {
          const superTypeProperties = map.get(superType);
          if (superTypeProperties) {
            map.addAll(interfaceType.name, superTypeProperties);
          }
        }
      }
      return map;
    }
    exports2.collectAllPlainProperties = collectAllPlainProperties;
    function distinctAndSorted(list, compareFn) {
      return Array.from(new Set(list)).sort(compareFn);
    }
    exports2.distinctAndSorted = distinctAndSorted;
    function collectChildrenTypes(interfaceNode, references, langiumDocuments, nodeLocator) {
      const childrenTypes = /* @__PURE__ */ new Set();
      childrenTypes.add(interfaceNode);
      const refs = references.findReferences(interfaceNode, {});
      refs.forEach((ref) => {
        const doc = langiumDocuments.getOrCreateDocument(ref.sourceUri);
        const astNode = nodeLocator.getAstNode(doc.parseResult.value, ref.sourcePath);
        if ((0, ast_1.isInterface)(astNode)) {
          childrenTypes.add(astNode);
          const childrenOfInterface = collectChildrenTypes(astNode, references, langiumDocuments, nodeLocator);
          childrenOfInterface.forEach((child) => childrenTypes.add(child));
        } else if (astNode && (0, ast_1.isType)(astNode.$container)) {
          childrenTypes.add(astNode.$container);
        }
      });
      return childrenTypes;
    }
    exports2.collectChildrenTypes = collectChildrenTypes;
    function collectTypeHierarchy(types) {
      const allTypes = new Set(types);
      const duplicateSuperTypes = new collections_1.MultiMap();
      const duplicateSubTypes = new collections_1.MultiMap();
      for (const type of allTypes) {
        for (const superType of type.superTypes) {
          if (allTypes.has(superType)) {
            duplicateSuperTypes.add(type.name, superType.name);
            duplicateSubTypes.add(superType.name, type.name);
          }
        }
        for (const subType of type.subTypes) {
          if (allTypes.has(subType)) {
            duplicateSuperTypes.add(subType.name, type.name);
            duplicateSubTypes.add(type.name, subType.name);
          }
        }
      }
      const superTypes = new collections_1.MultiMap();
      const subTypes = new collections_1.MultiMap();
      for (const [name, superTypeList] of Array.from(duplicateSuperTypes.entriesGroupedByKey()).sort(([aName], [bName]) => aName.localeCompare(bName))) {
        superTypes.addAll(name, Array.from(new Set(superTypeList)));
      }
      for (const [name, subTypeList] of Array.from(duplicateSubTypes.entriesGroupedByKey()).sort(([aName], [bName]) => aName.localeCompare(bName))) {
        subTypes.addAll(name, Array.from(new Set(subTypeList)));
      }
      return {
        superTypes,
        subTypes
      };
    }
    exports2.collectTypeHierarchy = collectTypeHierarchy;
    function collectSuperTypes(ruleNode) {
      const superTypes = /* @__PURE__ */ new Set();
      if ((0, ast_1.isInterface)(ruleNode)) {
        superTypes.add(ruleNode);
        ruleNode.superTypes.forEach((superType) => {
          if ((0, ast_1.isInterface)(superType.ref)) {
            superTypes.add(superType.ref);
            const collectedSuperTypes = collectSuperTypes(superType.ref);
            for (const superType2 of collectedSuperTypes) {
              superTypes.add(superType2);
            }
          }
        });
      } else if ((0, ast_1.isType)(ruleNode)) {
        const usedTypes = collectUsedTypes(ruleNode.type);
        for (const usedType of usedTypes) {
          const collectedSuperTypes = collectSuperTypes(usedType);
          for (const superType of collectedSuperTypes) {
            superTypes.add(superType);
          }
        }
      }
      return superTypes;
    }
    exports2.collectSuperTypes = collectSuperTypes;
    function collectUsedTypes(typeDefinition) {
      var _a;
      if ((0, ast_1.isUnionType)(typeDefinition)) {
        return typeDefinition.types.flatMap((e) => collectUsedTypes(e));
      } else if ((0, ast_1.isSimpleType)(typeDefinition)) {
        const value = (_a = typeDefinition.typeRef) === null || _a === void 0 ? void 0 : _a.ref;
        if ((0, ast_1.isType)(value) || (0, ast_1.isInterface)(value)) {
          return [value];
        }
      }
      return [];
    }
    function mergeInterfaces(inferred, declared) {
      return inferred.interfaces.concat(declared.interfaces);
    }
    exports2.mergeInterfaces = mergeInterfaces;
    function mergeTypesAndInterfaces(astTypes) {
      return astTypes.interfaces.concat(astTypes.unions);
    }
    exports2.mergeTypesAndInterfaces = mergeTypesAndInterfaces;
    function sortInterfacesTopologically(interfaces) {
      const nodes = interfaces.sort((a, b) => a.name.localeCompare(b.name)).map((e) => ({ value: e, nodes: [] }));
      for (const node of nodes) {
        node.nodes = nodes.filter((e) => node.value.superTypes.has(e.value.name));
      }
      const l = [];
      const s = nodes.filter((e) => e.nodes.length === 0);
      while (s.length > 0) {
        const n = s.shift();
        if (!l.includes(n)) {
          l.push(n);
          nodes.filter((e) => e.nodes.includes(n)).forEach((m) => s.push(m));
        }
      }
      return l.map((e) => e.value);
    }
    exports2.sortInterfacesTopologically = sortInterfacesTopologically;
    function hasArrayType(type) {
      if ((0, types_1.isPropertyUnion)(type)) {
        return type.types.some((e) => hasArrayType(e));
      } else if ((0, types_1.isArrayType)(type)) {
        return true;
      } else {
        return false;
      }
    }
    exports2.hasArrayType = hasArrayType;
    function hasBooleanType(type) {
      if ((0, types_1.isPropertyUnion)(type)) {
        return type.types.some((e) => hasBooleanType(e));
      } else if ((0, types_1.isPrimitiveType)(type)) {
        return type.primitive === "boolean";
      } else {
        return false;
      }
    }
    exports2.hasBooleanType = hasBooleanType;
    function findReferenceTypes(type) {
      if ((0, types_1.isPropertyUnion)(type)) {
        return type.types.flatMap((e) => findReferenceTypes(e));
      } else if ((0, types_1.isReferenceType)(type)) {
        const refType = type.referenceType;
        if ((0, types_1.isValueType)(refType)) {
          return [refType.value.name];
        }
      } else if ((0, types_1.isArrayType)(type)) {
        return findReferenceTypes(type.elementType);
      }
      return [];
    }
    exports2.findReferenceTypes = findReferenceTypes;
    function isAstType(type) {
      if ((0, types_1.isPropertyUnion)(type)) {
        return type.types.every(isAstType);
      } else if ((0, types_1.isValueType)(type)) {
        const value = type.value;
        if ("type" in value) {
          return isAstType(value.type);
        } else {
          return true;
        }
      }
      return false;
    }
    exports2.isAstType = isAstType;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/references/name-provider.js
var require_name_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/references/name-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultNameProvider = exports2.isNamed = void 0;
    var grammar_util_1 = require_grammar_util();
    function isNamed(node) {
      return typeof node.name === "string";
    }
    exports2.isNamed = isNamed;
    var DefaultNameProvider = class {
      getName(node) {
        if (isNamed(node)) {
          return node.name;
        }
        return void 0;
      }
      getNameNode(node) {
        return (0, grammar_util_1.findNodeForProperty)(node.$cstNode, "name");
      }
    };
    exports2.DefaultNameProvider = DefaultNameProvider;
  }
});

// ../../node_modules/.pnpm/regexp-to-ast@0.5.0/node_modules/regexp-to-ast/lib/regexp-to-ast.js
var require_regexp_to_ast = __commonJS({
  "../../node_modules/.pnpm/regexp-to-ast@0.5.0/node_modules/regexp-to-ast/lib/regexp-to-ast.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.regexpToAst = factory();
      }
    })(
      typeof self !== "undefined" ? (
        // istanbul ignore next
        self
      ) : exports2,
      function() {
        function RegExpParser() {
        }
        RegExpParser.prototype.saveState = function() {
          return {
            idx: this.idx,
            input: this.input,
            groupIdx: this.groupIdx
          };
        };
        RegExpParser.prototype.restoreState = function(newState) {
          this.idx = newState.idx;
          this.input = newState.input;
          this.groupIdx = newState.groupIdx;
        };
        RegExpParser.prototype.pattern = function(input) {
          this.idx = 0;
          this.input = input;
          this.groupIdx = 0;
          this.consumeChar("/");
          var value = this.disjunction();
          this.consumeChar("/");
          var flags = {
            type: "Flags",
            loc: { begin: this.idx, end: input.length },
            global: false,
            ignoreCase: false,
            multiLine: false,
            unicode: false,
            sticky: false
          };
          while (this.isRegExpFlag()) {
            switch (this.popChar()) {
              case "g":
                addFlag(flags, "global");
                break;
              case "i":
                addFlag(flags, "ignoreCase");
                break;
              case "m":
                addFlag(flags, "multiLine");
                break;
              case "u":
                addFlag(flags, "unicode");
                break;
              case "y":
                addFlag(flags, "sticky");
                break;
            }
          }
          if (this.idx !== this.input.length) {
            throw Error(
              "Redundant input: " + this.input.substring(this.idx)
            );
          }
          return {
            type: "Pattern",
            flags,
            value,
            loc: this.loc(0)
          };
        };
        RegExpParser.prototype.disjunction = function() {
          var alts = [];
          var begin = this.idx;
          alts.push(this.alternative());
          while (this.peekChar() === "|") {
            this.consumeChar("|");
            alts.push(this.alternative());
          }
          return { type: "Disjunction", value: alts, loc: this.loc(begin) };
        };
        RegExpParser.prototype.alternative = function() {
          var terms = [];
          var begin = this.idx;
          while (this.isTerm()) {
            terms.push(this.term());
          }
          return { type: "Alternative", value: terms, loc: this.loc(begin) };
        };
        RegExpParser.prototype.term = function() {
          if (this.isAssertion()) {
            return this.assertion();
          } else {
            return this.atom();
          }
        };
        RegExpParser.prototype.assertion = function() {
          var begin = this.idx;
          switch (this.popChar()) {
            case "^":
              return {
                type: "StartAnchor",
                loc: this.loc(begin)
              };
            case "$":
              return { type: "EndAnchor", loc: this.loc(begin) };
            case "\\":
              switch (this.popChar()) {
                case "b":
                  return {
                    type: "WordBoundary",
                    loc: this.loc(begin)
                  };
                case "B":
                  return {
                    type: "NonWordBoundary",
                    loc: this.loc(begin)
                  };
              }
              throw Error("Invalid Assertion Escape");
            case "(":
              this.consumeChar("?");
              var type;
              switch (this.popChar()) {
                case "=":
                  type = "Lookahead";
                  break;
                case "!":
                  type = "NegativeLookahead";
                  break;
              }
              ASSERT_EXISTS(type);
              var disjunction = this.disjunction();
              this.consumeChar(")");
              return {
                type,
                value: disjunction,
                loc: this.loc(begin)
              };
          }
          ASSERT_NEVER_REACH_HERE();
        };
        RegExpParser.prototype.quantifier = function(isBacktracking) {
          var range;
          var begin = this.idx;
          switch (this.popChar()) {
            case "*":
              range = {
                atLeast: 0,
                atMost: Infinity
              };
              break;
            case "+":
              range = {
                atLeast: 1,
                atMost: Infinity
              };
              break;
            case "?":
              range = {
                atLeast: 0,
                atMost: 1
              };
              break;
            case "{":
              var atLeast = this.integerIncludingZero();
              switch (this.popChar()) {
                case "}":
                  range = {
                    atLeast,
                    atMost: atLeast
                  };
                  break;
                case ",":
                  var atMost;
                  if (this.isDigit()) {
                    atMost = this.integerIncludingZero();
                    range = {
                      atLeast,
                      atMost
                    };
                  } else {
                    range = {
                      atLeast,
                      atMost: Infinity
                    };
                  }
                  this.consumeChar("}");
                  break;
              }
              if (isBacktracking === true && range === void 0) {
                return void 0;
              }
              ASSERT_EXISTS(range);
              break;
          }
          if (isBacktracking === true && range === void 0) {
            return void 0;
          }
          ASSERT_EXISTS(range);
          if (this.peekChar(0) === "?") {
            this.consumeChar("?");
            range.greedy = false;
          } else {
            range.greedy = true;
          }
          range.type = "Quantifier";
          range.loc = this.loc(begin);
          return range;
        };
        RegExpParser.prototype.atom = function() {
          var atom;
          var begin = this.idx;
          switch (this.peekChar()) {
            case ".":
              atom = this.dotAll();
              break;
            case "\\":
              atom = this.atomEscape();
              break;
            case "[":
              atom = this.characterClass();
              break;
            case "(":
              atom = this.group();
              break;
          }
          if (atom === void 0 && this.isPatternCharacter()) {
            atom = this.patternCharacter();
          }
          ASSERT_EXISTS(atom);
          atom.loc = this.loc(begin);
          if (this.isQuantifier()) {
            atom.quantifier = this.quantifier();
          }
          return atom;
        };
        RegExpParser.prototype.dotAll = function() {
          this.consumeChar(".");
          return {
            type: "Set",
            complement: true,
            value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
          };
        };
        RegExpParser.prototype.atomEscape = function() {
          this.consumeChar("\\");
          switch (this.peekChar()) {
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return this.decimalEscapeAtom();
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
              return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
              return this.controlEscapeAtom();
            case "c":
              return this.controlLetterEscapeAtom();
            case "0":
              return this.nulCharacterAtom();
            case "x":
              return this.hexEscapeSequenceAtom();
            case "u":
              return this.regExpUnicodeEscapeSequenceAtom();
            default:
              return this.identityEscapeAtom();
          }
        };
        RegExpParser.prototype.decimalEscapeAtom = function() {
          var value = this.positiveInteger();
          return { type: "GroupBackReference", value };
        };
        RegExpParser.prototype.characterClassEscape = function() {
          var set;
          var complement = false;
          switch (this.popChar()) {
            case "d":
              set = digitsCharCodes;
              break;
            case "D":
              set = digitsCharCodes;
              complement = true;
              break;
            case "s":
              set = whitespaceCodes;
              break;
            case "S":
              set = whitespaceCodes;
              complement = true;
              break;
            case "w":
              set = wordCharCodes;
              break;
            case "W":
              set = wordCharCodes;
              complement = true;
              break;
          }
          ASSERT_EXISTS(set);
          return { type: "Set", value: set, complement };
        };
        RegExpParser.prototype.controlEscapeAtom = function() {
          var escapeCode;
          switch (this.popChar()) {
            case "f":
              escapeCode = cc("\f");
              break;
            case "n":
              escapeCode = cc("\n");
              break;
            case "r":
              escapeCode = cc("\r");
              break;
            case "t":
              escapeCode = cc("	");
              break;
            case "v":
              escapeCode = cc("\v");
              break;
          }
          ASSERT_EXISTS(escapeCode);
          return { type: "Character", value: escapeCode };
        };
        RegExpParser.prototype.controlLetterEscapeAtom = function() {
          this.consumeChar("c");
          var letter = this.popChar();
          if (/[a-zA-Z]/.test(letter) === false) {
            throw Error("Invalid ");
          }
          var letterCode = letter.toUpperCase().charCodeAt(0) - 64;
          return { type: "Character", value: letterCode };
        };
        RegExpParser.prototype.nulCharacterAtom = function() {
          this.consumeChar("0");
          return { type: "Character", value: cc("\0") };
        };
        RegExpParser.prototype.hexEscapeSequenceAtom = function() {
          this.consumeChar("x");
          return this.parseHexDigits(2);
        };
        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {
          this.consumeChar("u");
          return this.parseHexDigits(4);
        };
        RegExpParser.prototype.identityEscapeAtom = function() {
          var escapedChar = this.popChar();
          return { type: "Character", value: cc(escapedChar) };
        };
        RegExpParser.prototype.classPatternCharacterAtom = function() {
          switch (this.peekChar()) {
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
            case "\\":
            case "]":
              throw Error("TBD");
            default:
              var nextChar = this.popChar();
              return { type: "Character", value: cc(nextChar) };
          }
        };
        RegExpParser.prototype.characterClass = function() {
          var set = [];
          var complement = false;
          this.consumeChar("[");
          if (this.peekChar(0) === "^") {
            this.consumeChar("^");
            complement = true;
          }
          while (this.isClassAtom()) {
            var from = this.classAtom();
            var isFromSingleChar = from.type === "Character";
            if (isFromSingleChar && this.isRangeDash()) {
              this.consumeChar("-");
              var to = this.classAtom();
              var isToSingleChar = to.type === "Character";
              if (isToSingleChar) {
                if (to.value < from.value) {
                  throw Error("Range out of order in character class");
                }
                set.push({ from: from.value, to: to.value });
              } else {
                insertToSet(from.value, set);
                set.push(cc("-"));
                insertToSet(to.value, set);
              }
            } else {
              insertToSet(from.value, set);
            }
          }
          this.consumeChar("]");
          return { type: "Set", complement, value: set };
        };
        RegExpParser.prototype.classAtom = function() {
          switch (this.peekChar()) {
            case "]":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              throw Error("TBD");
            case "\\":
              return this.classEscape();
            default:
              return this.classPatternCharacterAtom();
          }
        };
        RegExpParser.prototype.classEscape = function() {
          this.consumeChar("\\");
          switch (this.peekChar()) {
            case "b":
              this.consumeChar("b");
              return { type: "Character", value: cc("\b") };
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
              return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
              return this.controlEscapeAtom();
            case "c":
              return this.controlLetterEscapeAtom();
            case "0":
              return this.nulCharacterAtom();
            case "x":
              return this.hexEscapeSequenceAtom();
            case "u":
              return this.regExpUnicodeEscapeSequenceAtom();
            default:
              return this.identityEscapeAtom();
          }
        };
        RegExpParser.prototype.group = function() {
          var capturing = true;
          this.consumeChar("(");
          switch (this.peekChar(0)) {
            case "?":
              this.consumeChar("?");
              this.consumeChar(":");
              capturing = false;
              break;
            default:
              this.groupIdx++;
              break;
          }
          var value = this.disjunction();
          this.consumeChar(")");
          var groupAst = {
            type: "Group",
            capturing,
            value
          };
          if (capturing) {
            groupAst.idx = this.groupIdx;
          }
          return groupAst;
        };
        RegExpParser.prototype.positiveInteger = function() {
          var number = this.popChar();
          if (decimalPatternNoZero.test(number) === false) {
            throw Error("Expecting a positive integer");
          }
          while (decimalPattern.test(this.peekChar(0))) {
            number += this.popChar();
          }
          return parseInt(number, 10);
        };
        RegExpParser.prototype.integerIncludingZero = function() {
          var number = this.popChar();
          if (decimalPattern.test(number) === false) {
            throw Error("Expecting an integer");
          }
          while (decimalPattern.test(this.peekChar(0))) {
            number += this.popChar();
          }
          return parseInt(number, 10);
        };
        RegExpParser.prototype.patternCharacter = function() {
          var nextChar = this.popChar();
          switch (nextChar) {
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
              throw Error("TBD");
            default:
              return { type: "Character", value: cc(nextChar) };
          }
        };
        RegExpParser.prototype.isRegExpFlag = function() {
          switch (this.peekChar(0)) {
            case "g":
            case "i":
            case "m":
            case "u":
            case "y":
              return true;
            default:
              return false;
          }
        };
        RegExpParser.prototype.isRangeDash = function() {
          return this.peekChar() === "-" && this.isClassAtom(1);
        };
        RegExpParser.prototype.isDigit = function() {
          return decimalPattern.test(this.peekChar(0));
        };
        RegExpParser.prototype.isClassAtom = function(howMuch) {
          if (howMuch === void 0) {
            howMuch = 0;
          }
          switch (this.peekChar(howMuch)) {
            case "]":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return false;
            default:
              return true;
          }
        };
        RegExpParser.prototype.isTerm = function() {
          return this.isAtom() || this.isAssertion();
        };
        RegExpParser.prototype.isAtom = function() {
          if (this.isPatternCharacter()) {
            return true;
          }
          switch (this.peekChar(0)) {
            case ".":
            case "\\":
            case "[":
            case "(":
              return true;
            default:
              return false;
          }
        };
        RegExpParser.prototype.isAssertion = function() {
          switch (this.peekChar(0)) {
            case "^":
            case "$":
              return true;
            case "\\":
              switch (this.peekChar(1)) {
                case "b":
                case "B":
                  return true;
                default:
                  return false;
              }
            case "(":
              return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
            default:
              return false;
          }
        };
        RegExpParser.prototype.isQuantifier = function() {
          var prevState = this.saveState();
          try {
            return this.quantifier(true) !== void 0;
          } catch (e) {
            return false;
          } finally {
            this.restoreState(prevState);
          }
        };
        RegExpParser.prototype.isPatternCharacter = function() {
          switch (this.peekChar()) {
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
            case "/":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return false;
            default:
              return true;
          }
        };
        RegExpParser.prototype.parseHexDigits = function(howMany) {
          var hexString = "";
          for (var i2 = 0; i2 < howMany; i2++) {
            var hexChar = this.popChar();
            if (hexDigitPattern.test(hexChar) === false) {
              throw Error("Expecting a HexDecimal digits");
            }
            hexString += hexChar;
          }
          var charCode = parseInt(hexString, 16);
          return { type: "Character", value: charCode };
        };
        RegExpParser.prototype.peekChar = function(howMuch) {
          if (howMuch === void 0) {
            howMuch = 0;
          }
          return this.input[this.idx + howMuch];
        };
        RegExpParser.prototype.popChar = function() {
          var nextChar = this.peekChar(0);
          this.consumeChar();
          return nextChar;
        };
        RegExpParser.prototype.consumeChar = function(char) {
          if (char !== void 0 && this.input[this.idx] !== char) {
            throw Error(
              "Expected: '" + char + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx
            );
          }
          if (this.idx >= this.input.length) {
            throw Error("Unexpected end of input");
          }
          this.idx++;
        };
        RegExpParser.prototype.loc = function(begin) {
          return { begin, end: this.idx };
        };
        var hexDigitPattern = /[0-9a-fA-F]/;
        var decimalPattern = /[0-9]/;
        var decimalPatternNoZero = /[1-9]/;
        function cc(char) {
          return char.charCodeAt(0);
        }
        function insertToSet(item, set) {
          if (item.length !== void 0) {
            item.forEach(function(subItem) {
              set.push(subItem);
            });
          } else {
            set.push(item);
          }
        }
        function addFlag(flagObj, flagKey) {
          if (flagObj[flagKey] === true) {
            throw "duplicate flag " + flagKey;
          }
          flagObj[flagKey] = true;
        }
        function ASSERT_EXISTS(obj) {
          if (obj === void 0) {
            throw Error("Internal Error - Should never get here!");
          }
        }
        function ASSERT_NEVER_REACH_HERE() {
          throw Error("Internal Error - Should never get here!");
        }
        var i;
        var digitsCharCodes = [];
        for (i = cc("0"); i <= cc("9"); i++) {
          digitsCharCodes.push(i);
        }
        var wordCharCodes = [cc("_")].concat(digitsCharCodes);
        for (i = cc("a"); i <= cc("z"); i++) {
          wordCharCodes.push(i);
        }
        for (i = cc("A"); i <= cc("Z"); i++) {
          wordCharCodes.push(i);
        }
        var whitespaceCodes = [
          cc(" "),
          cc("\f"),
          cc("\n"),
          cc("\r"),
          cc("	"),
          cc("\v"),
          cc("	"),
          cc("\xA0"),
          cc("\u1680"),
          cc("\u2000"),
          cc("\u2001"),
          cc("\u2002"),
          cc("\u2003"),
          cc("\u2004"),
          cc("\u2005"),
          cc("\u2006"),
          cc("\u2007"),
          cc("\u2008"),
          cc("\u2009"),
          cc("\u200A"),
          cc("\u2028"),
          cc("\u2029"),
          cc("\u202F"),
          cc("\u205F"),
          cc("\u3000"),
          cc("\uFEFF")
        ];
        function BaseRegExpVisitor() {
        }
        BaseRegExpVisitor.prototype.visitChildren = function(node) {
          for (var key in node) {
            var child = node[key];
            if (node.hasOwnProperty(key)) {
              if (child.type !== void 0) {
                this.visit(child);
              } else if (Array.isArray(child)) {
                child.forEach(function(subChild) {
                  this.visit(subChild);
                }, this);
              }
            }
          }
        };
        BaseRegExpVisitor.prototype.visit = function(node) {
          switch (node.type) {
            case "Pattern":
              this.visitPattern(node);
              break;
            case "Flags":
              this.visitFlags(node);
              break;
            case "Disjunction":
              this.visitDisjunction(node);
              break;
            case "Alternative":
              this.visitAlternative(node);
              break;
            case "StartAnchor":
              this.visitStartAnchor(node);
              break;
            case "EndAnchor":
              this.visitEndAnchor(node);
              break;
            case "WordBoundary":
              this.visitWordBoundary(node);
              break;
            case "NonWordBoundary":
              this.visitNonWordBoundary(node);
              break;
            case "Lookahead":
              this.visitLookahead(node);
              break;
            case "NegativeLookahead":
              this.visitNegativeLookahead(node);
              break;
            case "Character":
              this.visitCharacter(node);
              break;
            case "Set":
              this.visitSet(node);
              break;
            case "Group":
              this.visitGroup(node);
              break;
            case "GroupBackReference":
              this.visitGroupBackReference(node);
              break;
            case "Quantifier":
              this.visitQuantifier(node);
              break;
          }
          this.visitChildren(node);
        };
        BaseRegExpVisitor.prototype.visitPattern = function(node) {
        };
        BaseRegExpVisitor.prototype.visitFlags = function(node) {
        };
        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {
        };
        BaseRegExpVisitor.prototype.visitAlternative = function(node) {
        };
        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {
        };
        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {
        };
        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {
        };
        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {
        };
        BaseRegExpVisitor.prototype.visitLookahead = function(node) {
        };
        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {
        };
        BaseRegExpVisitor.prototype.visitCharacter = function(node) {
        };
        BaseRegExpVisitor.prototype.visitSet = function(node) {
        };
        BaseRegExpVisitor.prototype.visitGroup = function(node) {
        };
        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {
        };
        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {
        };
        return {
          RegExpParser,
          BaseRegExpVisitor,
          VERSION: "0.5.0"
        };
      }
    );
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/regex-util.js
var require_regex_util = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/regex-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.partialRegex = exports2.partialMatches = exports2.getCaseInsensitivePattern = exports2.escapeRegExp = exports2.isWhitespaceRegExp = exports2.isMultilineComment = exports2.getTerminalParts = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var regexParser = new regexp_to_ast_1.RegExpParser();
    var TerminalRegexVisitor = class extends regexp_to_ast_1.BaseRegExpVisitor {
      constructor() {
        super(...arguments);
        this.isStarting = true;
        this.endRegexStack = [];
        this.multiline = false;
      }
      get endRegex() {
        return this.endRegexStack.join("");
      }
      reset(regex2) {
        this.multiline = false;
        this.regex = regex2;
        this.startRegex = "";
        this.isStarting = true;
        this.endRegexStack = [];
      }
      visitGroup(node) {
        if (node.quantifier) {
          this.isStarting = false;
          this.endRegexStack = [];
        }
      }
      visitCharacter(node) {
        const char = String.fromCharCode(node.value);
        if (!this.multiline && char === "\n") {
          this.multiline = true;
        }
        if (node.quantifier) {
          this.isStarting = false;
          this.endRegexStack = [];
        } else {
          const escapedChar = escapeRegExp(char);
          this.endRegexStack.push(escapedChar);
          if (this.isStarting) {
            this.startRegex += escapedChar;
          }
        }
      }
      visitSet(node) {
        if (!this.multiline) {
          const set = this.regex.substring(node.loc.begin, node.loc.end);
          const regex2 = new RegExp(set);
          this.multiline = Boolean("\n".match(regex2));
        }
        if (node.quantifier) {
          this.isStarting = false;
          this.endRegexStack = [];
        } else {
          const set = this.regex.substring(node.loc.begin, node.loc.end);
          this.endRegexStack.push(set);
          if (this.isStarting) {
            this.startRegex += set;
          }
        }
      }
      visitChildren(node) {
        if (node.type === "Group") {
          const group = node;
          if (group.quantifier) {
            return;
          }
        }
        super.visitChildren(node);
      }
    };
    var visitor = new TerminalRegexVisitor();
    function getTerminalParts(regex2) {
      try {
        if (typeof regex2 !== "string") {
          regex2 = regex2.source;
        }
        regex2 = `/${regex2}/`;
        const pattern = regexParser.pattern(regex2);
        const parts = [];
        for (const alternative of pattern.value.value) {
          visitor.reset(regex2);
          visitor.visit(alternative);
          parts.push({
            start: visitor.startRegex,
            end: visitor.endRegex
          });
        }
        return parts;
      } catch (_a) {
        return [];
      }
    }
    exports2.getTerminalParts = getTerminalParts;
    function isMultilineComment(regex2) {
      try {
        if (typeof regex2 !== "string") {
          regex2 = regex2.source;
        }
        regex2 = `/${regex2}/`;
        visitor.reset(regex2);
        visitor.visit(regexParser.pattern(regex2));
        return visitor.multiline;
      } catch (_a) {
        return false;
      }
    }
    exports2.isMultilineComment = isMultilineComment;
    function isWhitespaceRegExp(value) {
      const regexp = typeof value === "string" ? new RegExp(value) : value;
      return regexp.test(" ");
    }
    exports2.isWhitespaceRegExp = isWhitespaceRegExp;
    function escapeRegExp(value) {
      return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    exports2.escapeRegExp = escapeRegExp;
    function getCaseInsensitivePattern(keyword) {
      return Array.prototype.map.call(keyword, (letter) => /\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)).join("");
    }
    exports2.getCaseInsensitivePattern = getCaseInsensitivePattern;
    function partialMatches(regex2, input) {
      const partial = partialRegex(regex2);
      const match = input.match(partial);
      return !!match && match[0].length > 0;
    }
    exports2.partialMatches = partialMatches;
    function partialRegex(regex2) {
      if (typeof regex2 === "string") {
        regex2 = new RegExp(regex2);
      }
      const re = regex2, source = regex2.source;
      let i = 0;
      function process3() {
        let result = "", tmp;
        function appendRaw(nbChars) {
          result += source.substr(i, nbChars);
          i += nbChars;
        }
        function appendOptional(nbChars) {
          result += "(?:" + source.substr(i, nbChars) + "|$)";
          i += nbChars;
        }
        while (i < source.length) {
          switch (source[i]) {
            case "\\":
              switch (source[i + 1]) {
                case "c":
                  appendOptional(3);
                  break;
                case "x":
                  appendOptional(4);
                  break;
                case "u":
                  if (re.unicode) {
                    if (source[i + 2] === "{") {
                      appendOptional(source.indexOf("}", i) - i + 1);
                    } else {
                      appendOptional(6);
                    }
                  } else {
                    appendOptional(2);
                  }
                  break;
                case "p":
                case "P":
                  if (re.unicode) {
                    appendOptional(source.indexOf("}", i) - i + 1);
                  } else {
                    appendOptional(2);
                  }
                  break;
                case "k":
                  appendOptional(source.indexOf(">", i) - i + 1);
                  break;
                default:
                  appendOptional(2);
                  break;
              }
              break;
            case "[":
              tmp = /\[(?:\\.|.)*?\]/g;
              tmp.lastIndex = i;
              tmp = tmp.exec(source) || [];
              appendOptional(tmp[0].length);
              break;
            case "|":
            case "^":
            case "$":
            case "*":
            case "+":
            case "?":
              appendRaw(1);
              break;
            case "{":
              tmp = /\{\d+,?\d*\}/g;
              tmp.lastIndex = i;
              tmp = tmp.exec(source);
              if (tmp) {
                appendRaw(tmp[0].length);
              } else {
                appendOptional(1);
              }
              break;
            case "(":
              if (source[i + 1] === "?") {
                switch (source[i + 2]) {
                  case ":":
                    result += "(?:";
                    i += 3;
                    result += process3() + "|$)";
                    break;
                  case "=":
                    result += "(?=";
                    i += 3;
                    result += process3() + ")";
                    break;
                  case "!":
                    tmp = i;
                    i += 3;
                    process3();
                    result += source.substr(tmp, i - tmp);
                    break;
                  case "<":
                    switch (source[i + 3]) {
                      case "=":
                      case "!":
                        tmp = i;
                        i += 4;
                        process3();
                        result += source.substr(tmp, i - tmp);
                        break;
                      default:
                        appendRaw(source.indexOf(">", i) - i + 1);
                        result += process3() + "|$)";
                        break;
                    }
                    break;
                }
              } else {
                appendRaw(1);
                result += process3() + "|$)";
              }
              break;
            case ")":
              ++i;
              return result;
            default:
              appendOptional(1);
              break;
          }
        }
        return result;
      }
      return new RegExp(process3(), regex2.flags);
    }
    exports2.partialRegex = partialRegex;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/internal-grammar-util.js
var require_internal_grammar_util = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/internal-grammar-util.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPrimitiveType = exports2.extractAssignments = exports2.resolveTransitiveImports = exports2.resolveImport = exports2.resolveImportUri = exports2.terminalRegex = exports2.getRuleType = exports2.getActionType = exports2.getExplicitRuleType = exports2.getTypeNameWithoutError = exports2.getTypeName = exports2.getActionAtElement = exports2.isDataType = exports2.hasDataTypeReturn = exports2.isDataTypeRule = exports2.isArrayOperator = exports2.isArrayCardinality = exports2.isOptionalCardinality = void 0;
    var ast2 = __importStar(require_ast());
    var vscode_uri_1 = require_umd();
    var ast_util_1 = require_ast_util();
    var types_1 = require_types();
    var regex_util_1 = require_regex_util();
    function isOptionalCardinality(cardinality) {
      return cardinality === "?" || cardinality === "*";
    }
    exports2.isOptionalCardinality = isOptionalCardinality;
    function isArrayCardinality(cardinality) {
      return cardinality === "*" || cardinality === "+";
    }
    exports2.isArrayCardinality = isArrayCardinality;
    function isArrayOperator(operator) {
      return operator === "+=";
    }
    exports2.isArrayOperator = isArrayOperator;
    function isDataTypeRule(rule) {
      return isDataTypeRuleInternal(rule, /* @__PURE__ */ new Set());
    }
    exports2.isDataTypeRule = isDataTypeRule;
    function isDataTypeRuleInternal(rule, visited) {
      if (visited.has(rule)) {
        return true;
      } else {
        visited.add(rule);
      }
      for (const node of (0, ast_util_1.streamAllContents)(rule)) {
        if (ast2.isRuleCall(node)) {
          if (!node.rule.ref) {
            return false;
          }
          if (ast2.isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {
            return false;
          }
        } else if (ast2.isAssignment(node)) {
          return false;
        } else if (ast2.isAction(node)) {
          return false;
        }
      }
      return Boolean(rule.definition);
    }
    function hasDataTypeReturn(rule) {
      var _a;
      const returnType = (_a = rule.returnType) === null || _a === void 0 ? void 0 : _a.ref;
      return rule.dataType !== void 0 || ast2.isType(returnType) && isDataType(returnType);
    }
    exports2.hasDataTypeReturn = hasDataTypeReturn;
    function isDataType(type) {
      return isDataTypeInternal(type.type, /* @__PURE__ */ new Set());
    }
    exports2.isDataType = isDataType;
    function isDataTypeInternal(type, visited) {
      if (visited.has(type)) {
        return true;
      } else {
        visited.add(type);
      }
      if (ast2.isArrayType(type)) {
        return false;
      } else if (ast2.isReferenceType(type)) {
        return false;
      } else if (ast2.isUnionType(type)) {
        return type.types.every((e) => isDataTypeInternal(e, visited));
      } else if (ast2.isSimpleType(type)) {
        if (type.primitiveType !== void 0) {
          return true;
        } else if (type.stringType !== void 0) {
          return true;
        } else if (type.typeRef !== void 0) {
          const ref = type.typeRef.ref;
          if (ast2.isType(ref)) {
            return isDataTypeInternal(ref.type, visited);
          } else {
            return false;
          }
        } else {
          return false;
        }
      } else {
        return false;
      }
    }
    function getActionAtElement(element) {
      const parent = element.$container;
      if (ast2.isGroup(parent)) {
        const elements = parent.elements;
        const index = elements.indexOf(element);
        for (let i = index - 1; i >= 0; i--) {
          const item = elements[i];
          if (ast2.isAction(item)) {
            return item;
          } else {
            const action = (0, ast_util_1.streamAllContents)(elements[i]).find(ast2.isAction);
            if (action) {
              return action;
            }
          }
        }
      }
      if (ast2.isAbstractElement(parent)) {
        return getActionAtElement(parent);
      } else {
        return void 0;
      }
    }
    exports2.getActionAtElement = getActionAtElement;
    function getTypeName(type) {
      var _a;
      if (ast2.isParserRule(type)) {
        return isDataTypeRule(type) ? type.name : (_a = getExplicitRuleType(type)) !== null && _a !== void 0 ? _a : type.name;
      } else if (ast2.isInterface(type) || ast2.isType(type) || ast2.isReturnType(type)) {
        return type.name;
      } else if (ast2.isAction(type)) {
        const actionType = getActionType(type);
        if (actionType) {
          return actionType;
        }
      } else if (ast2.isInferredType(type)) {
        return type.name;
      }
      throw new types_1.TypeResolutionError("Cannot get name of Unknown Type", type.$cstNode);
    }
    exports2.getTypeName = getTypeName;
    function getTypeNameWithoutError(type) {
      if (!type) {
        return void 0;
      }
      try {
        return getTypeName(type);
      } catch (_a) {
        return void 0;
      }
    }
    exports2.getTypeNameWithoutError = getTypeNameWithoutError;
    function getExplicitRuleType(rule) {
      if (rule.inferredType) {
        return rule.inferredType.name;
      } else if (rule.dataType) {
        return rule.dataType;
      } else if (rule.returnType) {
        const refType = rule.returnType.ref;
        if (refType) {
          if (ast2.isParserRule(refType)) {
            return refType.name;
          } else if (ast2.isInterface(refType) || ast2.isType(refType)) {
            return refType.name;
          }
        }
      }
      return void 0;
    }
    exports2.getExplicitRuleType = getExplicitRuleType;
    function getActionType(action) {
      var _a;
      if (action.inferredType) {
        return action.inferredType.name;
      } else if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) {
        return getTypeName(action.type.ref);
      }
      return void 0;
    }
    exports2.getActionType = getActionType;
    function getRuleType(rule) {
      var _a, _b, _c;
      if (ast2.isTerminalRule(rule)) {
        return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "string";
      } else {
        return isDataTypeRule(rule) ? rule.name : (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;
      }
    }
    exports2.getRuleType = getRuleType;
    function terminalRegex(terminalRule) {
      return abstractElementToRegex(terminalRule.definition);
    }
    exports2.terminalRegex = terminalRegex;
    var WILDCARD = /[\s\S]/.source;
    function abstractElementToRegex(element) {
      if (ast2.isTerminalAlternatives(element)) {
        return terminalAlternativesToRegex(element);
      } else if (ast2.isTerminalGroup(element)) {
        return terminalGroupToRegex(element);
      } else if (ast2.isCharacterRange(element)) {
        return characterRangeToRegex(element);
      } else if (ast2.isTerminalRuleCall(element)) {
        const rule = element.rule.ref;
        if (!rule) {
          throw new Error("Missing rule reference.");
        }
        return withCardinality(terminalRegex(rule), {
          cardinality: element.cardinality,
          lookahead: element.lookahead
        });
      } else if (ast2.isNegatedToken(element)) {
        return negateTokenToRegex(element);
      } else if (ast2.isUntilToken(element)) {
        return untilTokenToRegex(element);
      } else if (ast2.isRegexToken(element)) {
        return withCardinality(element.regex, {
          cardinality: element.cardinality,
          lookahead: element.lookahead,
          wrap: false
        });
      } else if (ast2.isWildcard(element)) {
        return withCardinality(WILDCARD, {
          cardinality: element.cardinality,
          lookahead: element.lookahead
        });
      } else {
        throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);
      }
    }
    function terminalAlternativesToRegex(alternatives) {
      return withCardinality(alternatives.elements.map(abstractElementToRegex).join("|"), {
        cardinality: alternatives.cardinality,
        lookahead: alternatives.lookahead
      });
    }
    function terminalGroupToRegex(group) {
      return withCardinality(group.elements.map(abstractElementToRegex).join(""), {
        cardinality: group.cardinality,
        lookahead: group.lookahead
      });
    }
    function untilTokenToRegex(until) {
      return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {
        cardinality: until.cardinality,
        lookahead: until.lookahead
      });
    }
    function negateTokenToRegex(negate) {
      return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {
        cardinality: negate.cardinality,
        lookahead: negate.lookahead
      });
    }
    function characterRangeToRegex(range) {
      if (range.right) {
        return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {
          cardinality: range.cardinality,
          lookahead: range.lookahead,
          wrap: false
        });
      }
      return withCardinality(keywordToRegex(range.left), {
        cardinality: range.cardinality,
        lookahead: range.lookahead,
        wrap: false
      });
    }
    function keywordToRegex(keyword) {
      return (0, regex_util_1.escapeRegExp)(keyword.value);
    }
    function withCardinality(regex2, options) {
      var _a;
      if (options.wrap !== false || options.lookahead) {
        regex2 = `(${(_a = options.lookahead) !== null && _a !== void 0 ? _a : ""}${regex2})`;
      }
      if (options.cardinality) {
        return `${regex2}${options.cardinality}`;
      }
      return regex2;
    }
    function resolveImportUri(imp) {
      if (imp.path === void 0 || imp.path.length === 0) {
        return void 0;
      }
      const dirUri = vscode_uri_1.Utils.dirname((0, ast_util_1.getDocument)(imp).uri);
      let grammarPath = imp.path;
      if (!grammarPath.endsWith(".langium")) {
        grammarPath += ".langium";
      }
      return vscode_uri_1.Utils.resolvePath(dirUri, grammarPath);
    }
    exports2.resolveImportUri = resolveImportUri;
    function resolveImport(documents, imp) {
      const resolvedUri = resolveImportUri(imp);
      try {
        if (resolvedUri) {
          const resolvedDocument = documents.getOrCreateDocument(resolvedUri);
          const node = resolvedDocument.parseResult.value;
          if (ast2.isGrammar(node)) {
            return node;
          }
        }
      } catch (_a) {
      }
      return void 0;
    }
    exports2.resolveImport = resolveImport;
    function resolveTransitiveImports(documents, grammarOrImport) {
      if (ast2.isGrammarImport(grammarOrImport)) {
        const resolvedGrammar = resolveImport(documents, grammarOrImport);
        if (resolvedGrammar) {
          const transitiveGrammars = resolveTransitiveImportsInternal(documents, resolvedGrammar);
          transitiveGrammars.push(resolvedGrammar);
          return transitiveGrammars;
        }
        return [];
      } else {
        return resolveTransitiveImportsInternal(documents, grammarOrImport);
      }
    }
    exports2.resolveTransitiveImports = resolveTransitiveImports;
    function resolveTransitiveImportsInternal(documents, grammar, initialGrammar = grammar, visited = /* @__PURE__ */ new Set(), grammars = /* @__PURE__ */ new Set()) {
      const doc = (0, ast_util_1.getDocument)(grammar);
      if (initialGrammar !== grammar) {
        grammars.add(grammar);
      }
      if (!visited.has(doc.uri)) {
        visited.add(doc.uri);
        for (const imp of grammar.imports) {
          const importedGrammar = resolveImport(documents, imp);
          if (importedGrammar) {
            resolveTransitiveImportsInternal(documents, importedGrammar, initialGrammar, visited, grammars);
          }
        }
      }
      return Array.from(grammars);
    }
    function extractAssignments(element) {
      if (ast2.isAssignment(element)) {
        return [element];
      } else if (ast2.isAlternatives(element) || ast2.isGroup(element) || ast2.isUnorderedGroup(element)) {
        return element.elements.flatMap((e) => extractAssignments(e));
      } else if (ast2.isRuleCall(element) && element.rule.ref) {
        return extractAssignments(element.rule.ref.definition);
      }
      return [];
    }
    exports2.extractAssignments = extractAssignments;
    var primitiveTypes = ["string", "number", "boolean", "Date", "bigint"];
    function isPrimitiveType(type) {
      return primitiveTypes.includes(type);
    }
    exports2.isPrimitiveType = isPrimitiveType;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/type-collector/plain-types.js
var require_plain_types = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/type-collector/plain-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flattenPlainType = exports2.mergePropertyTypes = exports2.plainToTypes = exports2.isPlainStringType = exports2.isPlainPrimitiveType = exports2.isPlainValueType = exports2.isPlainPropertyUnion = exports2.isPlainArrayType = exports2.isPlainReferenceType = exports2.isPlainUnion = exports2.isPlainInterface = void 0;
    var types_1 = require_types();
    function isPlainInterface(type) {
      return !isPlainUnion(type);
    }
    exports2.isPlainInterface = isPlainInterface;
    function isPlainUnion(type) {
      return "type" in type;
    }
    exports2.isPlainUnion = isPlainUnion;
    function isPlainReferenceType(propertyType) {
      return "referenceType" in propertyType;
    }
    exports2.isPlainReferenceType = isPlainReferenceType;
    function isPlainArrayType(propertyType) {
      return "elementType" in propertyType;
    }
    exports2.isPlainArrayType = isPlainArrayType;
    function isPlainPropertyUnion(propertyType) {
      return "types" in propertyType;
    }
    exports2.isPlainPropertyUnion = isPlainPropertyUnion;
    function isPlainValueType(propertyType) {
      return "value" in propertyType;
    }
    exports2.isPlainValueType = isPlainValueType;
    function isPlainPrimitiveType(propertyType) {
      return "primitive" in propertyType;
    }
    exports2.isPlainPrimitiveType = isPlainPrimitiveType;
    function isPlainStringType(propertyType) {
      return "string" in propertyType;
    }
    exports2.isPlainStringType = isPlainStringType;
    function plainToTypes(plain) {
      const interfaceTypes = /* @__PURE__ */ new Map();
      const unionTypes = /* @__PURE__ */ new Map();
      for (const interfaceValue of plain.interfaces) {
        const type = new types_1.InterfaceType(interfaceValue.name, interfaceValue.declared, interfaceValue.abstract);
        interfaceTypes.set(interfaceValue.name, type);
      }
      for (const unionValue of plain.unions) {
        const type = new types_1.UnionType(unionValue.name, {
          declared: unionValue.declared,
          dataType: unionValue.dataType
        });
        unionTypes.set(unionValue.name, type);
      }
      for (const interfaceValue of plain.interfaces) {
        const type = interfaceTypes.get(interfaceValue.name);
        for (const superTypeName of interfaceValue.superTypes) {
          const superType = interfaceTypes.get(superTypeName) || unionTypes.get(superTypeName);
          if (superType) {
            type.superTypes.add(superType);
          }
        }
        for (const subTypeName of interfaceValue.subTypes) {
          const subType = interfaceTypes.get(subTypeName) || unionTypes.get(subTypeName);
          if (subType) {
            type.subTypes.add(subType);
          }
        }
        for (const property of interfaceValue.properties) {
          const prop = plainToProperty(property, interfaceTypes, unionTypes);
          type.properties.push(prop);
        }
      }
      for (const unionValue of plain.unions) {
        const type = unionTypes.get(unionValue.name);
        type.type = plainToPropertyType(unionValue.type, type, interfaceTypes, unionTypes);
      }
      return {
        interfaces: Array.from(interfaceTypes.values()),
        unions: Array.from(unionTypes.values())
      };
    }
    exports2.plainToTypes = plainToTypes;
    function plainToProperty(property, interfaces, unions) {
      return {
        name: property.name,
        optional: property.optional,
        astNodes: property.astNodes,
        type: plainToPropertyType(property.type, void 0, interfaces, unions)
      };
    }
    function plainToPropertyType(type, union, interfaces, unions) {
      if (isPlainArrayType(type)) {
        return {
          elementType: plainToPropertyType(type.elementType, union, interfaces, unions)
        };
      } else if (isPlainReferenceType(type)) {
        return {
          referenceType: plainToPropertyType(type.referenceType, void 0, interfaces, unions)
        };
      } else if (isPlainPropertyUnion(type)) {
        return {
          types: type.types.map((e) => plainToPropertyType(e, union, interfaces, unions))
        };
      } else if (isPlainStringType(type)) {
        return {
          string: type.string
        };
      } else if (isPlainPrimitiveType(type)) {
        return {
          primitive: type.primitive,
          regex: type.regex
        };
      } else if (isPlainValueType(type)) {
        const value = interfaces.get(type.value) || unions.get(type.value);
        if (!value) {
          return {
            primitive: "unknown"
          };
        }
        if (union) {
          union.subTypes.add(value);
        }
        return {
          value
        };
      } else {
        throw new Error("Invalid property type");
      }
    }
    function mergePropertyTypes(first, second) {
      const flattenedFirst = flattenPlainType(first);
      const flattenedSecond = flattenPlainType(second);
      for (const second2 of flattenedSecond) {
        if (!includesType(flattenedFirst, second2)) {
          flattenedFirst.push(second2);
        }
      }
      if (flattenedFirst.length === 1) {
        return flattenedFirst[0];
      } else {
        return {
          types: flattenedFirst
        };
      }
    }
    exports2.mergePropertyTypes = mergePropertyTypes;
    function includesType(list, value) {
      return list.some((e) => typeEquals(e, value));
    }
    function typeEquals(first, second) {
      if (isPlainArrayType(first) && isPlainArrayType(second)) {
        return typeEquals(first.elementType, second.elementType);
      } else if (isPlainReferenceType(first) && isPlainReferenceType(second)) {
        return typeEquals(first.referenceType, second.referenceType);
      } else if (isPlainValueType(first) && isPlainValueType(second)) {
        return first.value === second.value;
      } else {
        return false;
      }
    }
    function flattenPlainType(type) {
      if (isPlainPropertyUnion(type)) {
        return type.types.flatMap((e) => flattenPlainType(e));
      } else {
        return [type];
      }
    }
    exports2.flattenPlainType = flattenPlainType;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/type-collector/inferred-types.js
var require_inferred_types = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/type-collector/inferred-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectInferredTypes = void 0;
    var name_provider_1 = require_name_provider();
    var collections_1 = require_collections();
    var ast_1 = require_ast();
    var internal_grammar_util_1 = require_internal_grammar_util();
    var plain_types_1 = require_plain_types();
    var TypeGraph = class {
      constructor(context, root) {
        this.context = context;
        this.root = root;
      }
      getTypes() {
        const rootType = {
          name: this.root.name,
          properties: this.root.properties,
          ruleCalls: this.root.ruleCalls,
          super: []
        };
        if (this.root.children.length === 0) {
          return [{ alt: rootType, next: [] }];
        } else {
          return this.applyNext(this.root, {
            alt: rootType,
            next: this.root.children
          });
        }
      }
      applyNext(root, nextPath) {
        const splits = this.splitType(nextPath.alt, nextPath.next.length);
        const paths = [];
        for (let i = 0; i < nextPath.next.length; i++) {
          const split = splits[i];
          const part = nextPath.next[i];
          if (part.actionWithAssignment) {
            paths.push({
              alt: copyTypeAlternative(split),
              next: []
            });
          }
          if (part.name !== void 0 && part.name !== split.name) {
            if (part.actionWithAssignment) {
              split.properties = [];
              split.ruleCalls = [];
              split.super = [root.name];
              split.name = part.name;
            } else {
              split.super = [split.name, ...split.ruleCalls];
              split.properties = [];
              split.ruleCalls = [];
              split.name = part.name;
            }
          }
          split.properties.push(...part.properties);
          split.ruleCalls.push(...part.ruleCalls);
          const path2 = {
            alt: split,
            next: part.children
          };
          if (path2.next.length === 0) {
            path2.alt.super = path2.alt.super.filter((e) => e !== path2.alt.name);
            paths.push(path2);
          } else {
            paths.push(...this.applyNext(root, path2));
          }
        }
        return flattenTypes(paths);
      }
      splitType(type, count) {
        const alternatives = [];
        for (let i = 0; i < count; i++) {
          alternatives.push(copyTypeAlternative(type));
        }
        return alternatives;
      }
      getSuperTypes(node) {
        const set = /* @__PURE__ */ new Set();
        this.collectSuperTypes(node, node, set);
        return Array.from(set);
      }
      collectSuperTypes(original, part, set) {
        if (part.ruleCalls.length > 0) {
          for (const ruleCall of part.ruleCalls) {
            set.add(ruleCall);
          }
          return;
        }
        for (const parent of part.parents) {
          if (original.name === void 0) {
            this.collectSuperTypes(parent, parent, set);
          } else if (parent.name !== void 0 && parent.name !== original.name) {
            set.add(parent.name);
          } else {
            this.collectSuperTypes(original, parent, set);
          }
        }
        if (part.parents.length === 0 && part.name) {
          set.add(part.name);
        }
      }
      connect(parent, children) {
        children.parents.push(parent);
        parent.children.push(children);
        return children;
      }
      merge(...parts) {
        if (parts.length === 1) {
          return parts[0];
        } else if (parts.length === 0) {
          throw new Error("No parts to merge");
        }
        const node = newTypePart();
        node.parents = parts;
        for (const parent of parts) {
          parent.children.push(node);
        }
        return node;
      }
      hasLeafNode(part) {
        return this.partHasLeafNode(part);
      }
      partHasLeafNode(part, ignore) {
        if (part.children.some((e) => e !== ignore)) {
          return true;
        } else if (part.name) {
          return false;
        } else {
          return part.parents.some((e) => this.partHasLeafNode(e, part));
        }
      }
    };
    function copyTypePart(value) {
      return {
        name: value.name,
        children: [],
        parents: [],
        actionWithAssignment: value.actionWithAssignment,
        ruleCalls: [...value.ruleCalls],
        properties: value.properties.map(copyProperty)
      };
    }
    function copyTypeAlternative(value) {
      return {
        name: value.name,
        super: value.super,
        ruleCalls: value.ruleCalls,
        properties: value.properties.map((e) => copyProperty(e))
      };
    }
    function copyProperty(value) {
      return {
        name: value.name,
        optional: value.optional,
        type: value.type,
        astNodes: value.astNodes
      };
    }
    function collectInferredTypes(parserRules, datatypeRules, declared) {
      const allTypes = [];
      const context = {
        fragments: /* @__PURE__ */ new Map()
      };
      for (const rule of parserRules) {
        allTypes.push(...getRuleTypes(context, rule));
      }
      const interfaces = calculateInterfaces(allTypes);
      const unions = buildSuperUnions(interfaces);
      const astTypes = extractUnions(interfaces, unions, declared);
      for (const rule of datatypeRules) {
        const type = getDataRuleType(rule);
        astTypes.unions.push({
          name: rule.name,
          declared: false,
          type,
          subTypes: /* @__PURE__ */ new Set(),
          superTypes: /* @__PURE__ */ new Set(),
          dataType: rule.dataType
        });
      }
      return astTypes;
    }
    exports2.collectInferredTypes = collectInferredTypes;
    function getDataRuleType(rule) {
      if (rule.dataType && rule.dataType !== "string") {
        return {
          primitive: rule.dataType
        };
      }
      let cancelled = false;
      const cancel = () => {
        cancelled = true;
        return {
          primitive: "unknown"
        };
      };
      const type = buildDataRuleType(rule.definition, cancel);
      if (cancelled) {
        return {
          primitive: "string"
        };
      } else {
        return type;
      }
    }
    function buildDataRuleType(element, cancel) {
      var _a, _b, _c;
      if (element.cardinality) {
        return cancel();
      }
      if ((0, ast_1.isAlternatives)(element)) {
        return {
          types: element.elements.map((e) => buildDataRuleType(e, cancel))
        };
      } else if ((0, ast_1.isGroup)(element) || (0, ast_1.isUnorderedGroup)(element)) {
        if (element.elements.length !== 1) {
          return cancel();
        } else {
          return buildDataRuleType(element.elements[0], cancel);
        }
      } else if ((0, ast_1.isRuleCall)(element)) {
        const ref = (_a = element.rule) === null || _a === void 0 ? void 0 : _a.ref;
        if (ref) {
          if ((0, ast_1.isTerminalRule)(ref)) {
            return {
              primitive: (_c = (_b = ref.type) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : "string",
              regex: (0, internal_grammar_util_1.terminalRegex)(ref)
            };
          } else {
            return {
              value: ref.name
            };
          }
        } else {
          return cancel();
        }
      } else if ((0, ast_1.isKeyword)(element)) {
        return {
          string: element.value
        };
      }
      return cancel();
    }
    function getRuleTypes(context, rule) {
      const type = newTypePart(rule);
      const graph = new TypeGraph(context, type);
      if (rule.definition) {
        collectElement(graph, graph.root, rule.definition);
      }
      return graph.getTypes();
    }
    function newTypePart(element) {
      return {
        name: (0, ast_1.isParserRule)(element) || (0, ast_1.isAction)(element) ? (0, internal_grammar_util_1.getTypeNameWithoutError)(element) : element,
        properties: [],
        ruleCalls: [],
        children: [],
        parents: [],
        actionWithAssignment: false
      };
    }
    function collectElement(graph, current, element) {
      const optional = (0, internal_grammar_util_1.isOptionalCardinality)(element.cardinality);
      if ((0, ast_1.isAlternatives)(element)) {
        const children = [];
        if (optional) {
          children.push(graph.connect(current, newTypePart()));
        }
        for (const alt of element.elements) {
          const altType = graph.connect(current, newTypePart());
          children.push(collectElement(graph, altType, alt));
        }
        return graph.merge(...children);
      } else if ((0, ast_1.isGroup)(element) || (0, ast_1.isUnorderedGroup)(element)) {
        let groupNode = graph.connect(current, newTypePart());
        let skipNode;
        if (optional) {
          skipNode = graph.connect(current, newTypePart());
        }
        for (const item of element.elements) {
          groupNode = collectElement(graph, groupNode, item);
        }
        if (skipNode) {
          return graph.merge(skipNode, groupNode);
        } else {
          return groupNode;
        }
      } else if ((0, ast_1.isAction)(element)) {
        return addAction(graph, current, element);
      } else if ((0, ast_1.isAssignment)(element)) {
        addAssignment(current, element);
      } else if ((0, ast_1.isRuleCall)(element)) {
        addRuleCall(graph, current, element);
      }
      return current;
    }
    function addAction(graph, parent, action) {
      var _a;
      if (!graph.hasLeafNode(parent)) {
        const copy = copyTypePart(parent);
        graph.connect(parent, copy);
      }
      const typeNode = graph.connect(parent, newTypePart(action));
      if (action.type) {
        const type = (_a = action.type) === null || _a === void 0 ? void 0 : _a.ref;
        if (type && (0, name_provider_1.isNamed)(type))
          typeNode.name = type.name;
      }
      if (action.feature && action.operator) {
        typeNode.actionWithAssignment = true;
        typeNode.properties.push({
          name: action.feature,
          optional: false,
          type: toPropertyType(action.operator === "+=", false, graph.root.ruleCalls.length !== 0 ? graph.root.ruleCalls : graph.getSuperTypes(typeNode)),
          astNodes: /* @__PURE__ */ new Set([action])
        });
      }
      return typeNode;
    }
    function addAssignment(current, assignment) {
      const typeItems = { types: /* @__PURE__ */ new Set(), reference: false };
      findTypes(assignment.terminal, typeItems);
      const type = toPropertyType(assignment.operator === "+=", typeItems.reference, assignment.operator === "?=" ? ["boolean"] : Array.from(typeItems.types));
      current.properties.push({
        name: assignment.feature,
        optional: (0, internal_grammar_util_1.isOptionalCardinality)(assignment.cardinality),
        type,
        astNodes: /* @__PURE__ */ new Set([assignment])
      });
    }
    function findTypes(terminal, types) {
      if ((0, ast_1.isAlternatives)(terminal) || (0, ast_1.isUnorderedGroup)(terminal) || (0, ast_1.isGroup)(terminal)) {
        for (const element of terminal.elements) {
          findTypes(element, types);
        }
      } else if ((0, ast_1.isKeyword)(terminal)) {
        types.types.add(`'${terminal.value}'`);
      } else if ((0, ast_1.isRuleCall)(terminal) && terminal.rule.ref) {
        types.types.add((0, internal_grammar_util_1.getRuleType)(terminal.rule.ref));
      } else if ((0, ast_1.isCrossReference)(terminal) && terminal.type.ref) {
        const refTypeName = (0, internal_grammar_util_1.getTypeNameWithoutError)(terminal.type.ref);
        if (refTypeName) {
          types.types.add(refTypeName);
        }
        types.reference = true;
      }
    }
    function addRuleCall(graph, current, ruleCall) {
      const rule = ruleCall.rule.ref;
      if ((0, ast_1.isParserRule)(rule) && rule.fragment) {
        const properties = getFragmentProperties(rule, graph.context);
        if ((0, internal_grammar_util_1.isOptionalCardinality)(ruleCall.cardinality)) {
          current.properties.push(...properties.map((e) => Object.assign(Object.assign({}, e), { optional: true })));
        } else {
          current.properties.push(...properties);
        }
      } else if ((0, ast_1.isParserRule)(rule)) {
        current.ruleCalls.push((0, internal_grammar_util_1.getRuleType)(rule));
      }
    }
    function getFragmentProperties(fragment, context) {
      const existing = context.fragments.get(fragment);
      if (existing) {
        return existing;
      }
      const properties = [];
      context.fragments.set(fragment, properties);
      const fragmentName = (0, internal_grammar_util_1.getTypeNameWithoutError)(fragment);
      const typeAlternatives = getRuleTypes(context, fragment).filter((e) => e.alt.name === fragmentName);
      properties.push(...typeAlternatives.flatMap((e) => e.alt.properties));
      return properties;
    }
    function calculateInterfaces(alternatives) {
      const interfaces = /* @__PURE__ */ new Map();
      const ruleCallAlternatives = [];
      const flattened = flattenTypes(alternatives).map((e) => e.alt);
      for (const flat of flattened) {
        const interfaceType = {
          name: flat.name,
          properties: flat.properties,
          superTypes: new Set(flat.super),
          subTypes: /* @__PURE__ */ new Set(),
          declared: false,
          abstract: false
        };
        interfaces.set(interfaceType.name, interfaceType);
        if (flat.ruleCalls.length > 0) {
          ruleCallAlternatives.push(flat);
          flat.ruleCalls.forEach((e) => {
            if (e !== interfaceType.name) {
              interfaceType.subTypes.add(e);
            }
          });
        }
      }
      for (const ruleCallType of ruleCallAlternatives) {
        for (const ruleCall of ruleCallType.ruleCalls) {
          const calledInterface = interfaces.get(ruleCall);
          if (calledInterface) {
            if (calledInterface.name !== ruleCallType.name) {
              calledInterface.superTypes.add(ruleCallType.name);
            }
          }
        }
      }
      return Array.from(interfaces.values());
    }
    function flattenTypes(alternatives) {
      const nameToAlternatives = alternatives.reduce((acc, e) => acc.add(e.alt.name, e), new collections_1.MultiMap());
      const types = [];
      for (const [name, namedAlternatives] of nameToAlternatives.entriesGroupedByKey()) {
        const properties = [];
        const ruleCalls = /* @__PURE__ */ new Set();
        const type = { alt: { name, properties, ruleCalls: [], super: [] }, next: [] };
        for (const path2 of namedAlternatives) {
          const alt = path2.alt;
          type.alt.super.push(...alt.super);
          type.next.push(...path2.next);
          const altProperties = alt.properties;
          for (const altProperty of altProperties) {
            const existingProperty = properties.find((e) => e.name === altProperty.name);
            if (existingProperty) {
              existingProperty.type = (0, plain_types_1.mergePropertyTypes)(existingProperty.type, altProperty.type);
              altProperty.astNodes.forEach((e) => existingProperty.astNodes.add(e));
            } else {
              properties.push(Object.assign({}, altProperty));
            }
          }
          alt.ruleCalls.forEach((ruleCall) => ruleCalls.add(ruleCall));
        }
        for (const path2 of namedAlternatives) {
          const alt = path2.alt;
          if (alt.ruleCalls.length === 0) {
            for (const property of properties) {
              if (!alt.properties.find((e) => e.name === property.name)) {
                property.optional = true;
              }
            }
          }
        }
        type.alt.ruleCalls = Array.from(ruleCalls);
        types.push(type);
      }
      return types;
    }
    function buildSuperUnions(interfaces) {
      const interfaceMap = new Map(interfaces.map((e) => [e.name, e]));
      const unions = [];
      const allSupertypes = new collections_1.MultiMap();
      for (const interfaceType of interfaces) {
        for (const superType of interfaceType.superTypes) {
          allSupertypes.add(superType, interfaceType.name);
        }
      }
      for (const [superType, types] of allSupertypes.entriesGroupedByKey()) {
        if (!interfaceMap.has(superType)) {
          const union = {
            declared: false,
            name: superType,
            subTypes: /* @__PURE__ */ new Set(),
            superTypes: /* @__PURE__ */ new Set(),
            type: toPropertyType(false, false, types)
          };
          unions.push(union);
        }
      }
      return unions;
    }
    function extractUnions(interfaces, unions, declared) {
      const subTypes = new collections_1.MultiMap();
      for (const interfaceType of interfaces) {
        for (const superTypeName of interfaceType.superTypes) {
          subTypes.add(superTypeName, interfaceType.name);
        }
      }
      const declaredInterfaces = new Set(declared.interfaces.map((e) => e.name));
      const astTypes = { interfaces: [], unions };
      const unionTypes = new Map(unions.map((e) => [e.name, e]));
      for (const interfaceType of interfaces) {
        const interfaceSubTypes = new Set(subTypes.get(interfaceType.name));
        if (interfaceType.properties.length === 0 && interfaceSubTypes.size > 0) {
          if (declaredInterfaces.has(interfaceType.name)) {
            interfaceType.abstract = true;
            astTypes.interfaces.push(interfaceType);
          } else {
            const interfaceTypeValue = toPropertyType(false, false, Array.from(interfaceSubTypes));
            const existingUnion = unionTypes.get(interfaceType.name);
            if (existingUnion) {
              existingUnion.type = (0, plain_types_1.mergePropertyTypes)(existingUnion.type, interfaceTypeValue);
            } else {
              const unionType = {
                name: interfaceType.name,
                declared: false,
                subTypes: interfaceSubTypes,
                superTypes: interfaceType.superTypes,
                type: interfaceTypeValue
              };
              astTypes.unions.push(unionType);
              unionTypes.set(interfaceType.name, unionType);
            }
          }
        } else {
          astTypes.interfaces.push(interfaceType);
        }
      }
      for (const interfaceType of astTypes.interfaces) {
        interfaceType.superTypes = new Set([...interfaceType.superTypes].filter((superType) => !unionTypes.has(superType)));
      }
      return astTypes;
    }
    function toPropertyType(array, reference, types) {
      if (array) {
        return {
          elementType: toPropertyType(false, reference, types)
        };
      } else if (reference) {
        return {
          referenceType: toPropertyType(false, false, types)
        };
      } else if (types.length === 1) {
        const type = types[0];
        if (type.startsWith("'")) {
          return {
            string: type.substring(1, type.length - 1)
          };
        }
        if ((0, internal_grammar_util_1.isPrimitiveType)(type)) {
          return {
            primitive: type
          };
        } else {
          return {
            value: type
          };
        }
      } else {
        return {
          types: types.map((e) => toPropertyType(false, false, [e]))
        };
      }
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/type-collector/declared-types.js
var require_declared_types = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/type-collector/declared-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.typeDefinitionToPropertyType = exports2.collectDeclaredTypes = void 0;
    var ast_1 = require_ast();
    var internal_grammar_util_1 = require_internal_grammar_util();
    function collectDeclaredTypes(interfaces, unions) {
      const declaredTypes = { unions: [], interfaces: [] };
      for (const type of interfaces) {
        const properties = [];
        for (const attribute of type.attributes) {
          properties.push({
            name: attribute.name,
            optional: attribute.isOptional,
            astNodes: /* @__PURE__ */ new Set([attribute]),
            type: typeDefinitionToPropertyType(attribute.type)
          });
        }
        const superTypes = /* @__PURE__ */ new Set();
        for (const superType of type.superTypes) {
          if (superType.ref) {
            superTypes.add((0, internal_grammar_util_1.getTypeName)(superType.ref));
          }
        }
        const interfaceType = {
          name: type.name,
          declared: true,
          abstract: false,
          properties,
          superTypes,
          subTypes: /* @__PURE__ */ new Set()
        };
        declaredTypes.interfaces.push(interfaceType);
      }
      for (const union of unions) {
        const unionType = {
          name: union.name,
          declared: true,
          type: typeDefinitionToPropertyType(union.type),
          superTypes: /* @__PURE__ */ new Set(),
          subTypes: /* @__PURE__ */ new Set()
        };
        declaredTypes.unions.push(unionType);
      }
      return declaredTypes;
    }
    exports2.collectDeclaredTypes = collectDeclaredTypes;
    function typeDefinitionToPropertyType(type) {
      if ((0, ast_1.isArrayType)(type)) {
        return {
          elementType: typeDefinitionToPropertyType(type.elementType)
        };
      } else if ((0, ast_1.isReferenceType)(type)) {
        return {
          referenceType: typeDefinitionToPropertyType(type.referenceType)
        };
      } else if ((0, ast_1.isUnionType)(type)) {
        return {
          types: type.types.map(typeDefinitionToPropertyType)
        };
      } else if ((0, ast_1.isSimpleType)(type)) {
        let value;
        if (type.primitiveType) {
          value = type.primitiveType;
          return {
            primitive: value
          };
        } else if (type.stringType) {
          value = type.stringType;
          return {
            string: value
          };
        } else if (type.typeRef) {
          const ref = type.typeRef.ref;
          const value2 = (0, internal_grammar_util_1.getTypeNameWithoutError)(ref);
          if (value2) {
            if ((0, internal_grammar_util_1.isPrimitiveType)(value2)) {
              return {
                primitive: value2
              };
            } else {
              return {
                value: value2
              };
            }
          }
        }
      }
      return {
        primitive: "unknown"
      };
    }
    exports2.typeDefinitionToPropertyType = typeDefinitionToPropertyType;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/type-collector/all-types.js
var require_all_types = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/type-collector/all-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectAllAstResources = exports2.collectTypeResources = void 0;
    var inferred_types_1 = require_inferred_types();
    var declared_types_1 = require_declared_types();
    var ast_util_1 = require_ast_util();
    var ast_1 = require_ast();
    var internal_grammar_util_1 = require_internal_grammar_util();
    function collectTypeResources(grammars, documents) {
      const astResources = collectAllAstResources(grammars, documents);
      const declared = (0, declared_types_1.collectDeclaredTypes)(astResources.interfaces, astResources.types);
      const inferred = (0, inferred_types_1.collectInferredTypes)(astResources.parserRules, astResources.datatypeRules, declared);
      return {
        astResources,
        inferred,
        declared
      };
    }
    exports2.collectTypeResources = collectTypeResources;
    function collectAllAstResources(grammars, documents, visited = /* @__PURE__ */ new Set(), astResources = { parserRules: [], datatypeRules: [], interfaces: [], types: [] }) {
      if (!Array.isArray(grammars))
        grammars = [grammars];
      for (const grammar of grammars) {
        const doc = (0, ast_util_1.getDocument)(grammar);
        if (visited.has(doc.uri)) {
          continue;
        }
        visited.add(doc.uri);
        for (const rule of grammar.rules) {
          if ((0, ast_1.isParserRule)(rule) && !rule.fragment) {
            if ((0, internal_grammar_util_1.isDataTypeRule)(rule)) {
              astResources.datatypeRules.push(rule);
            } else {
              astResources.parserRules.push(rule);
            }
          }
        }
        grammar.interfaces.forEach((e) => astResources.interfaces.push(e));
        grammar.types.forEach((e) => astResources.types.push(e));
        if (documents) {
          const importedGrammars = grammar.imports.map((e) => (0, internal_grammar_util_1.resolveImport)(documents, e)).filter((e) => e !== void 0);
          collectAllAstResources(importedGrammars, documents, visited, astResources);
        }
      }
      return astResources;
    }
    exports2.collectAllAstResources = collectAllAstResources;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/ast-collector.js
var require_ast_collector = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/type-system/ast-collector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.specifyAstNodeProperties = exports2.createAstTypes = exports2.collectValidationAst = exports2.collectAst = void 0;
    var types_util_1 = require_types_util();
    var types_1 = require_types();
    var all_types_1 = require_all_types();
    var plain_types_1 = require_plain_types();
    function collectAst(grammars, documents) {
      const { inferred, declared } = (0, all_types_1.collectTypeResources)(grammars, documents);
      return createAstTypes(inferred, declared);
    }
    exports2.collectAst = collectAst;
    function collectValidationAst(grammars, documents) {
      const { inferred, declared, astResources } = (0, all_types_1.collectTypeResources)(grammars, documents);
      return {
        astResources,
        inferred: createAstTypes(declared, inferred),
        declared: createAstTypes(inferred, declared)
      };
    }
    exports2.collectValidationAst = collectValidationAst;
    function createAstTypes(first, second) {
      var _a, _b;
      const astTypes = {
        interfaces: (0, types_util_1.sortInterfacesTopologically)(mergeAndRemoveDuplicates(...first.interfaces, ...(_a = second === null || second === void 0 ? void 0 : second.interfaces) !== null && _a !== void 0 ? _a : [])),
        unions: mergeAndRemoveDuplicates(...first.unions, ...(_b = second === null || second === void 0 ? void 0 : second.unions) !== null && _b !== void 0 ? _b : [])
      };
      const finalTypes = (0, plain_types_1.plainToTypes)(astTypes);
      specifyAstNodeProperties(finalTypes);
      return finalTypes;
    }
    exports2.createAstTypes = createAstTypes;
    function mergeAndRemoveDuplicates(...elements) {
      return Array.from(elements.reduce((acc, type) => {
        acc.set(type.name, type);
        return acc;
      }, /* @__PURE__ */ new Map()).values()).sort((a, b) => a.name.localeCompare(b.name));
    }
    function specifyAstNodeProperties(astTypes) {
      const nameToType = filterInterfaceLikeTypes(astTypes);
      const array = Array.from(nameToType.values());
      addSubTypes(array);
      buildContainerTypes(array);
      buildTypeNames(array);
    }
    exports2.specifyAstNodeProperties = specifyAstNodeProperties;
    function buildTypeNames(types) {
      const visited = /* @__PURE__ */ new Set();
      const collect = (type) => {
        if (visited.has(type))
          return;
        visited.add(type);
        type.typeNames.add(type.name);
        for (const subtype of type.subTypes) {
          collect(subtype);
          subtype.typeNames.forEach((n) => type.typeNames.add(n));
        }
      };
      types.forEach(collect);
    }
    function filterInterfaceLikeTypes({ interfaces, unions }) {
      const nameToType = interfaces.concat(unions).reduce((acc, e) => {
        acc.set(e.name, e);
        return acc;
      }, /* @__PURE__ */ new Map());
      const cache = /* @__PURE__ */ new Map();
      for (const union of unions) {
        cache.set(union, isDataType(union.type, /* @__PURE__ */ new Set()));
      }
      for (const [union, isDataType2] of cache) {
        if (isDataType2) {
          nameToType.delete(union.name);
        }
      }
      return nameToType;
    }
    function isDataType(property, visited) {
      if (visited.has(property)) {
        return true;
      }
      visited.add(property);
      if ((0, types_1.isPropertyUnion)(property)) {
        return property.types.every((e) => isDataType(e, visited));
      } else if ((0, types_1.isValueType)(property)) {
        const value = property.value;
        if ((0, types_1.isUnionType)(value)) {
          return isDataType(value.type, visited);
        } else {
          return false;
        }
      } else {
        return (0, types_1.isPrimitiveType)(property) || (0, types_1.isStringType)(property);
      }
    }
    function addSubTypes(types) {
      for (const interfaceType of types) {
        for (const superTypeName of interfaceType.superTypes) {
          superTypeName.subTypes.add(interfaceType);
        }
      }
    }
    function buildContainerTypes(types) {
      const interfaces = types.filter(types_1.isInterfaceType);
      for (const interfaceType of interfaces) {
        const refTypes = interfaceType.properties.flatMap((property) => findChildTypes(property.type, /* @__PURE__ */ new Set()));
        for (const refType of refTypes) {
          refType.containerTypes.add(interfaceType);
        }
      }
      const connectedComponents = calculateConnectedComponents(types);
      shareContainerTypes(connectedComponents);
    }
    function findChildTypes(type, set) {
      if ((0, types_1.isPropertyUnion)(type)) {
        return type.types.flatMap((e) => findChildTypes(e, set));
      } else if ((0, types_1.isValueType)(type)) {
        if (set.has(type.value)) {
          return [];
        } else {
          set.add(type.value);
        }
        return [type.value];
      } else if ((0, types_1.isArrayType)(type)) {
        return findChildTypes(type.elementType, set);
      } else {
        return [];
      }
    }
    function calculateConnectedComponents(interfaces) {
      function dfs(typeInterface) {
        const component = [typeInterface];
        visited.add(typeInterface);
        const allTypes = [
          ...hierarchy.subTypes.get(typeInterface.name),
          ...hierarchy.superTypes.get(typeInterface.name)
        ];
        for (const nextTypeInterface of allTypes) {
          const nextType = map.get(nextTypeInterface);
          if (nextType && !visited.has(nextType)) {
            component.push(...dfs(nextType));
          }
        }
        return component;
      }
      const map = new Map(interfaces.map((e) => [e.name, e]));
      const connectedComponents = [];
      const hierarchy = (0, types_util_1.collectTypeHierarchy)(interfaces);
      const visited = /* @__PURE__ */ new Set();
      for (const typeInterface of interfaces) {
        if (!visited.has(typeInterface)) {
          connectedComponents.push(dfs(typeInterface));
        }
      }
      return connectedComponents;
    }
    function shareContainerTypes(connectedComponents) {
      for (const component of connectedComponents) {
        const superSet = /* @__PURE__ */ new Set();
        component.forEach((type) => type.containerTypes.forEach((e) => superSet.add(e)));
        component.forEach((type) => type.containerTypes = superSet);
      }
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/ast-reflection-interpreter.js
var require_ast_reflection_interpreter = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/ast-reflection-interpreter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.interpretAstReflection = void 0;
    var syntax_tree_1 = require_syntax_tree();
    var collections_1 = require_collections();
    var ast_1 = require_ast();
    var ast_collector_1 = require_ast_collector();
    var types_util_1 = require_types_util();
    function interpretAstReflection(grammarOrTypes, documents) {
      let collectedTypes;
      if ((0, ast_1.isGrammar)(grammarOrTypes)) {
        collectedTypes = (0, ast_collector_1.collectAst)(grammarOrTypes, documents);
      } else {
        collectedTypes = grammarOrTypes;
      }
      const allTypes = collectedTypes.interfaces.map((e) => e.name).concat(collectedTypes.unions.filter((e) => (0, types_util_1.isAstType)(e.type)).map((e) => e.name));
      const references = buildReferenceTypes(collectedTypes);
      const metaData = buildTypeMetaData(collectedTypes);
      const superTypes = (0, types_util_1.collectTypeHierarchy)((0, types_util_1.mergeTypesAndInterfaces)(collectedTypes)).superTypes;
      return new InterpretedAstReflection({
        allTypes,
        references,
        metaData,
        superTypes
      });
    }
    exports2.interpretAstReflection = interpretAstReflection;
    var InterpretedAstReflection = class extends syntax_tree_1.AbstractAstReflection {
      constructor(options) {
        super();
        this.allTypes = options.allTypes;
        this.references = options.references;
        this.metaData = options.metaData;
        this.superTypes = options.superTypes;
      }
      getAllTypes() {
        return this.allTypes;
      }
      getReferenceType(refInfo) {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        const referenceType = this.references.get(referenceId);
        if (referenceType) {
          return referenceType;
        }
        throw new Error("Could not find reference type for " + referenceId);
      }
      getTypeMetaData(type) {
        var _a;
        return (_a = this.metaData.get(type)) !== null && _a !== void 0 ? _a : {
          name: type,
          mandatory: []
        };
      }
      computeIsSubtype(subtype, originalSuperType) {
        const superTypes = this.superTypes.get(subtype);
        for (const superType of superTypes) {
          if (this.isSubtype(superType, originalSuperType)) {
            return true;
          }
        }
        return false;
      }
    };
    function buildReferenceTypes(astTypes) {
      const references = new collections_1.MultiMap();
      for (const interfaceType of astTypes.interfaces) {
        for (const property of interfaceType.properties) {
          for (const referenceType of (0, types_util_1.findReferenceTypes)(property.type)) {
            references.add(interfaceType.name, [property.name, referenceType]);
          }
        }
        for (const superType of interfaceType.interfaceSuperTypes) {
          const superTypeReferences = references.get(superType.name);
          references.addAll(interfaceType.name, superTypeReferences);
        }
      }
      const map = /* @__PURE__ */ new Map();
      for (const [type, [property, target]] of references) {
        map.set(`${type}:${property}`, target);
      }
      return map;
    }
    function buildTypeMetaData(astTypes) {
      const map = /* @__PURE__ */ new Map();
      for (const interfaceType of astTypes.interfaces) {
        const props = interfaceType.superProperties;
        const arrayProps = props.filter((e) => (0, types_util_1.hasArrayType)(e.type));
        const booleanProps = props.filter((e) => !(0, types_util_1.hasArrayType)(e.type) && (0, types_util_1.hasBooleanType)(e.type));
        if (arrayProps.length > 0 || booleanProps.length > 0) {
          map.set(interfaceType.name, {
            name: interfaceType.name,
            mandatory: buildMandatoryMetaData(arrayProps, booleanProps)
          });
        }
      }
      return map;
    }
    function buildMandatoryMetaData(arrayProps, booleanProps) {
      const array = [];
      const all = arrayProps.concat(booleanProps).sort((a, b) => a.name.localeCompare(b.name));
      for (const property of all) {
        const type = arrayProps.includes(property) ? "array" : "boolean";
        array.push({
          name: property.name,
          type
        });
      }
      return array;
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/generated/grammar.js
var require_grammar = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/generated/grammar.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarGrammar = void 0;
    var grammar_util_1 = require_grammar_util();
    var loadedLangiumGrammarGrammar;
    var LangiumGrammarGrammar = () => loadedLangiumGrammarGrammar !== null && loadedLangiumGrammarGrammar !== void 0 ? loadedLangiumGrammarGrammar : loadedLangiumGrammarGrammar = (0, grammar_util_1.loadGrammarFromJson)(`{
  "$type": "Grammar",
  "isDeclared": true,
  "name": "LangiumGrammar",
  "rules": [
    {
      "$type": "ParserRule",
      "name": "Grammar",
      "entry": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "isDeclared",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "grammar"
                }
              },
              {
                "$type": "Assignment",
                "feature": "name",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@59"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "with"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "usedGrammars",
                    "operator": "+=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/rules@0"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@59"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "usedGrammars",
                        "operator": "+=",
                        "terminal": {
                          "$type": "CrossReference",
                          "type": {
                            "$ref": "#/rules@0"
                          },
                          "terminal": {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@59"
                            },
                            "arguments": []
                          },
                          "deprecatedSyntax": false
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "definesHiddenTokens",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "hidden"
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "hiddenTokens",
                        "operator": "+=",
                        "terminal": {
                          "$type": "CrossReference",
                          "type": {
                            "$ref": "#/rules@11"
                          },
                          "terminal": {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@59"
                            },
                            "arguments": []
                          },
                          "deprecatedSyntax": false
                        }
                      },
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Keyword",
                            "value": ","
                          },
                          {
                            "$type": "Assignment",
                            "feature": "hiddenTokens",
                            "operator": "+=",
                            "terminal": {
                              "$type": "CrossReference",
                              "type": {
                                "$ref": "#/rules@11"
                              },
                              "terminal": {
                                "$type": "RuleCall",
                                "rule": {
                                  "$ref": "#/rules@59"
                                },
                                "arguments": []
                              },
                              "deprecatedSyntax": false
                            }
                          }
                        ],
                        "cardinality": "*"
                      }
                    ],
                    "cardinality": "?"
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "imports",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@12"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "rules",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@11"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "interfaces",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@1"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "types",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@10"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "+"
          }
        ]
      },
      "definesHiddenTokens": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Interface",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "interface"
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "extends"
              },
              {
                "$type": "Assignment",
                "feature": "superTypes",
                "operator": "+=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/types@0"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@59"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "superTypes",
                    "operator": "+=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/types@0"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@59"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  }
                ],
                "cardinality": "*"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@2"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SchemaType",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "{"
          },
          {
            "$type": "Assignment",
            "feature": "attributes",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@3"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": "}"
          },
          {
            "$type": "Keyword",
            "value": ";",
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@58"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "isOptional",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "?"
            },
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ":"
          },
          {
            "$type": "Assignment",
            "feature": "type",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@4"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";",
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeDefinition",
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@5"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnionType",
      "inferredType": {
        "$type": "InferredType",
        "name": "TypeDefinition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@6"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "UnionType"
                },
                "feature": "types",
                "operator": "+="
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "|"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "types",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@6"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ArrayType",
      "inferredType": {
        "$type": "InferredType",
        "name": "TypeDefinition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@7"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "ArrayType"
                },
                "feature": "elementType",
                "operator": "="
              },
              {
                "$type": "Keyword",
                "value": "["
              },
              {
                "$type": "Keyword",
                "value": "]"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReferenceType",
      "inferredType": {
        "$type": "InferredType",
        "name": "TypeDefinition"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@8"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "ReferenceType"
                }
              },
              {
                "$type": "Keyword",
                "value": "@"
              },
              {
                "$type": "Assignment",
                "feature": "referenceType",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@8"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SimpleType",
      "inferredType": {
        "$type": "InferredType",
        "name": "TypeDefinition"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@4"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "SimpleType"
                }
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "typeRef",
                    "operator": "=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/types@0"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@59"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "primitiveType",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@9"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "stringType",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@60"
                      },
                      "arguments": []
                    }
                  }
                ]
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrimitiveType",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "string"
          },
          {
            "$type": "Keyword",
            "value": "number"
          },
          {
            "$type": "Keyword",
            "value": "boolean"
          },
          {
            "$type": "Keyword",
            "value": "Date"
          },
          {
            "$type": "Keyword",
            "value": "bigint"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Type",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "type"
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "="
          },
          {
            "$type": "Assignment",
            "feature": "type",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@4"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";",
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AbstractRule",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@13"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@46"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "GrammarImport",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "import"
          },
          {
            "$type": "Assignment",
            "feature": "path",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@60"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";",
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParserRule",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "entry",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "entry"
                }
              },
              {
                "$type": "Assignment",
                "feature": "fragment",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "fragment"
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@15"
            },
            "arguments": []
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "wildcard",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "*"
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "returns"
                  },
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "returnType",
                        "operator": "=",
                        "terminal": {
                          "$type": "CrossReference",
                          "type": {
                            "$ref": "#/types@0"
                          },
                          "terminal": {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@59"
                            },
                            "arguments": []
                          },
                          "deprecatedSyntax": false
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "dataType",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@9"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  }
                ]
              },
              {
                "$type": "Assignment",
                "feature": "inferredType",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@14"
                  },
                  "arguments": [
                    {
                      "$type": "NamedArgument",
                      "value": {
                        "$type": "LiteralCondition",
                        "true": false
                      },
                      "calledByName": false
                    }
                  ]
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "definesHiddenTokens",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "hidden"
                }
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "hiddenTokens",
                    "operator": "+=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/rules@11"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@59"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "hiddenTokens",
                        "operator": "+=",
                        "terminal": {
                          "$type": "CrossReference",
                          "type": {
                            "$ref": "#/rules@11"
                          },
                          "terminal": {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@59"
                            },
                            "arguments": []
                          },
                          "deprecatedSyntax": false
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ":"
          },
          {
            "$type": "Assignment",
            "feature": "definition",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InferredType",
      "parameters": [
        {
          "$type": "Parameter",
          "name": "imperative"
        }
      ],
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "guardCondition": {
                  "$type": "ParameterReference",
                  "parameter": {
                    "$ref": "#/rules@14/parameters@0"
                  }
                },
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "infer"
                  }
                ]
              },
              {
                "$type": "Group",
                "guardCondition": {
                  "$type": "Negation",
                  "value": {
                    "$type": "ParameterReference",
                    "parameter": {
                      "$ref": "#/rules@14/parameters@0"
                    }
                  }
                },
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "infers"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RuleNameAndParams",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "<"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "parameters",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@16"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "parameters",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@16"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ">"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Parameter",
      "definition": {
        "$type": "Assignment",
        "feature": "name",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@59"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Alternatives",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@18"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Alternatives"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "|"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "elements",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@18"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConditionalBranch",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@19"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Group"
                }
              },
              {
                "$type": "Keyword",
                "value": "<"
              },
              {
                "$type": "Assignment",
                "feature": "guardCondition",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@29"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ">"
              },
              {
                "$type": "Assignment",
                "feature": "elements",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@21"
                  },
                  "arguments": []
                },
                "cardinality": "+"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnorderedGroup",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@20"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "UnorderedGroup"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "&"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "elements",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@20"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Group",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@21"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Group"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "elements",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@21"
                  },
                  "arguments": []
                },
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AbstractToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@22"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@23"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AbstractTokenWithCardinality",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@37"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@24"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "cardinality",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "?"
                },
                {
                  "$type": "Keyword",
                  "value": "*"
                },
                {
                  "$type": "Keyword",
                  "value": "+"
                }
              ]
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Action",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "Action"
            }
          },
          {
            "$type": "Keyword",
            "value": "{"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "type",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/types@0"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@59"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Assignment",
                "feature": "inferredType",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@14"
                  },
                  "arguments": [
                    {
                      "$type": "NamedArgument",
                      "value": {
                        "$type": "LiteralCondition",
                        "true": true
                      },
                      "calledByName": false
                    }
                  ]
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "."
              },
              {
                "$type": "Assignment",
                "feature": "feature",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@58"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "="
                    },
                    {
                      "$type": "Keyword",
                      "value": "+="
                    }
                  ]
                }
              },
              {
                "$type": "Keyword",
                "value": "current"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "}"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AbstractTerminal",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@25"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@26"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@43"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@35"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@36"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@44"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Keyword",
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@60"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RuleCall",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "rule",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@11"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@59"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "<"
              },
              {
                "$type": "Assignment",
                "feature": "arguments",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@27"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "arguments",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@27"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              },
              {
                "$type": "Keyword",
                "value": ">"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamedArgument",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "parameter",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/rules@16"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@59"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Assignment",
                "feature": "calledByName",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "="
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@29"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LiteralCondition",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "true",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "true"
            }
          },
          {
            "$type": "Keyword",
            "value": "false"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Disjunction",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@30"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Disjunction"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Keyword",
                "value": "|"
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@30"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Conjunction",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@31"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Conjunction"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Keyword",
                "value": "&"
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@31"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Negation",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Negation"
                }
              },
              {
                "$type": "Keyword",
                "value": "!"
              },
              {
                "$type": "Assignment",
                "feature": "value",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@31"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Atom",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@34"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@33"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@28"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParenthesizedCondition",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@29"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParameterReference",
      "definition": {
        "$type": "Assignment",
        "feature": "parameter",
        "operator": "=",
        "terminal": {
          "$type": "CrossReference",
          "type": {
            "$ref": "#/rules@16"
          },
          "terminal": {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@59"
            },
            "arguments": []
          },
          "deprecatedSyntax": false
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PredicatedKeyword",
      "inferredType": {
        "$type": "InferredType",
        "name": "Keyword"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "=>"
              },
              {
                "$type": "Keyword",
                "value": "->"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@60"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PredicatedRuleCall",
      "inferredType": {
        "$type": "InferredType",
        "name": "RuleCall"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "=>"
              },
              {
                "$type": "Keyword",
                "value": "->"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "rule",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@11"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@59"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "<"
              },
              {
                "$type": "Assignment",
                "feature": "arguments",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@27"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "arguments",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@27"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              },
              {
                "$type": "Keyword",
                "value": ">"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Assignment",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "Assignment"
            }
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "=>"
              },
              {
                "$type": "Keyword",
                "value": "->"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "feature",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@58"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "operator",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "+="
                },
                {
                  "$type": "Keyword",
                  "value": "="
                },
                {
                  "$type": "Keyword",
                  "value": "?="
                }
              ]
            }
          },
          {
            "$type": "Assignment",
            "feature": "terminal",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@38"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AssignableTerminal",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@25"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@26"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@39"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@41"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParenthesizedAssignableElement",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@40"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AssignableAlternatives",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@38"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Alternatives"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "|"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "elements",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@38"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CrossReference",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "CrossReference"
            }
          },
          {
            "$type": "Keyword",
            "value": "["
          },
          {
            "$type": "Assignment",
            "feature": "type",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/types@0"
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "deprecatedSyntax",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "|"
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ":"
                  }
                ]
              },
              {
                "$type": "Assignment",
                "feature": "terminal",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@42"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "]"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CrossReferenceableTerminal",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@25"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@26"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParenthesizedElement",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@17"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PredicatedGroup",
      "inferredType": {
        "$type": "InferredType",
        "name": "Group"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "=>"
              },
              {
                "$type": "Keyword",
                "value": "->"
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "elements",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReturnType",
      "definition": {
        "$type": "Assignment",
        "feature": "name",
        "operator": "=",
        "terminal": {
          "$type": "Alternatives",
          "elements": [
            {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@9"
              },
              "arguments": []
            },
            {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          ]
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalRule",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "hidden",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "hidden"
            },
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "terminal"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "fragment",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "fragment"
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "name",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@59"
                      },
                      "arguments": []
                    }
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "name",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@59"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "returns"
                      },
                      {
                        "$type": "Assignment",
                        "feature": "type",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@45"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ":"
          },
          {
            "$type": "Assignment",
            "feature": "definition",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@47"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalAlternatives",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@48"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "TerminalAlternatives"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Keyword",
                "value": "|"
              },
              {
                "$type": "Assignment",
                "feature": "elements",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@48"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalGroup",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@49"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "TerminalGroup"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "elements",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@49"
                  },
                  "arguments": []
                },
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@50"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "cardinality",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "?"
                },
                {
                  "$type": "Keyword",
                  "value": "*"
                },
                {
                  "$type": "Keyword",
                  "value": "+"
                }
              ]
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalTokenElement",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@57"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@52"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@51"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@53"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@54"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@55"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@56"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParenthesizedTerminalElement",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "lookahead",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "?="
                },
                {
                  "$type": "Keyword",
                  "value": "?!"
                }
              ]
            },
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@47"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalRuleCall",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "TerminalRuleCall"
            }
          },
          {
            "$type": "Assignment",
            "feature": "rule",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@46"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@59"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NegatedToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "NegatedToken"
            }
          },
          {
            "$type": "Keyword",
            "value": "!"
          },
          {
            "$type": "Assignment",
            "feature": "terminal",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@50"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UntilToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "UntilToken"
            }
          },
          {
            "$type": "Keyword",
            "value": "->"
          },
          {
            "$type": "Assignment",
            "feature": "terminal",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@50"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RegexToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "RegexToken"
            }
          },
          {
            "$type": "Assignment",
            "feature": "regex",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@61"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Wildcard",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "Wildcard"
            }
          },
          {
            "$type": "Keyword",
            "value": "."
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CharacterRange",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "CharacterRange"
            }
          },
          {
            "$type": "Assignment",
            "feature": "left",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@25"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ".."
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@25"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureName",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "current"
          },
          {
            "$type": "Keyword",
            "value": "entry"
          },
          {
            "$type": "Keyword",
            "value": "extends"
          },
          {
            "$type": "Keyword",
            "value": "false"
          },
          {
            "$type": "Keyword",
            "value": "fragment"
          },
          {
            "$type": "Keyword",
            "value": "grammar"
          },
          {
            "$type": "Keyword",
            "value": "hidden"
          },
          {
            "$type": "Keyword",
            "value": "import"
          },
          {
            "$type": "Keyword",
            "value": "interface"
          },
          {
            "$type": "Keyword",
            "value": "returns"
          },
          {
            "$type": "Keyword",
            "value": "terminal"
          },
          {
            "$type": "Keyword",
            "value": "true"
          },
          {
            "$type": "Keyword",
            "value": "type"
          },
          {
            "$type": "Keyword",
            "value": "infer"
          },
          {
            "$type": "Keyword",
            "value": "infers"
          },
          {
            "$type": "Keyword",
            "value": "with"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@9"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@59"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "TerminalRule",
      "name": "ID",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\^?[_a-zA-Z][\\\\w_]*"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "STRING",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\"(\\\\\\\\.|[^\\"\\\\\\\\])*\\"|'(\\\\\\\\.|[^'\\\\\\\\])*'"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "RegexLiteral",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/(?![*+?])(?:[^\\\\r\\\\n\\\\[/\\\\\\\\]|\\\\\\\\.|\\\\[(?:[^\\\\r\\\\n\\\\]\\\\\\\\]|\\\\\\\\.)*\\\\])+\\\\/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "WS",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\s+"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "ML_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "SL_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\/[^\\\\n\\\\r]*"
      },
      "fragment": false
    }
  ],
  "types": [
    {
      "$type": "Type",
      "name": "AbstractType",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@1"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@10"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@23/definition/elements@0"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@13"
            }
          }
        ]
      }
    }
  ],
  "definesHiddenTokens": false,
  "hiddenTokens": [],
  "imports": [],
  "interfaces": [],
  "usedGrammars": []
}`);
    exports2.LangiumGrammarGrammar = LangiumGrammarGrammar;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/generated/module.js
var require_module = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/generated/module.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarGeneratedModule = exports2.LangiumGrammarGeneratedSharedModule = exports2.LangiumGrammarParserConfig = exports2.LangiumGrammarLanguageMetaData = void 0;
    var ast_1 = require_ast();
    var grammar_1 = require_grammar();
    exports2.LangiumGrammarLanguageMetaData = {
      languageId: "langium",
      fileExtensions: [".langium"],
      caseInsensitive: false
    };
    exports2.LangiumGrammarParserConfig = {
      maxLookahead: 3
    };
    exports2.LangiumGrammarGeneratedSharedModule = {
      AstReflection: () => new ast_1.LangiumGrammarAstReflection()
    };
    exports2.LangiumGrammarGeneratedModule = {
      Grammar: () => (0, grammar_1.LangiumGrammarGrammar)(),
      LanguageMetaData: () => exports2.LangiumGrammarLanguageMetaData,
      parser: {
        ParserConfig: () => exports2.LangiumGrammarParserConfig
      }
    };
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/promise-util.js
var require_promise_util = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/promise-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Deferred = exports2.MutexLock = exports2.interruptAndCheck = exports2.isOperationCancelled = exports2.OperationCancelled = exports2.setInterruptionPeriod = exports2.startCancelableOperation = exports2.delayNextTick = void 0;
    var vscode_jsonrpc_1 = require_main();
    function delayNextTick() {
      return new Promise((resolve) => {
        if (typeof setImmediate === "undefined") {
          setTimeout(resolve, 0);
        } else {
          setImmediate(resolve);
        }
      });
    }
    exports2.delayNextTick = delayNextTick;
    var lastTick = 0;
    var globalInterruptionPeriod = 10;
    function startCancelableOperation() {
      lastTick = Date.now();
      return new vscode_jsonrpc_1.CancellationTokenSource();
    }
    exports2.startCancelableOperation = startCancelableOperation;
    function setInterruptionPeriod(period) {
      globalInterruptionPeriod = period;
    }
    exports2.setInterruptionPeriod = setInterruptionPeriod;
    exports2.OperationCancelled = Symbol("OperationCancelled");
    function isOperationCancelled(err) {
      return err === exports2.OperationCancelled;
    }
    exports2.isOperationCancelled = isOperationCancelled;
    async function interruptAndCheck(token) {
      if (token === vscode_jsonrpc_1.CancellationToken.None) {
        return;
      }
      const current = Date.now();
      if (current - lastTick >= globalInterruptionPeriod) {
        lastTick = current;
        await delayNextTick();
      }
      if (token.isCancellationRequested) {
        throw exports2.OperationCancelled;
      }
    }
    exports2.interruptAndCheck = interruptAndCheck;
    var MutexLock = class {
      constructor() {
        this.previousAction = Promise.resolve();
        this.previousTokenSource = new vscode_jsonrpc_1.CancellationTokenSource();
      }
      /**
       * Performs a single async action, like initializing the workspace or processing document changes.
       * Only one action will be executed at a time.
       *
       * When another action is queued up, the token provided for the action will be cancelled.
       * Assuming the action makes use of this token, the next action only has to wait for the current action to finish cancellation.
       */
      lock(action) {
        this.cancel();
        const tokenSource = new vscode_jsonrpc_1.CancellationTokenSource();
        this.previousTokenSource = tokenSource;
        return this.previousAction = this.previousAction.then(() => action(tokenSource.token).catch((err) => {
          if (!isOperationCancelled(err)) {
            console.error("Error: ", err);
          }
        }));
      }
      /**
       * Cancels the currently executed action
       */
      cancel() {
        this.previousTokenSource.cancel();
      }
    };
    exports2.MutexLock = MutexLock;
    var Deferred = class {
      constructor() {
        this.promise = new Promise((resolve, reject) => {
          this.resolve = (arg) => (resolve(arg), this);
          this.reject = (err) => (reject(err), this);
        });
      }
    };
    exports2.Deferred = Deferred;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/references/scope-computation.js
var require_scope_computation = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/references/scope-computation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultScopeComputation = void 0;
    var vscode_jsonrpc_1 = require_main();
    var ast_util_1 = require_ast_util();
    var collections_1 = require_collections();
    var promise_util_1 = require_promise_util();
    var DefaultScopeComputation = class {
      constructor(services) {
        this.nameProvider = services.references.NameProvider;
        this.descriptions = services.workspace.AstNodeDescriptionProvider;
      }
      async computeExports(document, cancelToken = vscode_jsonrpc_1.CancellationToken.None) {
        return this.computeExportsForNode(document.parseResult.value, document, void 0, cancelToken);
      }
      /**
       * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.
       * The list of children to be considered is determined by the function parameter {@link children}.
       * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.
       *
       * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.
       * @param document The document containing the AST node to be exported.
       * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.
       * @param cancelToken Indicates when to cancel the current operation.
       * @throws `OperationCanceled` if a user action occurs during execution.
       * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.
       */
      async computeExportsForNode(parentNode, document, children = ast_util_1.streamContents, cancelToken = vscode_jsonrpc_1.CancellationToken.None) {
        const exports3 = [];
        this.exportNode(parentNode, exports3, document);
        for (const node of children(parentNode)) {
          await (0, promise_util_1.interruptAndCheck)(cancelToken);
          this.exportNode(node, exports3, document);
        }
        return exports3;
      }
      /**
       * Add a single node to the list of exports if it has a name. Override this method to change how
       * symbols are exported, e.g. by modifying their exported name.
       */
      exportNode(node, exports3, document) {
        const name = this.nameProvider.getName(node);
        if (name) {
          exports3.push(this.descriptions.createDescription(node, name, document));
        }
      }
      async computeLocalScopes(document, cancelToken = vscode_jsonrpc_1.CancellationToken.None) {
        const rootNode = document.parseResult.value;
        const scopes = new collections_1.MultiMap();
        for (const node of (0, ast_util_1.streamAllContents)(rootNode)) {
          await (0, promise_util_1.interruptAndCheck)(cancelToken);
          this.processNode(node, document, scopes);
        }
        return scopes;
      }
      /**
       * Process a single node during scopes computation. The default implementation makes the node visible
       * in the subtree of its container (if the node has a name). Override this method to change this,
       * e.g. by increasing the visibility to a higher level in the AST.
       */
      processNode(node, document, scopes) {
        const container = node.$container;
        if (container) {
          const name = this.nameProvider.getName(node);
          if (name) {
            scopes.add(container, this.descriptions.createDescription(node, name, document));
          }
        }
      }
    };
    exports2.DefaultScopeComputation = DefaultScopeComputation;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/references/scope-provider.js
var require_scope_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/references/scope-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultScopeProvider = exports2.EMPTY_SCOPE = exports2.StreamScope = void 0;
    var ast_util_1 = require_ast_util();
    var stream_1 = require_stream();
    var StreamScope = class {
      constructor(elements, outerScope, options) {
        this.elements = elements;
        this.outerScope = outerScope;
        this.caseInsensitive = options === null || options === void 0 ? void 0 : options.caseInsensitive;
      }
      getAllElements() {
        if (this.outerScope) {
          return this.elements.concat(this.outerScope.getAllElements());
        } else {
          return this.elements;
        }
      }
      getElement(name) {
        const local = this.caseInsensitive ? this.elements.find((e) => e.name.toLowerCase() === name.toLowerCase()) : this.elements.find((e) => e.name === name);
        if (local) {
          return local;
        }
        if (this.outerScope) {
          return this.outerScope.getElement(name);
        }
        return void 0;
      }
    };
    exports2.StreamScope = StreamScope;
    exports2.EMPTY_SCOPE = {
      getElement() {
        return void 0;
      },
      getAllElements() {
        return stream_1.EMPTY_STREAM;
      }
    };
    var DefaultScopeProvider = class {
      constructor(services) {
        this.reflection = services.shared.AstReflection;
        this.nameProvider = services.references.NameProvider;
        this.descriptions = services.workspace.AstNodeDescriptionProvider;
        this.indexManager = services.shared.workspace.IndexManager;
      }
      getScope(context) {
        const scopes = [];
        const referenceType = this.reflection.getReferenceType(context);
        const precomputed = (0, ast_util_1.getDocument)(context.container).precomputedScopes;
        if (precomputed) {
          let currentNode = context.container;
          do {
            const allDescriptions = precomputed.get(currentNode);
            if (allDescriptions.length > 0) {
              scopes.push((0, stream_1.stream)(allDescriptions).filter((desc) => this.reflection.isSubtype(desc.type, referenceType)));
            }
            currentNode = currentNode.$container;
          } while (currentNode);
        }
        let result = this.getGlobalScope(referenceType, context);
        for (let i = scopes.length - 1; i >= 0; i--) {
          result = this.createScope(scopes[i], result);
        }
        return result;
      }
      /**
       * Create a scope for the given collection of AST node descriptions.
       */
      createScope(elements, outerScope, options) {
        return new StreamScope((0, stream_1.stream)(elements), outerScope, options);
      }
      /**
       * Create a scope for the given collection of AST nodes, which need to be transformed into respective
       * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.
       */
      createScopeForNodes(elements, outerScope, options) {
        const s = (0, stream_1.stream)(elements).map((e) => {
          const name = this.nameProvider.getName(e);
          if (name) {
            return this.descriptions.createDescription(e, name);
          }
          return void 0;
        }).nonNullable();
        return new StreamScope(s, outerScope, options);
      }
      /**
       * Create a global scope filtered for the given reference type.
       */
      getGlobalScope(referenceType, _context) {
        return new StreamScope(this.indexManager.allElements(referenceType));
      }
    };
    exports2.DefaultScopeProvider = DefaultScopeProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/uri-util.js
var require_uri_util = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/uri-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.relativeURI = exports2.equalURI = void 0;
    function equalURI(a, b) {
      return (a === null || a === void 0 ? void 0 : a.toString()) === (b === null || b === void 0 ? void 0 : b.toString());
    }
    exports2.equalURI = equalURI;
    function relativeURI(from, to) {
      const fromPath = from.path;
      const toPath = to.path;
      const fromParts = fromPath.split("/").filter((e) => e.length > 0);
      const toParts = toPath.split("/").filter((e) => e.length > 0);
      let i = 0;
      for (; i < fromParts.length; i++) {
        if (fromParts[i] !== toParts[i]) {
          break;
        }
      }
      const backPart = "../".repeat(fromParts.length - i);
      const toPart = toParts.slice(i).join("/");
      return backPart + toPart;
    }
    exports2.relativeURI = relativeURI;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/references/grammar-scope.js
var require_grammar_scope = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/references/grammar-scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarScopeComputation = exports2.LangiumGrammarScopeProvider = void 0;
    var scope_computation_1 = require_scope_computation();
    var scope_provider_1 = require_scope_provider();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var stream_1 = require_stream();
    var uri_util_1 = require_uri_util();
    var ast_1 = require_ast();
    var internal_grammar_util_1 = require_internal_grammar_util();
    var LangiumGrammarScopeProvider = class extends scope_provider_1.DefaultScopeProvider {
      constructor(services) {
        super(services);
      }
      getScope(context) {
        const referenceType = this.reflection.getReferenceType(context);
        if (referenceType === ast_1.AbstractType) {
          return this.getTypeScope(referenceType, context);
        } else {
          return super.getScope(context);
        }
      }
      getTypeScope(referenceType, context) {
        let localScope;
        const precomputed = (0, ast_util_1.getDocument)(context.container).precomputedScopes;
        const rootNode = (0, ast_util_1.findRootNode)(context.container);
        if (precomputed && rootNode) {
          const allDescriptions = precomputed.get(rootNode);
          if (allDescriptions.length > 0) {
            localScope = (0, stream_1.stream)(allDescriptions).filter((des) => des.type === ast_1.Interface || des.type === ast_1.Type);
          }
        }
        const globalScope = this.getGlobalScope(referenceType, context);
        if (localScope) {
          return this.createScope(localScope, globalScope);
        } else {
          return globalScope;
        }
      }
      getGlobalScope(referenceType, context) {
        const grammar = (0, ast_util_1.getContainerOfType)(context.container, ast_1.isGrammar);
        if (!grammar) {
          return scope_provider_1.EMPTY_SCOPE;
        }
        const importedUris = (0, stream_1.stream)(grammar.imports).map(internal_grammar_util_1.resolveImportUri).nonNullable();
        let importedElements = this.indexManager.allElements(referenceType).filter((des) => importedUris.some((importedUri) => (0, uri_util_1.equalURI)(des.documentUri, importedUri)));
        if (referenceType === ast_1.AbstractType) {
          importedElements = importedElements.filter((des) => des.type === ast_1.Interface || des.type === ast_1.Type);
        }
        return new scope_provider_1.StreamScope(importedElements);
      }
    };
    exports2.LangiumGrammarScopeProvider = LangiumGrammarScopeProvider;
    var LangiumGrammarScopeComputation = class extends scope_computation_1.DefaultScopeComputation {
      constructor(services) {
        super(services);
        this.astNodeLocator = services.workspace.AstNodeLocator;
      }
      exportNode(node, exports3, document) {
        var _a;
        super.exportNode(node, exports3, document);
        if ((0, ast_1.isParserRule)(node)) {
          if (!node.returnType && !node.dataType) {
            const typeNode = (_a = node.inferredType) !== null && _a !== void 0 ? _a : node;
            exports3.push(this.createInterfaceDescription(typeNode, typeNode.name, document));
          }
          (0, ast_util_1.streamAllContents)(node).forEach((childNode) => {
            if ((0, ast_1.isAction)(childNode) && childNode.inferredType) {
              const typeName = (0, internal_grammar_util_1.getActionType)(childNode);
              if (typeName) {
                exports3.push(this.createInterfaceDescription(childNode, typeName, document));
              }
            }
          });
        }
      }
      processNode(node, document, scopes) {
        if ((0, ast_1.isReturnType)(node))
          return;
        this.processTypeNode(node, document, scopes);
        this.processActionNode(node, document, scopes);
        super.processNode(node, document, scopes);
      }
      /**
       * Add synthetic Interface in case of explicitly or implicitly inferred type:<br>
       * cases: `ParserRule: ...;` or `ParserRule infers Type: ...;`
       */
      processTypeNode(node, document, scopes) {
        var _a;
        const container = node.$container;
        if (container && (0, ast_1.isParserRule)(node) && !node.returnType && !node.dataType) {
          const typeNode = (_a = node.inferredType) !== null && _a !== void 0 ? _a : node;
          scopes.add(container, this.createInterfaceDescription(typeNode, typeNode.name, document));
        }
      }
      /**
       * Add synthetic Interface in case of explicitly inferred type:
       *
       * case: `{infer Action}`
       */
      processActionNode(node, document, scopes) {
        const container = (0, ast_util_1.findRootNode)(node);
        if (container && (0, ast_1.isAction)(node) && node.inferredType) {
          const typeName = (0, internal_grammar_util_1.getActionType)(node);
          if (typeName) {
            scopes.add(container, this.createInterfaceDescription(node, typeName, document));
          }
        }
      }
      createInterfaceDescription(node, name, document = (0, ast_util_1.getDocument)(node)) {
        var _a;
        const nameNode = (_a = this.nameProvider.getNameNode(node)) !== null && _a !== void 0 ? _a : node.$cstNode;
        return {
          node,
          name,
          nameSegment: (0, cst_util_1.toDocumentSegment)(nameNode),
          selectionSegment: (0, cst_util_1.toDocumentSegment)(node.$cstNode),
          type: "Interface",
          documentUri: document.uri,
          path: this.astNodeLocator.getAstNodePath(node)
        };
      }
    };
    exports2.LangiumGrammarScopeComputation = LangiumGrammarScopeComputation;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/validation/validator.js
var require_validator = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/validation/validator.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarValidator = exports2.IssueCodes = exports2.registerValidationChecks = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var ast_util_1 = require_ast_util();
    var collections_1 = require_collections();
    var cst_util_1 = require_cst_util();
    var grammar_util_1 = require_grammar_util();
    var stream_1 = require_stream();
    var ast2 = __importStar(require_ast());
    var ast_1 = require_ast();
    var internal_grammar_util_1 = require_internal_grammar_util();
    var declared_types_1 = require_declared_types();
    var plain_types_1 = require_plain_types();
    function registerValidationChecks(services) {
      const registry = services.validation.ValidationRegistry;
      const validator = services.validation.LangiumGrammarValidator;
      const checks = {
        Action: [
          validator.checkAssignmentReservedName
        ],
        AbstractRule: validator.checkRuleName,
        Assignment: [
          validator.checkAssignmentWithFeatureName,
          validator.checkAssignmentToFragmentRule,
          validator.checkAssignmentTypes,
          validator.checkAssignmentReservedName
        ],
        ParserRule: [
          validator.checkParserRuleDataType,
          validator.checkRuleParametersUsed,
          validator.checkParserRuleReservedName
        ],
        TerminalRule: [
          validator.checkTerminalRuleReturnType,
          validator.checkHiddenTerminalRule,
          validator.checkEmptyTerminalRule
        ],
        InferredType: validator.checkTypeReservedName,
        Keyword: validator.checkKeyword,
        UnorderedGroup: validator.checkUnorderedGroup,
        Grammar: [
          validator.checkGrammarName,
          validator.checkEntryGrammarRule,
          validator.checkUniqueRuleName,
          validator.checkUniqueTypeName,
          validator.checkUniqueImportedRules,
          validator.checkDuplicateImportedGrammar,
          validator.checkGrammarHiddenTokens,
          validator.checkGrammarForUnusedRules,
          validator.checkGrammarTypeInfer,
          validator.checkClashingTerminalNames
        ],
        GrammarImport: validator.checkPackageImport,
        CharacterRange: validator.checkInvalidCharacterRange,
        Interface: [
          validator.checkTypeReservedName,
          validator.checkInterfacePropertyTypes
        ],
        Type: [
          validator.checkTypeReservedName
        ],
        TypeAttribute: validator.checkTypeReservedName,
        RuleCall: [
          validator.checkUsedHiddenTerminalRule,
          validator.checkUsedFragmentTerminalRule,
          validator.checkRuleCallParameters
        ],
        TerminalRuleCall: validator.checkUsedHiddenTerminalRule,
        CrossReference: [
          validator.checkCrossReferenceSyntax,
          validator.checkCrossRefNameAssignment,
          validator.checkCrossRefTerminalType,
          validator.checkCrossRefType,
          validator.checkCrossReferenceToTypeUnion
        ],
        SimpleType: validator.checkFragmentsInTypes,
        ReferenceType: validator.checkReferenceTypeUnion
      };
      registry.register(checks, validator);
    }
    exports2.registerValidationChecks = registerValidationChecks;
    var IssueCodes;
    (function(IssueCodes2) {
      IssueCodes2.GrammarNameUppercase = "grammar-name-uppercase";
      IssueCodes2.RuleNameUppercase = "rule-name-uppercase";
      IssueCodes2.HiddenGrammarTokens = "hidden-grammar-tokens";
      IssueCodes2.UseRegexTokens = "use-regex-tokens";
      IssueCodes2.EntryRuleTokenSyntax = "entry-rule-token-syntax";
      IssueCodes2.CrossRefTokenSyntax = "cross-ref-token-syntax";
      IssueCodes2.UnnecessaryFileExtension = "unnecessary-file-extension";
      IssueCodes2.InvalidReturns = "invalid-returns";
      IssueCodes2.InvalidInfers = "invalid-infers";
      IssueCodes2.MissingInfer = "missing-infer";
      IssueCodes2.MissingReturns = "missing-returns";
      IssueCodes2.SuperfluousInfer = "superfluous-infer";
      IssueCodes2.OptionalUnorderedGroup = "optional-unordered-group";
    })(IssueCodes = exports2.IssueCodes || (exports2.IssueCodes = {}));
    var LangiumGrammarValidator = class {
      constructor(services) {
        this.references = services.references.References;
        this.documents = services.shared.workspace.LangiumDocuments;
      }
      checkGrammarName(grammar, accept) {
        if (grammar.name) {
          const firstChar = grammar.name.substring(0, 1);
          if (firstChar.toUpperCase() !== firstChar) {
            accept("warning", "Grammar name should start with an upper case letter.", { node: grammar, property: "name", code: IssueCodes.GrammarNameUppercase });
          }
        }
      }
      checkEntryGrammarRule(grammar, accept) {
        if (grammar.isDeclared && !grammar.name) {
          return;
        }
        const entryRules = grammar.rules.filter((e) => ast2.isParserRule(e) && e.entry);
        if (grammar.isDeclared && entryRules.length === 0) {
          const possibleEntryRule = grammar.rules.find((e) => ast2.isParserRule(e) && !(0, internal_grammar_util_1.isDataTypeRule)(e));
          if (possibleEntryRule) {
            accept("error", "The grammar is missing an entry parser rule. This rule can be an entry one.", { node: possibleEntryRule, property: "name", code: IssueCodes.EntryRuleTokenSyntax });
          } else {
            accept("error", "This grammar is missing an entry parser rule.", { node: grammar, property: "name" });
          }
        } else if (!grammar.isDeclared && entryRules.length >= 1) {
          entryRules.forEach((rule) => accept("error", "Cannot declare entry rules for unnamed grammars.", { node: rule, property: "name" }));
        } else if (entryRules.length > 1) {
          entryRules.forEach((rule) => accept("error", "The entry rule has to be unique.", { node: rule, property: "name" }));
        } else if (entryRules.length === 1 && (0, internal_grammar_util_1.isDataTypeRule)(entryRules[0])) {
          accept("error", "The entry rule cannot be a data type rule.", { node: entryRules[0], property: "name" });
        }
      }
      /**
       * Check whether any rule defined in this grammar is a duplicate of an already defined rule or an imported rule
       */
      checkUniqueRuleName(grammar, accept) {
        const extractor = (grammar2) => (0, stream_1.stream)(grammar2.rules).filter((rule) => !isEmptyRule(rule));
        this.checkUniqueName(grammar, accept, extractor, "rule");
      }
      /**
       * Check whether any type defined in this grammar is a duplicate of an already defined type or an imported type
       */
      checkUniqueTypeName(grammar, accept) {
        const extractor = (grammar2) => (0, stream_1.stream)(grammar2.types).concat(grammar2.interfaces);
        this.checkUniqueName(grammar, accept, extractor, "type");
      }
      checkUniqueName(grammar, accept, extractor, uniqueObjName) {
        const map = new collections_1.MultiMap();
        extractor(grammar).forEach((e) => map.add(e.name, e));
        for (const [, types] of map.entriesGroupedByKey()) {
          if (types.length > 1) {
            types.forEach((e) => {
              accept("error", `A ${uniqueObjName}'s name has to be unique.`, { node: e, property: "name" });
            });
          }
        }
        const imported = /* @__PURE__ */ new Set();
        const resolvedGrammars = (0, internal_grammar_util_1.resolveTransitiveImports)(this.documents, grammar);
        for (const resolvedGrammar of resolvedGrammars) {
          extractor(resolvedGrammar).forEach((e) => imported.add(e.name));
        }
        for (const name of map.keys()) {
          if (imported.has(name)) {
            const types = map.get(name);
            types.forEach((e) => {
              accept("error", `A ${uniqueObjName} with the name '${e.name}' already exists in an imported grammar.`, { node: e, property: "name" });
            });
          }
        }
      }
      checkDuplicateImportedGrammar(grammar, accept) {
        const importMap = new collections_1.MultiMap();
        for (const imp of grammar.imports) {
          const resolvedGrammar = (0, internal_grammar_util_1.resolveImport)(this.documents, imp);
          if (resolvedGrammar) {
            importMap.add(resolvedGrammar, imp);
          }
        }
        for (const [, imports] of importMap.entriesGroupedByKey()) {
          if (imports.length > 1) {
            imports.forEach((imp, i) => {
              if (i > 0) {
                accept("warning", "The grammar is already being directly imported.", { node: imp, tags: [vscode_languageserver_types_1.DiagnosticTag.Unnecessary] });
              }
            });
          }
        }
      }
      /**
       * Compared to the validation above, this validation only checks whether two imported grammars export the same grammar rule.
       */
      checkUniqueImportedRules(grammar, accept) {
        const imports = /* @__PURE__ */ new Map();
        for (const imp of grammar.imports) {
          const importedGrammars = (0, internal_grammar_util_1.resolveTransitiveImports)(this.documents, imp);
          imports.set(imp, importedGrammars);
        }
        const allDuplicates = new collections_1.MultiMap();
        for (const outerImport of grammar.imports) {
          const outerGrammars = imports.get(outerImport);
          for (const innerImport of grammar.imports) {
            if (outerImport === innerImport) {
              continue;
            }
            const innerGrammars = imports.get(innerImport);
            const duplicates = this.getDuplicateExportedRules(outerGrammars, innerGrammars);
            for (const duplicate of duplicates) {
              allDuplicates.add(outerImport, duplicate);
            }
          }
        }
        for (const imp of grammar.imports) {
          const duplicates = allDuplicates.get(imp);
          if (duplicates.length > 0) {
            accept("error", "Some rules exported by this grammar are also included in other imports: " + (0, stream_1.stream)(duplicates).distinct().join(", "), { node: imp, property: "path" });
          }
        }
      }
      getDuplicateExportedRules(outer, inner) {
        const exclusiveOuter = outer.filter((g) => !inner.includes(g));
        const outerRules = exclusiveOuter.flatMap((e) => e.rules);
        const innerRules = inner.flatMap((e) => e.rules);
        const duplicates = /* @__PURE__ */ new Set();
        for (const outerRule of outerRules) {
          const outerName = outerRule.name;
          for (const innerRule of innerRules) {
            const innerName = innerRule.name;
            if (outerName === innerName) {
              duplicates.add(innerRule.name);
            }
          }
        }
        return duplicates;
      }
      checkGrammarTypeInfer(grammar, accept) {
        var _a, _b, _c;
        const types = /* @__PURE__ */ new Set();
        for (const type of grammar.types) {
          types.add(type.name);
        }
        for (const interfaceType of grammar.interfaces) {
          types.add(interfaceType.name);
        }
        (0, internal_grammar_util_1.resolveTransitiveImports)(this.documents, grammar).forEach((grammar2) => {
          grammar2.types.forEach((type) => types.add(type.name));
          grammar2.interfaces.forEach((iface) => types.add(iface.name));
        });
        for (const rule of grammar.rules.filter(ast2.isParserRule)) {
          if (isEmptyRule(rule)) {
            continue;
          }
          const isDataType = (0, internal_grammar_util_1.isDataTypeRule)(rule);
          const isInfers = !rule.returnType && !rule.dataType;
          const ruleTypeName = (0, internal_grammar_util_1.getTypeNameWithoutError)(rule);
          if (!isDataType && ruleTypeName && types.has(ruleTypeName) === isInfers) {
            if ((isInfers || ((_a = rule.returnType) === null || _a === void 0 ? void 0 : _a.ref) !== void 0) && rule.inferredType === void 0) {
              accept("error", getMessage(ruleTypeName, isInfers), {
                node: rule,
                property: "name",
                code: IssueCodes.MissingReturns
              });
            } else if (isInfers || ((_b = rule.returnType) === null || _b === void 0 ? void 0 : _b.ref) !== void 0) {
              const infersNode = (0, grammar_util_1.findNodeForKeyword)(rule.inferredType.$cstNode, "infers");
              accept("error", getMessage(ruleTypeName, isInfers), {
                node: rule.inferredType,
                property: "name",
                code: IssueCodes.InvalidInfers,
                data: (0, cst_util_1.toDocumentSegment)(infersNode)
              });
            }
          } else if (isDataType && isInfers) {
            const inferNode = (0, grammar_util_1.findNodeForKeyword)(rule.$cstNode, "infer");
            accept("error", "Data type rules cannot infer a type.", {
              node: rule,
              property: "inferredType",
              code: IssueCodes.InvalidInfers,
              data: (0, cst_util_1.toDocumentSegment)(inferNode)
            });
          }
        }
        for (const action of (0, ast_util_1.streamAllContents)(grammar).filter(ast2.isAction)) {
          const actionType = this.getActionType(action);
          if (actionType) {
            const isInfers = Boolean(action.inferredType);
            const typeName = (0, internal_grammar_util_1.getTypeNameWithoutError)(action);
            if (action.type && typeName && types.has(typeName) === isInfers) {
              const keywordNode = isInfers ? (0, grammar_util_1.findNodeForKeyword)(action.$cstNode, "infer") : (0, grammar_util_1.findNodeForKeyword)(action.$cstNode, "{");
              accept("error", getMessage(typeName, isInfers), {
                node: action,
                property: "type",
                code: isInfers ? IssueCodes.SuperfluousInfer : IssueCodes.MissingInfer,
                data: (0, cst_util_1.toDocumentSegment)(keywordNode)
              });
            } else if (actionType && typeName && types.has(typeName) && isInfers) {
              if (action.$cstNode) {
                const inferredTypeNode = (0, grammar_util_1.findNodeForProperty)((_c = action.inferredType) === null || _c === void 0 ? void 0 : _c.$cstNode, "name");
                const keywordNode = (0, grammar_util_1.findNodeForKeyword)(action.$cstNode, "{");
                if (inferredTypeNode && keywordNode) {
                  accept("error", `${typeName} is a declared type and cannot be redefined.`, {
                    node: action,
                    property: "type",
                    code: IssueCodes.SuperfluousInfer,
                    data: {
                      start: keywordNode.range.end,
                      end: inferredTypeNode.range.start
                    }
                  });
                }
              }
            }
          }
        }
        function getMessage(name, infer) {
          if (infer) {
            return `The type '${name}' is already explicitly declared and cannot be inferred.`;
          } else {
            return `The type '${name}' is not explicitly declared and must be inferred.`;
          }
        }
      }
      getActionType(rule) {
        var _a;
        if (rule.type) {
          return (_a = rule.type) === null || _a === void 0 ? void 0 : _a.ref;
        } else if (rule.inferredType) {
          return rule.inferredType;
        }
        return void 0;
      }
      checkGrammarHiddenTokens(grammar, accept) {
        if (grammar.definesHiddenTokens) {
          accept("error", "Hidden terminals are declared at the terminal definition.", { node: grammar, property: "definesHiddenTokens", code: IssueCodes.HiddenGrammarTokens });
        }
      }
      checkHiddenTerminalRule(terminalRule, accept) {
        if (terminalRule.hidden && terminalRule.fragment) {
          accept("error", "Cannot use terminal fragments as hidden tokens.", { node: terminalRule, property: "hidden" });
        }
      }
      checkEmptyTerminalRule(terminalRule, accept) {
        try {
          const regex2 = (0, internal_grammar_util_1.terminalRegex)(terminalRule);
          if (new RegExp(regex2).test("")) {
            accept("error", "This terminal could match an empty string.", { node: terminalRule, property: "name" });
          }
        } catch (_a) {
        }
      }
      checkUsedHiddenTerminalRule(ruleCall, accept) {
        const parentRule = (0, ast_util_1.getContainerOfType)(ruleCall, (n) => ast2.isTerminalRule(n) || ast2.isParserRule(n));
        if (parentRule) {
          if ("hidden" in parentRule && parentRule.hidden) {
            return;
          }
          const ref = ruleCall.rule.ref;
          if (ast2.isTerminalRule(ref) && ref.hidden) {
            accept("error", "Cannot use hidden terminal in non-hidden rule", { node: ruleCall, property: "rule" });
          }
        }
      }
      checkUsedFragmentTerminalRule(ruleCall, accept) {
        const terminal = ruleCall.rule.ref;
        if (ast2.isTerminalRule(terminal) && terminal.fragment) {
          const parentRule = (0, ast_util_1.getContainerOfType)(ruleCall, ast2.isParserRule);
          if (parentRule) {
            accept("error", "Cannot use terminal fragments as part of parser rules.", { node: ruleCall, property: "rule" });
          }
        }
      }
      checkCrossReferenceSyntax(crossRef, accept) {
        if (crossRef.deprecatedSyntax) {
          accept("error", "'|' is deprecated. Please, use ':' instead.", { node: crossRef, property: "deprecatedSyntax", code: IssueCodes.CrossRefTokenSyntax });
        }
      }
      checkPackageImport(imp, accept) {
        const resolvedGrammar = (0, internal_grammar_util_1.resolveImport)(this.documents, imp);
        if (resolvedGrammar === void 0) {
          accept("error", "Import cannot be resolved.", { node: imp, property: "path" });
        } else if (imp.path.endsWith(".langium")) {
          accept("warning", "Imports do not need file extensions.", { node: imp, property: "path", code: IssueCodes.UnnecessaryFileExtension });
        }
      }
      checkInvalidCharacterRange(range, accept) {
        if (range.right) {
          const message = "Character ranges cannot use more than one character";
          let invalid = false;
          if (range.left.value.length > 1) {
            invalid = true;
            accept("error", message, { node: range.left, property: "value" });
          }
          if (range.right.value.length > 1) {
            invalid = true;
            accept("error", message, { node: range.right, property: "value" });
          }
          if (!invalid) {
            accept("hint", "Consider using regex instead of character ranges", { node: range, code: IssueCodes.UseRegexTokens });
          }
        }
      }
      checkGrammarForUnusedRules(grammar, accept) {
        const reachableRules = (0, grammar_util_1.getAllReachableRules)(grammar, true);
        for (const rule of grammar.rules) {
          if (ast2.isTerminalRule(rule) && rule.hidden || isEmptyRule(rule)) {
            continue;
          }
          if (!reachableRules.has(rule)) {
            accept("hint", "This rule is declared but never referenced.", {
              node: rule,
              property: "name",
              tags: [vscode_languageserver_types_1.DiagnosticTag.Unnecessary]
            });
          }
        }
      }
      checkClashingTerminalNames(grammar, accept) {
        const localTerminals = new collections_1.MultiMap();
        const localKeywords = /* @__PURE__ */ new Set();
        for (const rule of grammar.rules) {
          if (ast2.isTerminalRule(rule) && rule.name) {
            localTerminals.add(rule.name, rule);
          }
          if (ast2.isParserRule(rule)) {
            const keywords = (0, ast_util_1.streamAllContents)(rule).filter(ast2.isKeyword);
            keywords.forEach((e) => localKeywords.add(e.value));
          }
        }
        const importedTerminals = new collections_1.MultiMap();
        const importedKeywords = new collections_1.MultiMap();
        for (const importNode of grammar.imports) {
          const importedGrammars = (0, internal_grammar_util_1.resolveTransitiveImports)(this.documents, importNode);
          for (const importedGrammar of importedGrammars) {
            for (const rule of importedGrammar.rules) {
              if (ast2.isTerminalRule(rule) && rule.name) {
                importedTerminals.add(rule.name, importNode);
              } else if (ast2.isParserRule(rule) && rule.name) {
                const keywords = (0, ast_util_1.streamAllContents)(rule).filter(ast2.isKeyword);
                keywords.forEach((e) => importedKeywords.add(e.value, importNode));
              }
            }
          }
        }
        for (const localTerminal of localTerminals.values()) {
          if (localKeywords.has(localTerminal.name)) {
            accept("error", "Terminal name clashes with existing keyword.", {
              node: localTerminal,
              property: "name"
            });
          } else if (importedKeywords.has(localTerminal.name)) {
            const importNode = importedKeywords.get(localTerminal.name);
            accept("error", `Terminal name clashes with imported keyword from "${importNode[0].path}".`, {
              node: localTerminal,
              property: "name"
            });
          }
        }
        const importTerminalMap = new collections_1.MultiMap();
        for (const localKeyword of localKeywords) {
          for (const importNode of importedTerminals.get(localKeyword)) {
            importTerminalMap.add(importNode, localKeyword);
          }
        }
        for (const [importNode, keywords] of importTerminalMap.entriesGroupedByKey()) {
          if (keywords.length > 0) {
            accept("error", `Imported terminals (${keywords.join(", ")}) clash with locally defined keywords.`, {
              node: importNode,
              property: "path"
            });
          }
        }
        const importKeywordMap = new collections_1.MultiMap();
        for (const [name, imports] of importedTerminals.entriesGroupedByKey()) {
          const keywordImports = importedKeywords.get(name);
          if (keywordImports.length > 0) {
            imports.filter((e) => !keywordImports.includes(e)).forEach((e) => importKeywordMap.add(e, name));
          }
        }
        for (const [importNode, keywords] of importKeywordMap.entriesGroupedByKey()) {
          if (keywords.length > 0) {
            accept("error", `Imported terminals (${keywords.join(", ")}) clash with imported keywords.`, {
              node: importNode,
              property: "path"
            });
          }
        }
      }
      checkRuleName(rule, accept) {
        if (rule.name && !isEmptyRule(rule)) {
          const firstChar = rule.name.substring(0, 1);
          if (firstChar.toUpperCase() !== firstChar) {
            accept("warning", "Rule name should start with an upper case letter.", {
              node: rule,
              property: "name",
              code: IssueCodes.RuleNameUppercase
            });
          }
        }
      }
      checkTypeReservedName(type, accept) {
        this.checkReservedName(type, "name", accept);
      }
      checkAssignmentReservedName(assignment, accept) {
        this.checkReservedName(assignment, "feature", accept);
      }
      checkParserRuleReservedName(rule, accept) {
        if (!rule.inferredType) {
          this.checkReservedName(rule, "name", accept);
        }
      }
      checkReservedName(node, property, accept) {
        const name = node[property];
        if (typeof name === "string" && reservedNames.has(name)) {
          accept("error", `'${name}' is a reserved name of the JavaScript runtime.`, {
            node,
            property
          });
        }
      }
      checkKeyword(keyword, accept) {
        if ((0, ast_util_1.getContainerOfType)(keyword, ast_1.isParserRule)) {
          if (keyword.value.length === 0) {
            accept("error", "Keywords cannot be empty.", { node: keyword });
          } else if (keyword.value.trim().length === 0) {
            accept("error", "Keywords cannot only consist of whitespace characters.", { node: keyword });
          } else if (/\s/g.test(keyword.value)) {
            accept("warning", "Keywords should not contain whitespace characters.", { node: keyword });
          }
        }
      }
      checkUnorderedGroup(unorderedGroup, accept) {
        unorderedGroup.elements.forEach((ele) => {
          if ((0, internal_grammar_util_1.isOptionalCardinality)(ele.cardinality)) {
            accept("error", "Optional elements in Unordered groups are currently not supported", { node: ele, code: IssueCodes.OptionalUnorderedGroup });
          }
        });
      }
      checkRuleParametersUsed(rule, accept) {
        const parameters = rule.parameters;
        if (parameters.length > 0) {
          const allReferences = (0, ast_util_1.streamAllContents)(rule).filter(ast2.isParameterReference);
          for (const parameter of parameters) {
            if (!allReferences.some((e) => e.parameter.ref === parameter)) {
              accept("hint", `Parameter '${parameter.name}' is unused.`, {
                node: parameter,
                tags: [vscode_languageserver_types_1.DiagnosticTag.Unnecessary]
              });
            }
          }
        }
      }
      checkParserRuleDataType(rule, accept) {
        if (isEmptyRule(rule)) {
          return;
        }
        const hasDatatypeReturnType = (0, internal_grammar_util_1.hasDataTypeReturn)(rule);
        const dataTypeRule = (0, internal_grammar_util_1.isDataTypeRule)(rule);
        if (!hasDatatypeReturnType && dataTypeRule) {
          accept("error", "This parser rule does not create an object. Add a primitive return type or an action to the start of the rule to force object instantiation.", { node: rule, property: "name" });
        } else if (hasDatatypeReturnType && !dataTypeRule) {
          accept("error", "Normal parser rules are not allowed to return a primitive value. Use a datatype rule for that.", { node: rule, property: rule.dataType ? "dataType" : "returnType" });
        }
      }
      checkAssignmentToFragmentRule(assignment, accept) {
        if (!assignment.terminal) {
          return;
        }
        if ((0, ast_1.isRuleCall)(assignment.terminal) && (0, ast_1.isParserRule)(assignment.terminal.rule.ref) && assignment.terminal.rule.ref.fragment) {
          accept("error", `Cannot use fragment rule '${assignment.terminal.rule.ref.name}' for assignment of property '${assignment.feature}'.`, { node: assignment, property: "terminal" });
        }
      }
      checkAssignmentTypes(assignment, accept) {
        if (!assignment.terminal) {
          return;
        }
        let firstType;
        const foundMixed = (0, ast_util_1.streamAllContents)(assignment.terminal).map((node) => ast2.isCrossReference(node) ? "ref" : "other").find((type) => {
          if (!firstType) {
            firstType = type;
            return false;
          }
          return type !== firstType;
        });
        if (foundMixed) {
          accept("error", this.createMixedTypeError(assignment.feature), {
            node: assignment,
            property: "terminal"
          });
        }
      }
      checkInterfacePropertyTypes(interfaceDecl, accept) {
        for (const attribute of interfaceDecl.attributes) {
          if (attribute.type) {
            const plainType = (0, declared_types_1.typeDefinitionToPropertyType)(attribute.type);
            const flattened = (0, plain_types_1.flattenPlainType)(plainType);
            let hasRef = false;
            let hasNonRef = false;
            for (const flat of flattened) {
              if ((0, plain_types_1.isPlainReferenceType)(flat)) {
                hasRef = true;
              } else if (!(0, plain_types_1.isPlainReferenceType)(flat)) {
                hasNonRef = true;
              }
            }
            if (hasRef && hasNonRef) {
              accept("error", this.createMixedTypeError(attribute.name), {
                node: attribute,
                property: "type"
              });
            }
          }
        }
      }
      createMixedTypeError(propName) {
        return `Mixing a cross-reference with other types is not supported. Consider splitting property "${propName}" into two or more different properties.`;
      }
      checkTerminalRuleReturnType(rule, accept) {
        var _a;
        if (((_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) && !(0, internal_grammar_util_1.isPrimitiveType)(rule.type.name)) {
          accept("error", "Terminal rules can only return primitive types like 'string', 'boolean', 'number', 'Date' or 'bigint'.", { node: rule.type, property: "name" });
        }
      }
      checkRuleCallParameters(ruleCall, accept) {
        const rule = ruleCall.rule.ref;
        if (ast2.isParserRule(rule)) {
          const expected = rule.parameters.length;
          const given = ruleCall.arguments.length;
          if (expected !== given) {
            accept("error", `Rule '${rule.name}' expects ${expected} arguments, but got ${given}.`, { node: ruleCall });
          }
        } else if (ast2.isTerminalRule(rule) && ruleCall.arguments.length > 0) {
          accept("error", "Terminal rules do not accept any arguments", { node: ruleCall });
        }
      }
      checkCrossRefNameAssignment(reference, accept) {
        if (!reference.terminal && reference.type.ref && !(0, grammar_util_1.findNameAssignment)(reference.type.ref)) {
          accept("error", "Cannot infer terminal or data type rule for cross reference.", { node: reference, property: "type" });
        }
      }
      checkCrossRefTerminalType(reference, accept) {
        if (ast2.isRuleCall(reference.terminal) && ast2.isParserRule(reference.terminal.rule.ref) && !(0, internal_grammar_util_1.isDataTypeRule)(reference.terminal.rule.ref)) {
          accept("error", "Parser rules cannot be used for cross references.", { node: reference.terminal, property: "rule" });
        }
      }
      checkCrossRefType(reference, accept) {
        const issue = this.checkReferenceToRuleButNotType(reference === null || reference === void 0 ? void 0 : reference.type);
        if (issue) {
          accept("error", issue, { node: reference, property: "type" });
        }
      }
      checkCrossReferenceToTypeUnion(reference, accept) {
        if (ast2.isType(reference.type.ref) && ast2.isUnionType(reference.type.ref.type)) {
          const errors = checkTypeUnionContainsOnlyParseRules(reference.type.ref.type);
          if (errors.length > 0) {
            accept("error", `Cross-reference on type union is only valid if all alternatives are AST nodes. ${errors.join(", ")} ${errors.length > 1 ? "are" : "is"} not ${errors.length > 1 ? "" : "an "}AST node${errors.length > 1 ? "s" : ""}.`, { node: reference, property: "type" });
          }
        }
      }
      checkFragmentsInTypes(type, accept) {
        var _a, _b;
        if (ast2.isParserRule((_a = type.typeRef) === null || _a === void 0 ? void 0 : _a.ref) && ((_b = type.typeRef) === null || _b === void 0 ? void 0 : _b.ref.fragment)) {
          accept("error", "Cannot use rule fragments in types.", { node: type, property: "typeRef" });
        }
      }
      checkReferenceTypeUnion(type, accept) {
        if (!ast2.isSimpleType(type.referenceType)) {
          accept("error", "Only direct rule references are allowed in reference types.", { node: type, property: "referenceType" });
        }
      }
      checkReferenceToRuleButNotType(type) {
        if (type && ast2.isParserRule(type.ref) && !(0, internal_grammar_util_1.isDataTypeRule)(type.ref) && (type.ref.returnType || type.ref.inferredType)) {
          const typeName = (0, internal_grammar_util_1.getTypeNameWithoutError)(type.ref);
          if (typeName) {
            return `Use the rule type '${typeName}' instead of the typed rule name '${type.ref.name}' for cross references.`;
          }
        }
        return void 0;
      }
      checkAssignmentWithFeatureName(assignment, accept) {
        if (assignment.feature === "name" && ast2.isCrossReference(assignment.terminal)) {
          accept("warning", 'The "name" property is not recommended for cross-references.', { node: assignment, property: "feature" });
        }
      }
    };
    exports2.LangiumGrammarValidator = LangiumGrammarValidator;
    function isEmptyRule(rule) {
      return !rule.definition || !rule.definition.$cstNode || rule.definition.$cstNode.length === 0;
    }
    var reservedNames = /* @__PURE__ */ new Set([
      // Built-in objects, properties and methods
      // Collections
      "Array",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array",
      // Keyed collections
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      // Errors
      "Error",
      "AggregateError",
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError",
      // Primitives
      "BigInt",
      "RegExp",
      "Number",
      "Object",
      "Function",
      "Symbol",
      "String",
      // Math
      "Math",
      "NaN",
      "Infinity",
      "isFinite",
      "isNaN",
      // Structured data
      "Buffer",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "Atomics",
      "DataView",
      "JSON",
      "globalThis",
      "decodeURIComponent",
      "decodeURI",
      "encodeURIComponent",
      "encodeURI",
      "parseInt",
      "parseFloat",
      // Control abstraction
      "Promise",
      "Generator",
      "GeneratorFunction",
      "AsyncFunction",
      "AsyncGenerator",
      "AsyncGeneratorFunction",
      // Reflection
      "Reflect",
      "Proxy",
      // Others
      "Date",
      "Intl",
      "eval",
      "undefined"
    ]);
    function checkTypeUnionContainsOnlyParseRules(type) {
      const errors = [];
      type.types.forEach((type2) => {
        var _a;
        if (ast2.isSimpleType(type2)) {
          if ((_a = type2.typeRef) === null || _a === void 0 ? void 0 : _a.ref) {
            if (ast2.isType(type2.typeRef.ref)) {
              if (ast2.isUnionType(type2.typeRef.ref.type)) {
                errors.push(...checkTypeUnionContainsOnlyParseRules(type2.typeRef.ref.type));
              } else {
                errors.push(type2.typeRef.ref.name);
              }
            }
          } else if (type2.stringType) {
            errors.push(`"${type2.stringType}"`);
          } else if (type2.primitiveType) {
            errors.push(type2.primitiveType);
          }
        }
      });
      return Array.from(new Set(errors));
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/validation/document-validator.js
var require_document_validator = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/validation/document-validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentValidator = exports2.toDiagnosticSeverity = exports2.getDiagnosticRange = exports2.DefaultDocumentValidator = void 0;
    var vscode_languageserver_1 = require_main4();
    var grammar_util_1 = require_grammar_util();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var promise_util_1 = require_promise_util();
    var DefaultDocumentValidator = class {
      constructor(services) {
        this.validationRegistry = services.validation.ValidationRegistry;
        this.metadata = services.LanguageMetaData;
      }
      async validateDocument(document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const parseResult = document.parseResult;
        const diagnostics = [];
        await (0, promise_util_1.interruptAndCheck)(cancelToken);
        for (const lexerError of parseResult.lexerErrors) {
          const diagnostic = {
            severity: vscode_languageserver_1.DiagnosticSeverity.Error,
            range: {
              start: {
                line: lexerError.line - 1,
                character: lexerError.column - 1
              },
              end: {
                line: lexerError.line - 1,
                character: lexerError.column + lexerError.length - 1
              }
            },
            message: lexerError.message,
            code: DocumentValidator.LexingError,
            source: this.getSource()
          };
          diagnostics.push(diagnostic);
        }
        for (const parserError of parseResult.parserErrors) {
          let range = void 0;
          if (isNaN(parserError.token.startOffset)) {
            if ("previousToken" in parserError) {
              const token = parserError.previousToken;
              if (!isNaN(token.startOffset)) {
                const position = vscode_languageserver_1.Position.create(token.endLine - 1, token.endColumn);
                range = vscode_languageserver_1.Range.create(position, position);
              } else {
                range = vscode_languageserver_1.Range.create(0, 0, 0, 0);
              }
            }
          } else {
            range = (0, cst_util_1.tokenToRange)(parserError.token);
          }
          if (range) {
            const diagnostic = {
              severity: vscode_languageserver_1.DiagnosticSeverity.Error,
              range,
              message: parserError.message,
              code: DocumentValidator.ParsingError,
              source: this.getSource()
            };
            diagnostics.push(diagnostic);
          }
        }
        for (const reference of document.references) {
          const linkingError = reference.error;
          if (linkingError) {
            const data = {
              containerType: linkingError.container.$type,
              property: linkingError.property,
              refText: linkingError.reference.$refText
            };
            const info = {
              node: linkingError.container,
              property: linkingError.property,
              index: linkingError.index,
              code: DocumentValidator.LinkingError,
              data
            };
            diagnostics.push(this.toDiagnostic("error", linkingError.message, info));
          }
        }
        try {
          diagnostics.push(...await this.validateAst(parseResult.value, document, cancelToken));
        } catch (err) {
          if ((0, promise_util_1.isOperationCancelled)(err)) {
            throw err;
          }
          console.error("An error occurred during validation:", err);
        }
        await (0, promise_util_1.interruptAndCheck)(cancelToken);
        return diagnostics;
      }
      async validateAst(rootNode, document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const validationItems = [];
        const acceptor = (severity, message, info) => {
          validationItems.push(this.toDiagnostic(severity, message, info));
        };
        await Promise.all((0, ast_util_1.streamAst)(rootNode).map(async (node) => {
          await (0, promise_util_1.interruptAndCheck)(cancelToken);
          const checks = this.validationRegistry.getChecks(node.$type);
          for (const check of checks) {
            await check(node, acceptor, cancelToken);
          }
        }));
        return validationItems;
      }
      toDiagnostic(severity, message, info) {
        return {
          message,
          range: getDiagnosticRange(info),
          severity: toDiagnosticSeverity(severity),
          code: info.code,
          codeDescription: info.codeDescription,
          tags: info.tags,
          relatedInformation: info.relatedInformation,
          data: info.data,
          source: this.getSource()
        };
      }
      getSource() {
        return this.metadata.languageId;
      }
    };
    exports2.DefaultDocumentValidator = DefaultDocumentValidator;
    function getDiagnosticRange(info) {
      if (vscode_languageserver_1.Range.is(info.range)) {
        return info.range;
      }
      let cstNode;
      if (typeof info.property === "string") {
        cstNode = (0, grammar_util_1.findNodeForProperty)(info.node.$cstNode, info.property, info.index);
      } else if (typeof info.keyword === "string") {
        cstNode = (0, grammar_util_1.findNodeForKeyword)(info.node.$cstNode, info.keyword, info.index);
      }
      cstNode !== null && cstNode !== void 0 ? cstNode : cstNode = info.node.$cstNode;
      if (!cstNode) {
        return {
          start: { line: 0, character: 0 },
          end: { line: 0, character: 0 }
        };
      }
      return cstNode.range;
    }
    exports2.getDiagnosticRange = getDiagnosticRange;
    function toDiagnosticSeverity(severity) {
      switch (severity) {
        case "error":
          return vscode_languageserver_1.DiagnosticSeverity.Error;
        case "warning":
          return vscode_languageserver_1.DiagnosticSeverity.Warning;
        case "info":
          return vscode_languageserver_1.DiagnosticSeverity.Information;
        case "hint":
          return vscode_languageserver_1.DiagnosticSeverity.Hint;
        default:
          throw new Error("Invalid diagnostic severity: " + severity);
      }
    }
    exports2.toDiagnosticSeverity = toDiagnosticSeverity;
    var DocumentValidator;
    (function(DocumentValidator2) {
      DocumentValidator2.LexingError = "lexing-error";
      DocumentValidator2.ParsingError = "parsing-error";
      DocumentValidator2.LinkingError = "linking-error";
    })(DocumentValidator = exports2.DocumentValidator || (exports2.DocumentValidator = {}));
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/lsp/grammar-code-actions.js
var require_grammar_code_actions = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/lsp/grammar-code-actions.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarCodeActionProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var vscode_uri_1 = require_umd();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var grammar_util_1 = require_grammar_util();
    var regex_util_1 = require_regex_util();
    var uri_util_1 = require_uri_util();
    var document_validator_1 = require_document_validator();
    var ast2 = __importStar(require_ast());
    var validator_1 = require_validator();
    var LangiumGrammarCodeActionProvider = class {
      constructor(services) {
        this.reflection = services.shared.AstReflection;
        this.indexManager = services.shared.workspace.IndexManager;
      }
      getCodeActions(document, params) {
        const result = [];
        const acceptor = (ca) => ca && result.push(ca);
        for (const diagnostic of params.context.diagnostics) {
          this.createCodeActions(diagnostic, document, acceptor);
        }
        return result;
      }
      createCodeActions(diagnostic, document, accept) {
        switch (diagnostic.code) {
          case validator_1.IssueCodes.GrammarNameUppercase:
          case validator_1.IssueCodes.RuleNameUppercase:
            accept(this.makeUpperCase(diagnostic, document));
            break;
          case validator_1.IssueCodes.HiddenGrammarTokens:
            accept(this.fixHiddenTerminals(diagnostic, document));
            break;
          case validator_1.IssueCodes.UseRegexTokens:
            accept(this.fixRegexTokens(diagnostic, document));
            break;
          case validator_1.IssueCodes.EntryRuleTokenSyntax:
            accept(this.addEntryKeyword(diagnostic, document));
            break;
          case validator_1.IssueCodes.CrossRefTokenSyntax:
            accept(this.fixCrossRefSyntax(diagnostic, document));
            break;
          case validator_1.IssueCodes.UnnecessaryFileExtension:
            accept(this.fixUnnecessaryFileExtension(diagnostic, document));
            break;
          case validator_1.IssueCodes.MissingReturns:
            accept(this.fixMissingReturns(diagnostic, document));
            break;
          case validator_1.IssueCodes.InvalidInfers:
          case validator_1.IssueCodes.InvalidReturns:
            accept(this.fixInvalidReturnsInfers(diagnostic, document));
            break;
          case validator_1.IssueCodes.MissingInfer:
            accept(this.fixMissingInfer(diagnostic, document));
            break;
          case validator_1.IssueCodes.SuperfluousInfer:
            accept(this.fixSuperfluousInfer(diagnostic, document));
            break;
          case document_validator_1.DocumentValidator.LinkingError: {
            const data = diagnostic.data;
            if (data && data.containerType === "RuleCall" && data.property === "rule") {
              accept(this.addNewRule(diagnostic, data, document));
            }
            if (data) {
              this.lookInGlobalScope(diagnostic, data, document).forEach(accept);
            }
            break;
          }
        }
        return void 0;
      }
      /**
       * Adds missing returns for parser rule
       */
      fixMissingReturns(diagnostic, document) {
        const text = document.textDocument.getText(diagnostic.range);
        if (text) {
          return {
            title: `Add explicit return type for parser rule ${text}`,
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            diagnostics: [diagnostic],
            edit: {
              changes: {
                [document.textDocument.uri]: [{
                  range: diagnostic.range,
                  newText: `${text} returns ${text}`
                  // suggestion adds missing 'return'
                }]
              }
            }
          };
        }
        return void 0;
      }
      fixInvalidReturnsInfers(diagnostic, document) {
        const data = diagnostic.data;
        if (data) {
          const text = document.textDocument.getText(data.range);
          return {
            title: `Correct ${text} usage`,
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            diagnostics: [diagnostic],
            edit: {
              changes: {
                [document.textDocument.uri]: [{
                  range: data.range,
                  newText: text === "infers" ? "returns" : "infers"
                }]
              }
            }
          };
        }
        return void 0;
      }
      fixMissingInfer(diagnostic, document) {
        const data = diagnostic.data;
        if (data) {
          return {
            title: "Correct 'infer' usage",
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            diagnostics: [diagnostic],
            edit: {
              changes: {
                [document.textDocument.uri]: [{
                  range: {
                    start: data.range.end,
                    end: data.range.end
                  },
                  newText: "infer "
                }]
              }
            }
          };
        }
        return void 0;
      }
      fixSuperfluousInfer(diagnostic, document) {
        if (diagnostic.data) {
          return {
            title: "Remove the 'infer' keyword",
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            diagnostics: [diagnostic],
            edit: {
              changes: {
                [document.textDocument.uri]: [{
                  range: diagnostic.data,
                  newText: ""
                }]
              }
            }
          };
        }
        return void 0;
      }
      fixUnnecessaryFileExtension(diagnostic, document) {
        const end = Object.assign({}, diagnostic.range.end);
        end.character -= 1;
        const start = Object.assign({}, end);
        start.character -= ".langium".length;
        return {
          title: "Remove file extension",
          kind: vscode_languageserver_1.CodeActionKind.QuickFix,
          diagnostics: [diagnostic],
          isPreferred: true,
          edit: {
            changes: {
              [document.textDocument.uri]: [{
                range: {
                  start,
                  end
                },
                newText: ""
              }]
            }
          }
        };
      }
      makeUpperCase(diagnostic, document) {
        const range = {
          start: diagnostic.range.start,
          end: {
            line: diagnostic.range.start.line,
            character: diagnostic.range.start.character + 1
          }
        };
        return {
          title: "First letter to upper case",
          kind: vscode_languageserver_1.CodeActionKind.QuickFix,
          diagnostics: [diagnostic],
          isPreferred: true,
          edit: {
            changes: {
              [document.textDocument.uri]: [{
                range,
                newText: document.textDocument.getText(range).toUpperCase()
              }]
            }
          }
        };
      }
      addEntryKeyword(diagnostic, document) {
        return {
          title: "Add entry keyword",
          kind: vscode_languageserver_1.CodeActionKind.QuickFix,
          diagnostics: [diagnostic],
          isPreferred: true,
          edit: {
            changes: {
              [document.textDocument.uri]: [{
                range: { start: diagnostic.range.start, end: diagnostic.range.start },
                newText: "entry "
              }]
            }
          }
        };
      }
      fixRegexTokens(diagnostic, document) {
        const offset = document.textDocument.offsetAt(diagnostic.range.start);
        const rootCst = document.parseResult.value.$cstNode;
        if (rootCst) {
          const cstNode = (0, cst_util_1.findLeafNodeAtOffset)(rootCst, offset);
          const container = (0, ast_util_1.getContainerOfType)(cstNode === null || cstNode === void 0 ? void 0 : cstNode.element, ast2.isCharacterRange);
          if (container && container.right && container.$cstNode) {
            const left = container.left.value;
            const right = container.right.value;
            return {
              title: "Refactor into regular expression",
              kind: vscode_languageserver_1.CodeActionKind.QuickFix,
              diagnostics: [diagnostic],
              isPreferred: true,
              edit: {
                changes: {
                  [document.textDocument.uri]: [{
                    range: container.$cstNode.range,
                    newText: `/[${(0, regex_util_1.escapeRegExp)(left)}-${(0, regex_util_1.escapeRegExp)(right)}]/`
                  }]
                }
              }
            };
          }
        }
        return void 0;
      }
      fixCrossRefSyntax(diagnostic, document) {
        return {
          title: "Replace '|' with ':'",
          kind: vscode_languageserver_1.CodeActionKind.QuickFix,
          diagnostics: [diagnostic],
          isPreferred: true,
          edit: {
            changes: {
              [document.textDocument.uri]: [{
                range: diagnostic.range,
                newText: ":"
              }]
            }
          }
        };
      }
      fixHiddenTerminals(diagnostic, document) {
        const grammar = document.parseResult.value;
        const hiddenTokens = grammar.hiddenTokens;
        const changes = [];
        const hiddenNode = (0, grammar_util_1.findNodeForProperty)(grammar.$cstNode, "definesHiddenTokens");
        if (hiddenNode) {
          const start = hiddenNode.range.start;
          const offset = hiddenNode.offset;
          const end = grammar.$cstNode.text.indexOf(")", offset) + 1;
          changes.push({
            newText: "",
            range: {
              start,
              end: document.textDocument.positionAt(end)
            }
          });
        }
        for (const terminal of hiddenTokens) {
          const ref = terminal.ref;
          if (ref && ast2.isTerminalRule(ref) && !ref.hidden && ref.$cstNode) {
            const start = ref.$cstNode.range.start;
            changes.push({
              newText: "hidden ",
              range: {
                start,
                end: start
              }
            });
          }
        }
        return {
          title: "Fix hidden terminals",
          kind: vscode_languageserver_1.CodeActionKind.QuickFix,
          diagnostics: [diagnostic],
          isPreferred: true,
          edit: {
            changes: {
              [document.textDocument.uri]: changes
            }
          }
        };
      }
      addNewRule(diagnostic, data, document) {
        const offset = document.textDocument.offsetAt(diagnostic.range.start);
        const rootCst = document.parseResult.value.$cstNode;
        if (rootCst) {
          const cstNode = (0, cst_util_1.findLeafNodeAtOffset)(rootCst, offset);
          const container = (0, ast_util_1.getContainerOfType)(cstNode === null || cstNode === void 0 ? void 0 : cstNode.element, ast2.isParserRule);
          if (container && container.$cstNode) {
            return {
              title: `Add new rule '${data.refText}'`,
              kind: vscode_languageserver_1.CodeActionKind.QuickFix,
              diagnostics: [diagnostic],
              isPreferred: false,
              edit: {
                changes: {
                  [document.textDocument.uri]: [{
                    range: {
                      start: container.$cstNode.range.end,
                      end: container.$cstNode.range.end
                    },
                    newText: "\n\n" + data.refText + ":\n    /* TODO implement rule */ {infer " + data.refText + "};"
                  }]
                }
              }
            };
          }
        }
        return void 0;
      }
      lookInGlobalScope(diagnostic, data, document) {
        var _a, _b;
        const refInfo = {
          container: {
            $type: data.containerType
          },
          property: data.property,
          reference: {
            $refText: data.refText
          }
        };
        const referenceType = this.reflection.getReferenceType(refInfo);
        const candidates = this.indexManager.allElements(referenceType).filter((e) => e.name === data.refText);
        const result = [];
        let shortestPathIndex = -1;
        let shortestPathLength = -1;
        for (const candidate of candidates) {
          if ((0, uri_util_1.equalURI)(candidate.documentUri, document.uri)) {
            continue;
          }
          const importPath = getRelativeImport(document.uri, candidate.documentUri);
          let position;
          let suffix = "";
          const grammar = document.parseResult.value;
          const nextImport = grammar.imports.find((imp) => imp.path && importPath < imp.path);
          if (nextImport) {
            position = (_a = nextImport.$cstNode) === null || _a === void 0 ? void 0 : _a.range.start;
          } else if (grammar.imports.length > 0) {
            const rangeEnd = grammar.imports[grammar.imports.length - 1].$cstNode.range.end;
            if (rangeEnd) {
              position = { line: rangeEnd.line + 1, character: 0 };
            }
          } else if (grammar.rules.length > 0) {
            position = (_b = grammar.rules[0].$cstNode) === null || _b === void 0 ? void 0 : _b.range.start;
            suffix = "\n";
          }
          if (position) {
            if (shortestPathIndex < 0 || importPath.length < shortestPathLength) {
              shortestPathIndex = result.length;
              shortestPathLength = importPath.length;
            }
            result.push({
              title: `Add import to '${importPath}'`,
              kind: vscode_languageserver_1.CodeActionKind.QuickFix,
              diagnostics: [diagnostic],
              isPreferred: false,
              edit: {
                changes: {
                  [document.textDocument.uri]: [{
                    range: {
                      start: position,
                      end: position
                    },
                    newText: `import '${importPath}'
${suffix}`
                  }]
                }
              }
            });
          }
        }
        if (shortestPathIndex >= 0) {
          result[shortestPathIndex].isPreferred = true;
        }
        return result;
      }
    };
    exports2.LangiumGrammarCodeActionProvider = LangiumGrammarCodeActionProvider;
    function getRelativeImport(source, target) {
      const sourceDir = vscode_uri_1.Utils.dirname(source);
      let relativePath = (0, uri_util_1.relativeURI)(sourceDir, target);
      if (!relativePath.startsWith("./") && !relativePath.startsWith("../")) {
        relativePath = "./" + relativePath;
      }
      if (relativePath.endsWith(".langium")) {
        relativePath = relativePath.substring(0, relativePath.length - ".langium".length);
      }
      return relativePath;
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/folding-range-provider.js
var require_folding_range_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/folding-range-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultFoldingRangeProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var DefaultFoldingRangeProvider = class {
      constructor(services) {
        this.commentNames = services.parser.GrammarConfig.multilineCommentRules;
      }
      getFoldingRanges(document) {
        const foldings = [];
        const acceptor = (foldingRange) => foldings.push(foldingRange);
        this.collectFolding(document, acceptor);
        return foldings;
      }
      collectFolding(document, acceptor) {
        var _a;
        const root = (_a = document.parseResult) === null || _a === void 0 ? void 0 : _a.value;
        if (root) {
          if (this.shouldProcessContent(root)) {
            const treeIterator = (0, ast_util_1.streamAllContents)(root).iterator();
            let result;
            do {
              result = treeIterator.next();
              if (!result.done) {
                const node = result.value;
                if (this.shouldProcess(node)) {
                  this.collectObjectFolding(document, node, acceptor);
                }
                if (!this.shouldProcessContent(node)) {
                  treeIterator.prune();
                }
              }
            } while (!result.done);
          }
          this.collectCommentFolding(document, root, acceptor);
        }
      }
      /**
       * Template method to determine whether the specified `AstNode` should be handled by the folding range provider.
       * Returns true by default for all nodes. Returning false only ignores the specified node and not its content.
       * To ignore the content of a node use `shouldProcessContent`.
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      shouldProcess(node) {
        return true;
      }
      /**
       * Template method to determine whether the content/children of the specified `AstNode` should be handled by the folding range provider.
       * Returns true by default for all nodes. Returning false ignores _all_ content of this node, even transitive ones.
       * For more precise control over foldings use the `shouldProcess` method.
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      shouldProcessContent(node) {
        return true;
      }
      collectObjectFolding(document, node, acceptor) {
        const cstNode = node.$cstNode;
        if (cstNode) {
          const foldingRange = this.toFoldingRange(document, cstNode);
          if (foldingRange) {
            acceptor(foldingRange);
          }
        }
      }
      collectCommentFolding(document, node, acceptor) {
        const cstNode = node.$cstNode;
        if (cstNode) {
          for (const node2 of (0, cst_util_1.flattenCst)(cstNode)) {
            if (this.commentNames.includes(node2.tokenType.name)) {
              const foldingRange = this.toFoldingRange(document, node2, vscode_languageserver_1.FoldingRangeKind.Comment);
              if (foldingRange) {
                acceptor(foldingRange);
              }
            }
          }
        }
      }
      toFoldingRange(document, node, kind) {
        const range = node.range;
        const start = range.start;
        let end = range.end;
        if (end.line - start.line < 2) {
          return void 0;
        }
        if (!this.includeLastFoldingLine(node, kind)) {
          end = document.textDocument.positionAt(document.textDocument.offsetAt({ line: end.line, character: 0 }) - 1);
        }
        return vscode_languageserver_1.FoldingRange.create(start.line, end.line, start.character, end.character, kind);
      }
      /**
       * Template method to determine whether the folding range for this cst node should include its last line.
       * Returns false by default for ast nodes which end in braces and for comments.
       */
      includeLastFoldingLine(node, kind) {
        if (kind === vscode_languageserver_1.FoldingRangeKind.Comment) {
          return false;
        }
        const nodeText = node.text;
        const endChar = nodeText.charAt(nodeText.length - 1);
        if (endChar === "}" || endChar === ")" || endChar === "]") {
          return false;
        }
        return true;
      }
    };
    exports2.DefaultFoldingRangeProvider = DefaultFoldingRangeProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/lsp/grammar-folding-ranges.js
var require_grammar_folding_ranges = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/lsp/grammar-folding-ranges.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarFoldingRangeProvider = void 0;
    var folding_range_provider_1 = require_folding_range_provider();
    var ast_1 = require_ast();
    var LangiumGrammarFoldingRangeProvider = class extends folding_range_provider_1.DefaultFoldingRangeProvider {
      shouldProcessContent(node) {
        return !(0, ast_1.isParserRule)(node);
      }
    };
    exports2.LangiumGrammarFoldingRangeProvider = LangiumGrammarFoldingRangeProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/formatter.js
var require_formatter = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/formatter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Formatting = exports2.FormattingRegion = exports2.DefaultNodeFormatter = exports2.AbstractFormatter = void 0;
    var grammar_util_1 = require_grammar_util();
    var syntax_tree_1 = require_syntax_tree();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var stream_1 = require_stream();
    var AbstractFormatter = class {
      constructor() {
        this.collector = () => {
        };
      }
      /**
       * Creates a formatter scoped to the supplied AST node.
       * Allows to define fine-grained formatting rules for elements.
       *
       * Example usage:
       *
       * ```ts
       * export class CustomFormatter extends AbstractFormatter {
       *   protected override format(node: AstNode): void {
       *     if (isPerson(node)) {
       *       const formatter = this.getNodeFormatter(node);
       *       formatter.property('name').prepend(Formatting.oneSpace());
       *     }
       *   }
       * }
       * ```
       * @param node The specific node the formatter should be scoped to. Every call to properties or keywords will only select those which belong to the supplied AST node.
       */
      getNodeFormatter(node) {
        return new DefaultNodeFormatter(node, this.collector);
      }
      formatDocument(document, params) {
        const pr = document.parseResult;
        if (pr.lexerErrors.length === 0 && pr.parserErrors.length === 0) {
          return this.doDocumentFormat(document, params.options);
        } else {
          return [];
        }
      }
      /**
       * Returns whether a range for a given document is error free, i.e. safe to format
       *
       * @param document Document to inspect for lexer & parser errors that may produce an unsafe range
       * @param range Formatting range to check for safety
       * @returns Whether the given formatting range does not overlap with or follow any regions with an error
       */
      isFormatRangeErrorFree(document, range) {
        const pr = document.parseResult;
        if (pr.lexerErrors.length || pr.parserErrors.length) {
          const earliestErrLine = Math.min(...pr.lexerErrors.map((e) => {
            var _a;
            return (_a = e.line) !== null && _a !== void 0 ? _a : Number.MAX_VALUE;
          }), ...pr.parserErrors.map((e) => {
            var _a;
            return (_a = e.token.startLine) !== null && _a !== void 0 ? _a : Number.MAX_VALUE;
          }));
          return earliestErrLine > range.end.line;
        } else {
          return true;
        }
      }
      formatDocumentRange(document, params) {
        if (this.isFormatRangeErrorFree(document, params.range)) {
          return this.doDocumentFormat(document, params.options, params.range);
        } else {
          return [];
        }
      }
      formatDocumentOnType(document, params) {
        const range = {
          start: {
            character: 0,
            line: params.position.line
          },
          end: params.position
        };
        if (this.isFormatRangeErrorFree(document, range)) {
          return this.doDocumentFormat(document, params.options, range);
        } else {
          return [];
        }
      }
      get formatOnTypeOptions() {
        return void 0;
      }
      doDocumentFormat(document, options, range) {
        const map = /* @__PURE__ */ new Map();
        const collector = (node, mode, formatting) => {
          var _a, _b;
          const key = this.nodeModeToKey(node, mode);
          const existing = map.get(key);
          const priority = (_a = formatting.options.priority) !== null && _a !== void 0 ? _a : 0;
          const existingPriority = (_b = existing === null || existing === void 0 ? void 0 : existing.options.priority) !== null && _b !== void 0 ? _b : 0;
          if (!existing || existingPriority <= priority) {
            map.set(key, formatting);
          }
        };
        this.collector = collector;
        this.iterateAstFormatting(document, range);
        const edits = this.iterateCstFormatting(document, map, options, range);
        return this.avoidOverlappingEdits(document.textDocument, edits);
      }
      avoidOverlappingEdits(textDocument, textEdits) {
        const edits = [];
        for (const edit of textEdits) {
          const last = edits[edits.length - 1];
          if (last) {
            const currentStart = textDocument.offsetAt(edit.range.start);
            const lastEnd = textDocument.offsetAt(last.range.end);
            if (currentStart < lastEnd) {
              edits.pop();
            }
          }
          edits.push(edit);
        }
        return edits;
      }
      iterateAstFormatting(document, range) {
        const root = document.parseResult.value;
        this.format(root);
        const treeIterator = (0, ast_util_1.streamAllContents)(root).iterator();
        let result;
        do {
          result = treeIterator.next();
          if (!result.done) {
            const node = result.value;
            const inside = this.insideRange(node.$cstNode.range, range);
            if (inside) {
              this.format(node);
            } else {
              treeIterator.prune();
            }
          }
        } while (!result.done);
      }
      nodeModeToKey(node, mode) {
        return `${node.offset}:${node.end}:${mode}`;
      }
      insideRange(inside, total) {
        if (!total) {
          return true;
        }
        if (inside.start.line <= total.start.line && inside.end.line >= total.end.line || inside.start.line >= total.start.line && inside.end.line <= total.end.line || inside.start.line <= total.end.line && inside.end.line >= total.end.line) {
          return true;
        }
        return false;
      }
      isNecessary(edit, document) {
        const existing = document.getText(edit.range);
        return existing !== edit.newText;
      }
      iterateCstFormatting(document, formattings, options, range) {
        const context = {
          indentation: 0,
          options,
          document: document.textDocument
        };
        const edits = [];
        const cstTreeStream = this.iterateCstTree(document, context);
        const iterator = cstTreeStream.iterator();
        let lastNode;
        let result;
        do {
          result = iterator.next();
          if (!result.done) {
            const node = result.value;
            const isLeaf = (0, syntax_tree_1.isLeafCstNode)(node);
            const prependKey = this.nodeModeToKey(node, "prepend");
            const prependFormatting = formattings.get(prependKey);
            formattings.delete(prependKey);
            if (prependFormatting) {
              const nodeEdits = this.createTextEdit(lastNode, node, prependFormatting, context);
              for (const edit of nodeEdits) {
                if (edit && this.insideRange(edit.range, range) && this.isNecessary(edit, document.textDocument)) {
                  edits.push(edit);
                }
              }
            }
            const appendKey = this.nodeModeToKey(node, "append");
            const appendFormatting = formattings.get(appendKey);
            formattings.delete(appendKey);
            if (appendFormatting) {
              const nextNode = (0, cst_util_1.getNextNode)(node);
              if (nextNode) {
                const nodeEdits = this.createTextEdit(node, nextNode, appendFormatting, context);
                for (const edit of nodeEdits) {
                  if (edit && this.insideRange(edit.range, range) && this.isNecessary(edit, document.textDocument)) {
                    edits.push(edit);
                  }
                }
              }
            }
            if (!prependFormatting && node.hidden) {
              const hiddenEdits = this.createHiddenTextEdits(lastNode, node, void 0, context);
              for (const edit of hiddenEdits) {
                if (edit && this.insideRange(edit.range, range) && this.isNecessary(edit, document.textDocument)) {
                  edits.push(edit);
                }
              }
            }
            if (isLeaf) {
              lastNode = node;
            }
          }
        } while (!result.done);
        return edits;
      }
      createHiddenTextEdits(previous, hidden, formatting, context) {
        var _a;
        const startLine = hidden.range.start.line;
        if (previous && previous.range.end.line === startLine) {
          return [];
        }
        const edits = [];
        const startRange = {
          start: {
            character: 0,
            line: startLine
          },
          end: hidden.range.start
        };
        const hiddenStartText = context.document.getText(startRange);
        const move = this.findFittingMove(startRange, (_a = formatting === null || formatting === void 0 ? void 0 : formatting.moves) !== null && _a !== void 0 ? _a : [], context);
        const hiddenStartChar = this.getExistingIndentationCharacterCount(hiddenStartText, context);
        const expectedStartChar = this.getIndentationCharacterCount(context, move);
        const characterIncrease = expectedStartChar - hiddenStartChar;
        if (characterIncrease === 0) {
          return [];
        }
        let newText = "";
        if (characterIncrease > 0) {
          newText = (context.options.insertSpaces ? " " : "	").repeat(characterIncrease);
        }
        const lines = hidden.text.split("\n");
        lines[0] = hiddenStartText + lines[0];
        for (let i = 0; i < lines.length; i++) {
          const currentLine = startLine + i;
          const pos = {
            character: 0,
            line: currentLine
          };
          if (characterIncrease > 0) {
            edits.push({
              newText,
              range: {
                start: pos,
                end: pos
              }
            });
          } else {
            const currentText = lines[i];
            let j = 0;
            for (; j < currentText.length; j++) {
              const char = currentText.charAt(j);
              if (char !== " " && char !== "	") {
                break;
              }
            }
            edits.push({
              newText: "",
              range: {
                start: pos,
                end: {
                  line: currentLine,
                  // Remove as much whitespace characters as necessary
                  // In some cases `characterIncrease` is actually larger than the amount of whitespace available
                  // So we simply remove all whitespace characters `j`
                  character: Math.min(j, Math.abs(characterIncrease))
                }
              }
            });
          }
        }
        return edits;
      }
      getExistingIndentationCharacterCount(text, context) {
        const tabWhitespace = " ".repeat(context.options.tabSize);
        const normalized = context.options.insertSpaces ? text.replaceAll("	", tabWhitespace) : text.replaceAll(tabWhitespace, "	");
        return normalized.length;
      }
      getIndentationCharacterCount(context, formattingMove) {
        let indentation = context.indentation;
        if (formattingMove && formattingMove.tabs) {
          indentation += formattingMove.tabs;
        }
        return (context.options.insertSpaces ? context.options.tabSize : 1) * indentation;
      }
      createTextEdit(a, b, formatting, context) {
        var _a;
        if (b.hidden) {
          return this.createHiddenTextEdits(a, b, formatting, context);
        }
        const betweenRange = {
          start: (_a = a === null || a === void 0 ? void 0 : a.range.end) !== null && _a !== void 0 ? _a : {
            character: 0,
            line: 0
          },
          end: b.range.start
        };
        const move = this.findFittingMove(betweenRange, formatting.moves, context);
        if (!move) {
          return [];
        }
        const chars = move.characters;
        const lines = move.lines;
        const tabs = move.tabs;
        const existingIndentation = context.indentation;
        context.indentation += tabs !== null && tabs !== void 0 ? tabs : 0;
        const edits = [];
        if (chars !== void 0) {
          edits.push(this.createSpaceTextEdit(betweenRange, chars, formatting.options));
        } else if (lines !== void 0) {
          edits.push(this.createLineTextEdit(betweenRange, lines, context, formatting.options));
        } else if (tabs !== void 0) {
          edits.push(this.createTabTextEdit(betweenRange, Boolean(a), context));
        }
        if ((0, syntax_tree_1.isLeafCstNode)(b)) {
          context.indentation = existingIndentation;
        }
        return edits;
      }
      createSpaceTextEdit(range, spaces, options) {
        if (range.start.line === range.end.line) {
          const existingSpaces = range.end.character - range.start.character;
          spaces = this.fitIntoOptions(spaces, existingSpaces, options);
        }
        const newText = " ".repeat(spaces);
        return {
          newText,
          range
        };
      }
      createLineTextEdit(range, lines, context, options) {
        const existingLines = range.end.line - range.start.line;
        lines = this.fitIntoOptions(lines, existingLines, options);
        const indent = context.options.insertSpaces ? " ".repeat(context.options.tabSize) : "	";
        const nodeIndent = indent.repeat(context.indentation);
        const newText = `${"\n".repeat(lines)}${nodeIndent}`;
        return {
          newText,
          range
        };
      }
      createTabTextEdit(range, hasPrevious, context) {
        const indent = context.options.insertSpaces ? " ".repeat(context.options.tabSize) : "	";
        const nodeIndent = indent.repeat(context.indentation);
        const minimumLines = hasPrevious ? 1 : 0;
        const lines = Math.max(range.end.line - range.start.line, minimumLines);
        const newText = `${"\n".repeat(lines)}${nodeIndent}`;
        return {
          newText,
          range
        };
      }
      fitIntoOptions(value, existing, options) {
        if (options.allowMore) {
          value = Math.max(existing, value);
        } else if (options.allowLess) {
          value = Math.min(existing, value);
        }
        return value;
      }
      findFittingMove(range, moves, _context) {
        if (moves.length === 0) {
          return void 0;
        } else if (moves.length === 1) {
          return moves[0];
        }
        const existingLines = range.end.line - range.start.line;
        for (const move of moves) {
          if (move.lines !== void 0 && existingLines <= move.lines) {
            return move;
          } else if (move.lines === void 0 && existingLines === 0) {
            return move;
          }
        }
        return moves[moves.length - 1];
      }
      iterateCstTree(document, context) {
        const root = document.parseResult.value;
        const rootCst = root.$cstNode;
        if (!rootCst) {
          return stream_1.EMPTY_STREAM;
        }
        return new stream_1.TreeStreamImpl(rootCst, (node) => this.iterateCst(node, context));
      }
      iterateCst(node, context) {
        if (!(0, syntax_tree_1.isCompositeCstNode)(node)) {
          return stream_1.EMPTY_STREAM;
        }
        const initial = context.indentation;
        return new stream_1.StreamImpl(() => ({ index: 0 }), (state) => {
          if (state.index < node.children.length) {
            return { done: false, value: node.children[state.index++] };
          } else {
            context.indentation = initial;
            return stream_1.DONE_RESULT;
          }
        });
      }
    };
    exports2.AbstractFormatter = AbstractFormatter;
    var DefaultNodeFormatter = class {
      constructor(astNode, collector) {
        this.astNode = astNode;
        this.collector = collector;
      }
      node(node) {
        return new FormattingRegion(node.$cstNode ? [node.$cstNode] : [], this.collector);
      }
      nodes(...nodes) {
        const cstNodes = [];
        for (const node of nodes) {
          if (node.$cstNode) {
            cstNodes.push(node.$cstNode);
          }
        }
        return new FormattingRegion(cstNodes, this.collector);
      }
      property(feature, index) {
        const cstNode = (0, grammar_util_1.findNodeForProperty)(this.astNode.$cstNode, feature, index);
        return new FormattingRegion(cstNode ? [cstNode] : [], this.collector);
      }
      properties(...features) {
        const nodes = [];
        for (const feature of features) {
          const cstNodes = (0, grammar_util_1.findNodesForProperty)(this.astNode.$cstNode, feature);
          nodes.push(...cstNodes);
        }
        return new FormattingRegion(nodes, this.collector);
      }
      keyword(keyword, index) {
        const cstNode = (0, grammar_util_1.findNodeForKeyword)(this.astNode.$cstNode, keyword, index);
        return new FormattingRegion(cstNode ? [cstNode] : [], this.collector);
      }
      keywords(...keywords) {
        const nodes = [];
        for (const feature of keywords) {
          const cstNodes = (0, grammar_util_1.findNodesForKeyword)(this.astNode.$cstNode, feature);
          nodes.push(...cstNodes);
        }
        return new FormattingRegion(nodes, this.collector);
      }
      cst(nodes) {
        return new FormattingRegion([...nodes], this.collector);
      }
      interior(start, end) {
        const startNodes = start.nodes;
        const endNodes = end.nodes;
        if (startNodes.length !== 1 || endNodes.length !== 1) {
          return new FormattingRegion([], this.collector);
        }
        let startNode = startNodes[0];
        let endNode = endNodes[0];
        if (startNode.offset > endNode.offset) {
          const intermediate = startNode;
          startNode = endNode;
          endNode = intermediate;
        }
        return new FormattingRegion((0, cst_util_1.getInteriorNodes)(startNode, endNode), this.collector);
      }
    };
    exports2.DefaultNodeFormatter = DefaultNodeFormatter;
    var FormattingRegion = class {
      constructor(nodes, collector) {
        this.nodes = nodes;
        this.collector = collector;
      }
      /**
       * Prepends the specified formatting to all nodes of this region.
       */
      prepend(formatting) {
        for (const node of this.nodes) {
          this.collector(node, "prepend", formatting);
        }
        return this;
      }
      /**
       * Appends the specified formatting to all nodes of this region.
       */
      append(formatting) {
        for (const node of this.nodes) {
          this.collector(node, "append", formatting);
        }
        return this;
      }
      /**
       * Sorrounds all nodes of this region with the specified formatting.
       * Functionally the same as invoking `prepend` and `append` with the same formatting.
       */
      surround(formatting) {
        for (const node of this.nodes) {
          this.collector(node, "prepend", formatting);
          this.collector(node, "append", formatting);
        }
        return this;
      }
      /**
       * Creates a copy of this region with a slice of the selected nodes.
       * For both start and end, a negative index can be used to indicate an offset from the end of the array.
       * For example, -2 refers to the second to last element of the array.
       * @param start The beginning index of the specified portion of the region. If start is undefined, then the slice begins at index 0.
       * @param end The end index of the specified portion of the region. This is exclusive of the element at the index 'end'. If end is undefined, then the slice extends to the end of the region.
       */
      slice(start, end) {
        return new FormattingRegion(this.nodes.slice(start, end), this.collector);
      }
    };
    exports2.FormattingRegion = FormattingRegion;
    var Formatting;
    (function(Formatting2) {
      function fit(...formattings) {
        return {
          options: {},
          moves: formattings.flatMap((e) => e.moves).sort(compareMoves)
        };
      }
      Formatting2.fit = fit;
      function noSpace(options) {
        return spaces(0, options);
      }
      Formatting2.noSpace = noSpace;
      function oneSpace(options) {
        return spaces(1, options);
      }
      Formatting2.oneSpace = oneSpace;
      function spaces(count, options) {
        return {
          options: options !== null && options !== void 0 ? options : {},
          moves: [{
            characters: count
          }]
        };
      }
      Formatting2.spaces = spaces;
      function newLine(options) {
        return newLines(1, options);
      }
      Formatting2.newLine = newLine;
      function newLines(count, options) {
        return {
          options: options !== null && options !== void 0 ? options : {},
          moves: [{
            lines: count
          }]
        };
      }
      Formatting2.newLines = newLines;
      function indent(options) {
        return {
          options: options !== null && options !== void 0 ? options : {},
          moves: [{
            tabs: 1,
            lines: 1
          }]
        };
      }
      Formatting2.indent = indent;
      function noIndent(options) {
        return {
          options: options !== null && options !== void 0 ? options : {},
          moves: [{
            tabs: 0
          }]
        };
      }
      Formatting2.noIndent = noIndent;
      function compareMoves(a, b) {
        var _a, _b, _c, _d, _e, _f;
        const aLines = (_a = a.lines) !== null && _a !== void 0 ? _a : 0;
        const bLines = (_b = b.lines) !== null && _b !== void 0 ? _b : 0;
        const aTabs = (_c = a.tabs) !== null && _c !== void 0 ? _c : 0;
        const bTabs = (_d = b.tabs) !== null && _d !== void 0 ? _d : 0;
        const aSpaces = (_e = a.characters) !== null && _e !== void 0 ? _e : 0;
        const bSpaces = (_f = b.characters) !== null && _f !== void 0 ? _f : 0;
        if (aLines < bLines) {
          return -1;
        } else if (aLines > bLines) {
          return 1;
        } else if (aTabs < bTabs) {
          return -1;
        } else if (aTabs > bTabs) {
          return 1;
        } else if (aSpaces < bSpaces) {
          return -1;
        } else if (aSpaces > bSpaces) {
          return 1;
        } else {
          return 0;
        }
      }
    })(Formatting = exports2.Formatting || (exports2.Formatting = {}));
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/lsp/grammar-formatter.js
var require_grammar_formatter = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/lsp/grammar-formatter.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarFormatter = void 0;
    var formatter_1 = require_formatter();
    var ast2 = __importStar(require_ast());
    var LangiumGrammarFormatter = class extends formatter_1.AbstractFormatter {
      format(node) {
        if (ast2.isCrossReference(node)) {
          const formatter = this.getNodeFormatter(node);
          formatter.properties("type", "terminal").surround(formatter_1.Formatting.noSpace());
        } else if (ast2.isParserRule(node)) {
          const formatter = this.getNodeFormatter(node);
          formatter.keywords("entry", "fragment", "returns").append(formatter_1.Formatting.oneSpace());
          if ((node.inferredType || node.returnType || node.dataType) && node.parameters.length === 0) {
            formatter.property("name").append(formatter_1.Formatting.oneSpace());
          } else {
            formatter.property("name").append(formatter_1.Formatting.noSpace());
          }
          formatter.properties("parameters").append(formatter_1.Formatting.noSpace());
          formatter.keywords(",").append(formatter_1.Formatting.oneSpace());
          formatter.keywords("<").append(formatter_1.Formatting.noSpace());
          const semicolon = formatter.keyword(";");
          const colon = formatter.keyword(":");
          colon.prepend(formatter_1.Formatting.noSpace());
          formatter.interior(colon, semicolon).prepend(formatter_1.Formatting.indent());
          semicolon.prepend(formatter_1.Formatting.fit(formatter_1.Formatting.noSpace(), formatter_1.Formatting.newLine()));
          formatter.node(node).prepend(formatter_1.Formatting.noIndent());
        } else if (ast2.isTerminalRule(node)) {
          const formatter = this.getNodeFormatter(node);
          if (node.type) {
            formatter.property("name").append(formatter_1.Formatting.oneSpace());
            formatter.keyword("returns").append(formatter_1.Formatting.oneSpace());
          }
          formatter.keywords("hidden", "terminal", "fragment").append(formatter_1.Formatting.oneSpace());
          formatter.keyword(":").prepend(formatter_1.Formatting.noSpace());
          formatter.keyword(";").prepend(formatter_1.Formatting.fit(formatter_1.Formatting.noSpace(), formatter_1.Formatting.newLine()));
          formatter.node(node).prepend(formatter_1.Formatting.noIndent());
        } else if (ast2.isAction(node)) {
          const formatter = this.getNodeFormatter(node);
          formatter.keyword("{").append(formatter_1.Formatting.noSpace());
          formatter.keywords(".", "+=", "=").surround(formatter_1.Formatting.noSpace());
          formatter.keyword("}").prepend(formatter_1.Formatting.noSpace());
        } else if (ast2.isInferredType(node)) {
          const formatter = this.getNodeFormatter(node);
          formatter.keywords("infer", "infers").append(formatter_1.Formatting.oneSpace());
        } else if (ast2.isAssignment(node)) {
          const formatter = this.getNodeFormatter(node);
          formatter.keywords("=", "+=", "?=").surround(formatter_1.Formatting.noSpace());
        } else if (ast2.isRuleCall(node)) {
          const formatter = this.getNodeFormatter(node);
          formatter.keyword("<").surround(formatter_1.Formatting.noSpace());
          formatter.keyword(",").append(formatter_1.Formatting.oneSpace());
          formatter.properties("arguments").append(formatter_1.Formatting.noSpace());
        }
        if (ast2.isAbstractElement(node)) {
          const formatter = this.getNodeFormatter(node);
          formatter.property("cardinality").prepend(formatter_1.Formatting.noSpace());
        }
      }
    };
    exports2.LangiumGrammarFormatter = LangiumGrammarFormatter;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/semantic-token-provider.js
var require_semantic_token_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/semantic-token-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensDecoder = exports2.AbstractSemanticTokenProvider = exports2.SemanticTokensBuilder = exports2.DefaultSemanticTokenOptions = exports2.AllSemanticTokenModifiers = exports2.AllSemanticTokenTypes = void 0;
    var vscode_languageserver_1 = require_main4();
    var grammar_util_1 = require_grammar_util();
    var ast_util_1 = require_ast_util();
    var promise_util_1 = require_promise_util();
    var cst_util_1 = require_cst_util();
    exports2.AllSemanticTokenTypes = {
      [vscode_languageserver_1.SemanticTokenTypes.class]: 0,
      [vscode_languageserver_1.SemanticTokenTypes.comment]: 1,
      [vscode_languageserver_1.SemanticTokenTypes.enum]: 2,
      [vscode_languageserver_1.SemanticTokenTypes.enumMember]: 3,
      [vscode_languageserver_1.SemanticTokenTypes.event]: 4,
      [vscode_languageserver_1.SemanticTokenTypes.function]: 5,
      [vscode_languageserver_1.SemanticTokenTypes.interface]: 6,
      [vscode_languageserver_1.SemanticTokenTypes.keyword]: 7,
      [vscode_languageserver_1.SemanticTokenTypes.macro]: 8,
      [vscode_languageserver_1.SemanticTokenTypes.method]: 9,
      [vscode_languageserver_1.SemanticTokenTypes.modifier]: 10,
      [vscode_languageserver_1.SemanticTokenTypes.namespace]: 11,
      [vscode_languageserver_1.SemanticTokenTypes.number]: 12,
      [vscode_languageserver_1.SemanticTokenTypes.operator]: 13,
      [vscode_languageserver_1.SemanticTokenTypes.parameter]: 14,
      [vscode_languageserver_1.SemanticTokenTypes.property]: 15,
      [vscode_languageserver_1.SemanticTokenTypes.regexp]: 16,
      [vscode_languageserver_1.SemanticTokenTypes.string]: 17,
      [vscode_languageserver_1.SemanticTokenTypes.struct]: 18,
      [vscode_languageserver_1.SemanticTokenTypes.type]: 19,
      [vscode_languageserver_1.SemanticTokenTypes.typeParameter]: 20,
      [vscode_languageserver_1.SemanticTokenTypes.variable]: 21
    };
    exports2.AllSemanticTokenModifiers = {
      [vscode_languageserver_1.SemanticTokenModifiers.abstract]: 1 << 0,
      [vscode_languageserver_1.SemanticTokenModifiers.async]: 1 << 1,
      [vscode_languageserver_1.SemanticTokenModifiers.declaration]: 1 << 2,
      [vscode_languageserver_1.SemanticTokenModifiers.defaultLibrary]: 1 << 3,
      [vscode_languageserver_1.SemanticTokenModifiers.definition]: 1 << 4,
      [vscode_languageserver_1.SemanticTokenModifiers.deprecated]: 1 << 5,
      [vscode_languageserver_1.SemanticTokenModifiers.documentation]: 1 << 6,
      [vscode_languageserver_1.SemanticTokenModifiers.modification]: 1 << 7,
      [vscode_languageserver_1.SemanticTokenModifiers.readonly]: 1 << 8,
      [vscode_languageserver_1.SemanticTokenModifiers.static]: 1 << 9
    };
    exports2.DefaultSemanticTokenOptions = {
      legend: {
        tokenTypes: Object.keys(exports2.AllSemanticTokenTypes),
        tokenModifiers: Object.keys(exports2.AllSemanticTokenModifiers)
      },
      full: {
        delta: true
      },
      range: true
    };
    var SemanticTokensBuilder = class extends vscode_languageserver_1.SemanticTokensBuilder {
      constructor() {
        super(...arguments);
        this._tokens = [];
      }
      push(line, char, length, tokenType, tokenModifiers) {
        this._tokens.push({
          line,
          char,
          length,
          tokenType,
          tokenModifiers
        });
      }
      build() {
        this.applyTokens();
        return super.build();
      }
      buildEdits() {
        this.applyTokens();
        return super.buildEdits();
      }
      applyTokens() {
        for (const token of this._tokens.sort(this.compareTokens)) {
          super.push(token.line, token.char, token.length, token.tokenType, token.tokenModifiers);
        }
        this._tokens = [];
      }
      compareTokens(a, b) {
        if (a.line === b.line) {
          return a.char - b.char;
        }
        return a.line - b.line;
      }
    };
    exports2.SemanticTokensBuilder = SemanticTokensBuilder;
    var AbstractSemanticTokenProvider = class {
      constructor(services) {
        this.tokensBuilders = /* @__PURE__ */ new Map();
        services.shared.workspace.TextDocuments.onDidClose((e) => {
          this.tokensBuilders.delete(e.document.uri);
        });
        services.shared.lsp.LanguageServer.onInitialize((params) => {
          var _a;
          this.initialize((_a = params.capabilities.textDocument) === null || _a === void 0 ? void 0 : _a.semanticTokens);
        });
      }
      initialize(clientCapabilities) {
        this.clientCapabilities = clientCapabilities;
      }
      async semanticHighlight(document, _params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        this.currentRange = void 0;
        this.currentDocument = document;
        this.currentTokensBuilder = this.getDocumentTokensBuilder(document);
        await this.computeHighlighting(document, this.createAcceptor(), cancelToken);
        return this.currentTokensBuilder.build();
      }
      async semanticHighlightRange(document, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        this.currentRange = params.range;
        this.currentDocument = document;
        this.currentTokensBuilder = this.getDocumentTokensBuilder(document);
        await this.computeHighlighting(document, this.createAcceptor(), cancelToken);
        return this.currentTokensBuilder.build();
      }
      async semanticHighlightDelta(document, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        this.currentRange = void 0;
        this.currentDocument = document;
        this.currentTokensBuilder = this.getDocumentTokensBuilder(document);
        this.currentTokensBuilder.previousResult(params.previousResultId);
        await this.computeHighlighting(document, this.createAcceptor(), cancelToken);
        return this.currentTokensBuilder.buildEdits();
      }
      createAcceptor() {
        const acceptor = (options) => {
          if ("line" in options) {
            this.highlightToken({
              range: {
                start: {
                  line: options.line,
                  character: options.char
                },
                end: {
                  line: options.line,
                  character: options.char + options.length
                }
              },
              type: options.type,
              modifier: options.modifier
            });
          } else if ("range" in options) {
            this.highlightToken(options);
          } else if ("keyword" in options) {
            this.highlightKeyword(options);
          } else if ("property" in options) {
            this.highlightProperty(options);
          } else {
            this.highlightNode({
              node: options.cst,
              type: options.type,
              modifier: options.modifier
            });
          }
        };
        return acceptor;
      }
      getDocumentTokensBuilder(document) {
        const existing = this.tokensBuilders.get(document.uri.toString());
        if (existing) {
          return existing;
        }
        const builder = new SemanticTokensBuilder();
        this.tokensBuilders.set(document.uri.toString(), builder);
        return builder;
      }
      async computeHighlighting(document, acceptor, cancelToken) {
        const root = document.parseResult.value;
        const treeIterator = (0, ast_util_1.streamAst)(root, { range: this.currentRange }).iterator();
        let result;
        do {
          result = treeIterator.next();
          if (!result.done) {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            const node = result.value;
            if (this.highlightElement(node, acceptor) === "prune") {
              treeIterator.prune();
            }
          }
        } while (!result.done);
      }
      highlightToken(options) {
        var _a;
        const { range, type } = options;
        let modifiers = options.modifier;
        if (this.currentRange && !(0, cst_util_1.inRange)(range, this.currentRange) || !this.currentDocument || !this.currentTokensBuilder) {
          return;
        }
        const intType = exports2.AllSemanticTokenTypes[type];
        let totalModifier = 0;
        if (modifiers !== void 0) {
          if (typeof modifiers === "string") {
            modifiers = [modifiers];
          }
          for (const modifier of modifiers) {
            const intModifier = exports2.AllSemanticTokenModifiers[modifier];
            totalModifier |= intModifier;
          }
        }
        const startLine = range.start.line;
        const endLine = range.end.line;
        if (startLine === endLine) {
          const char = range.start.character;
          const length = range.end.character - char;
          this.currentTokensBuilder.push(startLine, char, length, intType, totalModifier);
        } else if ((_a = this.clientCapabilities) === null || _a === void 0 ? void 0 : _a.multilineTokenSupport) {
          const startChar = range.start.character;
          const startOffset = this.currentDocument.textDocument.offsetAt(range.start);
          const endOffset = this.currentDocument.textDocument.offsetAt(range.end);
          this.currentTokensBuilder.push(startLine, startChar, endOffset - startOffset, intType, totalModifier);
        } else {
          const firstLineStart = range.start;
          let nextLineOffset = this.currentDocument.textDocument.offsetAt({
            line: startLine + 1,
            character: 0
          });
          this.currentTokensBuilder.push(firstLineStart.line, firstLineStart.character, nextLineOffset - firstLineStart.character - 1, intType, totalModifier);
          for (let i = startLine + 1; i < endLine; i++) {
            const currentLineOffset = nextLineOffset;
            nextLineOffset = this.currentDocument.textDocument.offsetAt({
              line: i + 1,
              character: 0
            });
            this.currentTokensBuilder.push(i, 0, nextLineOffset - currentLineOffset - 1, intType, totalModifier);
          }
          this.currentTokensBuilder.push(endLine, 0, range.end.character, intType, totalModifier);
        }
      }
      highlightProperty(options) {
        const nodes = [];
        if (typeof options.index === "number") {
          const node = (0, grammar_util_1.findNodeForProperty)(options.node.$cstNode, options.property, options.index);
          if (node) {
            nodes.push(node);
          }
        } else {
          nodes.push(...(0, grammar_util_1.findNodesForProperty)(options.node.$cstNode, options.property));
        }
        const { type, modifier } = options;
        for (const node of nodes) {
          this.highlightNode({
            node,
            type,
            modifier
          });
        }
      }
      highlightKeyword(options) {
        const { node, keyword, type, index, modifier } = options;
        const nodes = [];
        if (typeof index === "number") {
          const keywordNode = (0, grammar_util_1.findNodeForKeyword)(node.$cstNode, keyword, index);
          if (keywordNode) {
            nodes.push(keywordNode);
          }
        } else {
          nodes.push(...(0, grammar_util_1.findNodesForKeyword)(node.$cstNode, keyword));
        }
        for (const keywordNode of nodes) {
          this.highlightNode({
            node: keywordNode,
            type,
            modifier
          });
        }
      }
      highlightNode(options) {
        const { node, type, modifier } = options;
        const range = node.range;
        this.highlightToken({
          range,
          type,
          modifier
        });
      }
    };
    exports2.AbstractSemanticTokenProvider = AbstractSemanticTokenProvider;
    var SemanticTokensDecoder;
    (function(SemanticTokensDecoder2) {
      function decode(tokens, document) {
        const typeMap = /* @__PURE__ */ new Map();
        Object.entries(exports2.AllSemanticTokenTypes).forEach(([type, index]) => typeMap.set(index, type));
        let line = 0;
        let character = 0;
        return sliceIntoChunks(tokens.data, 5).map((t) => {
          line += t[0];
          if (t[0] !== 0) {
            character = 0;
          }
          character += t[1];
          const length = t[2];
          const offset = document.textDocument.offsetAt({ line, character });
          return {
            offset,
            tokenType: typeMap.get(t[3]),
            tokenModifiers: t[4],
            text: document.textDocument.getText({ start: { line, character }, end: { line, character: character + length } })
          };
        });
      }
      SemanticTokensDecoder2.decode = decode;
      function sliceIntoChunks(arr, chunkSize) {
        const res = [];
        for (let i = 0; i < arr.length; i += chunkSize) {
          const chunk = arr.slice(i, i + chunkSize);
          res.push(chunk);
        }
        return res;
      }
    })(SemanticTokensDecoder = exports2.SemanticTokensDecoder || (exports2.SemanticTokensDecoder = {}));
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/lsp/grammar-semantic-tokens.js
var require_grammar_semantic_tokens = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/lsp/grammar-semantic-tokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarSemanticTokenProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var semantic_token_provider_1 = require_semantic_token_provider();
    var ast_1 = require_ast();
    var LangiumGrammarSemanticTokenProvider = class extends semantic_token_provider_1.AbstractSemanticTokenProvider {
      highlightElement(node, acceptor) {
        var _a;
        if ((0, ast_1.isAssignment)(node)) {
          acceptor({
            node,
            property: "feature",
            type: vscode_languageserver_1.SemanticTokenTypes.property
          });
        } else if ((0, ast_1.isAction)(node)) {
          if (node.feature) {
            acceptor({
              node,
              property: "feature",
              type: vscode_languageserver_1.SemanticTokenTypes.property
            });
          }
        } else if ((0, ast_1.isReturnType)(node)) {
          acceptor({
            node,
            property: "name",
            type: vscode_languageserver_1.SemanticTokenTypes.type
          });
        } else if ((0, ast_1.isSimpleType)(node)) {
          if (node.primitiveType || node.typeRef) {
            acceptor({
              node,
              property: node.primitiveType ? "primitiveType" : "typeRef",
              type: vscode_languageserver_1.SemanticTokenTypes.type
            });
          }
        } else if ((0, ast_1.isParameter)(node)) {
          acceptor({
            node,
            property: "name",
            type: vscode_languageserver_1.SemanticTokenTypes.parameter
          });
        } else if ((0, ast_1.isParameterReference)(node)) {
          acceptor({
            node,
            property: "parameter",
            type: vscode_languageserver_1.SemanticTokenTypes.parameter
          });
        } else if ((0, ast_1.isRuleCall)(node)) {
          if ((_a = node.rule.ref) === null || _a === void 0 ? void 0 : _a.fragment) {
            acceptor({
              node,
              property: "rule",
              type: vscode_languageserver_1.SemanticTokenTypes.type
            });
          }
        } else if ((0, ast_1.isTypeAttribute)(node)) {
          acceptor({
            node,
            property: "name",
            type: vscode_languageserver_1.SemanticTokenTypes.property
          });
        }
      }
    };
    exports2.LangiumGrammarSemanticTokenProvider = LangiumGrammarSemanticTokenProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/references/grammar-naming.js
var require_grammar_naming = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/references/grammar-naming.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarNameProvider = void 0;
    var name_provider_1 = require_name_provider();
    var grammar_util_1 = require_grammar_util();
    var ast_1 = require_ast();
    var LangiumGrammarNameProvider = class extends name_provider_1.DefaultNameProvider {
      getName(node) {
        if ((0, ast_1.isAssignment)(node)) {
          return node.feature;
        } else {
          return super.getName(node);
        }
      }
      getNameNode(node) {
        if ((0, ast_1.isAssignment)(node)) {
          return (0, grammar_util_1.findNodeForProperty)(node.$cstNode, "feature");
        } else {
          return super.getNameNode(node);
        }
      }
    };
    exports2.LangiumGrammarNameProvider = LangiumGrammarNameProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/references/references.js
var require_references = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/references/references.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultReferences = void 0;
    var grammar_util_1 = require_grammar_util();
    var syntax_tree_1 = require_syntax_tree();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var stream_1 = require_stream();
    var uri_util_1 = require_uri_util();
    var DefaultReferences = class {
      constructor(services) {
        this.nameProvider = services.references.NameProvider;
        this.index = services.shared.workspace.IndexManager;
        this.nodeLocator = services.workspace.AstNodeLocator;
      }
      findDeclaration(sourceCstNode) {
        if (sourceCstNode) {
          const assignment = (0, grammar_util_1.findAssignment)(sourceCstNode);
          const nodeElem = sourceCstNode.element;
          if (assignment && nodeElem) {
            const reference = nodeElem[assignment.feature];
            if ((0, syntax_tree_1.isReference)(reference)) {
              return reference.ref;
            } else if (Array.isArray(reference)) {
              for (const ref of reference) {
                if ((0, syntax_tree_1.isReference)(ref) && ref.$refNode && ref.$refNode.offset <= sourceCstNode.offset && ref.$refNode.end >= sourceCstNode.end) {
                  return ref.ref;
                }
              }
            }
          }
          if (nodeElem) {
            const nameNode = this.nameProvider.getNameNode(nodeElem);
            if (nameNode && (nameNode === sourceCstNode || (0, cst_util_1.isCstChildNode)(sourceCstNode, nameNode))) {
              return nodeElem;
            }
          }
        }
        return void 0;
      }
      findDeclarationNode(sourceCstNode) {
        const astNode = this.findDeclaration(sourceCstNode);
        if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {
          const targetNode = this.nameProvider.getNameNode(astNode);
          return targetNode !== null && targetNode !== void 0 ? targetNode : astNode.$cstNode;
        }
        return void 0;
      }
      findReferences(targetNode, options) {
        const refs = [];
        if (options.includeDeclaration) {
          const ref = this.getReferenceToSelf(targetNode);
          if (ref) {
            refs.push(ref);
          }
        }
        let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));
        if (options.documentUri) {
          indexReferences = indexReferences.filter((ref) => (0, uri_util_1.equalURI)(ref.sourceUri, options.documentUri));
        }
        refs.push(...indexReferences);
        return (0, stream_1.stream)(refs);
      }
      getReferenceToSelf(targetNode) {
        const nameNode = this.nameProvider.getNameNode(targetNode);
        if (nameNode) {
          const doc = (0, ast_util_1.getDocument)(targetNode);
          const path2 = this.nodeLocator.getAstNodePath(targetNode);
          return {
            sourceUri: doc.uri,
            sourcePath: path2,
            targetUri: doc.uri,
            targetPath: path2,
            segment: (0, cst_util_1.toDocumentSegment)(nameNode),
            local: true
          };
        }
        return void 0;
      }
    };
    exports2.DefaultReferences = DefaultReferences;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/references/grammar-references.js
var require_grammar_references = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/references/grammar-references.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarReferences = void 0;
    var references_1 = require_references();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var grammar_util_1 = require_grammar_util();
    var stream_1 = require_stream();
    var uri_util_1 = require_uri_util();
    var ast_1 = require_ast();
    var internal_grammar_util_1 = require_internal_grammar_util();
    var types_util_1 = require_types_util();
    var LangiumGrammarReferences = class extends references_1.DefaultReferences {
      constructor(services) {
        super(services);
        this.documents = services.shared.workspace.LangiumDocuments;
      }
      findDeclaration(sourceCstNode) {
        const nodeElem = sourceCstNode.element;
        const assignment = (0, grammar_util_1.findAssignment)(sourceCstNode);
        if (assignment && assignment.feature === "feature") {
          if ((0, ast_1.isAssignment)(nodeElem)) {
            return this.findAssignmentDeclaration(nodeElem);
          } else if ((0, ast_1.isAction)(nodeElem)) {
            return this.findActionDeclaration(nodeElem);
          }
        }
        return super.findDeclaration(sourceCstNode);
      }
      findReferences(targetNode, options) {
        var _a;
        if ((0, ast_1.isTypeAttribute)(targetNode)) {
          return this.findReferencesToTypeAttribute(targetNode, (_a = options.includeDeclaration) !== null && _a !== void 0 ? _a : false);
        } else {
          return super.findReferences(targetNode, options);
        }
      }
      findReferencesToTypeAttribute(targetNode, includeDeclaration) {
        const refs = [];
        const interfaceNode = (0, ast_util_1.getContainerOfType)(targetNode, ast_1.isInterface);
        if (interfaceNode) {
          if (includeDeclaration) {
            const ref = this.getReferenceToSelf(targetNode);
            if (ref) {
              refs.push(ref);
            }
          }
          const interfaces = (0, types_util_1.collectChildrenTypes)(interfaceNode, this, this.documents, this.nodeLocator);
          const targetRules = [];
          interfaces.forEach((interf) => {
            const rules = this.findRulesWithReturnType(interf);
            targetRules.push(...rules);
          });
          targetRules.forEach((rule) => {
            const references = this.createReferencesToAttribute(rule, targetNode);
            refs.push(...references);
          });
        }
        return (0, stream_1.stream)(refs);
      }
      createReferencesToAttribute(ruleOrAction, attribute) {
        const refs = [];
        if ((0, ast_1.isParserRule)(ruleOrAction)) {
          const assignment = (0, internal_grammar_util_1.extractAssignments)(ruleOrAction.definition).find((a) => a.feature === attribute.name);
          if (assignment === null || assignment === void 0 ? void 0 : assignment.$cstNode) {
            const leaf = this.nameProvider.getNameNode(assignment);
            if (leaf) {
              refs.push({
                sourceUri: (0, ast_util_1.getDocument)(assignment).uri,
                sourcePath: this.nodeLocator.getAstNodePath(assignment),
                targetUri: (0, ast_util_1.getDocument)(attribute).uri,
                targetPath: this.nodeLocator.getAstNodePath(attribute),
                segment: (0, cst_util_1.toDocumentSegment)(leaf),
                local: (0, uri_util_1.equalURI)((0, ast_util_1.getDocument)(assignment).uri, (0, ast_util_1.getDocument)(attribute).uri)
              });
            }
          }
        } else {
          if (ruleOrAction.feature === attribute.name) {
            const leaf = (0, grammar_util_1.findNodeForProperty)(ruleOrAction.$cstNode, "feature");
            if (leaf) {
              refs.push({
                sourceUri: (0, ast_util_1.getDocument)(ruleOrAction).uri,
                sourcePath: this.nodeLocator.getAstNodePath(ruleOrAction),
                targetUri: (0, ast_util_1.getDocument)(attribute).uri,
                targetPath: this.nodeLocator.getAstNodePath(attribute),
                segment: (0, cst_util_1.toDocumentSegment)(leaf),
                local: (0, uri_util_1.equalURI)((0, ast_util_1.getDocument)(ruleOrAction).uri, (0, ast_util_1.getDocument)(attribute).uri)
              });
            }
          }
          const parserRule = (0, ast_util_1.getContainerOfType)(ruleOrAction, ast_1.isParserRule);
          refs.push(...this.createReferencesToAttribute(parserRule, attribute));
        }
        return refs;
      }
      findAssignmentDeclaration(assignment) {
        var _a;
        const parserRule = (0, ast_util_1.getContainerOfType)(assignment, ast_1.isParserRule);
        const action = (0, internal_grammar_util_1.getActionAtElement)(assignment);
        if (action) {
          const actionDeclaration = this.findActionDeclaration(action, assignment.feature);
          if (actionDeclaration) {
            return actionDeclaration;
          }
        }
        if ((_a = parserRule === null || parserRule === void 0 ? void 0 : parserRule.returnType) === null || _a === void 0 ? void 0 : _a.ref) {
          if ((0, ast_1.isInterface)(parserRule.returnType.ref) || (0, ast_1.isType)(parserRule.returnType.ref)) {
            const interfaces = (0, types_util_1.collectSuperTypes)(parserRule.returnType.ref);
            for (const interf of interfaces) {
              const typeAttribute = interf.attributes.find((att) => att.name === assignment.feature);
              if (typeAttribute) {
                return typeAttribute;
              }
            }
          }
        }
        return assignment;
      }
      findActionDeclaration(action, featureName) {
        var _a;
        if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) {
          const feature = featureName !== null && featureName !== void 0 ? featureName : action.feature;
          const interfaces = (0, types_util_1.collectSuperTypes)(action.type.ref);
          for (const interf of interfaces) {
            const typeAttribute = interf.attributes.find((att) => att.name === feature);
            if (typeAttribute) {
              return typeAttribute;
            }
          }
        }
        return void 0;
      }
      findRulesWithReturnType(interf) {
        const rules = [];
        const refs = this.index.findAllReferences(interf, this.nodeLocator.getAstNodePath(interf));
        refs.forEach((ref) => {
          const doc = this.documents.getOrCreateDocument(ref.sourceUri);
          const astNode = this.nodeLocator.getAstNode(doc.parseResult.value, ref.sourcePath);
          if ((0, ast_1.isParserRule)(astNode) || (0, ast_1.isAction)(astNode)) {
            rules.push(astNode);
          }
        });
        return rules;
      }
    };
    exports2.LangiumGrammarReferences = LangiumGrammarReferences;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/completion/follow-element-computation.js
var require_follow_element_computation = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/completion/follow-element-computation.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findFirstFeatures = exports2.findNextFeatures = void 0;
    var ast2 = __importStar(require_ast());
    var internal_grammar_util_1 = require_internal_grammar_util();
    var syntax_tree_1 = require_syntax_tree();
    var ast_util_1 = require_ast_util();
    var grammar_util_1 = require_grammar_util();
    function findNextFeatures(featureStack, unparsedTokens) {
      const context = {
        stacks: featureStack,
        tokens: unparsedTokens
      };
      interpretTokens(context);
      context.stacks.flat().forEach((feature) => {
        feature.property = void 0;
      });
      const nextStacks = findNextFeatureStacks(context.stacks);
      return nextStacks.map((e) => e[e.length - 1]);
    }
    exports2.findNextFeatures = findNextFeatures;
    function findNextFeaturesInternal(options) {
      const { next, cardinalities, visited, plus } = options;
      const features = [];
      const feature = next.feature;
      if (visited.has(feature)) {
        return [];
      } else {
        visited.add(feature);
      }
      let parent;
      let item = feature;
      while (item.$container) {
        if (ast2.isGroup(item.$container)) {
          parent = item.$container;
          break;
        } else if (ast2.isAbstractElement(item.$container)) {
          item = item.$container;
        } else {
          break;
        }
      }
      if ((0, internal_grammar_util_1.isArrayCardinality)(item.cardinality)) {
        const repeatingFeatures = findFirstFeaturesInternal({
          next: {
            feature: item,
            type: next.type,
            new: false
          },
          cardinalities,
          visited,
          plus
        });
        for (const repeatingFeature of repeatingFeatures) {
          plus.add(repeatingFeature.feature);
        }
        features.push(...repeatingFeatures);
      }
      if (parent) {
        const ownIndex = parent.elements.indexOf(item);
        if (ownIndex !== void 0 && ownIndex < parent.elements.length - 1) {
          features.push(...findNextFeaturesInGroup({
            feature: parent,
            type: next.type,
            new: false
          }, ownIndex + 1, cardinalities, visited, plus));
        }
        if (features.every((e) => (0, internal_grammar_util_1.isOptionalCardinality)(e.feature.cardinality) || (0, internal_grammar_util_1.isOptionalCardinality)(cardinalities.get(e.feature)) || plus.has(e.feature))) {
          features.push(...findNextFeaturesInternal({
            next: {
              feature: parent,
              type: next.type,
              new: false
            },
            cardinalities,
            visited,
            plus
          }));
        }
      }
      return features;
    }
    function findFirstFeatures(next) {
      if ((0, syntax_tree_1.isAstNode)(next)) {
        next = { feature: next };
      }
      return findFirstFeaturesInternal({ next, cardinalities: /* @__PURE__ */ new Map(), visited: /* @__PURE__ */ new Set(), plus: /* @__PURE__ */ new Set() });
    }
    exports2.findFirstFeatures = findFirstFeatures;
    function findFirstFeaturesInternal(options) {
      var _a, _b, _c;
      const { next, cardinalities, visited, plus } = options;
      if (next === void 0) {
        return [];
      }
      const { feature, type } = next;
      if (ast2.isGroup(feature)) {
        if (visited.has(feature)) {
          return [];
        } else {
          visited.add(feature);
        }
      }
      if (ast2.isGroup(feature)) {
        return findNextFeaturesInGroup(next, 0, cardinalities, visited, plus).map((e) => modifyCardinality(e, feature.cardinality, cardinalities));
      } else if (ast2.isAlternatives(feature) || ast2.isUnorderedGroup(feature)) {
        return feature.elements.flatMap((e) => findFirstFeaturesInternal({
          next: { feature: e, new: false, type },
          cardinalities,
          visited,
          plus
        })).map((e) => modifyCardinality(e, feature.cardinality, cardinalities));
      } else if (ast2.isAssignment(feature)) {
        const assignmentNext = {
          feature: feature.terminal,
          new: false,
          type,
          property: (_a = next.property) !== null && _a !== void 0 ? _a : feature.feature
        };
        return findFirstFeaturesInternal({ next: assignmentNext, cardinalities, visited, plus }).map((e) => modifyCardinality(e, feature.cardinality, cardinalities));
      } else if (ast2.isAction(feature)) {
        return findNextFeaturesInternal({
          next: {
            feature,
            new: true,
            type: (0, internal_grammar_util_1.getTypeName)(feature),
            property: (_b = next.property) !== null && _b !== void 0 ? _b : feature.feature
          },
          cardinalities,
          visited,
          plus
        });
      } else if (ast2.isRuleCall(feature) && ast2.isParserRule(feature.rule.ref)) {
        const rule = feature.rule.ref;
        const ruleCallNext = {
          feature: rule.definition,
          new: true,
          type: rule.fragment ? void 0 : (_c = (0, internal_grammar_util_1.getExplicitRuleType)(rule)) !== null && _c !== void 0 ? _c : rule.name,
          property: next.property
        };
        return findFirstFeaturesInternal({ next: ruleCallNext, cardinalities, visited, plus }).map((e) => modifyCardinality(e, feature.cardinality, cardinalities));
      } else {
        return [next];
      }
    }
    function modifyCardinality(next, cardinality, cardinalities) {
      cardinalities.set(next.feature, cardinality);
      return next;
    }
    function findNextFeaturesInGroup(next, index, cardinalities, visited, plus) {
      var _a;
      const features = [];
      let firstFeature;
      while (index < next.feature.elements.length) {
        firstFeature = { feature: next.feature.elements[index++], new: false, type: next.type };
        features.push(...findFirstFeaturesInternal({
          next: firstFeature,
          cardinalities,
          visited,
          plus
        }));
        if (!(0, internal_grammar_util_1.isOptionalCardinality)((_a = firstFeature.feature.cardinality) !== null && _a !== void 0 ? _a : cardinalities.get(firstFeature.feature))) {
          break;
        }
      }
      return features;
    }
    function interpretTokens(context) {
      for (const token of context.tokens) {
        const nextFeatureStacks = findNextFeatureStacks(context.stacks, token);
        context.stacks = nextFeatureStacks;
      }
    }
    function findNextFeatureStacks(stacks, token) {
      const newStacks = [];
      for (const stack of stacks) {
        newStacks.push(...interpretStackToken(stack, token));
      }
      return newStacks;
    }
    function interpretStackToken(stack, token) {
      const cardinalities = /* @__PURE__ */ new Map();
      const plus = new Set(stack.map((e) => e.feature).filter(isPlusFeature));
      const newStacks = [];
      while (stack.length > 0) {
        const top = stack.pop();
        const allNextFeatures = findNextFeaturesInternal({
          next: top,
          cardinalities,
          plus,
          visited: /* @__PURE__ */ new Set()
        }).filter((next) => token ? featureMatches(next.feature, token) : true);
        for (const nextFeature of allNextFeatures) {
          newStacks.push([...stack, nextFeature]);
        }
        if (!allNextFeatures.every((e) => (0, internal_grammar_util_1.isOptionalCardinality)(e.feature.cardinality) || (0, internal_grammar_util_1.isOptionalCardinality)(cardinalities.get(e.feature)))) {
          break;
        }
      }
      return newStacks;
    }
    function isPlusFeature(feature) {
      if (feature.cardinality === "+") {
        return true;
      }
      const assignment = (0, ast_util_1.getContainerOfType)(feature, ast2.isAssignment);
      if (assignment && assignment.cardinality === "+") {
        return true;
      }
      return false;
    }
    function featureMatches(feature, token) {
      if (ast2.isKeyword(feature)) {
        const content = feature.value;
        return content === token.image;
      } else if (ast2.isRuleCall(feature)) {
        return ruleMatches(feature.rule.ref, token);
      } else if (ast2.isCrossReference(feature)) {
        const crossRefTerminal = (0, grammar_util_1.getCrossReferenceTerminal)(feature);
        if (crossRefTerminal) {
          return featureMatches(crossRefTerminal, token);
        }
      }
      return false;
    }
    function ruleMatches(rule, token) {
      if (ast2.isParserRule(rule)) {
        const ruleFeatures = findFirstFeatures(rule.definition);
        return ruleFeatures.some((e) => featureMatches(e.feature, token));
      } else if (ast2.isTerminalRule(rule)) {
        return new RegExp((0, internal_grammar_util_1.terminalRegex)(rule)).test(token.image);
      } else {
        return false;
      }
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/completion/completion-provider.js
var require_completion_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/completion/completion-provider.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultCompletionProvider = exports2.mergeCompletionProviderOptions = void 0;
    var vscode_languageserver_1 = require_main4();
    var ast2 = __importStar(require_ast());
    var internal_grammar_util_1 = require_internal_grammar_util();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var grammar_util_1 = require_grammar_util();
    var stream_1 = require_stream();
    var follow_element_computation_1 = require_follow_element_computation();
    function mergeCompletionProviderOptions(options) {
      const triggerCharacters = Array.from(new Set(options.flatMap((option) => {
        var _a;
        return (_a = option === null || option === void 0 ? void 0 : option.triggerCharacters) !== null && _a !== void 0 ? _a : [];
      })));
      const allCommitCharacters = Array.from(new Set(options.flatMap((option) => {
        var _a;
        return (_a = option === null || option === void 0 ? void 0 : option.allCommitCharacters) !== null && _a !== void 0 ? _a : [];
      })));
      return {
        triggerCharacters: triggerCharacters.length > 0 ? triggerCharacters : void 0,
        allCommitCharacters: allCommitCharacters.length > 0 ? allCommitCharacters : void 0
      };
    }
    exports2.mergeCompletionProviderOptions = mergeCompletionProviderOptions;
    var DefaultCompletionProvider = class {
      constructor(services) {
        this.scopeProvider = services.references.ScopeProvider;
        this.grammar = services.Grammar;
        this.completionParser = services.parser.CompletionParser;
        this.nameProvider = services.references.NameProvider;
        this.grammarConfig = services.parser.GrammarConfig;
      }
      async getCompletion(document, params) {
        var _a, _b;
        const root = document.parseResult.value;
        const cst = root.$cstNode;
        if (!cst) {
          return void 0;
        }
        const items = [];
        const textDocument = document.textDocument;
        const text = textDocument.getText();
        const offset = textDocument.offsetAt(params.position);
        const acceptor = (value) => {
          const completionItem = this.fillCompletionItem(textDocument, offset, value);
          if (completionItem) {
            items.push(completionItem);
          }
        };
        const lastTokenOffset = this.backtrackToAnyToken(text, offset);
        const astNode = (_a = (0, cst_util_1.findLeafNodeAtOffset)(cst, lastTokenOffset)) === null || _a === void 0 ? void 0 : _a.element;
        const context = {
          document,
          textDocument,
          node: astNode,
          offset,
          position: params.position
        };
        if (!astNode) {
          const parserRule = (0, grammar_util_1.getEntryRule)(this.grammar);
          await this.completionForRule(context, parserRule, acceptor);
          return vscode_languageserver_1.CompletionList.create(this.deduplicateItems(items), true);
        }
        const contexts = [context];
        if (lastTokenOffset === offset && lastTokenOffset > 0) {
          const previousAstNode = (_b = (0, cst_util_1.findLeafNodeAtOffset)(cst, lastTokenOffset - 1)) === null || _b === void 0 ? void 0 : _b.element;
          if (previousAstNode !== astNode) {
            contexts.push({
              document,
              textDocument,
              node: previousAstNode,
              offset,
              position: params.position
            });
          }
        }
        const parserStart = this.backtrackToTokenStart(text, offset);
        const beforeFeatures = this.findFeaturesAt(textDocument, parserStart);
        let afterFeatures = [];
        const reparse = this.canReparse() && offset !== parserStart;
        if (reparse) {
          afterFeatures = this.findFeaturesAt(textDocument, offset);
        }
        const distinctionFunction = (element) => {
          if (ast2.isKeyword(element.feature)) {
            return element.feature.value;
          } else {
            return element.feature;
          }
        };
        await Promise.all((0, stream_1.stream)(beforeFeatures).distinct(distinctionFunction).map((e) => this.completionForContexts(contexts, e, acceptor)));
        if (reparse) {
          await Promise.all((0, stream_1.stream)(afterFeatures).exclude(beforeFeatures, distinctionFunction).distinct(distinctionFunction).map((e) => this.completionForContexts(contexts, e, acceptor)));
        }
        return vscode_languageserver_1.CompletionList.create(this.deduplicateItems(items), true);
      }
      /**
       * The completion algorithm could yield the same reference/keyword multiple times.
       *
       * This methods deduplicates these items afterwards before returning to the client.
       * Unique items are identified as a combination of `kind`, `label` and `detail`
       */
      deduplicateItems(items) {
        return (0, stream_1.stream)(items).distinct((item) => `${item.kind}_${item.label}_${item.detail}`).toArray();
      }
      /**
       * Determines whether the completion parser will reparse the input at the point of completion.
       * By default, this returns `false`, indicating that the completion will only look for completion results starting from the token at the cursor position.
       * Override this and return `true` to indicate that the completion should parse the input a second time.
       * This might add some missing completions at the cost at parsing the input twice.
       */
      canReparse() {
        return false;
      }
      findFeaturesAt(document, offset) {
        const text = document.getText({
          start: vscode_languageserver_1.Position.create(0, 0),
          end: document.positionAt(offset)
        });
        const parserResult = this.completionParser.parse(text);
        const tokens = parserResult.tokens;
        if (parserResult.tokenIndex === 0) {
          const parserRule = (0, grammar_util_1.getEntryRule)(this.grammar);
          const firstFeatures = (0, follow_element_computation_1.findFirstFeatures)({
            feature: parserRule.definition,
            new: true,
            type: (0, internal_grammar_util_1.getExplicitRuleType)(parserRule)
          });
          if (tokens.length > 0) {
            tokens.shift();
            return (0, follow_element_computation_1.findNextFeatures)(firstFeatures.map((e) => [e]), tokens);
          } else {
            return firstFeatures;
          }
        }
        const leftoverTokens = [...tokens].splice(parserResult.tokenIndex);
        const features = (0, follow_element_computation_1.findNextFeatures)([parserResult.elementStack.map((feature) => ({ feature }))], leftoverTokens);
        return features;
      }
      backtrackToAnyToken(text, offset) {
        if (offset >= text.length) {
          offset = text.length - 1;
        }
        while (offset > 0 && /\s/.test(text.charAt(offset))) {
          offset--;
        }
        return offset;
      }
      backtrackToTokenStart(text, offset) {
        if (offset < 1) {
          return offset;
        }
        const wordRegex = this.grammarConfig.nameRegexp;
        let lastCharacter = text.charAt(offset - 1);
        while (offset > 0 && wordRegex.test(lastCharacter)) {
          offset--;
          lastCharacter = text.charAt(offset - 1);
        }
        return offset;
      }
      async completionForRule(context, rule, acceptor) {
        if (ast2.isParserRule(rule)) {
          const firstFeatures = (0, follow_element_computation_1.findFirstFeatures)(rule.definition);
          await Promise.all(firstFeatures.map((next) => this.completionFor(context, next, acceptor)));
        }
      }
      async completionForContexts(contexts, next, acceptor) {
        for (const context of contexts) {
          await this.completionFor(context, next, acceptor);
        }
      }
      completionFor(context, next, acceptor) {
        if (ast2.isKeyword(next.feature)) {
          return this.completionForKeyword(context, next.feature, acceptor);
        } else if (ast2.isCrossReference(next.feature) && context.node) {
          return this.completionForCrossReference(context, next, acceptor);
        }
      }
      completionForCrossReference(context, crossRef, acceptor) {
        const assignment = (0, ast_util_1.getContainerOfType)(crossRef.feature, ast2.isAssignment);
        let node = context.node;
        if (assignment && node) {
          if (crossRef.type && (crossRef.new || node.$type !== crossRef.type)) {
            node = {
              $type: crossRef.type,
              $container: node,
              $containerProperty: crossRef.property
            };
          }
          if (!context) {
            return;
          }
          const refInfo = {
            reference: {},
            container: node,
            property: assignment.feature
          };
          try {
            const scope = this.scopeProvider.getScope(refInfo);
            const duplicateStore = /* @__PURE__ */ new Set();
            scope.getAllElements().forEach((e) => {
              if (!duplicateStore.has(e.name) && this.filterCrossReference(e)) {
                acceptor(this.createReferenceCompletionItem(e));
                duplicateStore.add(e.name);
              }
            });
          } catch (err) {
            console.error(err);
          }
        }
      }
      /**
       * Override this method to change how reference completion items are created.
       * Most notably useful to change the `kind` property which indicates which icon to display on the client.
       *
       * @param nodeDescription The description of a reference candidate
       * @returns A partial completion item
       */
      createReferenceCompletionItem(nodeDescription) {
        return {
          nodeDescription,
          kind: vscode_languageserver_1.CompletionItemKind.Reference,
          detail: nodeDescription.type,
          sortText: "0"
        };
      }
      filterCrossReference(_nodeDescription) {
        return true;
      }
      completionForKeyword(context, keyword, acceptor) {
        if (!keyword.value.match(/[\w]/)) {
          return;
        }
        acceptor({
          label: keyword.value,
          kind: vscode_languageserver_1.CompletionItemKind.Keyword,
          detail: "Keyword",
          sortText: "1"
        });
      }
      fillCompletionItem(document, offset, item) {
        var _a, _b;
        let label;
        if (typeof item.label === "string") {
          label = item.label;
        } else if ("node" in item) {
          const name = this.nameProvider.getName(item.node);
          if (!name) {
            return void 0;
          }
          label = name;
        } else if ("nodeDescription" in item) {
          label = item.nodeDescription.name;
        } else {
          return void 0;
        }
        let insertText;
        if (typeof ((_a = item.textEdit) === null || _a === void 0 ? void 0 : _a.newText) === "string") {
          insertText = item.textEdit.newText;
        } else if (typeof item.insertText === "string") {
          insertText = item.insertText;
        } else {
          insertText = label;
        }
        const textEdit = (_b = item.textEdit) !== null && _b !== void 0 ? _b : this.buildCompletionTextEdit(document, offset, label, insertText);
        if (!textEdit) {
          return void 0;
        }
        const completionItem = {
          additionalTextEdits: item.additionalTextEdits,
          command: item.command,
          commitCharacters: item.commitCharacters,
          data: item.data,
          detail: item.detail,
          documentation: item.documentation,
          filterText: item.filterText,
          insertText: item.insertText,
          insertTextFormat: item.insertTextFormat,
          insertTextMode: item.insertTextMode,
          kind: item.kind,
          labelDetails: item.labelDetails,
          preselect: item.preselect,
          sortText: item.sortText,
          tags: item.tags,
          textEditText: item.textEditText,
          textEdit,
          label
        };
        return completionItem;
      }
      buildCompletionTextEdit(document, offset, label, newText) {
        const content = document.getText();
        const tokenStart = this.backtrackToTokenStart(content, offset);
        const identifier = content.substring(tokenStart, offset);
        if (this.charactersFuzzyMatch(identifier, label)) {
          const start = document.positionAt(tokenStart);
          const end = document.positionAt(offset);
          return {
            newText,
            range: {
              start,
              end
            }
          };
        } else {
          return void 0;
        }
      }
      isWordCharacterAt(content, index) {
        return this.grammarConfig.nameRegexp.test(content.charAt(index));
      }
      charactersFuzzyMatch(existingValue, completionValue) {
        if (existingValue.length === 0) {
          return true;
        }
        completionValue = completionValue.toLowerCase();
        let matchedFirstCharacter = false;
        let previous;
        let character = 0;
        const len = completionValue.length;
        for (let i = 0; i < len; i++) {
          const strChar = completionValue.charCodeAt(i);
          const testChar = existingValue.charCodeAt(character);
          if (strChar === testChar || this.toUpperCharCode(strChar) === this.toUpperCharCode(testChar)) {
            matchedFirstCharacter || (matchedFirstCharacter = previous === void 0 || // Beginning of word
            this.isWordTransition(previous, strChar));
            if (matchedFirstCharacter) {
              character++;
            }
            if (character === existingValue.length) {
              return true;
            }
          }
          previous = strChar;
        }
        return false;
      }
      isWordTransition(previous, current) {
        return a <= previous && previous <= z && A <= current && current <= Z || // camelCase transition
        previous === _ && current !== _;
      }
      toUpperCharCode(charCode) {
        if (a <= charCode && charCode <= z) {
          return charCode - 32;
        }
        return charCode;
      }
    };
    exports2.DefaultCompletionProvider = DefaultCompletionProvider;
    var a = "a".charCodeAt(0);
    var z = "z".charCodeAt(0);
    var A = "A".charCodeAt(0);
    var Z = "Z".charCodeAt(0);
    var _ = "_".charCodeAt(0);
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/call-hierarchy-provider.js
var require_call_hierarchy_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/call-hierarchy-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractCallHierarchyProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var vscode_uri_1 = require_umd();
    var cst_util_1 = require_cst_util();
    var AbstractCallHierarchyProvider = class {
      constructor(services) {
        this.grammarConfig = services.parser.GrammarConfig;
        this.nameProvider = services.references.NameProvider;
        this.documents = services.shared.workspace.LangiumDocuments;
        this.references = services.references.References;
      }
      prepareCallHierarchy(document, params) {
        const rootNode = document.parseResult.value;
        const targetNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode.$cstNode, document.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
        if (!targetNode) {
          return void 0;
        }
        const declarationNode = this.references.findDeclarationNode(targetNode);
        if (!declarationNode) {
          return void 0;
        }
        return this.getCallHierarchyItems(declarationNode.element, document);
      }
      getCallHierarchyItems(targetNode, document) {
        const nameNode = this.nameProvider.getNameNode(targetNode);
        const name = this.nameProvider.getName(targetNode);
        if (!nameNode || !targetNode.$cstNode || name === void 0) {
          return void 0;
        }
        return [Object.assign({ kind: vscode_languageserver_1.SymbolKind.Method, name, range: targetNode.$cstNode.range, selectionRange: nameNode.range, uri: document.uri.toString() }, this.getCallHierarchyItem(targetNode))];
      }
      getCallHierarchyItem(_targetNode) {
        return void 0;
      }
      incomingCalls(params) {
        const document = this.documents.getOrCreateDocument(vscode_uri_1.URI.parse(params.item.uri));
        const rootNode = document.parseResult.value;
        const targetNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode.$cstNode, document.textDocument.offsetAt(params.item.range.start), this.grammarConfig.nameRegexp);
        if (!targetNode) {
          return void 0;
        }
        const references = this.references.findReferences(targetNode.element, {
          includeDeclaration: false
        });
        return this.getIncomingCalls(targetNode.element, references);
      }
      outgoingCalls(params) {
        const document = this.documents.getOrCreateDocument(vscode_uri_1.URI.parse(params.item.uri));
        const rootNode = document.parseResult.value;
        const targetNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode.$cstNode, document.textDocument.offsetAt(params.item.range.start), this.grammarConfig.nameRegexp);
        if (!targetNode) {
          return void 0;
        }
        return this.getOutgoingCalls(targetNode.element);
      }
    };
    exports2.AbstractCallHierarchyProvider = AbstractCallHierarchyProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/code-action.js
var require_code_action = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/code-action.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/code-lens-provider.js
var require_code_lens_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/code-lens-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/declaration-provider.js
var require_declaration_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/declaration-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/definition-provider.js
var require_definition_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/definition-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultDefinitionProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var DefaultDefinitionProvider = class {
      constructor(services) {
        this.nameProvider = services.references.NameProvider;
        this.references = services.references.References;
        this.grammarConfig = services.parser.GrammarConfig;
      }
      getDefinition(document, params) {
        const rootNode = document.parseResult.value;
        if (rootNode.$cstNode) {
          const cst = rootNode.$cstNode;
          const sourceCstNode = (0, cst_util_1.findDeclarationNodeAtOffset)(cst, document.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
          if (sourceCstNode) {
            return this.collectLocationLinks(sourceCstNode, params);
          }
        }
        return void 0;
      }
      collectLocationLinks(sourceCstNode, _params) {
        var _a;
        const goToLink = this.findLink(sourceCstNode);
        if (goToLink) {
          return [vscode_languageserver_1.LocationLink.create(goToLink.targetDocument.textDocument.uri, ((_a = goToLink.target.element.$cstNode) !== null && _a !== void 0 ? _a : goToLink.target).range, goToLink.target.range, goToLink.source.range)];
        }
        return void 0;
      }
      findLink(source) {
        const target = this.references.findDeclarationNode(source);
        if (target === null || target === void 0 ? void 0 : target.element) {
          const targetDocument = (0, ast_util_1.getDocument)(target.element);
          if (target && targetDocument) {
            return { source, target, targetDocument };
          }
        }
        return void 0;
      }
    };
    exports2.DefaultDefinitionProvider = DefaultDefinitionProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/document-highlight-provider.js
var require_document_highlight_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/document-highlight-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultDocumentHighlightProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var uri_util_1 = require_uri_util();
    var DefaultDocumentHighlightProvider = class {
      constructor(services) {
        this.references = services.references.References;
        this.nameProvider = services.references.NameProvider;
        this.grammarConfig = services.parser.GrammarConfig;
      }
      getDocumentHighlight(document, params) {
        const rootNode = document.parseResult.value.$cstNode;
        if (!rootNode) {
          return void 0;
        }
        const selectedNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode, document.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
        if (!selectedNode) {
          return void 0;
        }
        const targetAstNode = this.references.findDeclaration(selectedNode);
        if (targetAstNode) {
          const includeDeclaration = (0, uri_util_1.equalURI)((0, ast_util_1.getDocument)(targetAstNode).uri, document.uri);
          const options = { documentUri: document.uri, includeDeclaration };
          const references = this.references.findReferences(targetAstNode, options);
          return references.map((ref) => this.createDocumentHighlight(ref)).toArray();
        }
        return void 0;
      }
      /**
      * Override this method to determine the highlight kind of the given reference.
      */
      createDocumentHighlight(reference) {
        return vscode_languageserver_1.DocumentHighlight.create(reference.segment.range);
      }
    };
    exports2.DefaultDocumentHighlightProvider = DefaultDocumentHighlightProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/document-link-provider.js
var require_document_link_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/document-link-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/document-symbol-provider.js
var require_document_symbol_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/document-symbol-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultDocumentSymbolProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var ast_util_1 = require_ast_util();
    var DefaultDocumentSymbolProvider = class {
      constructor(services) {
        this.nameProvider = services.references.NameProvider;
      }
      getSymbols(document) {
        return this.getSymbol(document, document.parseResult.value);
      }
      getSymbol(document, astNode) {
        const node = astNode.$cstNode;
        const nameNode = this.nameProvider.getNameNode(astNode);
        if (nameNode && node) {
          const name = this.nameProvider.getName(astNode);
          return [{
            kind: this.getSymbolKind(astNode.$type),
            name: name !== null && name !== void 0 ? name : nameNode.text,
            range: node.range,
            selectionRange: nameNode.range,
            children: this.getChildSymbols(document, astNode)
          }];
        } else {
          return this.getChildSymbols(document, astNode) || [];
        }
      }
      getChildSymbols(document, astNode) {
        const children = [];
        for (const child of (0, ast_util_1.streamContents)(astNode)) {
          const result = this.getSymbol(document, child);
          children.push(...result);
        }
        if (children.length > 0) {
          return children;
        }
        return void 0;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getSymbolKind(type) {
        return vscode_languageserver_1.SymbolKind.Field;
      }
    };
    exports2.DefaultDocumentSymbolProvider = DefaultDocumentSymbolProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/execute-command-handler.js
var require_execute_command_handler = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/execute-command-handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractExecuteCommandHandler = void 0;
    var vscode_languageserver_1 = require_main4();
    var AbstractExecuteCommandHandler = class {
      get commands() {
        return Array.from(this.registeredCommands.keys());
      }
      constructor() {
        this.registeredCommands = /* @__PURE__ */ new Map();
        this.registerCommands(this.createCommandAcceptor());
      }
      async executeCommand(name, args, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const command = this.registeredCommands.get(name);
        if (command) {
          return command(args, cancelToken);
        } else {
          return void 0;
        }
      }
      createCommandAcceptor() {
        return (name, execute) => this.registeredCommands.set(name, execute);
      }
    };
    exports2.AbstractExecuteCommandHandler = AbstractExecuteCommandHandler;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/hover-provider.js
var require_hover_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/hover-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultilineCommentHoverProvider = exports2.AstNodeHoverProvider = void 0;
    var cst_util_1 = require_cst_util();
    var AstNodeHoverProvider = class {
      constructor(services) {
        this.references = services.references.References;
        this.grammarConfig = services.parser.GrammarConfig;
      }
      getHoverContent(document, params) {
        var _a, _b;
        const rootNode = (_b = (_a = document.parseResult) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.$cstNode;
        if (rootNode) {
          const offset = document.textDocument.offsetAt(params.position);
          const cstNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode, offset, this.grammarConfig.nameRegexp);
          if (cstNode && cstNode.offset + cstNode.length > offset) {
            const targetNode = this.references.findDeclaration(cstNode);
            if (targetNode) {
              return this.getAstNodeHoverContent(targetNode);
            }
          }
        }
        return void 0;
      }
    };
    exports2.AstNodeHoverProvider = AstNodeHoverProvider;
    var MultilineCommentHoverProvider = class extends AstNodeHoverProvider {
      constructor(services) {
        super(services);
        this.documentationProvider = services.documentation.DocumentationProvider;
      }
      getAstNodeHoverContent(node) {
        const content = this.documentationProvider.getDocumentation(node);
        if (content) {
          return {
            contents: {
              kind: "markdown",
              value: content
            }
          };
        }
        return void 0;
      }
    };
    exports2.MultilineCommentHoverProvider = MultilineCommentHoverProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/implementation-provider.js
var require_implementation_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/implementation-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractGoToImplementationProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var cst_util_1 = require_cst_util();
    var AbstractGoToImplementationProvider = class {
      constructor(services) {
        this.references = services.references.References;
        this.grammarConfig = services.parser.GrammarConfig;
      }
      getImplementation(document, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const rootNode = document.parseResult.value;
        if (rootNode.$cstNode) {
          const sourceCstNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode.$cstNode, document.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
          if (sourceCstNode) {
            const nodeDeclaration = this.references.findDeclaration(sourceCstNode);
            if (nodeDeclaration) {
              return this.collectGoToImplementationLocationLinks(nodeDeclaration, cancelToken);
            }
          }
        }
        return void 0;
      }
    };
    exports2.AbstractGoToImplementationProvider = AbstractGoToImplementationProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/inlay-hint-provider.js
var require_inlay_hint_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/inlay-hint-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractInlayHintProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var ast_util_1 = require_ast_util();
    var promise_util_1 = require_promise_util();
    var AbstractInlayHintProvider = class {
      async getInlayHints(document, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const root = document.parseResult.value;
        const inlayHints = [];
        const acceptor = (hint) => inlayHints.push(hint);
        for (const node of (0, ast_util_1.streamAst)(root, { range: params.range })) {
          await (0, promise_util_1.interruptAndCheck)(cancelToken);
          this.computeInlayHint(node, acceptor);
        }
        return inlayHints;
      }
    };
    exports2.AbstractInlayHintProvider = AbstractInlayHintProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/documents.js
var require_documents = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/documents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultLangiumDocuments = exports2.DefaultLangiumDocumentFactory = exports2.DocumentState = void 0;
    var vscode_languageserver_textdocument_1 = require_main5();
    var vscode_uri_1 = require_umd();
    var stream_1 = require_stream();
    var DocumentState;
    (function(DocumentState2) {
      DocumentState2[DocumentState2["Changed"] = 0] = "Changed";
      DocumentState2[DocumentState2["Parsed"] = 1] = "Parsed";
      DocumentState2[DocumentState2["IndexedContent"] = 2] = "IndexedContent";
      DocumentState2[DocumentState2["ComputedScopes"] = 3] = "ComputedScopes";
      DocumentState2[DocumentState2["Linked"] = 4] = "Linked";
      DocumentState2[DocumentState2["IndexedReferences"] = 5] = "IndexedReferences";
      DocumentState2[DocumentState2["Validated"] = 6] = "Validated";
    })(DocumentState = exports2.DocumentState || (exports2.DocumentState = {}));
    var DefaultLangiumDocumentFactory = class {
      constructor(services) {
        this.serviceRegistry = services.ServiceRegistry;
        this.textDocuments = services.workspace.TextDocuments;
        this.fileSystemProvider = services.workspace.FileSystemProvider;
      }
      fromTextDocument(textDocument, uri) {
        return this.create(uri !== null && uri !== void 0 ? uri : vscode_uri_1.URI.parse(textDocument.uri), textDocument);
      }
      fromString(text, uri) {
        return this.create(uri, text);
      }
      fromModel(model, uri) {
        return this.create(uri, { $model: model });
      }
      create(uri, content) {
        content !== null && content !== void 0 ? content : content = this.textDocuments.get(uri.toString());
        content !== null && content !== void 0 ? content : content = this.getContentFromFileSystem(uri);
        if (typeof content === "string") {
          const parseResult = this.parse(uri, content);
          return this.createLangiumDocument(parseResult, uri, void 0, content);
        } else if ("$model" in content) {
          const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };
          return this.createLangiumDocument(parseResult, uri);
        } else {
          const parseResult = this.parse(uri, content.getText());
          return this.createLangiumDocument(parseResult, uri, content);
        }
      }
      /**
       * Create a LangiumDocument from a given parse result.
       *
       * A TextDocument is created on demand if it is not provided as argument here. Usually this
       * should not be necessary because the main purpose of the TextDocument is to convert between
       * text ranges and offsets, which is done solely in LSP request handling.
       *
       * With the introduction of {@link update} below this method is supposed to be mainly called
       * during workspace initialization and on addition/recognition of new files, while changes in
       * existing documents are processed via {@link update}.
       */
      createLangiumDocument(parseResult, uri, textDocument, text) {
        let document;
        if (textDocument) {
          document = {
            parseResult,
            uri,
            state: DocumentState.Parsed,
            references: [],
            textDocument
          };
        } else {
          const textDocumentGetter = this.createTextDocumentGetter(uri, text);
          document = {
            parseResult,
            uri,
            state: DocumentState.Parsed,
            references: [],
            get textDocument() {
              return textDocumentGetter();
            }
          };
        }
        parseResult.value.$document = document;
        return document;
      }
      update(document) {
        const textDocument = this.textDocuments.get(document.uri.toString());
        const text = textDocument ? textDocument.getText() : this.getContentFromFileSystem(document.uri);
        if (textDocument) {
          Object.defineProperty(document, "textDocument", {
            value: textDocument
          });
        } else {
          const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);
          Object.defineProperty(document, "textDocument", {
            get: textDocumentGetter
          });
        }
        document.parseResult = this.parse(document.uri, text);
        document.parseResult.value.$document = document;
        document.state = DocumentState.Parsed;
        return document;
      }
      getContentFromFileSystem(uri) {
        return this.fileSystemProvider.readFileSync(uri);
      }
      parse(uri, text) {
        const services = this.serviceRegistry.getServices(uri);
        return services.parser.LangiumParser.parse(text);
      }
      createTextDocumentGetter(uri, text) {
        const serviceRegistry = this.serviceRegistry;
        let textDoc = void 0;
        return () => {
          return textDoc !== null && textDoc !== void 0 ? textDoc : textDoc = vscode_languageserver_textdocument_1.TextDocument.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null && text !== void 0 ? text : "");
        };
      }
    };
    exports2.DefaultLangiumDocumentFactory = DefaultLangiumDocumentFactory;
    var DefaultLangiumDocuments = class {
      constructor(services) {
        this.documentMap = /* @__PURE__ */ new Map();
        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;
      }
      get all() {
        return (0, stream_1.stream)(this.documentMap.values());
      }
      addDocument(document) {
        const uriString = document.uri.toString();
        if (this.documentMap.has(uriString)) {
          throw new Error(`A document with the URI '${uriString}' is already present.`);
        }
        this.documentMap.set(uriString, document);
      }
      getOrCreateDocument(uri) {
        const uriString = uri.toString();
        let langiumDoc = this.documentMap.get(uriString);
        if (langiumDoc) {
          return langiumDoc;
        }
        langiumDoc = this.langiumDocumentFactory.create(uri);
        this.documentMap.set(uriString, langiumDoc);
        return langiumDoc;
      }
      hasDocument(uri) {
        return this.documentMap.has(uri.toString());
      }
      invalidateDocument(uri) {
        const uriString = uri.toString();
        const langiumDoc = this.documentMap.get(uriString);
        if (langiumDoc) {
          langiumDoc.state = DocumentState.Changed;
          langiumDoc.references = [];
          langiumDoc.precomputedScopes = void 0;
          langiumDoc.diagnostics = [];
        }
        return langiumDoc;
      }
      deleteDocument(uri) {
        const uriString = uri.toString();
        const langiumDoc = this.documentMap.get(uriString);
        if (langiumDoc) {
          langiumDoc.state = DocumentState.Changed;
          this.documentMap.delete(uriString);
        }
        return langiumDoc;
      }
    };
    exports2.DefaultLangiumDocuments = DefaultLangiumDocuments;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/signature-help-provider.js
var require_signature_help_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/signature-help-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeSignatureHelpOptions = exports2.AbstractSignatureHelpProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var cst_util_1 = require_cst_util();
    var AbstractSignatureHelpProvider = class {
      provideSignatureHelp(document, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const rootNode = document.parseResult.value;
        const cst = rootNode.$cstNode;
        if (cst) {
          const sourceCstNode = (0, cst_util_1.findLeafNodeAtOffset)(cst, document.textDocument.offsetAt(params.position));
          if (sourceCstNode) {
            return this.getSignatureFromElement(sourceCstNode.element, cancelToken);
          }
        }
        return void 0;
      }
      /**
       * Override this getter to return the list of triggering characters for your language. To deactivate the signature help, return an empty object.
       */
      get signatureHelpOptions() {
        return {
          triggerCharacters: ["("],
          retriggerCharacters: [","]
        };
      }
    };
    exports2.AbstractSignatureHelpProvider = AbstractSignatureHelpProvider;
    function mergeSignatureHelpOptions(options) {
      const triggerCharacters = [];
      const retriggerCharacters = [];
      options.forEach((option) => {
        if (option === null || option === void 0 ? void 0 : option.triggerCharacters) {
          triggerCharacters.push(...option.triggerCharacters);
        }
        if (option === null || option === void 0 ? void 0 : option.retriggerCharacters) {
          retriggerCharacters.push(...option.retriggerCharacters);
        }
      });
      const mergedOptions = {
        triggerCharacters: triggerCharacters.length > 0 ? Array.from(new Set(triggerCharacters)).sort() : void 0,
        retriggerCharacters: retriggerCharacters.length > 0 ? Array.from(new Set(retriggerCharacters)).sort() : void 0
      };
      return mergedOptions.triggerCharacters ? mergedOptions : void 0;
    }
    exports2.mergeSignatureHelpOptions = mergeSignatureHelpOptions;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/language-server.js
var require_language_server = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/language-server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createRequestHandler = exports2.createServerRequestHandler = exports2.createCallHierarchyRequestHandler = exports2.addCallHierarchyHandler = exports2.addCodeLensHandler = exports2.addSignatureHelpHandler = exports2.addDocumentLinkHandler = exports2.addExecuteCommandHandler = exports2.addConfigurationChangeHandler = exports2.addSemanticTokenHandler = exports2.addInlayHintHandler = exports2.addRenameHandler = exports2.addFormattingHandler = exports2.addFoldingRangeHandler = exports2.addHoverHandler = exports2.addDocumentHighlightsHandler = exports2.addGoToDeclarationHandler = exports2.addGoToImplementationHandler = exports2.addGoToTypeDefinitionHandler = exports2.addGotoDefinitionHandler = exports2.addDocumentSymbolHandler = exports2.addCodeActionHandler = exports2.addFindReferencesHandler = exports2.addCompletionHandler = exports2.addDiagnosticsHandler = exports2.addDocumentsHandler = exports2.startLanguageServer = exports2.DefaultLanguageServer = void 0;
    var vscode_languageserver_1 = require_main4();
    var vscode_uri_1 = require_umd();
    var dependency_injection_1 = require_dependency_injection();
    var promise_util_1 = require_promise_util();
    var documents_1 = require_documents();
    var completion_provider_1 = require_completion_provider();
    var semantic_token_provider_1 = require_semantic_token_provider();
    var signature_help_provider_1 = require_signature_help_provider();
    var DefaultLanguageServer = class {
      constructor(services) {
        this.onInitializeEmitter = new vscode_languageserver_1.Emitter();
        this.onInitializedEmitter = new vscode_languageserver_1.Emitter();
        this.services = services;
      }
      get onInitialize() {
        return this.onInitializeEmitter.event;
      }
      get onInitialized() {
        return this.onInitializedEmitter.event;
      }
      async initialize(params) {
        this.eagerLoadServices();
        this.onInitializeEmitter.fire(params);
        this.onInitializeEmitter.dispose();
        return this.buildInitializeResult(params);
      }
      /**
       * Eagerly loads all services before emitting the `onInitialize` event.
       * Ensures that all services are able to catch the event.
       */
      eagerLoadServices() {
        (0, dependency_injection_1.eagerLoad)(this.services);
        this.services.ServiceRegistry.all.forEach((language) => (0, dependency_injection_1.eagerLoad)(language));
      }
      hasService(callback) {
        return this.services.ServiceRegistry.all.some((language) => callback(language) !== void 0);
      }
      buildInitializeResult(_params) {
        var _a;
        const languages = this.services.ServiceRegistry.all;
        const hasFormattingService = this.hasService((e) => e.lsp.Formatter);
        const formattingOnTypeOptions = languages.map((e) => {
          var _a2;
          return (_a2 = e.lsp.Formatter) === null || _a2 === void 0 ? void 0 : _a2.formatOnTypeOptions;
        }).find((e) => Boolean(e));
        const hasCodeActionProvider = this.hasService((e) => e.lsp.CodeActionProvider);
        const hasSemanticTokensProvider = this.hasService((e) => e.lsp.SemanticTokenProvider);
        const commandNames = (_a = this.services.lsp.ExecuteCommandHandler) === null || _a === void 0 ? void 0 : _a.commands;
        const documentLinkProvider = this.services.lsp.DocumentLinkProvider;
        const signatureHelpOptions = (0, signature_help_provider_1.mergeSignatureHelpOptions)(languages.map((e) => {
          var _a2;
          return (_a2 = e.lsp.SignatureHelp) === null || _a2 === void 0 ? void 0 : _a2.signatureHelpOptions;
        }));
        const hasGoToTypeProvider = this.hasService((e) => e.lsp.TypeProvider);
        const hasGoToImplementationProvider = this.hasService((e) => e.lsp.ImplementationProvider);
        const hasCompletionProvider = this.hasService((e) => e.lsp.CompletionProvider);
        const completionOptions = (0, completion_provider_1.mergeCompletionProviderOptions)(languages.map((e) => {
          var _a2;
          return (_a2 = e.lsp.CompletionProvider) === null || _a2 === void 0 ? void 0 : _a2.completionOptions;
        }));
        const hasReferencesProvider = this.hasService((e) => e.lsp.ReferencesProvider);
        const hasDocumentSymbolProvider = this.hasService((e) => e.lsp.DocumentSymbolProvider);
        const hasDefinitionProvider = this.hasService((e) => e.lsp.DefinitionProvider);
        const hasDocumentHighlightProvider = this.hasService((e) => e.lsp.DocumentHighlightProvider);
        const hasFoldingRangeProvider = this.hasService((e) => e.lsp.FoldingRangeProvider);
        const hasHoverProvider = this.hasService((e) => e.lsp.HoverProvider);
        const hasRenameProvider = this.hasService((e) => e.lsp.RenameProvider);
        const hasCallHierarchyProvider = this.hasService((e) => e.lsp.CallHierarchyProvider);
        const codeLensProvider = this.services.lsp.CodeLensProvider;
        const hasDeclarationProvider = this.hasService((e) => e.lsp.DeclarationProvider);
        const inlayHintProvider = this.services.lsp.InlayHintProvider;
        const result = {
          capabilities: {
            workspace: {
              workspaceFolders: {
                supported: true
              }
            },
            executeCommandProvider: commandNames && {
              commands: commandNames
            },
            textDocumentSync: vscode_languageserver_1.TextDocumentSyncKind.Incremental,
            completionProvider: hasCompletionProvider ? completionOptions : void 0,
            referencesProvider: hasReferencesProvider,
            documentSymbolProvider: hasDocumentSymbolProvider,
            definitionProvider: hasDefinitionProvider,
            typeDefinitionProvider: hasGoToTypeProvider,
            documentHighlightProvider: hasDocumentHighlightProvider,
            codeActionProvider: hasCodeActionProvider,
            documentFormattingProvider: hasFormattingService,
            documentRangeFormattingProvider: hasFormattingService,
            documentOnTypeFormattingProvider: formattingOnTypeOptions,
            foldingRangeProvider: hasFoldingRangeProvider,
            hoverProvider: hasHoverProvider,
            renameProvider: hasRenameProvider ? {
              prepareProvider: true
            } : void 0,
            semanticTokensProvider: hasSemanticTokensProvider ? semantic_token_provider_1.DefaultSemanticTokenOptions : void 0,
            signatureHelpProvider: signatureHelpOptions,
            implementationProvider: hasGoToImplementationProvider,
            callHierarchyProvider: hasCallHierarchyProvider ? {} : void 0,
            documentLinkProvider: documentLinkProvider ? { resolveProvider: Boolean(documentLinkProvider.resolveDocumentLink) } : void 0,
            codeLensProvider: codeLensProvider ? { resolveProvider: Boolean(codeLensProvider.resolveCodeLens) } : void 0,
            declarationProvider: hasDeclarationProvider,
            inlayHintProvider: inlayHintProvider ? { resolveProvider: Boolean(inlayHintProvider.resolveInlayHint) } : void 0
          }
        };
        return result;
      }
      async initialized(params) {
        this.onInitializedEmitter.fire(params);
        this.onInitializedEmitter.dispose();
      }
    };
    exports2.DefaultLanguageServer = DefaultLanguageServer;
    function startLanguageServer(services) {
      const connection = services.lsp.Connection;
      if (!connection) {
        throw new Error("Starting a language server requires the languageServer.Connection service to be set.");
      }
      addDocumentsHandler(connection, services);
      addDiagnosticsHandler(connection, services);
      addCompletionHandler(connection, services);
      addFindReferencesHandler(connection, services);
      addDocumentSymbolHandler(connection, services);
      addGotoDefinitionHandler(connection, services);
      addGoToTypeDefinitionHandler(connection, services);
      addGoToImplementationHandler(connection, services);
      addDocumentHighlightsHandler(connection, services);
      addFoldingRangeHandler(connection, services);
      addFormattingHandler(connection, services);
      addCodeActionHandler(connection, services);
      addRenameHandler(connection, services);
      addHoverHandler(connection, services);
      addInlayHintHandler(connection, services);
      addSemanticTokenHandler(connection, services);
      addExecuteCommandHandler(connection, services);
      addSignatureHelpHandler(connection, services);
      addCallHierarchyHandler(connection, services);
      addCodeLensHandler(connection, services);
      addDocumentLinkHandler(connection, services);
      addConfigurationChangeHandler(connection, services);
      addGoToDeclarationHandler(connection, services);
      connection.onInitialize((params) => {
        return services.lsp.LanguageServer.initialize(params);
      });
      connection.onInitialized((params) => {
        return services.lsp.LanguageServer.initialized(params);
      });
      const documents = services.workspace.TextDocuments;
      documents.listen(connection);
      connection.listen();
    }
    exports2.startLanguageServer = startLanguageServer;
    function addDocumentsHandler(connection, services) {
      const documentBuilder = services.workspace.DocumentBuilder;
      const mutex = services.workspace.MutexLock;
      function onDidChange(changed, deleted) {
        mutex.lock((token) => documentBuilder.update(changed, deleted, token));
      }
      const documents = services.workspace.TextDocuments;
      documents.onDidChangeContent((change) => {
        onDidChange([vscode_uri_1.URI.parse(change.document.uri)], []);
      });
      connection.onDidChangeWatchedFiles((params) => {
        const changedUris = [];
        const deletedUris = [];
        for (const change of params.changes) {
          const uri = vscode_uri_1.URI.parse(change.uri);
          if (change.type === vscode_languageserver_1.FileChangeType.Deleted) {
            deletedUris.push(uri);
          } else {
            changedUris.push(uri);
          }
        }
        onDidChange(changedUris, deletedUris);
      });
    }
    exports2.addDocumentsHandler = addDocumentsHandler;
    function addDiagnosticsHandler(connection, services) {
      const documentBuilder = services.workspace.DocumentBuilder;
      documentBuilder.onBuildPhase(documents_1.DocumentState.Validated, async (documents, cancelToken) => {
        for (const document of documents) {
          if (document.diagnostics) {
            connection.sendDiagnostics({
              uri: document.uri.toString(),
              diagnostics: document.diagnostics
            });
          }
          if (cancelToken.isCancellationRequested) {
            return;
          }
        }
      });
    }
    exports2.addDiagnosticsHandler = addDiagnosticsHandler;
    function addCompletionHandler(connection, services) {
      connection.onCompletion(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.CompletionProvider) === null || _a === void 0 ? void 0 : _a.getCompletion(document, params, cancelToken);
      }, services));
    }
    exports2.addCompletionHandler = addCompletionHandler;
    function addFindReferencesHandler(connection, services) {
      connection.onReferences(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.ReferencesProvider) === null || _a === void 0 ? void 0 : _a.findReferences(document, params, cancelToken);
      }, services));
    }
    exports2.addFindReferencesHandler = addFindReferencesHandler;
    function addCodeActionHandler(connection, services) {
      connection.onCodeAction(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.CodeActionProvider) === null || _a === void 0 ? void 0 : _a.getCodeActions(document, params, cancelToken);
      }, services));
    }
    exports2.addCodeActionHandler = addCodeActionHandler;
    function addDocumentSymbolHandler(connection, services) {
      connection.onDocumentSymbol(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.DocumentSymbolProvider) === null || _a === void 0 ? void 0 : _a.getSymbols(document, params, cancelToken);
      }, services));
    }
    exports2.addDocumentSymbolHandler = addDocumentSymbolHandler;
    function addGotoDefinitionHandler(connection, services) {
      connection.onDefinition(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.DefinitionProvider) === null || _a === void 0 ? void 0 : _a.getDefinition(document, params, cancelToken);
      }, services));
    }
    exports2.addGotoDefinitionHandler = addGotoDefinitionHandler;
    function addGoToTypeDefinitionHandler(connection, services) {
      connection.onTypeDefinition(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.TypeProvider) === null || _a === void 0 ? void 0 : _a.getTypeDefinition(document, params, cancelToken);
      }, services));
    }
    exports2.addGoToTypeDefinitionHandler = addGoToTypeDefinitionHandler;
    function addGoToImplementationHandler(connection, services) {
      connection.onImplementation(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.ImplementationProvider) === null || _a === void 0 ? void 0 : _a.getImplementation(document, params, cancelToken);
      }, services));
    }
    exports2.addGoToImplementationHandler = addGoToImplementationHandler;
    function addGoToDeclarationHandler(connection, services) {
      connection.onDeclaration(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.DeclarationProvider) === null || _a === void 0 ? void 0 : _a.getDeclaration(document, params, cancelToken);
      }, services));
    }
    exports2.addGoToDeclarationHandler = addGoToDeclarationHandler;
    function addDocumentHighlightsHandler(connection, services) {
      connection.onDocumentHighlight(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.DocumentHighlightProvider) === null || _a === void 0 ? void 0 : _a.getDocumentHighlight(document, params, cancelToken);
      }, services));
    }
    exports2.addDocumentHighlightsHandler = addDocumentHighlightsHandler;
    function addHoverHandler(connection, services) {
      connection.onHover(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.HoverProvider) === null || _a === void 0 ? void 0 : _a.getHoverContent(document, params, cancelToken);
      }, services));
    }
    exports2.addHoverHandler = addHoverHandler;
    function addFoldingRangeHandler(connection, services) {
      connection.onFoldingRanges(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.FoldingRangeProvider) === null || _a === void 0 ? void 0 : _a.getFoldingRanges(document, params, cancelToken);
      }, services));
    }
    exports2.addFoldingRangeHandler = addFoldingRangeHandler;
    function addFormattingHandler(connection, services) {
      connection.onDocumentFormatting(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.Formatter) === null || _a === void 0 ? void 0 : _a.formatDocument(document, params, cancelToken);
      }, services));
      connection.onDocumentRangeFormatting(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.Formatter) === null || _a === void 0 ? void 0 : _a.formatDocumentRange(document, params, cancelToken);
      }, services));
      connection.onDocumentOnTypeFormatting(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.Formatter) === null || _a === void 0 ? void 0 : _a.formatDocumentOnType(document, params, cancelToken);
      }, services));
    }
    exports2.addFormattingHandler = addFormattingHandler;
    function addRenameHandler(connection, services) {
      connection.onRenameRequest(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.RenameProvider) === null || _a === void 0 ? void 0 : _a.rename(document, params, cancelToken);
      }, services));
      connection.onPrepareRename(createRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.RenameProvider) === null || _a === void 0 ? void 0 : _a.prepareRename(document, params, cancelToken);
      }, services));
    }
    exports2.addRenameHandler = addRenameHandler;
    function addInlayHintHandler(connection, services) {
      var _a;
      const inlayHintProvider = services.lsp.InlayHintProvider;
      if (inlayHintProvider) {
        connection.languages.inlayHint.on(createServerRequestHandler((_, document, params, cancelToken) => inlayHintProvider.getInlayHints(document, params, cancelToken), services));
        const resolveInlayHint = (_a = inlayHintProvider.resolveInlayHint) === null || _a === void 0 ? void 0 : _a.bind(inlayHintProvider);
        if (resolveInlayHint) {
          connection.languages.inlayHint.resolve(async (inlayHint, token) => {
            try {
              return await resolveInlayHint(inlayHint, token);
            } catch (err) {
              return responseError(err);
            }
          });
        }
      }
    }
    exports2.addInlayHintHandler = addInlayHintHandler;
    function addSemanticTokenHandler(connection, services) {
      const emptyResult = { data: [] };
      connection.languages.semanticTokens.on(createServerRequestHandler((services2, document, params, cancelToken) => {
        if (services2.lsp.SemanticTokenProvider) {
          return services2.lsp.SemanticTokenProvider.semanticHighlight(document, params, cancelToken);
        }
        return emptyResult;
      }, services));
      connection.languages.semanticTokens.onDelta(createServerRequestHandler((services2, document, params, cancelToken) => {
        if (services2.lsp.SemanticTokenProvider) {
          return services2.lsp.SemanticTokenProvider.semanticHighlightDelta(document, params, cancelToken);
        }
        return emptyResult;
      }, services));
      connection.languages.semanticTokens.onRange(createServerRequestHandler((services2, document, params, cancelToken) => {
        if (services2.lsp.SemanticTokenProvider) {
          return services2.lsp.SemanticTokenProvider.semanticHighlightRange(document, params, cancelToken);
        }
        return emptyResult;
      }, services));
    }
    exports2.addSemanticTokenHandler = addSemanticTokenHandler;
    function addConfigurationChangeHandler(connection, services) {
      connection.onDidChangeConfiguration((change) => {
        if (change.settings) {
          services.workspace.ConfigurationProvider.updateConfiguration(change);
        }
      });
    }
    exports2.addConfigurationChangeHandler = addConfigurationChangeHandler;
    function addExecuteCommandHandler(connection, services) {
      const commandHandler = services.lsp.ExecuteCommandHandler;
      if (commandHandler) {
        connection.onExecuteCommand(async (params, token) => {
          var _a;
          try {
            return await commandHandler.executeCommand(params.command, (_a = params.arguments) !== null && _a !== void 0 ? _a : [], token);
          } catch (err) {
            return responseError(err);
          }
        });
      }
    }
    exports2.addExecuteCommandHandler = addExecuteCommandHandler;
    function addDocumentLinkHandler(connection, services) {
      var _a;
      const documentLinkProvider = services.lsp.DocumentLinkProvider;
      if (documentLinkProvider) {
        connection.onDocumentLinks(createServerRequestHandler((_, document, params, cancelToken) => documentLinkProvider.getDocumentLinks(document, params, cancelToken), services));
        const resolveDocumentLink = (_a = documentLinkProvider.resolveDocumentLink) === null || _a === void 0 ? void 0 : _a.bind(documentLinkProvider);
        if (resolveDocumentLink) {
          connection.onDocumentLinkResolve(async (documentLink, token) => {
            try {
              return await resolveDocumentLink(documentLink, token);
            } catch (err) {
              return responseError(err);
            }
          });
        }
      }
    }
    exports2.addDocumentLinkHandler = addDocumentLinkHandler;
    function addSignatureHelpHandler(connection, services) {
      connection.onSignatureHelp(createServerRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        return (_a = services2.lsp.SignatureHelp) === null || _a === void 0 ? void 0 : _a.provideSignatureHelp(document, params, cancelToken);
      }, services));
    }
    exports2.addSignatureHelpHandler = addSignatureHelpHandler;
    function addCodeLensHandler(connection, services) {
      var _a;
      const codeLensProvider = services.lsp.CodeLensProvider;
      if (codeLensProvider) {
        connection.onCodeLens(createServerRequestHandler((_, document, params, cancelToken) => codeLensProvider.provideCodeLens(document, params, cancelToken), services));
        const resolveCodeLens = (_a = codeLensProvider.resolveCodeLens) === null || _a === void 0 ? void 0 : _a.bind(codeLensProvider);
        if (resolveCodeLens) {
          connection.onCodeLensResolve(async (codeLens, token) => {
            try {
              return await resolveCodeLens(codeLens, token);
            } catch (err) {
              return responseError(err);
            }
          });
        }
      }
    }
    exports2.addCodeLensHandler = addCodeLensHandler;
    function addCallHierarchyHandler(connection, services) {
      connection.languages.callHierarchy.onPrepare(createServerRequestHandler((services2, document, params, cancelToken) => {
        var _a;
        if (services2.lsp.CallHierarchyProvider) {
          return (_a = services2.lsp.CallHierarchyProvider.prepareCallHierarchy(document, params, cancelToken)) !== null && _a !== void 0 ? _a : null;
        }
        return null;
      }, services));
      connection.languages.callHierarchy.onIncomingCalls(createCallHierarchyRequestHandler((services2, params, cancelToken) => {
        var _a;
        if (services2.lsp.CallHierarchyProvider) {
          return (_a = services2.lsp.CallHierarchyProvider.incomingCalls(params, cancelToken)) !== null && _a !== void 0 ? _a : null;
        }
        return null;
      }, services));
      connection.languages.callHierarchy.onOutgoingCalls(createCallHierarchyRequestHandler((services2, params, cancelToken) => {
        var _a;
        if (services2.lsp.CallHierarchyProvider) {
          return (_a = services2.lsp.CallHierarchyProvider.outgoingCalls(params, cancelToken)) !== null && _a !== void 0 ? _a : null;
        }
        return null;
      }, services));
    }
    exports2.addCallHierarchyHandler = addCallHierarchyHandler;
    function createCallHierarchyRequestHandler(serviceCall, sharedServices) {
      const serviceRegistry = sharedServices.ServiceRegistry;
      return async (params, cancelToken) => {
        const uri = vscode_uri_1.URI.parse(params.item.uri);
        const language = serviceRegistry.getServices(uri);
        if (!language) {
          const message = `Could not find service instance for uri: '${uri.toString()}'`;
          console.error(message);
          throw new Error(message);
        }
        try {
          return await serviceCall(language, params, cancelToken);
        } catch (err) {
          return responseError(err);
        }
      };
    }
    exports2.createCallHierarchyRequestHandler = createCallHierarchyRequestHandler;
    function createServerRequestHandler(serviceCall, sharedServices) {
      const documents = sharedServices.workspace.LangiumDocuments;
      const serviceRegistry = sharedServices.ServiceRegistry;
      return async (params, cancelToken) => {
        const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
        const language = serviceRegistry.getServices(uri);
        if (!language) {
          console.error(`Could not find service instance for uri: '${uri.toString()}'`);
          throw new Error();
        }
        const document = documents.getOrCreateDocument(uri);
        if (!document) {
          throw new Error();
        }
        try {
          return await serviceCall(language, document, params, cancelToken);
        } catch (err) {
          return responseError(err);
        }
      };
    }
    exports2.createServerRequestHandler = createServerRequestHandler;
    function createRequestHandler(serviceCall, sharedServices) {
      const documents = sharedServices.workspace.LangiumDocuments;
      const serviceRegistry = sharedServices.ServiceRegistry;
      return async (params, cancelToken) => {
        const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
        const language = serviceRegistry.getServices(uri);
        if (!language) {
          console.error(`Could not find service instance for uri: '${uri.toString()}'`);
          return null;
        }
        const document = documents.getOrCreateDocument(uri);
        if (!document) {
          return null;
        }
        try {
          return await serviceCall(language, document, params, cancelToken);
        } catch (err) {
          return responseError(err);
        }
      };
    }
    exports2.createRequestHandler = createRequestHandler;
    function responseError(err) {
      if ((0, promise_util_1.isOperationCancelled)(err)) {
        return new vscode_languageserver_1.ResponseError(vscode_languageserver_1.LSPErrorCodes.RequestCancelled, "The request has been cancelled.");
      }
      if (err instanceof vscode_languageserver_1.ResponseError) {
        return err;
      }
      throw err;
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/references-provider.js
var require_references_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/references-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultReferencesProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var cst_util_1 = require_cst_util();
    var DefaultReferencesProvider = class {
      constructor(services) {
        this.nameProvider = services.references.NameProvider;
        this.references = services.references.References;
        this.grammarConfig = services.parser.GrammarConfig;
      }
      findReferences(document, params) {
        const rootNode = document.parseResult.value.$cstNode;
        if (!rootNode) {
          return [];
        }
        const selectedNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode, document.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
        if (!selectedNode) {
          return [];
        }
        return this.getReferences(selectedNode, params, document);
      }
      getReferences(selectedNode, params, _document) {
        const locations = [];
        const targetAstNode = this.references.findDeclaration(selectedNode);
        if (targetAstNode) {
          const options = { includeDeclaration: params.context.includeDeclaration };
          this.references.findReferences(targetAstNode, options).forEach((reference) => {
            locations.push(vscode_languageserver_1.Location.create(reference.sourceUri.toString(), reference.segment.range));
          });
        }
        return locations;
      }
    };
    exports2.DefaultReferencesProvider = DefaultReferencesProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/rename-provider.js
var require_rename_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/rename-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultRenameProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var name_provider_1 = require_name_provider();
    var cst_util_1 = require_cst_util();
    var DefaultRenameProvider = class {
      constructor(services) {
        this.references = services.references.References;
        this.nameProvider = services.references.NameProvider;
        this.grammarConfig = services.parser.GrammarConfig;
      }
      async rename(document, params) {
        const changes = {};
        const rootNode = document.parseResult.value.$cstNode;
        if (!rootNode)
          return void 0;
        const offset = document.textDocument.offsetAt(params.position);
        const leafNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode, offset, this.grammarConfig.nameRegexp);
        if (!leafNode)
          return void 0;
        const targetNode = this.references.findDeclaration(leafNode);
        if (!targetNode)
          return void 0;
        const options = { onlyLocal: false, includeDeclaration: true };
        const references = this.references.findReferences(targetNode, options);
        references.forEach((ref) => {
          const change = vscode_languageserver_1.TextEdit.replace(ref.segment.range, params.newName);
          const uri = ref.sourceUri.toString();
          if (changes[uri]) {
            changes[uri].push(change);
          } else {
            changes[uri] = [change];
          }
        });
        return { changes };
      }
      prepareRename(document, params) {
        return this.renameNodeRange(document, params.position);
      }
      renameNodeRange(doc, position) {
        const rootNode = doc.parseResult.value.$cstNode;
        const offset = doc.textDocument.offsetAt(position);
        if (rootNode && offset) {
          const leafNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode, offset, this.grammarConfig.nameRegexp);
          if (!leafNode) {
            return void 0;
          }
          const isCrossRef = this.references.findDeclaration(leafNode);
          if (isCrossRef || this.isNameNode(leafNode)) {
            return leafNode.range;
          }
        }
        return void 0;
      }
      isNameNode(leafNode) {
        return (leafNode === null || leafNode === void 0 ? void 0 : leafNode.element) && (0, name_provider_1.isNamed)(leafNode.element) && leafNode === this.nameProvider.getNameNode(leafNode.element);
      }
    };
    exports2.DefaultRenameProvider = DefaultRenameProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/type-provider.js
var require_type_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/type-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractTypeDefinitionProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var cst_util_1 = require_cst_util();
    var AbstractTypeDefinitionProvider = class {
      constructor(services) {
        this.references = services.references.References;
      }
      getTypeDefinition(document, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const rootNode = document.parseResult.value;
        if (rootNode.$cstNode) {
          const sourceCstNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode.$cstNode, document.textDocument.offsetAt(params.position));
          if (sourceCstNode) {
            const nodeDeclaration = this.references.findDeclaration(sourceCstNode);
            if (nodeDeclaration) {
              return this.collectGoToTypeLocationLinks(nodeDeclaration, cancelToken);
            }
          }
        }
        return void 0;
      }
    };
    exports2.AbstractTypeDefinitionProvider = AbstractTypeDefinitionProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/index.js
var require_lsp = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/lsp/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_completion_provider(), exports2);
    __exportStar(require_follow_element_computation(), exports2);
    __exportStar(require_call_hierarchy_provider(), exports2);
    __exportStar(require_code_action(), exports2);
    __exportStar(require_code_lens_provider(), exports2);
    __exportStar(require_declaration_provider(), exports2);
    __exportStar(require_definition_provider(), exports2);
    __exportStar(require_document_highlight_provider(), exports2);
    __exportStar(require_document_link_provider(), exports2);
    __exportStar(require_document_symbol_provider(), exports2);
    __exportStar(require_execute_command_handler(), exports2);
    __exportStar(require_folding_range_provider(), exports2);
    __exportStar(require_formatter(), exports2);
    __exportStar(require_hover_provider(), exports2);
    __exportStar(require_implementation_provider(), exports2);
    __exportStar(require_inlay_hint_provider(), exports2);
    __exportStar(require_language_server(), exports2);
    __exportStar(require_references_provider(), exports2);
    __exportStar(require_rename_provider(), exports2);
    __exportStar(require_semantic_token_provider(), exports2);
    __exportStar(require_signature_help_provider(), exports2);
    __exportStar(require_type_provider(), exports2);
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/lsp/grammar-definition.js
var require_grammar_definition = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/lsp/grammar-definition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarDefinitionProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var lsp_1 = require_lsp();
    var ast_util_1 = require_ast_util();
    var grammar_util_1 = require_grammar_util();
    var ast_1 = require_ast();
    var internal_grammar_util_1 = require_internal_grammar_util();
    var LangiumGrammarDefinitionProvider = class extends lsp_1.DefaultDefinitionProvider {
      constructor(services) {
        super(services);
        this.documents = services.shared.workspace.LangiumDocuments;
      }
      collectLocationLinks(sourceCstNode, _params) {
        var _a, _b, _c, _d, _e, _f;
        const pathFeature = "path";
        if ((0, ast_1.isGrammarImport)(sourceCstNode.element) && ((_a = (0, grammar_util_1.findAssignment)(sourceCstNode)) === null || _a === void 0 ? void 0 : _a.feature) === pathFeature) {
          const importedGrammar = (0, internal_grammar_util_1.resolveImport)(this.documents, sourceCstNode.element);
          if (importedGrammar === null || importedGrammar === void 0 ? void 0 : importedGrammar.$document) {
            const targetObject = (_b = this.findTargetObject(importedGrammar)) !== null && _b !== void 0 ? _b : importedGrammar;
            const selectionRange = (_d = (_c = this.nameProvider.getNameNode(targetObject)) === null || _c === void 0 ? void 0 : _c.range) !== null && _d !== void 0 ? _d : vscode_languageserver_1.Range.create(0, 0, 0, 0);
            const previewRange = (_f = (_e = targetObject.$cstNode) === null || _e === void 0 ? void 0 : _e.range) !== null && _f !== void 0 ? _f : vscode_languageserver_1.Range.create(0, 0, 0, 0);
            return [
              vscode_languageserver_1.LocationLink.create(importedGrammar.$document.uri.toString(), previewRange, selectionRange, sourceCstNode.range)
            ];
          }
          return void 0;
        }
        return super.collectLocationLinks(sourceCstNode, _params);
      }
      findTargetObject(importedGrammar) {
        if (importedGrammar.isDeclared) {
          return importedGrammar;
        }
        return (0, ast_util_1.streamContents)(importedGrammar).head();
      }
    };
    exports2.LangiumGrammarDefinitionProvider = LangiumGrammarDefinitionProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/lsp/grammar-call-hierarchy.js
var require_grammar_call_hierarchy = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/lsp/grammar-call-hierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarCallHierarchyProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var call_hierarchy_provider_1 = require_call_hierarchy_provider();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var ast_1 = require_ast();
    var LangiumGrammarCallHierarchyProvider = class extends call_hierarchy_provider_1.AbstractCallHierarchyProvider {
      getIncomingCalls(node, references) {
        if (!(0, ast_1.isParserRule)(node)) {
          return void 0;
        }
        const uniqueRules = /* @__PURE__ */ new Map();
        references.forEach((ref) => {
          const doc = this.documents.getOrCreateDocument(ref.sourceUri);
          const rootNode = doc.parseResult.value;
          if (!rootNode.$cstNode) {
            return;
          }
          const targetNode = (0, cst_util_1.findLeafNodeAtOffset)(rootNode.$cstNode, ref.segment.offset);
          if (!targetNode) {
            return;
          }
          const parserRule = (0, ast_util_1.getContainerOfType)(targetNode.element, ast_1.isParserRule);
          if (!parserRule || !parserRule.$cstNode) {
            return;
          }
          const nameNode = this.nameProvider.getNameNode(parserRule);
          if (!nameNode) {
            return;
          }
          const refDocUri = ref.sourceUri.toString();
          const ruleId = refDocUri + "@" + nameNode.text;
          uniqueRules.has(ruleId) ? uniqueRules.set(ruleId, { parserRule: parserRule.$cstNode, nameNode, targetNodes: [...uniqueRules.get(ruleId).targetNodes, targetNode], docUri: refDocUri }) : uniqueRules.set(ruleId, { parserRule: parserRule.$cstNode, nameNode, targetNodes: [targetNode], docUri: refDocUri });
        });
        if (uniqueRules.size === 0) {
          return void 0;
        }
        return Array.from(uniqueRules.values()).map((rule) => ({
          from: {
            kind: vscode_languageserver_1.SymbolKind.Method,
            name: rule.nameNode.text,
            range: rule.parserRule.range,
            selectionRange: rule.nameNode.range,
            uri: rule.docUri
          },
          fromRanges: rule.targetNodes.map((node2) => node2.range)
        }));
      }
      getOutgoingCalls(node) {
        if (!(0, ast_1.isParserRule)(node)) {
          return void 0;
        }
        const ruleCalls = (0, ast_util_1.streamAllContents)(node).filter(ast_1.isRuleCall).toArray();
        const uniqueRules = /* @__PURE__ */ new Map();
        ruleCalls.forEach((ruleCall) => {
          var _a;
          const cstNode = ruleCall.$cstNode;
          if (!cstNode) {
            return;
          }
          const refCstNode = (_a = ruleCall.rule.ref) === null || _a === void 0 ? void 0 : _a.$cstNode;
          if (!refCstNode) {
            return;
          }
          const refNameNode = this.nameProvider.getNameNode(refCstNode.element);
          if (!refNameNode) {
            return;
          }
          const refDocUri = (0, ast_util_1.getDocument)(refCstNode.element).uri.toString();
          const ruleId = refDocUri + "@" + refNameNode.text;
          uniqueRules.has(ruleId) ? uniqueRules.set(ruleId, { refCstNode, to: refNameNode, from: [...uniqueRules.get(ruleId).from, cstNode.range], docUri: refDocUri }) : uniqueRules.set(ruleId, { refCstNode, to: refNameNode, from: [cstNode.range], docUri: refDocUri });
        });
        if (uniqueRules.size === 0) {
          return void 0;
        }
        return Array.from(uniqueRules.values()).map((rule) => ({
          to: {
            kind: vscode_languageserver_1.SymbolKind.Method,
            name: rule.to.text,
            range: rule.refCstNode.range,
            selectionRange: rule.to.range,
            uri: rule.docUri
          },
          fromRanges: rule.from
        }));
      }
    };
    exports2.LangiumGrammarCallHierarchyProvider = LangiumGrammarCallHierarchyProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/validation/validation-resources-collector.js
var require_validation_resources_collector = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/validation/validation-resources-collector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarValidationResourcesCollector = void 0;
    var collections_1 = require_collections();
    var stream_1 = require_stream();
    var ast_1 = require_ast();
    var internal_grammar_util_1 = require_internal_grammar_util();
    var types_util_1 = require_types_util();
    var ast_collector_1 = require_ast_collector();
    var LangiumGrammarValidationResourcesCollector = class {
      constructor(services) {
        this.documents = services.shared.workspace.LangiumDocuments;
      }
      collectValidationResources(grammar) {
        const typeResources = (0, ast_collector_1.collectValidationAst)(grammar, this.documents);
        return {
          typeToValidationInfo: this.collectValidationInfo(typeResources),
          typeToSuperProperties: this.collectSuperProperties(typeResources)
        };
      }
      collectValidationInfo({ astResources, inferred, declared }) {
        const res = /* @__PURE__ */ new Map();
        const typeNameToRulesActions = collectNameToRulesActions(astResources);
        for (const type of (0, types_util_1.mergeTypesAndInterfaces)(inferred)) {
          res.set(type.name, { inferred: type, inferredNodes: typeNameToRulesActions.get(type.name) });
        }
        const typeNametoInterfacesUnions = (0, stream_1.stream)(astResources.interfaces).concat(astResources.types).reduce((acc, type) => acc.set(type.name, type), /* @__PURE__ */ new Map());
        for (const type of (0, types_util_1.mergeTypesAndInterfaces)(declared)) {
          const node = typeNametoInterfacesUnions.get(type.name);
          if (node) {
            const inferred2 = res.get(type.name);
            res.set(type.name, Object.assign(Object.assign({}, inferred2 !== null && inferred2 !== void 0 ? inferred2 : {}), { declared: type, declaredNode: node }));
          }
        }
        return res;
      }
      collectSuperProperties({ inferred, declared }) {
        const typeToSuperProperties = /* @__PURE__ */ new Map();
        const interfaces = (0, types_util_1.mergeInterfaces)(inferred, declared);
        const interfaceMap = new Map(interfaces.map((e) => [e.name, e]));
        for (const type of (0, types_util_1.mergeInterfaces)(inferred, declared)) {
          typeToSuperProperties.set(type.name, this.addSuperProperties(type, interfaceMap, /* @__PURE__ */ new Set()));
        }
        return typeToSuperProperties;
      }
      addSuperProperties(interfaceType, map, visited) {
        if (visited.has(interfaceType.name)) {
          return [];
        }
        visited.add(interfaceType.name);
        const properties = [...interfaceType.properties];
        for (const superType of interfaceType.superTypes) {
          const value = map.get(superType.name);
          if (value) {
            properties.push(...this.addSuperProperties(value, map, visited));
          }
        }
        return properties;
      }
    };
    exports2.LangiumGrammarValidationResourcesCollector = LangiumGrammarValidationResourcesCollector;
    function collectNameToRulesActions({ parserRules, datatypeRules }) {
      const acc = new collections_1.MultiMap();
      (0, stream_1.stream)(parserRules).concat(datatypeRules).forEach((rule) => acc.add((0, internal_grammar_util_1.getRuleType)(rule), rule));
      function collectActions(element) {
        if ((0, ast_1.isAction)(element)) {
          const name = (0, internal_grammar_util_1.getActionType)(element);
          if (name) {
            acc.add(name, element);
          }
        }
        if ((0, ast_1.isAlternatives)(element) || (0, ast_1.isGroup)(element) || (0, ast_1.isUnorderedGroup)(element)) {
          element.elements.forEach((e) => collectActions(e));
        }
      }
      parserRules.forEach((rule) => collectActions(rule.definition));
      return acc;
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/workspace/documents.js
var require_documents2 = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/workspace/documents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isInferredAndDeclared = exports2.isInferred = exports2.isDeclared = void 0;
    function isDeclared(type) {
      return type && "declared" in type;
    }
    exports2.isDeclared = isDeclared;
    function isInferred(type) {
      return type && "inferred" in type;
    }
    exports2.isInferred = isInferred;
    function isInferredAndDeclared(type) {
      return type && "inferred" in type && "declared" in type;
    }
    exports2.isInferredAndDeclared = isInferredAndDeclared;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/validation/types-validator.js
var require_types_validator = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/validation/types-validator.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumGrammarTypesValidator = exports2.registerTypeValidationChecks = void 0;
    var ast2 = __importStar(require_ast());
    var collections_1 = require_collections();
    var internal_grammar_util_1 = require_internal_grammar_util();
    var types_1 = require_types();
    var documents_1 = require_documents2();
    function registerTypeValidationChecks(services) {
      const registry = services.validation.ValidationRegistry;
      const typesValidator = services.validation.LangiumGrammarTypesValidator;
      const checks = {
        Action: [
          typesValidator.checkActionIsNotUnionType
        ],
        Grammar: [
          typesValidator.checkDeclaredTypesConsistency,
          typesValidator.checkDeclaredAndInferredTypesConsistency
        ]
      };
      registry.register(checks, typesValidator);
    }
    exports2.registerTypeValidationChecks = registerTypeValidationChecks;
    var LangiumGrammarTypesValidator = class {
      checkDeclaredTypesConsistency(grammar, accept) {
        var _a;
        const validationResources = (_a = grammar.$document) === null || _a === void 0 ? void 0 : _a.validationResources;
        if (validationResources) {
          for (const typeInfo of validationResources.typeToValidationInfo.values()) {
            if ((0, documents_1.isDeclared)(typeInfo) && (0, types_1.isInterfaceType)(typeInfo.declared) && ast2.isInterface(typeInfo.declaredNode)) {
              const declInterface = typeInfo;
              validateInterfaceSuperTypes(declInterface, accept);
              validateSuperTypesConsistency(declInterface, accept);
            }
          }
        }
      }
      checkDeclaredAndInferredTypesConsistency(grammar, accept) {
        var _a;
        const validationResources = (_a = grammar.$document) === null || _a === void 0 ? void 0 : _a.validationResources;
        if (validationResources) {
          for (const typeInfo of validationResources.typeToValidationInfo.values()) {
            if ((0, documents_1.isInferred)(typeInfo) && typeInfo.inferred instanceof types_1.InterfaceType) {
              validateInferredInterface(typeInfo.inferred, accept);
            }
            if ((0, documents_1.isInferredAndDeclared)(typeInfo)) {
              validateDeclaredAndInferredConsistency(typeInfo, validationResources, accept);
            }
          }
        }
      }
      checkActionIsNotUnionType(action, accept) {
        if (ast2.isType(action.type)) {
          accept("error", "Actions cannot create union types.", { node: action, property: "type" });
        }
      }
    };
    exports2.LangiumGrammarTypesValidator = LangiumGrammarTypesValidator;
    function validateInferredInterface(inferredInterface, accept) {
      inferredInterface.properties.forEach((prop) => {
        var _a;
        const flattened = (0, types_1.flattenPropertyUnion)(prop.type);
        if (flattened.length > 1) {
          const typeKind = (type) => (0, types_1.isReferenceType)(type) ? "ref" : "other";
          const firstKind = typeKind(flattened[0]);
          if (flattened.slice(1).some((type) => typeKind(type) !== firstKind)) {
            const targetNode = (_a = prop.astNodes.values().next()) === null || _a === void 0 ? void 0 : _a.value;
            if (targetNode) {
              accept("error", `Mixing a cross-reference with other types is not supported. Consider splitting property "${prop.name}" into two or more different properties.`, { node: targetNode });
            }
          }
        }
      });
    }
    function validateInterfaceSuperTypes({ declared, declaredNode }, accept) {
      Array.from(declared.superTypes).forEach((superType, i) => {
        if (superType) {
          if ((0, types_1.isUnionType)(superType)) {
            accept("error", "Interfaces cannot extend union types.", { node: declaredNode, property: "superTypes", index: i });
          }
          if (!superType.declared) {
            accept("error", "Extending an inferred type is discouraged.", { node: declaredNode, property: "superTypes", index: i });
          }
        }
      });
    }
    function validateSuperTypesConsistency({ declared, declaredNode }, accept) {
      const nameToProp = declared.properties.reduce((acc, e) => acc.add(e.name, e), new collections_1.MultiMap());
      for (const [name, props] of nameToProp.entriesGroupedByKey()) {
        if (props.length > 1) {
          for (const prop of props) {
            accept("error", `Cannot have two properties with the same name '${name}'.`, {
              node: Array.from(prop.astNodes)[0],
              property: "name"
            });
          }
        }
      }
      const allSuperTypes = Array.from(declared.superTypes);
      for (let i = 0; i < allSuperTypes.length; i++) {
        for (let j = i + 1; j < allSuperTypes.length; j++) {
          const outerType = allSuperTypes[i];
          const innerType = allSuperTypes[j];
          const outerProps = (0, types_1.isInterfaceType)(outerType) ? outerType.superProperties : [];
          const innerProps = (0, types_1.isInterfaceType)(innerType) ? innerType.superProperties : [];
          const nonIdentical = getNonIdenticalProps(outerProps, innerProps);
          if (nonIdentical.length > 0) {
            accept("error", `Cannot simultaneously inherit from '${outerType}' and '${innerType}'. Their ${nonIdentical.map((e) => "'" + e + "'").join(", ")} properties are not identical.`, {
              node: declaredNode,
              property: "name"
            });
          }
        }
      }
      const allSuperProps = /* @__PURE__ */ new Set();
      for (const superType of allSuperTypes) {
        const props = (0, types_1.isInterfaceType)(superType) ? superType.superProperties : [];
        for (const prop of props) {
          allSuperProps.add(prop.name);
        }
      }
      for (const ownProp of declared.properties) {
        if (allSuperProps.has(ownProp.name)) {
          const propNode = declaredNode.attributes.find((e) => e.name === ownProp.name);
          if (propNode) {
            accept("error", `Cannot redeclare property '${ownProp.name}'. It is already inherited from another interface.`, {
              node: propNode,
              property: "name"
            });
          }
        }
      }
    }
    function getNonIdenticalProps(a, b) {
      const nonIdentical = [];
      for (const outerProp of a) {
        const innerProp = b.find((e) => e.name === outerProp.name);
        if (innerProp && !arePropTypesIdentical(outerProp, innerProp)) {
          nonIdentical.push(outerProp.name);
        }
      }
      return nonIdentical;
    }
    function arePropTypesIdentical(a, b) {
      return (0, types_1.isTypeAssignable)(a.type, b.type) && (0, types_1.isTypeAssignable)(b.type, a.type);
    }
    function validateDeclaredAndInferredConsistency(typeInfo, resources, accept) {
      const { inferred, declared, declaredNode, inferredNodes } = typeInfo;
      const typeName = declared.name;
      const applyErrorToRulesAndActions = (msgPostfix) => (errorMsg) => inferredNodes.forEach((node) => accept("error", `${errorMsg}${msgPostfix ? ` ${msgPostfix}` : ""}.`, (node === null || node === void 0 ? void 0 : node.inferredType) ? { node: node === null || node === void 0 ? void 0 : node.inferredType, property: "name" } : { node, property: ast2.isAction(node) ? "type" : "name" }));
      const applyErrorToProperties = (nodes, errorMessage) => nodes.forEach((node) => accept("error", errorMessage, { node, property: ast2.isAssignment(node) || ast2.isAction(node) ? "feature" : "name" }));
      const applyMissingPropErrorToRules = (missingProp) => {
        inferredNodes.forEach((node) => {
          if (ast2.isParserRule(node)) {
            const assignments = (0, internal_grammar_util_1.extractAssignments)(node.definition);
            if (assignments.find((e) => e.feature === missingProp) === void 0) {
              accept("error", `Property '${missingProp}' is missing in a rule '${node.name}', but is required in type '${typeName}'.`, {
                node,
                property: "parameters"
              });
            }
          }
        });
      };
      if ((0, types_1.isUnionType)(inferred) && (0, types_1.isUnionType)(declared)) {
        validateAlternativesConsistency(inferred.type, declared.type, applyErrorToRulesAndActions(`in a rule that returns type '${typeName}'`));
      } else if ((0, types_1.isInterfaceType)(inferred) && (0, types_1.isInterfaceType)(declared)) {
        validatePropertiesConsistency(inferred, declared, resources, applyErrorToRulesAndActions(`in a rule that returns type '${typeName}'`), applyErrorToProperties, applyMissingPropErrorToRules);
      } else {
        const errorMessage = `Inferred and declared versions of type '${typeName}' both have to be interfaces or unions.`;
        applyErrorToRulesAndActions()(errorMessage);
        accept("error", errorMessage, { node: declaredNode, property: "name" });
      }
    }
    function validateAlternativesConsistency(inferred, declared, applyErrorToInferredTypes) {
      if (!(0, types_1.isTypeAssignable)(inferred, declared)) {
        applyErrorToInferredTypes(`Cannot assign type '${(0, types_1.propertyTypeToString)(inferred, "DeclaredType")}' to '${(0, types_1.propertyTypeToString)(declared, "DeclaredType")}'`);
      }
    }
    function isOptionalProperty(prop) {
      return prop.optional || (0, types_1.isMandatoryPropertyType)(prop.type);
    }
    function validatePropertiesConsistency(inferred, declared, resources, applyErrorToType, applyErrorToProperties, applyMissingPropErrorToRules) {
      const ownInferredProps = new Set(inferred.properties.map((e) => e.name));
      const allInferredProps = new Map(inferred.allProperties.map((e) => [e.name, e]));
      const declaredProps = new Map(declared.superProperties.map((e) => [e.name, e]));
      const matchingProp = (type) => {
        if ((0, types_1.isPropertyUnion)(type))
          return { types: type.types.map((t) => matchingProp(t)) };
        if ((0, types_1.isReferenceType)(type))
          return { referenceType: matchingProp(type.referenceType) };
        if ((0, types_1.isArrayType)(type))
          return { elementType: matchingProp(type.elementType) };
        if ((0, types_1.isValueType)(type)) {
          const resource = resources.typeToValidationInfo.get(type.value.name);
          if (!resource)
            return type;
          return { value: "declared" in resource ? resource.declared : resource.inferred };
        }
        return type;
      };
      for (const [name, foundProp] of allInferredProps.entries()) {
        const expectedProp = declaredProps.get(name);
        if (expectedProp) {
          const foundTypeAsStr = (0, types_1.propertyTypeToString)(foundProp.type, "DeclaredType");
          const expectedTypeAsStr = (0, types_1.propertyTypeToString)(expectedProp.type, "DeclaredType");
          const typeAlternativesErrors = (0, types_1.isTypeAssignable)(matchingProp(foundProp.type), expectedProp.type);
          if (!typeAlternativesErrors) {
            const errorMsgPrefix = `The assigned type '${foundTypeAsStr}' is not compatible with the declared property '${name}' of type '${expectedTypeAsStr}'.`;
            applyErrorToProperties(foundProp.astNodes, errorMsgPrefix);
          }
          if (foundProp.optional && !isOptionalProperty(expectedProp)) {
            applyMissingPropErrorToRules(name);
          }
        } else if (ownInferredProps.has(name)) {
          applyErrorToProperties(foundProp.astNodes, `A property '${name}' is not expected.`);
        }
      }
      const missingProps = /* @__PURE__ */ new Set();
      for (const [name, expectedProperties] of declaredProps.entries()) {
        const foundProperty = allInferredProps.get(name);
        if (!foundProperty && !isOptionalProperty(expectedProperties)) {
          missingProps.add(name);
        }
      }
      if (missingProps.size > 0) {
        const prefix = missingProps.size > 1 ? "Properties" : "A property";
        const postfix = missingProps.size > 1 ? "are expected" : "is expected";
        const props = Array.from(missingProps).map((e) => `'${e}'`).sort().join(", ");
        applyErrorToType(`${prefix} ${props} ${postfix}.`);
      }
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/langium-grammar-module.js
var require_langium_grammar_module = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/langium-grammar-module.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createLangiumGrammarServices = exports2.LangiumGrammarModule = void 0;
    var default_module_1 = require_default_module();
    var dependency_injection_1 = require_dependency_injection();
    var module_1 = require_module();
    var grammar_scope_1 = require_grammar_scope();
    var validator_1 = require_validator();
    var grammar_code_actions_1 = require_grammar_code_actions();
    var grammar_folding_ranges_1 = require_grammar_folding_ranges();
    var grammar_formatter_1 = require_grammar_formatter();
    var grammar_semantic_tokens_1 = require_grammar_semantic_tokens();
    var grammar_naming_1 = require_grammar_naming();
    var grammar_references_1 = require_grammar_references();
    var grammar_definition_1 = require_grammar_definition();
    var grammar_call_hierarchy_1 = require_grammar_call_hierarchy();
    var validation_resources_collector_1 = require_validation_resources_collector();
    var types_validator_1 = require_types_validator();
    var promise_util_1 = require_promise_util();
    var documents_1 = require_documents();
    exports2.LangiumGrammarModule = {
      validation: {
        LangiumGrammarValidator: (services) => new validator_1.LangiumGrammarValidator(services),
        ValidationResourcesCollector: (services) => new validation_resources_collector_1.LangiumGrammarValidationResourcesCollector(services),
        LangiumGrammarTypesValidator: () => new types_validator_1.LangiumGrammarTypesValidator()
      },
      lsp: {
        FoldingRangeProvider: (services) => new grammar_folding_ranges_1.LangiumGrammarFoldingRangeProvider(services),
        CodeActionProvider: (services) => new grammar_code_actions_1.LangiumGrammarCodeActionProvider(services),
        SemanticTokenProvider: (services) => new grammar_semantic_tokens_1.LangiumGrammarSemanticTokenProvider(services),
        Formatter: () => new grammar_formatter_1.LangiumGrammarFormatter(),
        DefinitionProvider: (services) => new grammar_definition_1.LangiumGrammarDefinitionProvider(services),
        CallHierarchyProvider: (services) => new grammar_call_hierarchy_1.LangiumGrammarCallHierarchyProvider(services)
      },
      references: {
        ScopeComputation: (services) => new grammar_scope_1.LangiumGrammarScopeComputation(services),
        ScopeProvider: (services) => new grammar_scope_1.LangiumGrammarScopeProvider(services),
        References: (services) => new grammar_references_1.LangiumGrammarReferences(services),
        NameProvider: () => new grammar_naming_1.LangiumGrammarNameProvider()
      }
    };
    function createLangiumGrammarServices(context, sharedModule) {
      const shared = (0, dependency_injection_1.inject)((0, default_module_1.createDefaultSharedModule)(context), module_1.LangiumGrammarGeneratedSharedModule, sharedModule);
      const grammar = (0, dependency_injection_1.inject)((0, default_module_1.createDefaultModule)({ shared }), module_1.LangiumGrammarGeneratedModule, exports2.LangiumGrammarModule);
      addTypeCollectionPhase(shared, grammar);
      shared.ServiceRegistry.register(grammar);
      (0, validator_1.registerValidationChecks)(grammar);
      (0, types_validator_1.registerTypeValidationChecks)(grammar);
      return { shared, grammar };
    }
    exports2.createLangiumGrammarServices = createLangiumGrammarServices;
    function addTypeCollectionPhase(sharedServices, grammarServices) {
      const documentBuilder = sharedServices.workspace.DocumentBuilder;
      documentBuilder.onBuildPhase(documents_1.DocumentState.IndexedReferences, async (documents, cancelToken) => {
        for (const document of documents) {
          await (0, promise_util_1.interruptAndCheck)(cancelToken);
          const typeCollector = grammarServices.validation.ValidationResourcesCollector;
          const grammar = document.parseResult.value;
          document.validationResources = typeCollector.collectValidationResources(grammar);
        }
      });
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/file-system-provider.js
var require_file_system_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/file-system-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmptyFileSystem = exports2.EmptyFileSystemProvider = void 0;
    var EmptyFileSystemProvider = class {
      readFile() {
        throw new Error("Method not implemented.");
      }
      readFileSync() {
        throw new Error("Method not implemented.");
      }
      async readDirectory() {
        return [];
      }
    };
    exports2.EmptyFileSystemProvider = EmptyFileSystemProvider;
    exports2.EmptyFileSystem = {
      fileSystemProvider: () => new EmptyFileSystemProvider()
    };
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/grammar-util.js
var require_grammar_util = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/grammar-util.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createServicesForGrammar = exports2.loadGrammarFromJson = exports2.findNameAssignment = exports2.findAssignment = exports2.findNodesForKeywordInternal = exports2.findNodeForKeyword = exports2.findNodesForKeyword = exports2.findNodeForProperty = exports2.findNodesForProperty = exports2.isCommentTerminal = exports2.getCrossReferenceTerminal = exports2.getAllReachableRules = exports2.getHiddenRules = exports2.getEntryRule = void 0;
    var vscode_uri_1 = require_umd();
    var default_module_1 = require_default_module();
    var dependency_injection_1 = require_dependency_injection();
    var ast_reflection_interpreter_1 = require_ast_reflection_interpreter();
    var ast2 = __importStar(require_ast());
    var internal_grammar_util_1 = require_internal_grammar_util();
    var langium_grammar_module_1 = require_langium_grammar_module();
    var syntax_tree_1 = require_syntax_tree();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var file_system_provider_1 = require_file_system_provider();
    function getEntryRule(grammar) {
      return grammar.rules.find((e) => ast2.isParserRule(e) && e.entry);
    }
    exports2.getEntryRule = getEntryRule;
    function getHiddenRules(grammar) {
      return grammar.rules.filter((e) => ast2.isTerminalRule(e) && e.hidden);
    }
    exports2.getHiddenRules = getHiddenRules;
    function getAllReachableRules(grammar, allTerminals) {
      const ruleNames = /* @__PURE__ */ new Set();
      const entryRule = getEntryRule(grammar);
      if (!entryRule) {
        return new Set(grammar.rules);
      }
      const topMostRules = [entryRule].concat(getHiddenRules(grammar));
      for (const rule of topMostRules) {
        ruleDfs(rule, ruleNames, allTerminals);
      }
      const rules = /* @__PURE__ */ new Set();
      for (const rule of grammar.rules) {
        if (ruleNames.has(rule.name) || ast2.isTerminalRule(rule) && rule.hidden) {
          rules.add(rule);
        }
      }
      return rules;
    }
    exports2.getAllReachableRules = getAllReachableRules;
    function ruleDfs(rule, visitedSet, allTerminals) {
      visitedSet.add(rule.name);
      (0, ast_util_1.streamAllContents)(rule).forEach((node) => {
        if (ast2.isRuleCall(node) || allTerminals && ast2.isTerminalRuleCall(node)) {
          const refRule = node.rule.ref;
          if (refRule && !visitedSet.has(refRule.name)) {
            ruleDfs(refRule, visitedSet, allTerminals);
          }
        }
      });
    }
    function getCrossReferenceTerminal(crossRef) {
      if (crossRef.terminal) {
        return crossRef.terminal;
      } else if (crossRef.type.ref) {
        const nameAssigment = findNameAssignment(crossRef.type.ref);
        return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;
      }
      return void 0;
    }
    exports2.getCrossReferenceTerminal = getCrossReferenceTerminal;
    function isCommentTerminal(terminalRule) {
      return terminalRule.hidden && !" ".match((0, internal_grammar_util_1.terminalRegex)(terminalRule));
    }
    exports2.isCommentTerminal = isCommentTerminal;
    function findNodesForProperty(node, property) {
      if (!node || !property) {
        return [];
      }
      return findNodesForPropertyInternal(node, property, node.element, true);
    }
    exports2.findNodesForProperty = findNodesForProperty;
    function findNodeForProperty(node, property, index) {
      if (!node || !property) {
        return void 0;
      }
      const nodes = findNodesForPropertyInternal(node, property, node.element, true);
      if (nodes.length === 0) {
        return void 0;
      }
      if (index !== void 0) {
        index = Math.max(0, Math.min(index, nodes.length - 1));
      } else {
        index = 0;
      }
      return nodes[index];
    }
    exports2.findNodeForProperty = findNodeForProperty;
    function findNodesForPropertyInternal(node, property, element, first) {
      if (!first) {
        const nodeFeature = (0, ast_util_1.getContainerOfType)(node.feature, ast2.isAssignment);
        if (nodeFeature && nodeFeature.feature === property) {
          return [node];
        }
      }
      if ((0, syntax_tree_1.isCompositeCstNode)(node) && node.element === element) {
        return node.children.flatMap((e) => findNodesForPropertyInternal(e, property, element, false));
      }
      return [];
    }
    function findNodesForKeyword(node, keyword) {
      if (!node) {
        return [];
      }
      return findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.element);
    }
    exports2.findNodesForKeyword = findNodesForKeyword;
    function findNodeForKeyword(node, keyword, index) {
      if (!node) {
        return void 0;
      }
      const nodes = findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.element);
      if (nodes.length === 0) {
        return void 0;
      }
      if (index !== void 0) {
        index = Math.max(0, Math.min(index, nodes.length - 1));
      } else {
        index = 0;
      }
      return nodes[index];
    }
    exports2.findNodeForKeyword = findNodeForKeyword;
    function findNodesForKeywordInternal(node, keyword, element) {
      if (node.element !== element) {
        return [];
      }
      if (ast2.isKeyword(node.feature) && node.feature.value === keyword) {
        return [node];
      }
      const treeIterator = (0, cst_util_1.streamCst)(node).iterator();
      let result;
      const keywordNodes = [];
      do {
        result = treeIterator.next();
        if (!result.done) {
          const childNode = result.value;
          if (childNode.element === element) {
            if (ast2.isKeyword(childNode.feature) && childNode.feature.value === keyword) {
              keywordNodes.push(childNode);
            }
          } else {
            treeIterator.prune();
          }
        }
      } while (!result.done);
      return keywordNodes;
    }
    exports2.findNodesForKeywordInternal = findNodesForKeywordInternal;
    function findAssignment(cstNode) {
      var _a;
      const astNode = cstNode.element;
      while (astNode === ((_a = cstNode.parent) === null || _a === void 0 ? void 0 : _a.element)) {
        const assignment = (0, ast_util_1.getContainerOfType)(cstNode.feature, ast2.isAssignment);
        if (assignment) {
          return assignment;
        }
        cstNode = cstNode.parent;
      }
      return void 0;
    }
    exports2.findAssignment = findAssignment;
    function findNameAssignment(type) {
      if (ast2.isInferredType(type)) {
        type = type.$container;
      }
      return findNameAssignmentInternal(type, /* @__PURE__ */ new Map());
    }
    exports2.findNameAssignment = findNameAssignment;
    function findNameAssignmentInternal(type, cache) {
      var _a;
      function go(node, refType) {
        let childAssignment = void 0;
        const parentAssignment = (0, ast_util_1.getContainerOfType)(node, ast2.isAssignment);
        if (!parentAssignment) {
          childAssignment = findNameAssignmentInternal(refType, cache);
        }
        cache.set(type, childAssignment);
        return childAssignment;
      }
      if (cache.has(type))
        return cache.get(type);
      cache.set(type, void 0);
      for (const node of (0, ast_util_1.streamAllContents)(type)) {
        if (ast2.isAssignment(node) && node.feature.toLowerCase() === "name") {
          cache.set(type, node);
          return node;
        } else if (ast2.isRuleCall(node) && ast2.isParserRule(node.rule.ref)) {
          return go(node, node.rule.ref);
        } else if (ast2.isSimpleType(node) && ((_a = node.typeRef) === null || _a === void 0 ? void 0 : _a.ref)) {
          return go(node, node.typeRef.ref);
        }
      }
      return void 0;
    }
    function loadGrammarFromJson(json) {
      var _a;
      const services = (0, langium_grammar_module_1.createLangiumGrammarServices)(file_system_provider_1.EmptyFileSystem).grammar;
      const astNode = services.serializer.JsonSerializer.deserialize(json);
      services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, vscode_uri_1.URI.parse(`memory://${(_a = astNode.name) !== null && _a !== void 0 ? _a : "grammar"}.langium`));
      return astNode;
    }
    exports2.loadGrammarFromJson = loadGrammarFromJson;
    async function createServicesForGrammar(config) {
      var _a, _b, _c, _d, _e, _f;
      const grammarServices = (_a = config.grammarServices) !== null && _a !== void 0 ? _a : (0, langium_grammar_module_1.createLangiumGrammarServices)(file_system_provider_1.EmptyFileSystem).grammar;
      const uri = vscode_uri_1.URI.parse("memory:///grammar.langium");
      const factory = grammarServices.shared.workspace.LangiumDocumentFactory;
      const grammarDocument = typeof config.grammar === "string" ? factory.fromString(config.grammar, uri) : (0, ast_util_1.getDocument)(config.grammar);
      const grammarNode = grammarDocument.parseResult.value;
      const documentBuilder = grammarServices.shared.workspace.DocumentBuilder;
      await documentBuilder.build([grammarDocument], { validationChecks: "none" });
      const parserConfig = (_b = config.parserConfig) !== null && _b !== void 0 ? _b : {
        skipValidations: false
      };
      const languageMetaData = (_c = config.languageMetaData) !== null && _c !== void 0 ? _c : {
        caseInsensitive: false,
        fileExtensions: [`.${(_e = (_d = grammarNode.name) === null || _d === void 0 ? void 0 : _d.toLowerCase()) !== null && _e !== void 0 ? _e : "unknown"}`],
        languageId: (_f = grammarNode.name) !== null && _f !== void 0 ? _f : "UNKNOWN"
      };
      const generatedSharedModule = {
        AstReflection: () => (0, ast_reflection_interpreter_1.interpretAstReflection)(grammarNode)
      };
      const generatedModule = {
        Grammar: () => grammarNode,
        LanguageMetaData: () => languageMetaData,
        parser: {
          ParserConfig: () => parserConfig
        }
      };
      const shared = (0, dependency_injection_1.inject)((0, default_module_1.createDefaultSharedModule)(file_system_provider_1.EmptyFileSystem), generatedSharedModule, config.sharedModule);
      const services = (0, dependency_injection_1.inject)((0, default_module_1.createDefaultModule)({ shared }), generatedModule, config.module);
      shared.ServiceRegistry.register(services);
      return services;
    }
    exports2.createServicesForGrammar = createServicesForGrammar;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/grammar-config.js
var require_grammar_config = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/grammar-config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createGrammarConfig = void 0;
    var cst_util_1 = require_cst_util();
    var grammar_util_1 = require_grammar_util();
    var regex_util_1 = require_regex_util();
    var ast_1 = require_ast();
    var internal_grammar_util_1 = require_internal_grammar_util();
    function createGrammarConfig(services) {
      const rules = [];
      const grammar = services.Grammar;
      for (const rule of grammar.rules) {
        if ((0, ast_1.isTerminalRule)(rule) && (0, grammar_util_1.isCommentTerminal)(rule) && (0, regex_util_1.isMultilineComment)((0, internal_grammar_util_1.terminalRegex)(rule))) {
          rules.push(rule.name);
        }
      }
      return {
        multilineCommentRules: rules,
        nameRegexp: cst_util_1.DefaultNameRegexp
      };
    }
    exports2.createGrammarConfig = createGrammarConfig;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/version.js
var require_version = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERSION = void 0;
    exports2.VERSION = "10.4.2";
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto2;
    }
    module2.exports = isPrototype;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView = getNative(root, "DataView");
    module2.exports = DataView;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module2.exports = WeakMap2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js"(exports2, module2) {
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isEmpty.js"(exports2, module2) {
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLike = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = isEmpty;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js
var require_eq = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js"(exports2, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js"(exports2, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js"(exports2, module2) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js"(exports2, module2) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js"(exports2, module2) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js"(exports2, module2) {
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js"(exports2, module2) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js"(exports2, module2) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js"(exports2, module2) {
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js"(exports2, module2) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js"(exports2, module2) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js"(exports2, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js
var require_keys = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js"(exports2, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
    var isObject = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    module2.exports = isStrictComparable;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js"(exports2, module2) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module2.exports = getMatchData;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    module2.exports = matchesStrictComparable;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js"(exports2, module2) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    module2.exports = baseMatches;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js"(exports2, module2) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module2.exports = memoize;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js"(exports2, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js
var require_toString = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js"(exports2, module2) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js"(exports2, module2) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module2.exports = castPath;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js"(exports2, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path2) {
      path2 = castPath(path2, object);
      var index = 0, length = path2.length;
      while (object != null && index < length) {
        object = object[toKey(path2[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module2.exports = baseGet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js
var require_get = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function get(object, path2, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path2);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js"(exports2, module2) {
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    module2.exports = baseHasIn;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js"(exports2, module2) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path2, hasFunc) {
      path2 = castPath(path2, object);
      var index = -1, length = path2.length, result = false;
      while (++index < length) {
        var key = toKey(path2[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    module2.exports = hasPath;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js"(exports2, module2) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path2) {
      return object != null && hasPath(object, path2, baseHasIn);
    }
    module2.exports = hasIn;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    var get = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path2, srcValue) {
      if (isKey(path2) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path2), srcValue);
      }
      return function(object) {
        var objValue = get(object, path2);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module2.exports = baseMatchesProperty;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js
var require_identity = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js"(exports2, module2) {
    function identity(value) {
      return value;
    }
    module2.exports = identity;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js"(exports2, module2) {
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    module2.exports = baseProperty;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path2) {
      return function(object) {
        return baseGet(object, path2);
      };
    }
    module2.exports = basePropertyDeep;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js
var require_property = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js"(exports2, module2) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path2) {
      return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
    }
    module2.exports = property;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js"(exports2, module2) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module2.exports = baseIteratee;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js"(exports2, module2) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module2.exports = createBaseFor;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js"(exports2, module2) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js"(exports2, module2) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module2.exports = baseForOwn;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseEach.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module2.exports = createBaseEach;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEach.js"(exports2, module2) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module2.exports = baseEach;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMap.js"(exports2, module2) {
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    module2.exports = baseMap;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/map.js
var require_map = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/map.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var isArray = require_isArray();
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee, 3));
    }
    module2.exports = map;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEach.js"(exports2, module2) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module2.exports = arrayEach;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castFunction.js"(exports2, module2) {
    var identity = require_identity();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    module2.exports = castFunction;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/forEach.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    module2.exports = forEach;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseValues.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    module2.exports = baseValues;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/values.js
var require_values = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/values.js"(exports2, module2) {
    var baseValues = require_baseValues();
    var keys = require_keys();
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }
    module2.exports = values;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHas.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }
    module2.exports = baseHas;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/has.js
var require_has = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/has.js"(exports2, module2) {
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has(object, path2) {
      return object != null && hasPath(object, path2, baseHas);
    }
    module2.exports = has;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js"(exports2, module2) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module2.exports = assignValue;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module2.exports = copyObject;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssign.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module2.exports = baseAssign;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = keysIn;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module2.exports = baseAssignIn;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
    var root = require_root();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js"(exports2, module2) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module2.exports = copyArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbols.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module2.exports = copySymbols;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module2.exports = copySymbolsIn;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneArray.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module2.exports = initCloneArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneDataView.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module2.exports = cloneSymbol;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module2.exports = initCloneByTag;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js"(exports2, module2) {
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object() {
      }
      return function(proto2) {
        if (!isObject(proto2)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto2);
        }
        object.prototype = proto2;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js"(exports2, module2) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module2.exports = initCloneObject;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMap.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module2.exports = baseIsMap;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isMap.js"(exports2, module2) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsSet.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module2.exports = baseIsSet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSet.js"(exports2, module2) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseClone.js"(exports2, module2) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module2.exports = baseClone;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/clone.js
var require_clone = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/clone.js"(exports2, module2) {
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    module2.exports = clone;
  }
});

// ../../node_modules/.pnpm/@chevrotain+utils@10.4.2/node_modules/@chevrotain/utils/lib/src/print.js
var require_print = __commonJS({
  "../../node_modules/.pnpm/@chevrotain+utils@10.4.2/node_modules/@chevrotain/utils/lib/src/print.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PRINT_WARNING = exports2.PRINT_ERROR = void 0;
    function PRINT_ERROR(msg) {
      if (console && console.error) {
        console.error("Error: ".concat(msg));
      }
    }
    exports2.PRINT_ERROR = PRINT_ERROR;
    function PRINT_WARNING(msg) {
      if (console && console.warn) {
        console.warn("Warning: ".concat(msg));
      }
    }
    exports2.PRINT_WARNING = PRINT_WARNING;
  }
});

// ../../node_modules/.pnpm/@chevrotain+utils@10.4.2/node_modules/@chevrotain/utils/lib/src/timer.js
var require_timer = __commonJS({
  "../../node_modules/.pnpm/@chevrotain+utils@10.4.2/node_modules/@chevrotain/utils/lib/src/timer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timer = void 0;
    function timer(func) {
      var start = (/* @__PURE__ */ new Date()).getTime();
      var val = func();
      var end = (/* @__PURE__ */ new Date()).getTime();
      var total = end - start;
      return { time: total, value: val };
    }
    exports2.timer = timer;
  }
});

// ../../node_modules/.pnpm/@chevrotain+utils@10.4.2/node_modules/@chevrotain/utils/lib/src/to-fast-properties.js
var require_to_fast_properties = __commonJS({
  "../../node_modules/.pnpm/@chevrotain+utils@10.4.2/node_modules/@chevrotain/utils/lib/src/to-fast-properties.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toFastProperties = void 0;
    function toFastProperties(toBecomeFast) {
      function FakeConstructor() {
      }
      FakeConstructor.prototype = toBecomeFast;
      var fakeInstance = new FakeConstructor();
      function fakeAccess() {
        return typeof fakeInstance.bar;
      }
      fakeAccess();
      fakeAccess();
      if (1)
        return toBecomeFast;
      eval(toBecomeFast);
    }
    exports.toFastProperties = toFastProperties;
  }
});

// ../../node_modules/.pnpm/@chevrotain+utils@10.4.2/node_modules/@chevrotain/utils/lib/src/api.js
var require_api4 = __commonJS({
  "../../node_modules/.pnpm/@chevrotain+utils@10.4.2/node_modules/@chevrotain/utils/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toFastProperties = exports2.timer = exports2.PRINT_ERROR = exports2.PRINT_WARNING = void 0;
    var print_1 = require_print();
    Object.defineProperty(exports2, "PRINT_WARNING", { enumerable: true, get: function() {
      return print_1.PRINT_WARNING;
    } });
    Object.defineProperty(exports2, "PRINT_ERROR", { enumerable: true, get: function() {
      return print_1.PRINT_ERROR;
    } });
    var timer_1 = require_timer();
    Object.defineProperty(exports2, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var to_fast_properties_1 = require_to_fast_properties();
    Object.defineProperty(exports2, "toFastProperties", { enumerable: true, get: function() {
      return to_fast_properties_1.toFastProperties;
    } });
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js"(exports2, module2) {
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    module2.exports = baseSlice;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js"(exports2, module2) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    module2.exports = trimmedEndIndex;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js"(exports2, module2) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module2.exports = baseTrim;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js"(exports2, module2) {
    var baseTrim = require_baseTrim();
    var isObject = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = toNumber;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toFinite.js"(exports2, module2) {
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    module2.exports = toFinite;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toInteger.js"(exports2, module2) {
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    module2.exports = toInteger;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/drop.js
var require_drop = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/drop.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    var toInteger = require_toInteger();
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = guard || n === void 0 ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }
    module2.exports = drop;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isString.js
var require_isString = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isString.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsRegExp.js
var require_baseIsRegExp = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsRegExp.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var regexpTag = "[object RegExp]";
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }
    module2.exports = baseIsRegExp;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isRegExp.js
var require_isRegExp = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isRegExp.js"(exports2, module2) {
    var baseIsRegExp = require_baseIsRegExp();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
    module2.exports = isRegExp;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSet.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path2, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path2 = castPath(path2, object);
      var index = -1, length = path2.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path2[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    module2.exports = baseSet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePickBy.js"(exports2, module2) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path2 = paths[index], value = baseGet(object, path2);
        if (predicate(value, path2)) {
          baseSet(result, castPath(path2, object), value);
        }
      }
      return result;
    }
    module2.exports = basePickBy;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/pickBy.js
var require_pickBy = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/pickBy.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var basePickBy = require_basePickBy();
    var getAllKeysIn = require_getAllKeysIn();
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = baseIteratee(predicate);
      return basePickBy(object, props, function(value, path2) {
        return predicate(value, path2[0]);
      });
    }
    module2.exports = pickBy;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js"(exports2, module2) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module2.exports = apply;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js"(exports2, module2) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    module2.exports = overRest;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js
var require_constant = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js"(exports2, module2) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module2.exports = constant;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js"(exports2, module2) {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module2.exports = baseSetToString;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js"(exports2, module2) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module2.exports = shortOut;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js"(exports2, module2) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module2.exports = setToString;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js"(exports2, module2) {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module2.exports = baseRest;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js"(exports2, module2) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module2.exports = isIterateeCall;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAssigner.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module2.exports = createAssigner;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/assign.js
var require_assign = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/assign.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var isArrayLike = require_isArrayLike();
    var isPrototype = require_isPrototype();
    var keys = require_keys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });
    module2.exports = assign;
  }
});

// ../../node_modules/.pnpm/@chevrotain+gast@10.4.2/node_modules/@chevrotain/gast/lib/src/model.js
var require_model = __commonJS({
  "../../node_modules/.pnpm/@chevrotain+gast@10.4.2/node_modules/@chevrotain/gast/lib/src/model.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.Repetition = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Option = exports2.Alternative = exports2.Rule = exports2.NonTerminal = exports2.AbstractProduction = void 0;
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var isString_1 = __importDefault(require_isString());
    var isRegExp_1 = __importDefault(require_isRegExp());
    var pickBy_1 = __importDefault(require_pickBy());
    var assign_1 = __importDefault(require_assign());
    function tokenLabel(tokType) {
      if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
      } else {
        return tokType.name;
      }
    }
    function hasTokenLabel(obj) {
      return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
    }
    var AbstractProduction = (
      /** @class */
      function() {
        function AbstractProduction2(_definition) {
          this._definition = _definition;
        }
        Object.defineProperty(AbstractProduction2.prototype, "definition", {
          get: function() {
            return this._definition;
          },
          set: function(value) {
            this._definition = value;
          },
          enumerable: false,
          configurable: true
        });
        AbstractProduction2.prototype.accept = function(visitor) {
          visitor.visit(this);
          (0, forEach_1.default)(this.definition, function(prod) {
            prod.accept(visitor);
          });
        };
        return AbstractProduction2;
      }()
    );
    exports2.AbstractProduction = AbstractProduction;
    var NonTerminal = (
      /** @class */
      function(_super) {
        __extends(NonTerminal2, _super);
        function NonTerminal2(options) {
          var _this = _super.call(this, []) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        Object.defineProperty(NonTerminal2.prototype, "definition", {
          get: function() {
            if (this.referencedRule !== void 0) {
              return this.referencedRule.definition;
            }
            return [];
          },
          set: function(definition) {
          },
          enumerable: false,
          configurable: true
        });
        NonTerminal2.prototype.accept = function(visitor) {
          visitor.visit(this);
        };
        return NonTerminal2;
      }(AbstractProduction)
    );
    exports2.NonTerminal = NonTerminal;
    var Rule = (
      /** @class */
      function(_super) {
        __extends(Rule2, _super);
        function Rule2(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.orgText = "";
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Rule2;
      }(AbstractProduction)
    );
    exports2.Rule = Rule;
    var Alternative = (
      /** @class */
      function(_super) {
        __extends(Alternative2, _super);
        function Alternative2(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.ignoreAmbiguities = false;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Alternative2;
      }(AbstractProduction)
    );
    exports2.Alternative = Alternative;
    var Option2 = (
      /** @class */
      function(_super) {
        __extends(Option3, _super);
        function Option3(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Option3;
      }(AbstractProduction)
    );
    exports2.Option = Option2;
    var RepetitionMandatory = (
      /** @class */
      function(_super) {
        __extends(RepetitionMandatory2, _super);
        function RepetitionMandatory2(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return RepetitionMandatory2;
      }(AbstractProduction)
    );
    exports2.RepetitionMandatory = RepetitionMandatory;
    var RepetitionMandatoryWithSeparator = (
      /** @class */
      function(_super) {
        __extends(RepetitionMandatoryWithSeparator2, _super);
        function RepetitionMandatoryWithSeparator2(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return RepetitionMandatoryWithSeparator2;
      }(AbstractProduction)
    );
    exports2.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator;
    var Repetition = (
      /** @class */
      function(_super) {
        __extends(Repetition2, _super);
        function Repetition2(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return Repetition2;
      }(AbstractProduction)
    );
    exports2.Repetition = Repetition;
    var RepetitionWithSeparator = (
      /** @class */
      function(_super) {
        __extends(RepetitionWithSeparator2, _super);
        function RepetitionWithSeparator2(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        return RepetitionWithSeparator2;
      }(AbstractProduction)
    );
    exports2.RepetitionWithSeparator = RepetitionWithSeparator;
    var Alternation = (
      /** @class */
      function(_super) {
        __extends(Alternation2, _super);
        function Alternation2(options) {
          var _this = _super.call(this, options.definition) || this;
          _this.idx = 1;
          _this.ignoreAmbiguities = false;
          _this.hasPredicates = false;
          (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
          return _this;
        }
        Object.defineProperty(Alternation2.prototype, "definition", {
          get: function() {
            return this._definition;
          },
          set: function(value) {
            this._definition = value;
          },
          enumerable: false,
          configurable: true
        });
        return Alternation2;
      }(AbstractProduction)
    );
    exports2.Alternation = Alternation;
    var Terminal = (
      /** @class */
      function() {
        function Terminal2(options) {
          this.idx = 1;
          (0, assign_1.default)(this, (0, pickBy_1.default)(options, function(v) {
            return v !== void 0;
          }));
        }
        Terminal2.prototype.accept = function(visitor) {
          visitor.visit(this);
        };
        return Terminal2;
      }()
    );
    exports2.Terminal = Terminal;
    function serializeGrammar(topRules) {
      return (0, map_1.default)(topRules, serializeProduction);
    }
    exports2.serializeGrammar = serializeGrammar;
    function serializeProduction(node) {
      function convertDefinition(definition) {
        return (0, map_1.default)(definition, serializeProduction);
      }
      if (node instanceof NonTerminal) {
        var serializedNonTerminal = {
          type: "NonTerminal",
          name: node.nonTerminalName,
          idx: node.idx
        };
        if ((0, isString_1.default)(node.label)) {
          serializedNonTerminal.label = node.label;
        }
        return serializedNonTerminal;
      } else if (node instanceof Alternative) {
        return {
          type: "Alternative",
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Option2) {
        return {
          type: "Option",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionMandatory) {
        return {
          type: "RepetitionMandatory",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionMandatoryWithSeparator) {
        return {
          type: "RepetitionMandatoryWithSeparator",
          idx: node.idx,
          separator: serializeProduction(new Terminal({ terminalType: node.separator })),
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof RepetitionWithSeparator) {
        return {
          type: "RepetitionWithSeparator",
          idx: node.idx,
          separator: serializeProduction(new Terminal({ terminalType: node.separator })),
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Repetition) {
        return {
          type: "Repetition",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Alternation) {
        return {
          type: "Alternation",
          idx: node.idx,
          definition: convertDefinition(node.definition)
        };
      } else if (node instanceof Terminal) {
        var serializedTerminal = {
          type: "Terminal",
          name: node.terminalType.name,
          label: tokenLabel(node.terminalType),
          idx: node.idx
        };
        if ((0, isString_1.default)(node.label)) {
          serializedTerminal.terminalLabel = node.label;
        }
        var pattern = node.terminalType.PATTERN;
        if (node.terminalType.PATTERN) {
          serializedTerminal.pattern = (0, isRegExp_1.default)(pattern) ? pattern.source : pattern;
        }
        return serializedTerminal;
      } else if (node instanceof Rule) {
        return {
          type: "Rule",
          name: node.name,
          orgText: node.orgText,
          definition: convertDefinition(node.definition)
        };
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.serializeProduction = serializeProduction;
  }
});

// ../../node_modules/.pnpm/@chevrotain+gast@10.4.2/node_modules/@chevrotain/gast/lib/src/visitor.js
var require_visitor = __commonJS({
  "../../node_modules/.pnpm/@chevrotain+gast@10.4.2/node_modules/@chevrotain/gast/lib/src/visitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GAstVisitor = void 0;
    var model_1 = require_model();
    var GAstVisitor = (
      /** @class */
      function() {
        function GAstVisitor2() {
        }
        GAstVisitor2.prototype.visit = function(node) {
          var nodeAny = node;
          switch (nodeAny.constructor) {
            case model_1.NonTerminal:
              return this.visitNonTerminal(nodeAny);
            case model_1.Alternative:
              return this.visitAlternative(nodeAny);
            case model_1.Option:
              return this.visitOption(nodeAny);
            case model_1.RepetitionMandatory:
              return this.visitRepetitionMandatory(nodeAny);
            case model_1.RepetitionMandatoryWithSeparator:
              return this.visitRepetitionMandatoryWithSeparator(nodeAny);
            case model_1.RepetitionWithSeparator:
              return this.visitRepetitionWithSeparator(nodeAny);
            case model_1.Repetition:
              return this.visitRepetition(nodeAny);
            case model_1.Alternation:
              return this.visitAlternation(nodeAny);
            case model_1.Terminal:
              return this.visitTerminal(nodeAny);
            case model_1.Rule:
              return this.visitRule(nodeAny);
            default:
              throw Error("non exhaustive match");
          }
        };
        GAstVisitor2.prototype.visitNonTerminal = function(node) {
        };
        GAstVisitor2.prototype.visitAlternative = function(node) {
        };
        GAstVisitor2.prototype.visitOption = function(node) {
        };
        GAstVisitor2.prototype.visitRepetition = function(node) {
        };
        GAstVisitor2.prototype.visitRepetitionMandatory = function(node) {
        };
        GAstVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
        };
        GAstVisitor2.prototype.visitRepetitionWithSeparator = function(node) {
        };
        GAstVisitor2.prototype.visitAlternation = function(node) {
        };
        GAstVisitor2.prototype.visitTerminal = function(node) {
        };
        GAstVisitor2.prototype.visitRule = function(node) {
        };
        return GAstVisitor2;
      }()
    );
    exports2.GAstVisitor = GAstVisitor;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSome.js
var require_baseSome = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSome.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseSome(collection, predicate) {
      var result;
      baseEach(collection, function(value, index, collection2) {
        result = predicate(value, index, collection2);
        return !result;
      });
      return !!result;
    }
    module2.exports = baseSome;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/some.js
var require_some = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/some.js"(exports2, module2) {
    var arraySome = require_arraySome();
    var baseIteratee = require_baseIteratee();
    var baseSome = require_baseSome();
    var isArray = require_isArray();
    var isIterateeCall = require_isIterateeCall();
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = some;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEvery.js
var require_arrayEvery = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEvery.js"(exports2, module2) {
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    module2.exports = arrayEvery;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEvery.js
var require_baseEvery = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEvery.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection2) {
        result = !!predicate(value, index, collection2);
        return result;
      });
      return result;
    }
    module2.exports = baseEvery;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/every.js
var require_every = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/every.js"(exports2, module2) {
    var arrayEvery = require_arrayEvery();
    var baseEvery = require_baseEvery();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    var isIterateeCall = require_isIterateeCall();
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = every;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseFindIndex;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module2.exports = baseIsNaN;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = strictIndexOf;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module2.exports = baseIndexOf;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/includes.js
var require_includes = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/includes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    var isArrayLike = require_isArrayLike();
    var isString = require_isString();
    var toInteger = require_toInteger();
    var values = require_values();
    var nativeMax = Math.max;
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    module2.exports = includes;
  }
});

// ../../node_modules/.pnpm/@chevrotain+gast@10.4.2/node_modules/@chevrotain/gast/lib/src/helpers.js
var require_helpers = __commonJS({
  "../../node_modules/.pnpm/@chevrotain+gast@10.4.2/node_modules/@chevrotain/gast/lib/src/helpers.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProductionDslName = exports2.isBranchingProd = exports2.isOptionalProd = exports2.isSequenceProd = void 0;
    var some_1 = __importDefault(require_some());
    var every_1 = __importDefault(require_every());
    var includes_1 = __importDefault(require_includes());
    var model_1 = require_model();
    function isSequenceProd(prod) {
      return prod instanceof model_1.Alternative || prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionMandatory || prod instanceof model_1.RepetitionMandatoryWithSeparator || prod instanceof model_1.RepetitionWithSeparator || prod instanceof model_1.Terminal || prod instanceof model_1.Rule;
    }
    exports2.isSequenceProd = isSequenceProd;
    function isOptionalProd(prod, alreadyVisited) {
      if (alreadyVisited === void 0) {
        alreadyVisited = [];
      }
      var isDirectlyOptional = prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionWithSeparator;
      if (isDirectlyOptional) {
        return true;
      }
      if (prod instanceof model_1.Alternation) {
        return (0, some_1.default)(prod.definition, function(subProd) {
          return isOptionalProd(subProd, alreadyVisited);
        });
      } else if (prod instanceof model_1.NonTerminal && (0, includes_1.default)(alreadyVisited, prod)) {
        return false;
      } else if (prod instanceof model_1.AbstractProduction) {
        if (prod instanceof model_1.NonTerminal) {
          alreadyVisited.push(prod);
        }
        return (0, every_1.default)(prod.definition, function(subProd) {
          return isOptionalProd(subProd, alreadyVisited);
        });
      } else {
        return false;
      }
    }
    exports2.isOptionalProd = isOptionalProd;
    function isBranchingProd(prod) {
      return prod instanceof model_1.Alternation;
    }
    exports2.isBranchingProd = isBranchingProd;
    function getProductionDslName(prod) {
      if (prod instanceof model_1.NonTerminal) {
        return "SUBRULE";
      } else if (prod instanceof model_1.Option) {
        return "OPTION";
      } else if (prod instanceof model_1.Alternation) {
        return "OR";
      } else if (prod instanceof model_1.RepetitionMandatory) {
        return "AT_LEAST_ONE";
      } else if (prod instanceof model_1.RepetitionMandatoryWithSeparator) {
        return "AT_LEAST_ONE_SEP";
      } else if (prod instanceof model_1.RepetitionWithSeparator) {
        return "MANY_SEP";
      } else if (prod instanceof model_1.Repetition) {
        return "MANY";
      } else if (prod instanceof model_1.Terminal) {
        return "CONSUME";
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.getProductionDslName = getProductionDslName;
  }
});

// ../../node_modules/.pnpm/@chevrotain+gast@10.4.2/node_modules/@chevrotain/gast/lib/src/api.js
var require_api5 = __commonJS({
  "../../node_modules/.pnpm/@chevrotain+gast@10.4.2/node_modules/@chevrotain/gast/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSequenceProd = exports2.isBranchingProd = exports2.isOptionalProd = exports2.getProductionDslName = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Alternative = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Terminal = exports2.Rule = void 0;
    var model_1 = require_model();
    Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
      return model_1.Rule;
    } });
    Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
      return model_1.Terminal;
    } });
    Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
      return model_1.NonTerminal;
    } });
    Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
      return model_1.Option;
    } });
    Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
      return model_1.Repetition;
    } });
    Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
      return model_1.RepetitionMandatory;
    } });
    Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
      return model_1.RepetitionMandatoryWithSeparator;
    } });
    Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
      return model_1.RepetitionWithSeparator;
    } });
    Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
      return model_1.Alternation;
    } });
    Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
      return model_1.Alternative;
    } });
    Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
      return model_1.serializeGrammar;
    } });
    Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
      return model_1.serializeProduction;
    } });
    var visitor_1 = require_visitor();
    Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
      return visitor_1.GAstVisitor;
    } });
    var helpers_1 = require_helpers();
    Object.defineProperty(exports2, "getProductionDslName", { enumerable: true, get: function() {
      return helpers_1.getProductionDslName;
    } });
    Object.defineProperty(exports2, "isOptionalProd", { enumerable: true, get: function() {
      return helpers_1.isOptionalProd;
    } });
    Object.defineProperty(exports2, "isBranchingProd", { enumerable: true, get: function() {
      return helpers_1.isBranchingProd;
    } });
    Object.defineProperty(exports2, "isSequenceProd", { enumerable: true, get: function() {
      return helpers_1.isSequenceProd;
    } });
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/rest.js
var require_rest = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/rest.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestWalker = void 0;
    var drop_1 = __importDefault(require_drop());
    var forEach_1 = __importDefault(require_forEach());
    var gast_1 = require_api5();
    var RestWalker = (
      /** @class */
      function() {
        function RestWalker2() {
        }
        RestWalker2.prototype.walk = function(prod, prevRest) {
          var _this = this;
          if (prevRest === void 0) {
            prevRest = [];
          }
          (0, forEach_1.default)(prod.definition, function(subProd, index) {
            var currRest = (0, drop_1.default)(prod.definition, index + 1);
            if (subProd instanceof gast_1.NonTerminal) {
              _this.walkProdRef(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Terminal) {
              _this.walkTerminal(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Alternative) {
              _this.walkFlat(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Option) {
              _this.walkOption(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.RepetitionMandatory) {
              _this.walkAtLeastOne(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.RepetitionMandatoryWithSeparator) {
              _this.walkAtLeastOneSep(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.RepetitionWithSeparator) {
              _this.walkManySep(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Repetition) {
              _this.walkMany(subProd, currRest, prevRest);
            } else if (subProd instanceof gast_1.Alternation) {
              _this.walkOr(subProd, currRest, prevRest);
            } else {
              throw Error("non exhaustive match");
            }
          });
        };
        RestWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
        };
        RestWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
        };
        RestWalker2.prototype.walkFlat = function(flatProd, currRest, prevRest) {
          var fullOrRest = currRest.concat(prevRest);
          this.walk(flatProd, fullOrRest);
        };
        RestWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
          var fullOrRest = currRest.concat(prevRest);
          this.walk(optionProd, fullOrRest);
        };
        RestWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
          var fullAtLeastOneRest = [
            new gast_1.Option({ definition: atLeastOneProd.definition })
          ].concat(currRest, prevRest);
          this.walk(atLeastOneProd, fullAtLeastOneRest);
        };
        RestWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
          var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
          this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
        };
        RestWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
          var fullManyRest = [
            new gast_1.Option({ definition: manyProd.definition })
          ].concat(currRest, prevRest);
          this.walk(manyProd, fullManyRest);
        };
        RestWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
          var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
          this.walk(manySepProd, fullManySepRest);
        };
        RestWalker2.prototype.walkOr = function(orProd, currRest, prevRest) {
          var _this = this;
          var fullOrRest = currRest.concat(prevRest);
          (0, forEach_1.default)(orProd.definition, function(alt) {
            var prodWrapper = new gast_1.Alternative({ definition: [alt] });
            _this.walk(prodWrapper, fullOrRest);
          });
        };
        return RestWalker2;
      }()
    );
    exports2.RestWalker = RestWalker;
    function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
      var repSepRest = [
        new gast_1.Option({
          definition: [
            new gast_1.Terminal({ terminalType: repSepProd.separator })
          ].concat(repSepProd.definition)
        })
      ];
      var fullRepSepRest = repSepRest.concat(currRest, prevRest);
      return fullRepSepRest;
    }
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module2.exports = isFlattenable;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module2.exports = baseFlatten;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module2.exports = flatten;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module2.exports = arrayIncludes;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arrayIncludesWith;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/noop.js
var require_noop = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/noop.js"(exports2, module2) {
    function noop() {
    }
    module2.exports = noop;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createSet.js"(exports2, module2) {
    var Set2 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    module2.exports = createSet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUniq.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseUniq;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniq.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module2.exports = uniq;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/first.js
var require_first = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/first.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.firstForTerminal = exports2.firstForBranching = exports2.firstForSequence = exports2.first = void 0;
    var flatten_1 = __importDefault(require_flatten());
    var uniq_1 = __importDefault(require_uniq());
    var map_1 = __importDefault(require_map());
    var gast_1 = require_api5();
    var gast_2 = require_api5();
    function first(prod) {
      if (prod instanceof gast_1.NonTerminal) {
        return first(prod.referencedRule);
      } else if (prod instanceof gast_1.Terminal) {
        return firstForTerminal(prod);
      } else if ((0, gast_2.isSequenceProd)(prod)) {
        return firstForSequence(prod);
      } else if ((0, gast_2.isBranchingProd)(prod)) {
        return firstForBranching(prod);
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.first = first;
    function firstForSequence(prod) {
      var firstSet = [];
      var seq = prod.definition;
      var nextSubProdIdx = 0;
      var hasInnerProdsRemaining = seq.length > nextSubProdIdx;
      var currSubProd;
      var isLastInnerProdOptional = true;
      while (hasInnerProdsRemaining && isLastInnerProdOptional) {
        currSubProd = seq[nextSubProdIdx];
        isLastInnerProdOptional = (0, gast_2.isOptionalProd)(currSubProd);
        firstSet = firstSet.concat(first(currSubProd));
        nextSubProdIdx = nextSubProdIdx + 1;
        hasInnerProdsRemaining = seq.length > nextSubProdIdx;
      }
      return (0, uniq_1.default)(firstSet);
    }
    exports2.firstForSequence = firstForSequence;
    function firstForBranching(prod) {
      var allAlternativesFirsts = (0, map_1.default)(prod.definition, function(innerProd) {
        return first(innerProd);
      });
      return (0, uniq_1.default)((0, flatten_1.default)(allAlternativesFirsts));
    }
    exports2.firstForBranching = firstForBranching;
    function firstForTerminal(terminal) {
      return [terminal.terminalType];
    }
    exports2.firstForTerminal = firstForTerminal;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IN = void 0;
    exports2.IN = "_~IN~_";
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/follow.js
var require_follow = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/follow.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildInProdFollowPrefix = exports2.buildBetweenProdsFollowPrefix = exports2.computeAllProdsFollows = exports2.ResyncFollowsWalker = void 0;
    var rest_1 = require_rest();
    var first_1 = require_first();
    var forEach_1 = __importDefault(require_forEach());
    var assign_1 = __importDefault(require_assign());
    var constants_1 = require_constants();
    var gast_1 = require_api5();
    var ResyncFollowsWalker = (
      /** @class */
      function(_super) {
        __extends(ResyncFollowsWalker2, _super);
        function ResyncFollowsWalker2(topProd) {
          var _this = _super.call(this) || this;
          _this.topProd = topProd;
          _this.follows = {};
          return _this;
        }
        ResyncFollowsWalker2.prototype.startWalking = function() {
          this.walk(this.topProd);
          return this.follows;
        };
        ResyncFollowsWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
        };
        ResyncFollowsWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
          var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;
          var fullRest = currRest.concat(prevRest);
          var restProd = new gast_1.Alternative({ definition: fullRest });
          var t_in_topProd_follows = (0, first_1.first)(restProd);
          this.follows[followName] = t_in_topProd_follows;
        };
        return ResyncFollowsWalker2;
      }(rest_1.RestWalker)
    );
    exports2.ResyncFollowsWalker = ResyncFollowsWalker;
    function computeAllProdsFollows(topProductions) {
      var reSyncFollows = {};
      (0, forEach_1.default)(topProductions, function(topProd) {
        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
        (0, assign_1.default)(reSyncFollows, currRefsFollow);
      });
      return reSyncFollows;
    }
    exports2.computeAllProdsFollows = computeAllProdsFollows;
    function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
      return inner.name + occurenceInParent + constants_1.IN;
    }
    exports2.buildBetweenProdsFollowPrefix = buildBetweenProdsFollowPrefix;
    function buildInProdFollowPrefix(terminal) {
      var terminalName = terminal.terminalType.name;
      return terminalName + terminal.idx + constants_1.IN;
    }
    exports2.buildInProdFollowPrefix = buildInProdFollowPrefix;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isUndefined.js"(exports2, module2) {
    function isUndefined(value) {
      return value === void 0;
    }
    module2.exports = isUndefined;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/head.js
var require_head = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/head.js"(exports2, module2) {
    function head(array) {
      return array && array.length ? array[0] : void 0;
    }
    module2.exports = head;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/first.js
var require_first2 = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/first.js"(exports2, module2) {
    module2.exports = require_head();
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/compact.js
var require_compact = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/compact.js"(exports2, module2) {
    function compact(array) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = compact;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFilter.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    module2.exports = baseFilter;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/negate.js
var require_negate = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/negate.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    function negate(predicate) {
      if (typeof predicate != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return !predicate.call(this);
          case 1:
            return !predicate.call(this, args[0]);
          case 2:
            return !predicate.call(this, args[0], args[1]);
          case 3:
            return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }
    module2.exports = negate;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reject.js
var require_reject = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reject.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    var negate = require_negate();
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(baseIteratee(predicate, 3)));
    }
    module2.exports = reject;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseDifference;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module2.exports = isArrayLikeObject;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/difference.js
var require_difference = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/difference.js"(exports2, module2) {
    var baseDifference = require_baseDifference();
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    module2.exports = difference;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/indexOf.js
var require_indexOf = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/indexOf.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }
    module2.exports = indexOf;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createFind.js
var require_createFind = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createFind.js"(exports2, module2) {
    var baseIteratee = require_baseIteratee();
    var isArrayLike = require_isArrayLike();
    var keys = require_keys();
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
      };
    }
    module2.exports = createFind;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/findIndex.js
var require_findIndex = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/findIndex.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIteratee = require_baseIteratee();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, baseIteratee(predicate, 3), index);
    }
    module2.exports = findIndex;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/find.js
var require_find = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/find.js"(exports2, module2) {
    var createFind = require_createFind();
    var findIndex = require_findIndex();
    var find = createFind(findIndex);
    module2.exports = find;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/filter.js
var require_filter = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/filter.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    module2.exports = filter;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/defaults.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    module2.exports = defaults;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayReduce.js"(exports2, module2) {
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    module2.exports = arrayReduce;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseReduce.js
var require_baseReduce = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseReduce.js"(exports2, module2) {
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    module2.exports = baseReduce;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reduce.js
var require_reduce = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reduce.js"(exports2, module2) {
    var arrayReduce = require_arrayReduce();
    var baseEach = require_baseEach();
    var baseIteratee = require_baseIteratee();
    var baseReduce = require_baseReduce();
    var isArray = require_isArray();
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    module2.exports = reduce;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/reg_exp_parser.js
var require_reg_exp_parser = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/reg_exp_parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.clearRegExpParserCache = exports2.getRegExpAst = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var regExpAstCache = {};
    var regExpParser = new regexp_to_ast_1.RegExpParser();
    function getRegExpAst(regExp) {
      var regExpStr = regExp.toString();
      if (regExpAstCache.hasOwnProperty(regExpStr)) {
        return regExpAstCache[regExpStr];
      } else {
        var regExpAst = regExpParser.pattern(regExpStr);
        regExpAstCache[regExpStr] = regExpAst;
        return regExpAst;
      }
    }
    exports2.getRegExpAst = getRegExpAst;
    function clearRegExpParserCache() {
      regExpAstCache = {};
    }
    exports2.clearRegExpParserCache = clearRegExpParserCache;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/reg_exp.js
var require_reg_exp = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/reg_exp.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.canMatchCharCode = exports2.firstCharOptimizedIndices = exports2.getOptimizedStartCodesIndices = exports2.failedOptimizationPrefixMsg = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var isArray_1 = __importDefault(require_isArray());
    var every_1 = __importDefault(require_every());
    var forEach_1 = __importDefault(require_forEach());
    var find_1 = __importDefault(require_find());
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var utils_1 = require_api4();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var lexer_1 = require_lexer();
    var complementErrorMessage = "Complement Sets are not supported for first char optimization";
    exports2.failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
    function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {
      if (ensureOptimizations === void 0) {
        ensureOptimizations = false;
      }
      try {
        var ast2 = (0, reg_exp_parser_1.getRegExpAst)(regExp);
        var firstChars = firstCharOptimizedIndices(ast2.value, {}, ast2.flags.ignoreCase);
        return firstChars;
      } catch (e) {
        if (e.message === complementErrorMessage) {
          if (ensureOptimizations) {
            (0, utils_1.PRINT_WARNING)("".concat(exports2.failedOptimizationPrefixMsg) + "	Unable to optimize: < ".concat(regExp.toString(), " >\n") + "	Complement Sets cannot be automatically optimized.\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
          }
        } else {
          var msgSuffix = "";
          if (ensureOptimizations) {
            msgSuffix = "\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
          }
          (0, utils_1.PRINT_ERROR)("".concat(exports2.failedOptimizationPrefixMsg, "\n") + "	Failed parsing: < ".concat(regExp.toString(), " >\n") + "	Using the regexp-to-ast library version: ".concat(regexp_to_ast_1.VERSION, "\n") + "	Please open an issue at: https://github.com/bd82/regexp-to-ast/issues" + msgSuffix);
        }
      }
      return [];
    }
    exports2.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;
    function firstCharOptimizedIndices(ast2, result, ignoreCase) {
      switch (ast2.type) {
        case "Disjunction":
          for (var i = 0; i < ast2.value.length; i++) {
            firstCharOptimizedIndices(ast2.value[i], result, ignoreCase);
          }
          break;
        case "Alternative":
          var terms = ast2.value;
          for (var i = 0; i < terms.length; i++) {
            var term = terms[i];
            switch (term.type) {
              case "EndAnchor":
              case "GroupBackReference":
              case "Lookahead":
              case "NegativeLookahead":
              case "StartAnchor":
              case "WordBoundary":
              case "NonWordBoundary":
                continue;
            }
            var atom = term;
            switch (atom.type) {
              case "Character":
                addOptimizedIdxToResult(atom.value, result, ignoreCase);
                break;
              case "Set":
                if (atom.complement === true) {
                  throw Error(complementErrorMessage);
                }
                (0, forEach_1.default)(atom.value, function(code) {
                  if (typeof code === "number") {
                    addOptimizedIdxToResult(code, result, ignoreCase);
                  } else {
                    var range = code;
                    if (ignoreCase === true) {
                      for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {
                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                      }
                    } else {
                      for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {
                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                      }
                      if (range.to >= lexer_1.minOptimizationVal) {
                        var minUnOptVal = range.from >= lexer_1.minOptimizationVal ? range.from : lexer_1.minOptimizationVal;
                        var maxUnOptVal = range.to;
                        var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);
                        var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);
                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                          result[currOptIdx] = currOptIdx;
                        }
                      }
                    }
                  }
                });
                break;
              case "Group":
                firstCharOptimizedIndices(atom.value, result, ignoreCase);
                break;
              default:
                throw Error("Non Exhaustive Match");
            }
            var isOptionalQuantifier = atom.quantifier !== void 0 && atom.quantifier.atLeast === 0;
            if (
              // A group may be optional due to empty contents /(?:)/
              // or if everything inside it is optional /((a)?)/
              atom.type === "Group" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier
              atom.type !== "Group" && isOptionalQuantifier === false
            ) {
              break;
            }
          }
          break;
        default:
          throw Error("non exhaustive match!");
      }
      return (0, values_1.default)(result);
    }
    exports2.firstCharOptimizedIndices = firstCharOptimizedIndices;
    function addOptimizedIdxToResult(code, result, ignoreCase) {
      var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);
      result[optimizedCharIdx] = optimizedCharIdx;
      if (ignoreCase === true) {
        handleIgnoreCase(code, result);
      }
    }
    function handleIgnoreCase(code, result) {
      var char = String.fromCharCode(code);
      var upperChar = char.toUpperCase();
      if (upperChar !== char) {
        var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));
        result[optimizedCharIdx] = optimizedCharIdx;
      } else {
        var lowerChar = char.toLowerCase();
        if (lowerChar !== char) {
          var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));
          result[optimizedCharIdx] = optimizedCharIdx;
        }
      }
    }
    function findCode(setNode, targetCharCodes) {
      return (0, find_1.default)(setNode.value, function(codeOrRange) {
        if (typeof codeOrRange === "number") {
          return (0, includes_1.default)(targetCharCodes, codeOrRange);
        } else {
          var range_1 = codeOrRange;
          return (0, find_1.default)(targetCharCodes, function(targetCode) {
            return range_1.from <= targetCode && targetCode <= range_1.to;
          }) !== void 0;
        }
      });
    }
    function isWholeOptional(ast2) {
      var quantifier = ast2.quantifier;
      if (quantifier && quantifier.atLeast === 0) {
        return true;
      }
      if (!ast2.value) {
        return false;
      }
      return (0, isArray_1.default)(ast2.value) ? (0, every_1.default)(ast2.value, isWholeOptional) : isWholeOptional(ast2.value);
    }
    var CharCodeFinder = (
      /** @class */
      function(_super) {
        __extends(CharCodeFinder2, _super);
        function CharCodeFinder2(targetCharCodes) {
          var _this = _super.call(this) || this;
          _this.targetCharCodes = targetCharCodes;
          _this.found = false;
          return _this;
        }
        CharCodeFinder2.prototype.visitChildren = function(node) {
          if (this.found === true) {
            return;
          }
          switch (node.type) {
            case "Lookahead":
              this.visitLookahead(node);
              return;
            case "NegativeLookahead":
              this.visitNegativeLookahead(node);
              return;
          }
          _super.prototype.visitChildren.call(this, node);
        };
        CharCodeFinder2.prototype.visitCharacter = function(node) {
          if ((0, includes_1.default)(this.targetCharCodes, node.value)) {
            this.found = true;
          }
        };
        CharCodeFinder2.prototype.visitSet = function(node) {
          if (node.complement) {
            if (findCode(node, this.targetCharCodes) === void 0) {
              this.found = true;
            }
          } else {
            if (findCode(node, this.targetCharCodes) !== void 0) {
              this.found = true;
            }
          }
        };
        return CharCodeFinder2;
      }(regexp_to_ast_1.BaseRegExpVisitor)
    );
    function canMatchCharCode(charCodes, pattern) {
      if (pattern instanceof RegExp) {
        var ast2 = (0, reg_exp_parser_1.getRegExpAst)(pattern);
        var charCodeFinder = new CharCodeFinder(charCodes);
        charCodeFinder.visit(ast2);
        return charCodeFinder.found;
      } else {
        return (0, find_1.default)(pattern, function(char) {
          return (0, includes_1.default)(charCodes, char.charCodeAt(0));
        }) !== void 0;
      }
    }
    exports2.canMatchCharCode = canMatchCharCode;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/lexer.js
var require_lexer = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/lexer.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.charCodeToOptimizedIndex = exports2.minOptimizationVal = exports2.buildLineBreakIssueMessage = exports2.LineTerminatorOptimizedTester = exports2.isShortPattern = exports2.isCustomPattern = exports2.cloneEmptyGroups = exports2.performWarningRuntimeChecks = exports2.performRuntimeChecks = exports2.addStickyFlag = exports2.addStartOfInput = exports2.findUnreachablePatterns = exports2.findModesThatDoNotExist = exports2.findInvalidGroupType = exports2.findDuplicatePatterns = exports2.findUnsupportedFlags = exports2.findStartOfInputAnchor = exports2.findEmptyMatchRegExps = exports2.findEndOfInputAnchor = exports2.findInvalidPatterns = exports2.findMissingPatterns = exports2.validatePatterns = exports2.analyzeTokenTypes = exports2.enableSticky = exports2.disableSticky = exports2.SUPPORT_STICKY = exports2.MODES = exports2.DEFAULT_MODE = void 0;
    var regexp_to_ast_1 = require_regexp_to_ast();
    var lexer_public_1 = require_lexer_public();
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var values_1 = __importDefault(require_values());
    var flatten_1 = __importDefault(require_flatten());
    var reject_1 = __importDefault(require_reject());
    var difference_1 = __importDefault(require_difference());
    var indexOf_1 = __importDefault(require_indexOf());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var isString_1 = __importDefault(require_isString());
    var isFunction_1 = __importDefault(require_isFunction());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var find_1 = __importDefault(require_find());
    var has_1 = __importDefault(require_has());
    var keys_1 = __importDefault(require_keys());
    var isRegExp_1 = __importDefault(require_isRegExp());
    var filter_1 = __importDefault(require_filter());
    var defaults_1 = __importDefault(require_defaults());
    var reduce_1 = __importDefault(require_reduce());
    var includes_1 = __importDefault(require_includes());
    var utils_1 = require_api4();
    var reg_exp_1 = require_reg_exp();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var PATTERN = "PATTERN";
    exports2.DEFAULT_MODE = "defaultMode";
    exports2.MODES = "modes";
    exports2.SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
    function disableSticky() {
      exports2.SUPPORT_STICKY = false;
    }
    exports2.disableSticky = disableSticky;
    function enableSticky() {
      exports2.SUPPORT_STICKY = true;
    }
    exports2.enableSticky = enableSticky;
    function analyzeTokenTypes(tokenTypes, options) {
      options = (0, defaults_1.default)(options, {
        useSticky: exports2.SUPPORT_STICKY,
        debug: false,
        safeMode: false,
        positionTracking: "full",
        lineTerminatorCharacters: ["\r", "\n"],
        tracer: function(msg, action) {
          return action();
        }
      });
      var tracer = options.tracer;
      tracer("initCharCodeToOptimizedIndexMap", function() {
        initCharCodeToOptimizedIndexMap();
      });
      var onlyRelevantTypes;
      tracer("Reject Lexer.NA", function() {
        onlyRelevantTypes = (0, reject_1.default)(tokenTypes, function(currType) {
          return currType[PATTERN] === lexer_public_1.Lexer.NA;
        });
      });
      var hasCustom = false;
      var allTransformedPatterns;
      tracer("Transform Patterns", function() {
        hasCustom = false;
        allTransformedPatterns = (0, map_1.default)(onlyRelevantTypes, function(currType) {
          var currPattern = currType[PATTERN];
          if ((0, isRegExp_1.default)(currPattern)) {
            var regExpSource = currPattern.source;
            if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp
            regExpSource !== "^" && regExpSource !== "$" && regExpSource !== "." && !currPattern.ignoreCase) {
              return regExpSource;
            } else if (regExpSource.length === 2 && regExpSource[0] === "\\" && // not a meta character
            !(0, includes_1.default)([
              "d",
              "D",
              "s",
              "S",
              "t",
              "r",
              "n",
              "t",
              "0",
              "c",
              "b",
              "B",
              "f",
              "v",
              "w",
              "W"
            ], regExpSource[1])) {
              return regExpSource[1];
            } else {
              return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);
            }
          } else if ((0, isFunction_1.default)(currPattern)) {
            hasCustom = true;
            return { exec: currPattern };
          } else if (typeof currPattern === "object") {
            hasCustom = true;
            return currPattern;
          } else if (typeof currPattern === "string") {
            if (currPattern.length === 1) {
              return currPattern;
            } else {
              var escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
              var wrappedRegExp = new RegExp(escapedRegExpString);
              return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);
            }
          } else {
            throw Error("non exhaustive match");
          }
        });
      });
      var patternIdxToType;
      var patternIdxToGroup;
      var patternIdxToLongerAltIdxArr;
      var patternIdxToPushMode;
      var patternIdxToPopMode;
      tracer("misc mapping", function() {
        patternIdxToType = (0, map_1.default)(onlyRelevantTypes, function(currType) {
          return currType.tokenTypeIdx;
        });
        patternIdxToGroup = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          var groupName = clazz.GROUP;
          if (groupName === lexer_public_1.Lexer.SKIPPED) {
            return void 0;
          } else if ((0, isString_1.default)(groupName)) {
            return groupName;
          } else if ((0, isUndefined_1.default)(groupName)) {
            return false;
          } else {
            throw Error("non exhaustive match");
          }
        });
        patternIdxToLongerAltIdxArr = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          var longerAltType = clazz.LONGER_ALT;
          if (longerAltType) {
            var longerAltIdxArr = (0, isArray_1.default)(longerAltType) ? (0, map_1.default)(longerAltType, function(type) {
              return (0, indexOf_1.default)(onlyRelevantTypes, type);
            }) : [(0, indexOf_1.default)(onlyRelevantTypes, longerAltType)];
            return longerAltIdxArr;
          }
        });
        patternIdxToPushMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          return clazz.PUSH_MODE;
        });
        patternIdxToPopMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
          return (0, has_1.default)(clazz, "POP_MODE");
        });
      });
      var patternIdxToCanLineTerminator;
      tracer("Line Terminator Handling", function() {
        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
        patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
          return false;
        });
        if (options.positionTracking !== "onlyOffset") {
          patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
            if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
              return !!tokType.LINE_BREAKS;
            } else {
              return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
            }
          });
        }
      });
      var patternIdxToIsCustom;
      var patternIdxToShort;
      var emptyGroups;
      var patternIdxToConfig;
      tracer("Misc Mapping #2", function() {
        patternIdxToIsCustom = (0, map_1.default)(onlyRelevantTypes, isCustomPattern);
        patternIdxToShort = (0, map_1.default)(allTransformedPatterns, isShortPattern);
        emptyGroups = (0, reduce_1.default)(onlyRelevantTypes, function(acc, clazz) {
          var groupName = clazz.GROUP;
          if ((0, isString_1.default)(groupName) && !(groupName === lexer_public_1.Lexer.SKIPPED)) {
            acc[groupName] = [];
          }
          return acc;
        }, {});
        patternIdxToConfig = (0, map_1.default)(allTransformedPatterns, function(x, idx) {
          return {
            pattern: allTransformedPatterns[idx],
            longerAlt: patternIdxToLongerAltIdxArr[idx],
            canLineTerminator: patternIdxToCanLineTerminator[idx],
            isCustom: patternIdxToIsCustom[idx],
            short: patternIdxToShort[idx],
            group: patternIdxToGroup[idx],
            push: patternIdxToPushMode[idx],
            pop: patternIdxToPopMode[idx],
            tokenTypeIdx: patternIdxToType[idx],
            tokenType: onlyRelevantTypes[idx]
          };
        });
      });
      var canBeOptimized = true;
      var charCodeToPatternIdxToConfig = [];
      if (!options.safeMode) {
        tracer("First Char Optimization", function() {
          charCodeToPatternIdxToConfig = (0, reduce_1.default)(onlyRelevantTypes, function(result, currTokType, idx) {
            if (typeof currTokType.PATTERN === "string") {
              var charCode = currTokType.PATTERN.charCodeAt(0);
              var optimizedIdx = charCodeToOptimizedIndex(charCode);
              addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
            } else if ((0, isArray_1.default)(currTokType.START_CHARS_HINT)) {
              var lastOptimizedIdx_1;
              (0, forEach_1.default)(currTokType.START_CHARS_HINT, function(charOrInt) {
                var charCode2 = typeof charOrInt === "string" ? charOrInt.charCodeAt(0) : charOrInt;
                var currOptimizedIdx = charCodeToOptimizedIndex(charCode2);
                if (lastOptimizedIdx_1 !== currOptimizedIdx) {
                  lastOptimizedIdx_1 = currOptimizedIdx;
                  addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
                }
              });
            } else if ((0, isRegExp_1.default)(currTokType.PATTERN)) {
              if (currTokType.PATTERN.unicode) {
                canBeOptimized = false;
                if (options.ensureOptimizations) {
                  (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	Unable to analyze < ".concat(currTokType.PATTERN.toString(), " > pattern.\n") + "	The regexp unicode flag is not currently supported by the regexp-to-ast library.\n	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
                }
              } else {
                var optimizedCodes = (0, reg_exp_1.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);
                if ((0, isEmpty_1.default)(optimizedCodes)) {
                  canBeOptimized = false;
                }
                (0, forEach_1.default)(optimizedCodes, function(code) {
                  addToMapOfArrays(result, code, patternIdxToConfig[idx]);
                });
              }
            } else {
              if (options.ensureOptimizations) {
                (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	TokenType: <".concat(currTokType.name, "> is using a custom token pattern without providing <start_chars_hint> parameter.\n") + "	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
              }
              canBeOptimized = false;
            }
            return result;
          }, []);
        });
      }
      return {
        emptyGroups,
        patternIdxToConfig,
        charCodeToPatternIdxToConfig,
        hasCustom,
        canBeOptimized
      };
    }
    exports2.analyzeTokenTypes = analyzeTokenTypes;
    function validatePatterns(tokenTypes, validModesNames) {
      var errors = [];
      var missingResult = findMissingPatterns(tokenTypes);
      errors = errors.concat(missingResult.errors);
      var invalidResult = findInvalidPatterns(missingResult.valid);
      var validTokenTypes = invalidResult.valid;
      errors = errors.concat(invalidResult.errors);
      errors = errors.concat(validateRegExpPattern(validTokenTypes));
      errors = errors.concat(findInvalidGroupType(validTokenTypes));
      errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
      errors = errors.concat(findUnreachablePatterns(validTokenTypes));
      return errors;
    }
    exports2.validatePatterns = validatePatterns;
    function validateRegExpPattern(tokenTypes) {
      var errors = [];
      var withRegExpPatterns = (0, filter_1.default)(tokenTypes, function(currTokType) {
        return (0, isRegExp_1.default)(currTokType[PATTERN]);
      });
      errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
      errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
      errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
      errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
      errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
      return errors;
    }
    function findMissingPatterns(tokenTypes) {
      var tokenTypesWithMissingPattern = (0, filter_1.default)(tokenTypes, function(currType) {
        return !(0, has_1.default)(currType, PATTERN);
      });
      var errors = (0, map_1.default)(tokenTypesWithMissingPattern, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- missing static 'PATTERN' property",
          type: lexer_public_1.LexerDefinitionErrorType.MISSING_PATTERN,
          tokenTypes: [currType]
        };
      });
      var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithMissingPattern);
      return { errors, valid };
    }
    exports2.findMissingPatterns = findMissingPatterns;
    function findInvalidPatterns(tokenTypes) {
      var tokenTypesWithInvalidPattern = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        return !(0, isRegExp_1.default)(pattern) && !(0, isFunction_1.default)(pattern) && !(0, has_1.default)(pattern, "exec") && !(0, isString_1.default)(pattern);
      });
      var errors = (0, map_1.default)(tokenTypesWithInvalidPattern, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
          type: lexer_public_1.LexerDefinitionErrorType.INVALID_PATTERN,
          tokenTypes: [currType]
        };
      });
      var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithInvalidPattern);
      return { errors, valid };
    }
    exports2.findInvalidPatterns = findInvalidPatterns;
    var end_of_input = /[^\\][$]/;
    function findEndOfInputAnchor(tokenTypes) {
      var EndAnchorFinder = (
        /** @class */
        function(_super) {
          __extends(EndAnchorFinder2, _super);
          function EndAnchorFinder2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
          }
          EndAnchorFinder2.prototype.visitEndAnchor = function(node) {
            this.found = true;
          };
          return EndAnchorFinder2;
        }(regexp_to_ast_1.BaseRegExpVisitor)
      );
      var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        try {
          var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
          var endAnchorVisitor = new EndAnchorFinder();
          endAnchorVisitor.visit(regexpAst);
          return endAnchorVisitor.found;
        } catch (e) {
          return end_of_input.test(pattern.source);
        }
      });
      var errors = (0, map_1.default)(invalidRegex, function(currType) {
        return {
          message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain end of input anchor '$'\n	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findEndOfInputAnchor = findEndOfInputAnchor;
    function findEmptyMatchRegExps(tokenTypes) {
      var matchesEmptyString = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        return pattern.test("");
      });
      var errors = (0, map_1.default)(matchesEmptyString, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' must not match an empty string",
          type: lexer_public_1.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findEmptyMatchRegExps = findEmptyMatchRegExps;
    var start_of_input = /[^\\[][\^]|^\^/;
    function findStartOfInputAnchor(tokenTypes) {
      var StartAnchorFinder = (
        /** @class */
        function(_super) {
          __extends(StartAnchorFinder2, _super);
          function StartAnchorFinder2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
          }
          StartAnchorFinder2.prototype.visitStartAnchor = function(node) {
            this.found = true;
          };
          return StartAnchorFinder2;
        }(regexp_to_ast_1.BaseRegExpVisitor)
      );
      var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType.PATTERN;
        try {
          var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
          var startAnchorVisitor = new StartAnchorFinder();
          startAnchorVisitor.visit(regexpAst);
          return startAnchorVisitor.found;
        } catch (e) {
          return start_of_input.test(pattern.source);
        }
      });
      var errors = (0, map_1.default)(invalidRegex, function(currType) {
        return {
          message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain start of input anchor '^'\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findStartOfInputAnchor = findStartOfInputAnchor;
    function findUnsupportedFlags(tokenTypes) {
      var invalidFlags = (0, filter_1.default)(tokenTypes, function(currType) {
        var pattern = currType[PATTERN];
        return pattern instanceof RegExp && (pattern.multiline || pattern.global);
      });
      var errors = (0, map_1.default)(invalidFlags, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
          type: lexer_public_1.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findUnsupportedFlags = findUnsupportedFlags;
    function findDuplicatePatterns(tokenTypes) {
      var found = [];
      var identicalPatterns = (0, map_1.default)(tokenTypes, function(outerType) {
        return (0, reduce_1.default)(tokenTypes, function(result, innerType) {
          if (outerType.PATTERN.source === innerType.PATTERN.source && !(0, includes_1.default)(found, innerType) && innerType.PATTERN !== lexer_public_1.Lexer.NA) {
            found.push(innerType);
            result.push(innerType);
            return result;
          }
          return result;
        }, []);
      });
      identicalPatterns = (0, compact_1.default)(identicalPatterns);
      var duplicatePatterns = (0, filter_1.default)(identicalPatterns, function(currIdenticalSet) {
        return currIdenticalSet.length > 1;
      });
      var errors = (0, map_1.default)(duplicatePatterns, function(setOfIdentical) {
        var tokenTypeNames = (0, map_1.default)(setOfIdentical, function(currType) {
          return currType.name;
        });
        var dupPatternSrc = (0, first_1.default)(setOfIdentical).PATTERN;
        return {
          message: "The same RegExp pattern ->".concat(dupPatternSrc, "<-") + "has been used in all of the following Token Types: ".concat(tokenTypeNames.join(", "), " <-"),
          type: lexer_public_1.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
          tokenTypes: setOfIdentical
        };
      });
      return errors;
    }
    exports2.findDuplicatePatterns = findDuplicatePatterns;
    function findInvalidGroupType(tokenTypes) {
      var invalidTypes = (0, filter_1.default)(tokenTypes, function(clazz) {
        if (!(0, has_1.default)(clazz, "GROUP")) {
          return false;
        }
        var group = clazz.GROUP;
        return group !== lexer_public_1.Lexer.SKIPPED && group !== lexer_public_1.Lexer.NA && !(0, isString_1.default)(group);
      });
      var errors = (0, map_1.default)(invalidTypes, function(currType) {
        return {
          message: "Token Type: ->" + currType.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
          type: lexer_public_1.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
          tokenTypes: [currType]
        };
      });
      return errors;
    }
    exports2.findInvalidGroupType = findInvalidGroupType;
    function findModesThatDoNotExist(tokenTypes, validModes) {
      var invalidModes = (0, filter_1.default)(tokenTypes, function(clazz) {
        return clazz.PUSH_MODE !== void 0 && !(0, includes_1.default)(validModes, clazz.PUSH_MODE);
      });
      var errors = (0, map_1.default)(invalidModes, function(tokType) {
        var msg = "Token Type: ->".concat(tokType.name, "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->").concat(tokType.PUSH_MODE, "<-") + "which does not exist";
        return {
          message: msg,
          type: lexer_public_1.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
          tokenTypes: [tokType]
        };
      });
      return errors;
    }
    exports2.findModesThatDoNotExist = findModesThatDoNotExist;
    function findUnreachablePatterns(tokenTypes) {
      var errors = [];
      var canBeTested = (0, reduce_1.default)(tokenTypes, function(result, tokType, idx) {
        var pattern = tokType.PATTERN;
        if (pattern === lexer_public_1.Lexer.NA) {
          return result;
        }
        if ((0, isString_1.default)(pattern)) {
          result.push({ str: pattern, idx, tokenType: tokType });
        } else if ((0, isRegExp_1.default)(pattern) && noMetaChar(pattern)) {
          result.push({ str: pattern.source, idx, tokenType: tokType });
        }
        return result;
      }, []);
      (0, forEach_1.default)(tokenTypes, function(tokType, testIdx) {
        (0, forEach_1.default)(canBeTested, function(_a) {
          var str = _a.str, idx = _a.idx, tokenType = _a.tokenType;
          if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
            var msg = "Token: ->".concat(tokenType.name, "<- can never be matched.\n") + "Because it appears AFTER the Token Type ->".concat(tokType.name, "<-") + "in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
            errors.push({
              message: msg,
              type: lexer_public_1.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
              tokenTypes: [tokType, tokenType]
            });
          }
        });
      });
      return errors;
    }
    exports2.findUnreachablePatterns = findUnreachablePatterns;
    function testTokenType(str, pattern) {
      if ((0, isRegExp_1.default)(pattern)) {
        var regExpArray = pattern.exec(str);
        return regExpArray !== null && regExpArray.index === 0;
      } else if ((0, isFunction_1.default)(pattern)) {
        return pattern(str, 0, [], {});
      } else if ((0, has_1.default)(pattern, "exec")) {
        return pattern.exec(str, 0, [], {});
      } else if (typeof pattern === "string") {
        return pattern === str;
      } else {
        throw Error("non exhaustive match");
      }
    }
    function noMetaChar(regExp) {
      var metaChars = [
        ".",
        "\\",
        "[",
        "]",
        "|",
        "^",
        "$",
        "(",
        ")",
        "?",
        "*",
        "+",
        "{"
      ];
      return (0, find_1.default)(metaChars, function(char) {
        return regExp.source.indexOf(char) !== -1;
      }) === void 0;
    }
    function addStartOfInput(pattern) {
      var flags = pattern.ignoreCase ? "i" : "";
      return new RegExp("^(?:".concat(pattern.source, ")"), flags);
    }
    exports2.addStartOfInput = addStartOfInput;
    function addStickyFlag(pattern) {
      var flags = pattern.ignoreCase ? "iy" : "y";
      return new RegExp("".concat(pattern.source), flags);
    }
    exports2.addStickyFlag = addStickyFlag;
    function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
      var errors = [];
      if (!(0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized without a <" + exports2.DEFAULT_MODE + "> property in its definition\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
        });
      }
      if (!(0, has_1.default)(lexerDefinition, exports2.MODES)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized without a <" + exports2.MODES + "> property in its definition\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
        });
      }
      if ((0, has_1.default)(lexerDefinition, exports2.MODES) && (0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE) && !(0, has_1.default)(lexerDefinition.modes, lexerDefinition.defaultMode)) {
        errors.push({
          message: "A MultiMode Lexer cannot be initialized with a ".concat(exports2.DEFAULT_MODE, ": <").concat(lexerDefinition.defaultMode, ">") + "which does not exist\n",
          type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
        });
      }
      if ((0, has_1.default)(lexerDefinition, exports2.MODES)) {
        (0, forEach_1.default)(lexerDefinition.modes, function(currModeValue, currModeName) {
          (0, forEach_1.default)(currModeValue, function(currTokType, currIdx) {
            if ((0, isUndefined_1.default)(currTokType)) {
              errors.push({
                message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + "<".concat(currModeName, "> at index: <").concat(currIdx, ">\n"),
                type: lexer_public_1.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
              });
            } else if ((0, has_1.default)(currTokType, "LONGER_ALT")) {
              var longerAlt = (0, isArray_1.default)(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];
              (0, forEach_1.default)(longerAlt, function(currLongerAlt) {
                if (!(0, isUndefined_1.default)(currLongerAlt) && !(0, includes_1.default)(currModeValue, currLongerAlt)) {
                  errors.push({
                    message: "A MultiMode Lexer cannot be initialized with a longer_alt <".concat(currLongerAlt.name, "> on token <").concat(currTokType.name, "> outside of mode <").concat(currModeName, ">\n"),
                    type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
                  });
                }
              });
            }
          });
        });
      }
      return errors;
    }
    exports2.performRuntimeChecks = performRuntimeChecks;
    function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
      var warnings = [];
      var hasAnyLineBreak = false;
      var allTokenTypes = (0, compact_1.default)((0, flatten_1.default)((0, values_1.default)(lexerDefinition.modes)));
      var concreteTokenTypes = (0, reject_1.default)(allTokenTypes, function(currType) {
        return currType[PATTERN] === lexer_public_1.Lexer.NA;
      });
      var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
      if (trackLines) {
        (0, forEach_1.default)(concreteTokenTypes, function(tokType) {
          var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
          if (currIssue !== false) {
            var message = buildLineBreakIssueMessage(tokType, currIssue);
            var warningDescriptor = {
              message,
              type: currIssue.issue,
              tokenType: tokType
            };
            warnings.push(warningDescriptor);
          } else {
            if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
              if (tokType.LINE_BREAKS === true) {
                hasAnyLineBreak = true;
              }
            } else {
              if ((0, reg_exp_1.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) {
                hasAnyLineBreak = true;
              }
            }
          }
        });
      }
      if (trackLines && !hasAnyLineBreak) {
        warnings.push({
          message: "Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.",
          type: lexer_public_1.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
        });
      }
      return warnings;
    }
    exports2.performWarningRuntimeChecks = performWarningRuntimeChecks;
    function cloneEmptyGroups(emptyGroups) {
      var clonedResult = {};
      var groupKeys = (0, keys_1.default)(emptyGroups);
      (0, forEach_1.default)(groupKeys, function(currKey) {
        var currGroupValue = emptyGroups[currKey];
        if ((0, isArray_1.default)(currGroupValue)) {
          clonedResult[currKey] = [];
        } else {
          throw Error("non exhaustive match");
        }
      });
      return clonedResult;
    }
    exports2.cloneEmptyGroups = cloneEmptyGroups;
    function isCustomPattern(tokenType) {
      var pattern = tokenType.PATTERN;
      if ((0, isRegExp_1.default)(pattern)) {
        return false;
      } else if ((0, isFunction_1.default)(pattern)) {
        return true;
      } else if ((0, has_1.default)(pattern, "exec")) {
        return true;
      } else if ((0, isString_1.default)(pattern)) {
        return false;
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.isCustomPattern = isCustomPattern;
    function isShortPattern(pattern) {
      if ((0, isString_1.default)(pattern) && pattern.length === 1) {
        return pattern.charCodeAt(0);
      } else {
        return false;
      }
    }
    exports2.isShortPattern = isShortPattern;
    exports2.LineTerminatorOptimizedTester = {
      // implements /\n|\r\n?/g.test
      test: function(text) {
        var len = text.length;
        for (var i = this.lastIndex; i < len; i++) {
          var c = text.charCodeAt(i);
          if (c === 10) {
            this.lastIndex = i + 1;
            return true;
          } else if (c === 13) {
            if (text.charCodeAt(i + 1) === 10) {
              this.lastIndex = i + 2;
            } else {
              this.lastIndex = i + 1;
            }
            return true;
          }
        }
        return false;
      },
      lastIndex: 0
    };
    function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
      if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
        return false;
      } else {
        if ((0, isRegExp_1.default)(tokType.PATTERN)) {
          try {
            (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
          } catch (e) {
            return {
              issue: lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
              errMsg: e.message
            };
          }
          return false;
        } else if ((0, isString_1.default)(tokType.PATTERN)) {
          return false;
        } else if (isCustomPattern(tokType)) {
          return { issue: lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
        } else {
          throw Error("non exhaustive match");
        }
      }
    }
    function buildLineBreakIssueMessage(tokType, details) {
      if (details.issue === lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
        return "Warning: unable to identify line terminator usage in pattern.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	 Root cause: ".concat(details.errMsg, ".\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
      } else if (details.issue === lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
        return "Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.buildLineBreakIssueMessage = buildLineBreakIssueMessage;
    function getCharCodes(charsOrCodes) {
      var charCodes = (0, map_1.default)(charsOrCodes, function(numOrString) {
        if ((0, isString_1.default)(numOrString)) {
          return numOrString.charCodeAt(0);
        } else {
          return numOrString;
        }
      });
      return charCodes;
    }
    function addToMapOfArrays(map, key, value) {
      if (map[key] === void 0) {
        map[key] = [value];
      } else {
        map[key].push(value);
      }
    }
    exports2.minOptimizationVal = 256;
    var charCodeToOptimizedIdxMap = [];
    function charCodeToOptimizedIndex(charCode) {
      return charCode < exports2.minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];
    }
    exports2.charCodeToOptimizedIndex = charCodeToOptimizedIndex;
    function initCharCodeToOptimizedIndexMap() {
      if ((0, isEmpty_1.default)(charCodeToOptimizedIdxMap)) {
        charCodeToOptimizedIdxMap = new Array(65536);
        for (var i = 0; i < 65536; i++) {
          charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/last.js
var require_last = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/last.js"(exports2, module2) {
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    module2.exports = last;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/tokens.js
var require_tokens = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/tokens.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTokenType = exports2.hasExtendingTokensTypesMapProperty = exports2.hasExtendingTokensTypesProperty = exports2.hasCategoriesProperty = exports2.hasShortKeyProperty = exports2.singleAssignCategoriesToksMap = exports2.assignCategoriesMapProp = exports2.assignCategoriesTokensProp = exports2.assignTokenDefaultProps = exports2.expandCategories = exports2.augmentTokenTypes = exports2.tokenIdxToClass = exports2.tokenShortNameIdx = exports2.tokenStructuredMatcherNoCategories = exports2.tokenStructuredMatcher = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var flatten_1 = __importDefault(require_flatten());
    var difference_1 = __importDefault(require_difference());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var includes_1 = __importDefault(require_includes());
    var clone_1 = __importDefault(require_clone());
    function tokenStructuredMatcher(tokInstance, tokConstructor) {
      var instanceType = tokInstance.tokenTypeIdx;
      if (instanceType === tokConstructor.tokenTypeIdx) {
        return true;
      } else {
        return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;
      }
    }
    exports2.tokenStructuredMatcher = tokenStructuredMatcher;
    function tokenStructuredMatcherNoCategories(token, tokType) {
      return token.tokenTypeIdx === tokType.tokenTypeIdx;
    }
    exports2.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;
    exports2.tokenShortNameIdx = 1;
    exports2.tokenIdxToClass = {};
    function augmentTokenTypes(tokenTypes) {
      var tokenTypesAndParents = expandCategories(tokenTypes);
      assignTokenDefaultProps(tokenTypesAndParents);
      assignCategoriesMapProp(tokenTypesAndParents);
      assignCategoriesTokensProp(tokenTypesAndParents);
      (0, forEach_1.default)(tokenTypesAndParents, function(tokType) {
        tokType.isParent = tokType.categoryMatches.length > 0;
      });
    }
    exports2.augmentTokenTypes = augmentTokenTypes;
    function expandCategories(tokenTypes) {
      var result = (0, clone_1.default)(tokenTypes);
      var categories = tokenTypes;
      var searching = true;
      while (searching) {
        categories = (0, compact_1.default)((0, flatten_1.default)((0, map_1.default)(categories, function(currTokType) {
          return currTokType.CATEGORIES;
        })));
        var newCategories = (0, difference_1.default)(categories, result);
        result = result.concat(newCategories);
        if ((0, isEmpty_1.default)(newCategories)) {
          searching = false;
        } else {
          categories = newCategories;
        }
      }
      return result;
    }
    exports2.expandCategories = expandCategories;
    function assignTokenDefaultProps(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        if (!hasShortKeyProperty(currTokType)) {
          exports2.tokenIdxToClass[exports2.tokenShortNameIdx] = currTokType;
          currTokType.tokenTypeIdx = exports2.tokenShortNameIdx++;
        }
        if (hasCategoriesProperty(currTokType) && !(0, isArray_1.default)(currTokType.CATEGORIES)) {
          currTokType.CATEGORIES = [currTokType.CATEGORIES];
        }
        if (!hasCategoriesProperty(currTokType)) {
          currTokType.CATEGORIES = [];
        }
        if (!hasExtendingTokensTypesProperty(currTokType)) {
          currTokType.categoryMatches = [];
        }
        if (!hasExtendingTokensTypesMapProperty(currTokType)) {
          currTokType.categoryMatchesMap = {};
        }
      });
    }
    exports2.assignTokenDefaultProps = assignTokenDefaultProps;
    function assignCategoriesTokensProp(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        currTokType.categoryMatches = [];
        (0, forEach_1.default)(currTokType.categoryMatchesMap, function(val, key) {
          currTokType.categoryMatches.push(exports2.tokenIdxToClass[key].tokenTypeIdx);
        });
      });
    }
    exports2.assignCategoriesTokensProp = assignCategoriesTokensProp;
    function assignCategoriesMapProp(tokenTypes) {
      (0, forEach_1.default)(tokenTypes, function(currTokType) {
        singleAssignCategoriesToksMap([], currTokType);
      });
    }
    exports2.assignCategoriesMapProp = assignCategoriesMapProp;
    function singleAssignCategoriesToksMap(path2, nextNode) {
      (0, forEach_1.default)(path2, function(pathNode) {
        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
      });
      (0, forEach_1.default)(nextNode.CATEGORIES, function(nextCategory) {
        var newPath = path2.concat(nextNode);
        if (!(0, includes_1.default)(newPath, nextCategory)) {
          singleAssignCategoriesToksMap(newPath, nextCategory);
        }
      });
    }
    exports2.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;
    function hasShortKeyProperty(tokType) {
      return (0, has_1.default)(tokType, "tokenTypeIdx");
    }
    exports2.hasShortKeyProperty = hasShortKeyProperty;
    function hasCategoriesProperty(tokType) {
      return (0, has_1.default)(tokType, "CATEGORIES");
    }
    exports2.hasCategoriesProperty = hasCategoriesProperty;
    function hasExtendingTokensTypesProperty(tokType) {
      return (0, has_1.default)(tokType, "categoryMatches");
    }
    exports2.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;
    function hasExtendingTokensTypesMapProperty(tokType) {
      return (0, has_1.default)(tokType, "categoryMatchesMap");
    }
    exports2.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;
    function isTokenType(tokType) {
      return (0, has_1.default)(tokType, "tokenTypeIdx");
    }
    exports2.isTokenType = isTokenType;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/lexer_errors_public.js
var require_lexer_errors_public = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/lexer_errors_public.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultLexerErrorProvider = void 0;
    exports2.defaultLexerErrorProvider = {
      buildUnableToPopLexerModeMessage: function(token) {
        return "Unable to pop Lexer Mode after encountering Token ->".concat(token.image, "<- The Mode Stack is empty");
      },
      buildUnexpectedCharactersMessage: function(fullText, startOffset, length, line, column) {
        return "unexpected character: ->".concat(fullText.charAt(startOffset), "<- at offset: ").concat(startOffset, ",") + " skipped ".concat(length, " characters.");
      }
    };
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/lexer_public.js
var require_lexer_public = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/lexer_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Lexer = exports2.LexerDefinitionErrorType = void 0;
    var lexer_1 = require_lexer();
    var noop_1 = __importDefault(require_noop());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var isArray_1 = __importDefault(require_isArray());
    var last_1 = __importDefault(require_last());
    var reject_1 = __importDefault(require_reject());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var keys_1 = __importDefault(require_keys());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var identity_1 = __importDefault(require_identity());
    var assign_1 = __importDefault(require_assign());
    var reduce_1 = __importDefault(require_reduce());
    var clone_1 = __importDefault(require_clone());
    var utils_1 = require_api4();
    var tokens_1 = require_tokens();
    var lexer_errors_public_1 = require_lexer_errors_public();
    var reg_exp_parser_1 = require_reg_exp_parser();
    var LexerDefinitionErrorType;
    (function(LexerDefinitionErrorType2) {
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"] = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
    })(LexerDefinitionErrorType = exports2.LexerDefinitionErrorType || (exports2.LexerDefinitionErrorType = {}));
    var DEFAULT_LEXER_CONFIG = {
      deferDefinitionErrorsHandling: false,
      positionTracking: "full",
      lineTerminatorsPattern: /\n|\r\n?/g,
      lineTerminatorCharacters: ["\n", "\r"],
      ensureOptimizations: false,
      safeMode: false,
      errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,
      traceInitPerf: false,
      skipValidations: false,
      recoveryEnabled: true
    };
    Object.freeze(DEFAULT_LEXER_CONFIG);
    var Lexer = (
      /** @class */
      function() {
        function Lexer2(lexerDefinition, config) {
          if (config === void 0) {
            config = DEFAULT_LEXER_CONFIG;
          }
          var _this = this;
          this.lexerDefinition = lexerDefinition;
          this.lexerDefinitionErrors = [];
          this.lexerDefinitionWarning = [];
          this.patternIdxToConfig = {};
          this.charCodeToPatternIdxToConfig = {};
          this.modes = [];
          this.emptyGroups = {};
          this.trackStartLines = true;
          this.trackEndLines = true;
          this.hasCustom = false;
          this.canModeBeOptimized = {};
          this.TRACE_INIT = function(phaseDesc, phaseImpl) {
            if (_this.traceInitPerf === true) {
              _this.traceInitIndent++;
              var indent = new Array(_this.traceInitIndent + 1).join("	");
              if (_this.traceInitIndent < _this.traceInitMaxIdent) {
                console.log("".concat(indent, "--> <").concat(phaseDesc, ">"));
              }
              var _a = (0, utils_1.timer)(phaseImpl), time = _a.time, value = _a.value;
              var traceMethod = time > 10 ? console.warn : console.log;
              if (_this.traceInitIndent < _this.traceInitMaxIdent) {
                traceMethod("".concat(indent, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
              }
              _this.traceInitIndent--;
              return value;
            } else {
              return phaseImpl();
            }
          };
          if (typeof config === "boolean") {
            throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");
          }
          this.config = (0, assign_1.default)({}, DEFAULT_LEXER_CONFIG, config);
          var traceInitVal = this.config.traceInitPerf;
          if (traceInitVal === true) {
            this.traceInitMaxIdent = Infinity;
            this.traceInitPerf = true;
          } else if (typeof traceInitVal === "number") {
            this.traceInitMaxIdent = traceInitVal;
            this.traceInitPerf = true;
          }
          this.traceInitIndent = -1;
          this.TRACE_INIT("Lexer Constructor", function() {
            var actualDefinition;
            var hasOnlySingleMode = true;
            _this.TRACE_INIT("Lexer Config handling", function() {
              if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
                _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;
              } else {
                if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
                  throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
                }
              }
              if (config.safeMode && config.ensureOptimizations) {
                throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
              }
              _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);
              _this.trackEndLines = /full/i.test(_this.config.positionTracking);
              if ((0, isArray_1.default)(lexerDefinition)) {
                actualDefinition = {
                  modes: { defaultMode: (0, clone_1.default)(lexerDefinition) },
                  defaultMode: lexer_1.DEFAULT_MODE
                };
              } else {
                hasOnlySingleMode = false;
                actualDefinition = (0, clone_1.default)(lexerDefinition);
              }
            });
            if (_this.config.skipValidations === false) {
              _this.TRACE_INIT("performRuntimeChecks", function() {
                _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
              });
              _this.TRACE_INIT("performWarningRuntimeChecks", function() {
                _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0, lexer_1.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
              });
            }
            actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};
            (0, forEach_1.default)(actualDefinition.modes, function(currModeValue, currModeName) {
              actualDefinition.modes[currModeName] = (0, reject_1.default)(currModeValue, function(currTokType) {
                return (0, isUndefined_1.default)(currTokType);
              });
            });
            var allModeNames = (0, keys_1.default)(actualDefinition.modes);
            (0, forEach_1.default)(actualDefinition.modes, function(currModDef, currModName) {
              _this.TRACE_INIT("Mode: <".concat(currModName, "> processing"), function() {
                _this.modes.push(currModName);
                if (_this.config.skipValidations === false) {
                  _this.TRACE_INIT("validatePatterns", function() {
                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.validatePatterns)(currModDef, allModeNames));
                  });
                }
                if ((0, isEmpty_1.default)(_this.lexerDefinitionErrors)) {
                  (0, tokens_1.augmentTokenTypes)(currModDef);
                  var currAnalyzeResult_1;
                  _this.TRACE_INIT("analyzeTokenTypes", function() {
                    currAnalyzeResult_1 = (0, lexer_1.analyzeTokenTypes)(currModDef, {
                      lineTerminatorCharacters: _this.config.lineTerminatorCharacters,
                      positionTracking: config.positionTracking,
                      ensureOptimizations: config.ensureOptimizations,
                      safeMode: config.safeMode,
                      tracer: _this.TRACE_INIT
                    });
                  });
                  _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;
                  _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;
                  _this.emptyGroups = (0, assign_1.default)({}, _this.emptyGroups, currAnalyzeResult_1.emptyGroups);
                  _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;
                  _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;
                }
              });
            });
            _this.defaultMode = actualDefinition.defaultMode;
            if (!(0, isEmpty_1.default)(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {
              var allErrMessages = (0, map_1.default)(_this.lexerDefinitionErrors, function(error) {
                return error.message;
              });
              var allErrMessagesString = allErrMessages.join("-----------------------\n");
              throw new Error("Errors detected in definition of Lexer:\n" + allErrMessagesString);
            }
            (0, forEach_1.default)(_this.lexerDefinitionWarning, function(warningDescriptor) {
              (0, utils_1.PRINT_WARNING)(warningDescriptor.message);
            });
            _this.TRACE_INIT("Choosing sub-methods implementations", function() {
              if (lexer_1.SUPPORT_STICKY) {
                _this.chopInput = identity_1.default;
                _this.match = _this.matchWithTest;
              } else {
                _this.updateLastIndex = noop_1.default;
                _this.match = _this.matchWithExec;
              }
              if (hasOnlySingleMode) {
                _this.handleModes = noop_1.default;
              }
              if (_this.trackStartLines === false) {
                _this.computeNewColumn = identity_1.default;
              }
              if (_this.trackEndLines === false) {
                _this.updateTokenEndLineColumnLocation = noop_1.default;
              }
              if (/full/i.test(_this.config.positionTracking)) {
                _this.createTokenInstance = _this.createFullToken;
              } else if (/onlyStart/i.test(_this.config.positionTracking)) {
                _this.createTokenInstance = _this.createStartOnlyToken;
              } else if (/onlyOffset/i.test(_this.config.positionTracking)) {
                _this.createTokenInstance = _this.createOffsetOnlyToken;
              } else {
                throw Error('Invalid <positionTracking> config option: "'.concat(_this.config.positionTracking, '"'));
              }
              if (_this.hasCustom) {
                _this.addToken = _this.addTokenUsingPush;
                _this.handlePayload = _this.handlePayloadWithCustom;
              } else {
                _this.addToken = _this.addTokenUsingMemberAccess;
                _this.handlePayload = _this.handlePayloadNoCustom;
              }
            });
            _this.TRACE_INIT("Failed Optimization Warnings", function() {
              var unOptimizedModes = (0, reduce_1.default)(_this.canModeBeOptimized, function(cannotBeOptimized, canBeOptimized, modeName) {
                if (canBeOptimized === false) {
                  cannotBeOptimized.push(modeName);
                }
                return cannotBeOptimized;
              }, []);
              if (config.ensureOptimizations && !(0, isEmpty_1.default)(unOptimizedModes)) {
                throw Error("Lexer Modes: < ".concat(unOptimizedModes.join(", "), " > cannot be optimized.\n") + '	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n	 Or inspect the console log for details on how to resolve these issues.');
              }
            });
            _this.TRACE_INIT("clearRegExpParserCache", function() {
              (0, reg_exp_parser_1.clearRegExpParserCache)();
            });
            _this.TRACE_INIT("toFastProperties", function() {
              (0, utils_1.toFastProperties)(_this);
            });
          });
        }
        Lexer2.prototype.tokenize = function(text, initialMode) {
          if (initialMode === void 0) {
            initialMode = this.defaultMode;
          }
          if (!(0, isEmpty_1.default)(this.lexerDefinitionErrors)) {
            var allErrMessages = (0, map_1.default)(this.lexerDefinitionErrors, function(error) {
              return error.message;
            });
            var allErrMessagesString = allErrMessages.join("-----------------------\n");
            throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + allErrMessagesString);
          }
          return this.tokenizeInternal(text, initialMode);
        };
        Lexer2.prototype.tokenizeInternal = function(text, initialMode) {
          var _this = this;
          var i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
          var orgText = text;
          var orgLength = orgText.length;
          var offset = 0;
          var matchedTokensIndex = 0;
          var guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);
          var matchedTokens = new Array(guessedNumberOfTokens);
          var errors = [];
          var line = this.trackStartLines ? 1 : void 0;
          var column = this.trackStartLines ? 1 : void 0;
          var groups = (0, lexer_1.cloneEmptyGroups)(this.emptyGroups);
          var trackLines = this.trackStartLines;
          var lineTerminatorPattern = this.config.lineTerminatorsPattern;
          var currModePatternsLength = 0;
          var patternIdxToConfig = [];
          var currCharCodeToPatternIdxToConfig = [];
          var modeStack = [];
          var emptyArray = [];
          Object.freeze(emptyArray);
          var getPossiblePatterns;
          function getPossiblePatternsSlow() {
            return patternIdxToConfig;
          }
          function getPossiblePatternsOptimized(charCode) {
            var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(charCode);
            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
            if (possiblePatterns === void 0) {
              return emptyArray;
            } else {
              return possiblePatterns;
            }
          }
          var pop_mode = function(popToken) {
            if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
            // So no error should occur.
            popToken.tokenType.PUSH_MODE === void 0) {
              var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
              errors.push({
                offset: popToken.startOffset,
                line: popToken.startLine,
                column: popToken.startColumn,
                length: popToken.image.length,
                message: msg_1
              });
            } else {
              modeStack.pop();
              var newMode = (0, last_1.default)(modeStack);
              patternIdxToConfig = _this.patternIdxToConfig[newMode];
              currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];
              currModePatternsLength = patternIdxToConfig.length;
              var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;
              if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                getPossiblePatterns = getPossiblePatternsOptimized;
              } else {
                getPossiblePatterns = getPossiblePatternsSlow;
              }
            }
          };
          function push_mode(newMode) {
            modeStack.push(newMode);
            currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
            patternIdxToConfig = this.patternIdxToConfig[newMode];
            currModePatternsLength = patternIdxToConfig.length;
            currModePatternsLength = patternIdxToConfig.length;
            var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
              getPossiblePatterns = getPossiblePatternsOptimized;
            } else {
              getPossiblePatterns = getPossiblePatternsSlow;
            }
          }
          push_mode.call(this, initialMode);
          var currConfig;
          var recoveryEnabled = this.config.recoveryEnabled;
          while (offset < orgLength) {
            matchedImage = null;
            var nextCharCode = orgText.charCodeAt(offset);
            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
            var chosenPatternsLength = chosenPatternIdxToConfig.length;
            for (i = 0; i < chosenPatternsLength; i++) {
              currConfig = chosenPatternIdxToConfig[i];
              var currPattern = currConfig.pattern;
              payload = null;
              var singleCharCode = currConfig.short;
              if (singleCharCode !== false) {
                if (nextCharCode === singleCharCode) {
                  matchedImage = currPattern;
                }
              } else if (currConfig.isCustom === true) {
                match = currPattern.exec(orgText, offset, matchedTokens, groups);
                if (match !== null) {
                  matchedImage = match[0];
                  if (match.payload !== void 0) {
                    payload = match.payload;
                  }
                } else {
                  matchedImage = null;
                }
              } else {
                this.updateLastIndex(currPattern, offset);
                matchedImage = this.match(currPattern, text, offset);
              }
              if (matchedImage !== null) {
                longerAlt = currConfig.longerAlt;
                if (longerAlt !== void 0) {
                  var longerAltLength = longerAlt.length;
                  for (k = 0; k < longerAltLength; k++) {
                    var longerAltConfig = patternIdxToConfig[longerAlt[k]];
                    var longerAltPattern = longerAltConfig.pattern;
                    altPayload = null;
                    if (longerAltConfig.isCustom === true) {
                      match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                      if (match !== null) {
                        matchAltImage = match[0];
                        if (match.payload !== void 0) {
                          altPayload = match.payload;
                        }
                      } else {
                        matchAltImage = null;
                      }
                    } else {
                      this.updateLastIndex(longerAltPattern, offset);
                      matchAltImage = this.match(longerAltPattern, text, offset);
                    }
                    if (matchAltImage && matchAltImage.length > matchedImage.length) {
                      matchedImage = matchAltImage;
                      payload = altPayload;
                      currConfig = longerAltConfig;
                      break;
                    }
                  }
                }
                break;
              }
            }
            if (matchedImage !== null) {
              imageLength = matchedImage.length;
              group = currConfig.group;
              if (group !== void 0) {
                tokType = currConfig.tokenTypeIdx;
                newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
                this.handlePayload(newToken, payload);
                if (group === false) {
                  matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
                } else {
                  groups[group].push(newToken);
                }
              }
              text = this.chopInput(text, imageLength);
              offset = offset + imageLength;
              column = this.computeNewColumn(column, imageLength);
              if (trackLines === true && currConfig.canLineTerminator === true) {
                var numOfLTsInMatch = 0;
                var foundTerminator = void 0;
                var lastLTEndOffset = void 0;
                lineTerminatorPattern.lastIndex = 0;
                do {
                  foundTerminator = lineTerminatorPattern.test(matchedImage);
                  if (foundTerminator === true) {
                    lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;
                    numOfLTsInMatch++;
                  }
                } while (foundTerminator === true);
                if (numOfLTsInMatch !== 0) {
                  line = line + numOfLTsInMatch;
                  column = imageLength - lastLTEndOffset;
                  this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
                }
              }
              this.handleModes(currConfig, pop_mode, push_mode, newToken);
            } else {
              var errorStartOffset = offset;
              var errorLine = line;
              var errorColumn = column;
              var foundResyncPoint = recoveryEnabled === false;
              while (foundResyncPoint === false && offset < orgLength) {
                text = this.chopInput(text, 1);
                offset++;
                for (j = 0; j < currModePatternsLength; j++) {
                  var currConfig_1 = patternIdxToConfig[j];
                  var currPattern = currConfig_1.pattern;
                  var singleCharCode = currConfig_1.short;
                  if (singleCharCode !== false) {
                    if (orgText.charCodeAt(offset) === singleCharCode) {
                      foundResyncPoint = true;
                    }
                  } else if (currConfig_1.isCustom === true) {
                    foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                  } else {
                    this.updateLastIndex(currPattern, offset);
                    foundResyncPoint = currPattern.exec(text) !== null;
                  }
                  if (foundResyncPoint === true) {
                    break;
                  }
                }
              }
              errLength = offset - errorStartOffset;
              msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
              errors.push({
                offset: errorStartOffset,
                line: errorLine,
                column: errorColumn,
                length: errLength,
                message: msg
              });
              if (recoveryEnabled === false) {
                break;
              }
            }
          }
          if (!this.hasCustom) {
            matchedTokens.length = matchedTokensIndex;
          }
          return {
            tokens: matchedTokens,
            groups,
            errors
          };
        };
        Lexer2.prototype.handleModes = function(config, pop_mode, push_mode, newToken) {
          if (config.pop === true) {
            var pushMode = config.push;
            pop_mode(newToken);
            if (pushMode !== void 0) {
              push_mode.call(this, pushMode);
            }
          } else if (config.push !== void 0) {
            push_mode.call(this, config.push);
          }
        };
        Lexer2.prototype.chopInput = function(text, length) {
          return text.substring(length);
        };
        Lexer2.prototype.updateLastIndex = function(regExp, newLastIndex) {
          regExp.lastIndex = newLastIndex;
        };
        Lexer2.prototype.updateTokenEndLineColumnLocation = function(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
          var lastCharIsLT, fixForEndingInLT;
          if (group !== void 0) {
            lastCharIsLT = lastLTIdx === imageLength - 1;
            fixForEndingInLT = lastCharIsLT ? -1 : 0;
            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
              newToken.endLine = line + fixForEndingInLT;
              newToken.endColumn = column - 1 + -fixForEndingInLT;
            }
          }
        };
        Lexer2.prototype.computeNewColumn = function(oldColumn, imageLength) {
          return oldColumn + imageLength;
        };
        Lexer2.prototype.createOffsetOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType) {
          return {
            image,
            startOffset,
            tokenTypeIdx,
            tokenType
          };
        };
        Lexer2.prototype.createStartOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
          return {
            image,
            startOffset,
            startLine,
            startColumn,
            tokenTypeIdx,
            tokenType
          };
        };
        Lexer2.prototype.createFullToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
          return {
            image,
            startOffset,
            endOffset: startOffset + imageLength - 1,
            startLine,
            endLine: startLine,
            startColumn,
            endColumn: startColumn + imageLength - 1,
            tokenTypeIdx,
            tokenType
          };
        };
        Lexer2.prototype.addTokenUsingPush = function(tokenVector, index, tokenToAdd) {
          tokenVector.push(tokenToAdd);
          return index;
        };
        Lexer2.prototype.addTokenUsingMemberAccess = function(tokenVector, index, tokenToAdd) {
          tokenVector[index] = tokenToAdd;
          index++;
          return index;
        };
        Lexer2.prototype.handlePayloadNoCustom = function(token, payload) {
        };
        Lexer2.prototype.handlePayloadWithCustom = function(token, payload) {
          if (payload !== null) {
            token.payload = payload;
          }
        };
        Lexer2.prototype.matchWithTest = function(pattern, text, offset) {
          var found = pattern.test(text);
          if (found === true) {
            return text.substring(offset, pattern.lastIndex);
          }
          return null;
        };
        Lexer2.prototype.matchWithExec = function(pattern, text) {
          var regExpArray = pattern.exec(text);
          return regExpArray !== null ? regExpArray[0] : null;
        };
        Lexer2.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
        Lexer2.NA = /NOT_APPLICABLE/;
        return Lexer2;
      }()
    );
    exports2.Lexer = Lexer;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/tokens_public.js
var require_tokens_public = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/scan/tokens_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenMatcher = exports2.createTokenInstance = exports2.EOF = exports2.createToken = exports2.hasTokenLabel = exports2.tokenName = exports2.tokenLabel = void 0;
    var isString_1 = __importDefault(require_isString());
    var has_1 = __importDefault(require_has());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var lexer_public_1 = require_lexer_public();
    var tokens_1 = require_tokens();
    function tokenLabel(tokType) {
      if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
      } else {
        return tokType.name;
      }
    }
    exports2.tokenLabel = tokenLabel;
    function tokenName(tokType) {
      return tokType.name;
    }
    exports2.tokenName = tokenName;
    function hasTokenLabel(obj) {
      return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
    }
    exports2.hasTokenLabel = hasTokenLabel;
    var PARENT = "parent";
    var CATEGORIES = "categories";
    var LABEL = "label";
    var GROUP = "group";
    var PUSH_MODE = "push_mode";
    var POP_MODE = "pop_mode";
    var LONGER_ALT = "longer_alt";
    var LINE_BREAKS = "line_breaks";
    var START_CHARS_HINT = "start_chars_hint";
    function createToken(config) {
      return createTokenInternal(config);
    }
    exports2.createToken = createToken;
    function createTokenInternal(config) {
      var pattern = config.pattern;
      var tokenType = {};
      tokenType.name = config.name;
      if (!(0, isUndefined_1.default)(pattern)) {
        tokenType.PATTERN = pattern;
      }
      if ((0, has_1.default)(config, PARENT)) {
        throw "The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";
      }
      if ((0, has_1.default)(config, CATEGORIES)) {
        tokenType.CATEGORIES = config[CATEGORIES];
      }
      (0, tokens_1.augmentTokenTypes)([tokenType]);
      if ((0, has_1.default)(config, LABEL)) {
        tokenType.LABEL = config[LABEL];
      }
      if ((0, has_1.default)(config, GROUP)) {
        tokenType.GROUP = config[GROUP];
      }
      if ((0, has_1.default)(config, POP_MODE)) {
        tokenType.POP_MODE = config[POP_MODE];
      }
      if ((0, has_1.default)(config, PUSH_MODE)) {
        tokenType.PUSH_MODE = config[PUSH_MODE];
      }
      if ((0, has_1.default)(config, LONGER_ALT)) {
        tokenType.LONGER_ALT = config[LONGER_ALT];
      }
      if ((0, has_1.default)(config, LINE_BREAKS)) {
        tokenType.LINE_BREAKS = config[LINE_BREAKS];
      }
      if ((0, has_1.default)(config, START_CHARS_HINT)) {
        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
      }
      return tokenType;
    }
    exports2.EOF = createToken({ name: "EOF", pattern: lexer_public_1.Lexer.NA });
    (0, tokens_1.augmentTokenTypes)([exports2.EOF]);
    function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
      return {
        image,
        startOffset,
        endOffset,
        startLine,
        endLine,
        startColumn,
        endColumn,
        tokenTypeIdx: tokType.tokenTypeIdx,
        tokenType: tokType
      };
    }
    exports2.createTokenInstance = createTokenInstance;
    function tokenMatcher(token, tokType) {
      return (0, tokens_1.tokenStructuredMatcher)(token, tokType);
    }
    exports2.tokenMatcher = tokenMatcher;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/errors_public.js
var require_errors_public = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/errors_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultGrammarValidatorErrorProvider = exports2.defaultGrammarResolverErrorProvider = exports2.defaultParserErrorProvider = void 0;
    var tokens_public_1 = require_tokens_public();
    var first_1 = __importDefault(require_first2());
    var map_1 = __importDefault(require_map());
    var reduce_1 = __importDefault(require_reduce());
    var gast_1 = require_api5();
    var gast_2 = require_api5();
    exports2.defaultParserErrorProvider = {
      buildMismatchTokenMessage: function(_a) {
        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;
        var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);
        var expectedMsg = hasLabel ? "--> ".concat((0, tokens_public_1.tokenLabel)(expected), " <--") : "token of type --> ".concat(expected.name, " <--");
        var msg = "Expecting ".concat(expectedMsg, " but found --> '").concat(actual.image, "' <--");
        return msg;
      },
      buildNotAllInputParsedMessage: function(_a) {
        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;
        return "Redundant input, expecting EOF but found: " + firstRedundant.image;
      },
      buildNoViableAltMessage: function(_a) {
        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        var actualText = (0, first_1.default)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
          return errPrefix + customUserDescription + errSuffix;
        } else {
          var allLookAheadPaths = (0, reduce_1.default)(expectedPathsPerAlt, function(result, currAltPaths) {
            return result.concat(currAltPaths);
          }, []);
          var nextValidTokenSequences = (0, map_1.default)(allLookAheadPaths, function(currPath) {
            return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
              return (0, tokens_public_1.tokenLabel)(currTokenType);
            }).join(", "), "]");
          });
          var nextValidSequenceItems = (0, map_1.default)(nextValidTokenSequences, function(itemMsg, idx) {
            return "  ".concat(idx + 1, ". ").concat(itemMsg);
          });
          var calculatedDescription = "one of these possible Token sequences:\n".concat(nextValidSequenceItems.join("\n"));
          return errPrefix + calculatedDescription + errSuffix;
        }
      },
      buildEarlyExitMessage: function(_a) {
        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        var actualText = (0, first_1.default)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
          return errPrefix + customUserDescription + errSuffix;
        } else {
          var nextValidTokenSequences = (0, map_1.default)(expectedIterationPaths, function(currPath) {
            return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
              return (0, tokens_public_1.tokenLabel)(currTokenType);
            }).join(","), "]");
          });
          var calculatedDescription = "expecting at least one iteration which starts with one of these possible Token sequences::\n  " + "<".concat(nextValidTokenSequences.join(" ,"), ">");
          return errPrefix + calculatedDescription + errSuffix;
        }
      }
    };
    Object.freeze(exports2.defaultParserErrorProvider);
    exports2.defaultGrammarResolverErrorProvider = {
      buildRuleNotFoundError: function(topLevelRule, undefinedRule) {
        var msg = "Invalid grammar, reference to a rule which is not defined: ->" + undefinedRule.nonTerminalName + "<-\ninside top level rule: ->" + topLevelRule.name + "<-";
        return msg;
      }
    };
    exports2.defaultGrammarValidatorErrorProvider = {
      buildDuplicateFoundError: function(topLevelRule, duplicateProds) {
        function getExtraProductionArgument(prod) {
          if (prod instanceof gast_1.Terminal) {
            return prod.terminalType.name;
          } else if (prod instanceof gast_1.NonTerminal) {
            return prod.nonTerminalName;
          } else {
            return "";
          }
        }
        var topLevelName = topLevelRule.name;
        var duplicateProd = (0, first_1.default)(duplicateProds);
        var index = duplicateProd.idx;
        var dslName = (0, gast_2.getProductionDslName)(duplicateProd);
        var extraArgument = getExtraProductionArgument(duplicateProd);
        var hasExplicitIndex = index > 0;
        var msg = "->".concat(dslName).concat(hasExplicitIndex ? index : "", "<- ").concat(extraArgument ? "with argument: ->".concat(extraArgument, "<-") : "", "\n                  appears more than once (").concat(duplicateProds.length, " times) in the top level rule: ->").concat(topLevelName, "<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ");
        msg = msg.replace(/[ \t]+/g, " ");
        msg = msg.replace(/\s\s+/g, "\n");
        return msg;
      },
      buildNamespaceConflictError: function(rule) {
        var errMsg = "Namespace conflict found in grammar.\n" + "The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <".concat(rule.name, ">.\n") + "To resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.";
        return errMsg;
      },
      buildAlternationPrefixAmbiguityError: function(options) {
        var pathMsg = (0, map_1.default)(options.prefixPath, function(currTok) {
          return (0, tokens_public_1.tokenLabel)(currTok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var errMsg = "Ambiguous alternatives: <".concat(options.ambiguityIndices.join(" ,"), "> due to common lookahead prefix\n") + "in <OR".concat(occurrence, "> inside <").concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n") + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.";
        return errMsg;
      },
      buildAlternationAmbiguityError: function(options) {
        var pathMsg = (0, map_1.default)(options.prefixPath, function(currtok) {
          return (0, tokens_public_1.tokenLabel)(currtok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var currMessage = "Ambiguous Alternatives Detected: <".concat(options.ambiguityIndices.join(" ,"), "> in <OR").concat(occurrence, ">") + " inside <".concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n");
        currMessage = currMessage + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.";
        return currMessage;
      },
      buildEmptyRepetitionError: function(options) {
        var dslName = (0, gast_2.getProductionDslName)(options.repetition);
        if (options.repetition.idx !== 0) {
          dslName += options.repetition.idx;
        }
        var errMsg = "The repetition <".concat(dslName, "> within Rule <").concat(options.topLevelRule.name, "> can never consume any tokens.\n") + "This could lead to an infinite loop.";
        return errMsg;
      },
      // TODO: remove - `errors_public` from nyc.config.js exclude
      //       once this method is fully removed from this file
      buildTokenNameError: function(options) {
        return "deprecated";
      },
      buildEmptyAlternationError: function(options) {
        var errMsg = "Ambiguous empty alternative: <".concat(options.emptyChoiceIdx + 1, ">") + " in <OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n") + "Only the last alternative may be an empty alternative.";
        return errMsg;
      },
      buildTooManyAlternativesError: function(options) {
        var errMsg = "An Alternation cannot have more than 256 alternatives:\n" + "<OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n has ").concat(options.alternation.definition.length + 1, " alternatives.");
        return errMsg;
      },
      buildLeftRecursionError: function(options) {
        var ruleName = options.topLevelRule.name;
        var pathNames = (0, map_1.default)(options.leftRecursionPath, function(currRule) {
          return currRule.name;
        });
        var leftRecursivePath = "".concat(ruleName, " --> ").concat(pathNames.concat([ruleName]).join(" --> "));
        var errMsg = "Left Recursion found in grammar.\n" + "rule: <".concat(ruleName, "> can be invoked from itself (directly or indirectly)\n") + "without consuming any Tokens. The grammar path that causes this is: \n ".concat(leftRecursivePath, "\n") + " To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.";
        return errMsg;
      },
      // TODO: remove - `errors_public` from nyc.config.js exclude
      //       once this method is fully removed from this file
      buildInvalidRuleNameError: function(options) {
        return "deprecated";
      },
      buildDuplicateRuleNameError: function(options) {
        var ruleName;
        if (options.topLevelRule instanceof gast_1.Rule) {
          ruleName = options.topLevelRule.name;
        } else {
          ruleName = options.topLevelRule;
        }
        var errMsg = "Duplicate definition, rule: ->".concat(ruleName, "<- is already defined in the grammar: ->").concat(options.grammarName, "<-");
        return errMsg;
      }
    };
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/resolver.js
var require_resolver = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/resolver.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GastRefResolverVisitor = exports2.resolveGrammar = void 0;
    var parser_1 = require_parser();
    var forEach_1 = __importDefault(require_forEach());
    var values_1 = __importDefault(require_values());
    var gast_1 = require_api5();
    function resolveGrammar(topLevels, errMsgProvider) {
      var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
      refResolver.resolveRefs();
      return refResolver.errors;
    }
    exports2.resolveGrammar = resolveGrammar;
    var GastRefResolverVisitor = (
      /** @class */
      function(_super) {
        __extends(GastRefResolverVisitor2, _super);
        function GastRefResolverVisitor2(nameToTopRule, errMsgProvider) {
          var _this = _super.call(this) || this;
          _this.nameToTopRule = nameToTopRule;
          _this.errMsgProvider = errMsgProvider;
          _this.errors = [];
          return _this;
        }
        GastRefResolverVisitor2.prototype.resolveRefs = function() {
          var _this = this;
          (0, forEach_1.default)((0, values_1.default)(this.nameToTopRule), function(prod) {
            _this.currTopLevel = prod;
            prod.accept(_this);
          });
        };
        GastRefResolverVisitor2.prototype.visitNonTerminal = function(node) {
          var ref = this.nameToTopRule[node.nonTerminalName];
          if (!ref) {
            var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
            this.errors.push({
              message: msg,
              type: parser_1.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
              ruleName: this.currTopLevel.name,
              unresolvedRefName: node.nonTerminalName
            });
          } else {
            node.referencedRule = ref;
          }
        };
        return GastRefResolverVisitor2;
      }(gast_1.GAstVisitor)
    );
    exports2.GastRefResolverVisitor = GastRefResolverVisitor;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayAggregator.js
var require_arrayAggregator = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayAggregator.js"(exports2, module2) {
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    module2.exports = arrayAggregator;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAggregator.js
var require_baseAggregator = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAggregator.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    module2.exports = baseAggregator;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAggregator.js
var require_createAggregator = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAggregator.js"(exports2, module2) {
    var arrayAggregator = require_arrayAggregator();
    var baseAggregator = require_baseAggregator();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
      };
    }
    module2.exports = createAggregator;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/groupBy.js
var require_groupBy = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/groupBy.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var createAggregator = require_createAggregator();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });
    module2.exports = groupBy;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatMap.js
var require_flatMap = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatMap.js"(exports2, module2) {
    var baseFlatten = require_baseFlatten();
    var map = require_map();
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }
    module2.exports = flatMap;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/dropRight.js
var require_dropRight = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/dropRight.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    var toInteger = require_toInteger();
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = guard || n === void 0 ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }
    module2.exports = dropRight;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/interpreter.js
var require_interpreter = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/interpreter.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.nextPossibleTokensAfter = exports2.possiblePathsFrom = exports2.NextTerminalAfterAtLeastOneSepWalker = exports2.NextTerminalAfterAtLeastOneWalker = exports2.NextTerminalAfterManySepWalker = exports2.NextTerminalAfterManyWalker = exports2.AbstractNextTerminalAfterProductionWalker = exports2.NextAfterTokenWalker = exports2.AbstractNextPossibleTokensWalker = void 0;
    var rest_1 = require_rest();
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var dropRight_1 = __importDefault(require_dropRight());
    var drop_1 = __importDefault(require_drop());
    var last_1 = __importDefault(require_last());
    var forEach_1 = __importDefault(require_forEach());
    var clone_1 = __importDefault(require_clone());
    var first_2 = require_first();
    var gast_1 = require_api5();
    var AbstractNextPossibleTokensWalker = (
      /** @class */
      function(_super) {
        __extends(AbstractNextPossibleTokensWalker2, _super);
        function AbstractNextPossibleTokensWalker2(topProd, path2) {
          var _this = _super.call(this) || this;
          _this.topProd = topProd;
          _this.path = path2;
          _this.possibleTokTypes = [];
          _this.nextProductionName = "";
          _this.nextProductionOccurrence = 0;
          _this.found = false;
          _this.isAtEndOfPath = false;
          return _this;
        }
        AbstractNextPossibleTokensWalker2.prototype.startWalking = function() {
          this.found = false;
          if (this.path.ruleStack[0] !== this.topProd.name) {
            throw Error("The path does not start with the walker's top Rule!");
          }
          this.ruleStack = (0, clone_1.default)(this.path.ruleStack).reverse();
          this.occurrenceStack = (0, clone_1.default)(this.path.occurrenceStack).reverse();
          this.ruleStack.pop();
          this.occurrenceStack.pop();
          this.updateExpectedNext();
          this.walk(this.topProd);
          return this.possibleTokTypes;
        };
        AbstractNextPossibleTokensWalker2.prototype.walk = function(prod, prevRest) {
          if (prevRest === void 0) {
            prevRest = [];
          }
          if (!this.found) {
            _super.prototype.walk.call(this, prod, prevRest);
          }
        };
        AbstractNextPossibleTokensWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
          if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {
            var fullRest = currRest.concat(prevRest);
            this.updateExpectedNext();
            this.walk(refProd.referencedRule, fullRest);
          }
        };
        AbstractNextPossibleTokensWalker2.prototype.updateExpectedNext = function() {
          if ((0, isEmpty_1.default)(this.ruleStack)) {
            this.nextProductionName = "";
            this.nextProductionOccurrence = 0;
            this.isAtEndOfPath = true;
          } else {
            this.nextProductionName = this.ruleStack.pop();
            this.nextProductionOccurrence = this.occurrenceStack.pop();
          }
        };
        return AbstractNextPossibleTokensWalker2;
      }(rest_1.RestWalker)
    );
    exports2.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;
    var NextAfterTokenWalker = (
      /** @class */
      function(_super) {
        __extends(NextAfterTokenWalker2, _super);
        function NextAfterTokenWalker2(topProd, path2) {
          var _this = _super.call(this, topProd, path2) || this;
          _this.path = path2;
          _this.nextTerminalName = "";
          _this.nextTerminalOccurrence = 0;
          _this.nextTerminalName = _this.path.lastTok.name;
          _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;
          return _this;
        }
        NextAfterTokenWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
          if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {
            var fullRest = currRest.concat(prevRest);
            var restProd = new gast_1.Alternative({ definition: fullRest });
            this.possibleTokTypes = (0, first_2.first)(restProd);
            this.found = true;
          }
        };
        return NextAfterTokenWalker2;
      }(AbstractNextPossibleTokensWalker)
    );
    exports2.NextAfterTokenWalker = NextAfterTokenWalker;
    var AbstractNextTerminalAfterProductionWalker = (
      /** @class */
      function(_super) {
        __extends(AbstractNextTerminalAfterProductionWalker2, _super);
        function AbstractNextTerminalAfterProductionWalker2(topRule, occurrence) {
          var _this = _super.call(this) || this;
          _this.topRule = topRule;
          _this.occurrence = occurrence;
          _this.result = {
            token: void 0,
            occurrence: void 0,
            isEndOfRule: void 0
          };
          return _this;
        }
        AbstractNextTerminalAfterProductionWalker2.prototype.startWalking = function() {
          this.walk(this.topRule);
          return this.result;
        };
        return AbstractNextTerminalAfterProductionWalker2;
      }(rest_1.RestWalker)
    );
    exports2.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;
    var NextTerminalAfterManyWalker = (
      /** @class */
      function(_super) {
        __extends(NextTerminalAfterManyWalker2, _super);
        function NextTerminalAfterManyWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterManyWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
          if (manyProd.idx === this.occurrence) {
            var firstAfterMany = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterMany === void 0;
            if (firstAfterMany instanceof gast_1.Terminal) {
              this.result.token = firstAfterMany.terminalType;
              this.result.occurrence = firstAfterMany.idx;
            }
          } else {
            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterManyWalker2;
      }(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;
    var NextTerminalAfterManySepWalker = (
      /** @class */
      function(_super) {
        __extends(NextTerminalAfterManySepWalker2, _super);
        function NextTerminalAfterManySepWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterManySepWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
          if (manySepProd.idx === this.occurrence) {
            var firstAfterManySep = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterManySep === void 0;
            if (firstAfterManySep instanceof gast_1.Terminal) {
              this.result.token = firstAfterManySep.terminalType;
              this.result.occurrence = firstAfterManySep.idx;
            }
          } else {
            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterManySepWalker2;
      }(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;
    var NextTerminalAfterAtLeastOneWalker = (
      /** @class */
      function(_super) {
        __extends(NextTerminalAfterAtLeastOneWalker2, _super);
        function NextTerminalAfterAtLeastOneWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterAtLeastOneWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
          if (atLeastOneProd.idx === this.occurrence) {
            var firstAfterAtLeastOne = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterAtLeastOne === void 0;
            if (firstAfterAtLeastOne instanceof gast_1.Terminal) {
              this.result.token = firstAfterAtLeastOne.terminalType;
              this.result.occurrence = firstAfterAtLeastOne.idx;
            }
          } else {
            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterAtLeastOneWalker2;
      }(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker;
    var NextTerminalAfterAtLeastOneSepWalker = (
      /** @class */
      function(_super) {
        __extends(NextTerminalAfterAtLeastOneSepWalker2, _super);
        function NextTerminalAfterAtLeastOneSepWalker2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NextTerminalAfterAtLeastOneSepWalker2.prototype.walkAtLeastOneSep = function(atleastOneSepProd, currRest, prevRest) {
          if (atleastOneSepProd.idx === this.occurrence) {
            var firstAfterfirstAfterAtLeastOneSep = (0, first_1.default)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;
            if (firstAfterfirstAfterAtLeastOneSep instanceof gast_1.Terminal) {
              this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;
              this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
            }
          } else {
            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);
          }
        };
        return NextTerminalAfterAtLeastOneSepWalker2;
      }(AbstractNextTerminalAfterProductionWalker)
    );
    exports2.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;
    function possiblePathsFrom(targetDef, maxLength, currPath) {
      if (currPath === void 0) {
        currPath = [];
      }
      currPath = (0, clone_1.default)(currPath);
      var result = [];
      var i = 0;
      function remainingPathWith(nextDef) {
        return nextDef.concat((0, drop_1.default)(targetDef, i + 1));
      }
      function getAlternativesForProd(definition) {
        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
        return result.concat(alternatives);
      }
      while (currPath.length < maxLength && i < targetDef.length) {
        var prod = targetDef[i];
        if (prod instanceof gast_1.Alternative) {
          return getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.NonTerminal) {
          return getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.Option) {
          result = getAlternativesForProd(prod.definition);
        } else if (prod instanceof gast_1.RepetitionMandatory) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: prod.definition
            })
          ]);
          return getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
          var newDef = [
            new gast_1.Alternative({ definition: prod.definition }),
            new gast_1.Repetition({
              definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
            })
          ];
          return getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.RepetitionWithSeparator) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
            })
          ]);
          result = getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.Repetition) {
          var newDef = prod.definition.concat([
            new gast_1.Repetition({
              definition: prod.definition
            })
          ]);
          result = getAlternativesForProd(newDef);
        } else if (prod instanceof gast_1.Alternation) {
          (0, forEach_1.default)(prod.definition, function(currAlt) {
            if ((0, isEmpty_1.default)(currAlt.definition) === false) {
              result = getAlternativesForProd(currAlt.definition);
            }
          });
          return result;
        } else if (prod instanceof gast_1.Terminal) {
          currPath.push(prod.terminalType);
        } else {
          throw Error("non exhaustive match");
        }
        i++;
      }
      result.push({
        partialPath: currPath,
        suffixDef: (0, drop_1.default)(targetDef, i)
      });
      return result;
    }
    exports2.possiblePathsFrom = possiblePathsFrom;
    function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
      var EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
      var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
      var EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
      var foundCompletePath = false;
      var tokenVectorLength = tokenVector.length;
      var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
      var result = [];
      var possiblePaths = [];
      possiblePaths.push({
        idx: -1,
        def: initialDef,
        ruleStack: [],
        occurrenceStack: []
      });
      while (!(0, isEmpty_1.default)(possiblePaths)) {
        var currPath = possiblePaths.pop();
        if (currPath === EXIT_ALTERNATIVE) {
          if (foundCompletePath && (0, last_1.default)(possiblePaths).idx <= minimalAlternativesIndex) {
            possiblePaths.pop();
          }
          continue;
        }
        var currDef = currPath.def;
        var currIdx = currPath.idx;
        var currRuleStack = currPath.ruleStack;
        var currOccurrenceStack = currPath.occurrenceStack;
        if ((0, isEmpty_1.default)(currDef)) {
          continue;
        }
        var prod = currDef[0];
        if (prod === EXIT_NON_TERMINAL) {
          var nextPath = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: (0, dropRight_1.default)(currRuleStack),
            occurrenceStack: (0, dropRight_1.default)(currOccurrenceStack)
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.Terminal) {
          if (currIdx < tokenVectorLength - 1) {
            var nextIdx = currIdx + 1;
            var actualToken = tokenVector[nextIdx];
            if (tokMatcher(actualToken, prod.terminalType)) {
              var nextPath = {
                idx: nextIdx,
                def: (0, drop_1.default)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
              };
              possiblePaths.push(nextPath);
            }
          } else if (currIdx === tokenVectorLength - 1) {
            result.push({
              nextTokenType: prod.terminalType,
              nextTokenOccurrence: prod.idx,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            });
            foundCompletePath = true;
          } else {
            throw Error("non exhaustive match");
          }
        } else if (prod instanceof gast_1.NonTerminal) {
          var newRuleStack = (0, clone_1.default)(currRuleStack);
          newRuleStack.push(prod.nonTerminalName);
          var newOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
          newOccurrenceStack.push(prod.idx);
          var nextPath = {
            idx: currIdx,
            def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0, drop_1.default)(currDef)),
            ruleStack: newRuleStack,
            occurrenceStack: newOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.Option) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var nextPathWith = {
            idx: currIdx,
            def: prod.definition.concat((0, drop_1.default)(currDef)),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.RepetitionMandatory) {
          var secondIteration = new gast_1.Repetition({
            definition: prod.definition,
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
          var nextPath = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
          var separatorGast = new gast_1.Terminal({
            terminalType: prod.separator
          });
          var secondIteration = new gast_1.Repetition({
            definition: [separatorGast].concat(prod.definition),
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
          var nextPath = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } else if (prod instanceof gast_1.RepetitionWithSeparator) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var separatorGast = new gast_1.Terminal({
            terminalType: prod.separator
          });
          var nthRepetition = new gast_1.Repetition({
            definition: [separatorGast].concat(prod.definition),
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
          var nextPathWith = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.Repetition) {
          var nextPathWithout = {
            idx: currIdx,
            def: (0, drop_1.default)(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWithout);
          possiblePaths.push(EXIT_ALTERNATIVE);
          var nthRepetition = new gast_1.Repetition({
            definition: prod.definition,
            idx: prod.idx
          });
          var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
          var nextPathWith = {
            idx: currIdx,
            def: nextDef,
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPathWith);
        } else if (prod instanceof gast_1.Alternation) {
          for (var i = prod.definition.length - 1; i >= 0; i--) {
            var currAlt = prod.definition[i];
            var currAltPath = {
              idx: currIdx,
              def: currAlt.definition.concat((0, drop_1.default)(currDef)),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(currAltPath);
            possiblePaths.push(EXIT_ALTERNATIVE);
          }
        } else if (prod instanceof gast_1.Alternative) {
          possiblePaths.push({
            idx: currIdx,
            def: prod.definition.concat((0, drop_1.default)(currDef)),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          });
        } else if (prod instanceof gast_1.Rule) {
          possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
        } else {
          throw Error("non exhaustive match");
        }
      }
      return result;
    }
    exports2.nextPossibleTokensAfter = nextPossibleTokensAfter;
    function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
      var newRuleStack = (0, clone_1.default)(currRuleStack);
      newRuleStack.push(topRule.name);
      var newCurrOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
      newCurrOccurrenceStack.push(1);
      return {
        idx: currIdx,
        def: topRule.definition,
        ruleStack: newRuleStack,
        occurrenceStack: newCurrOccurrenceStack
      };
    }
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/lookahead.js
var require_lookahead = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/lookahead.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.areTokenCategoriesNotUsed = exports2.isStrictPrefixOfPath = exports2.containsPath = exports2.getLookaheadPathsForOptionalProd = exports2.getLookaheadPathsForOr = exports2.lookAheadSequenceFromAlternatives = exports2.buildSingleAlternativeLookaheadFunction = exports2.buildAlternativesLookAheadFunc = exports2.buildLookaheadFuncForOptionalProd = exports2.buildLookaheadFuncForOr = exports2.getLookaheadPaths = exports2.getProdType = exports2.PROD_TYPE = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var flatten_1 = __importDefault(require_flatten());
    var every_1 = __importDefault(require_every());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var reduce_1 = __importDefault(require_reduce());
    var interpreter_1 = require_interpreter();
    var rest_1 = require_rest();
    var tokens_1 = require_tokens();
    var gast_1 = require_api5();
    var gast_2 = require_api5();
    var PROD_TYPE;
    (function(PROD_TYPE2) {
      PROD_TYPE2[PROD_TYPE2["OPTION"] = 0] = "OPTION";
      PROD_TYPE2[PROD_TYPE2["REPETITION"] = 1] = "REPETITION";
      PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
      PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
      PROD_TYPE2[PROD_TYPE2["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
      PROD_TYPE2[PROD_TYPE2["ALTERNATION"] = 5] = "ALTERNATION";
    })(PROD_TYPE = exports2.PROD_TYPE || (exports2.PROD_TYPE = {}));
    function getProdType(prod) {
      if (prod instanceof gast_1.Option || prod === "Option") {
        return PROD_TYPE.OPTION;
      } else if (prod instanceof gast_1.Repetition || prod === "Repetition") {
        return PROD_TYPE.REPETITION;
      } else if (prod instanceof gast_1.RepetitionMandatory || prod === "RepetitionMandatory") {
        return PROD_TYPE.REPETITION_MANDATORY;
      } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator || prod === "RepetitionMandatoryWithSeparator") {
        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
      } else if (prod instanceof gast_1.RepetitionWithSeparator || prod === "RepetitionWithSeparator") {
        return PROD_TYPE.REPETITION_WITH_SEPARATOR;
      } else if (prod instanceof gast_1.Alternation || prod === "Alternation") {
        return PROD_TYPE.ALTERNATION;
      } else {
        throw Error("non exhaustive match");
      }
    }
    exports2.getProdType = getProdType;
    function getLookaheadPaths(options) {
      var occurrence = options.occurrence, rule = options.rule, prodType = options.prodType, maxLookahead = options.maxLookahead;
      var type = getProdType(prodType);
      if (type === PROD_TYPE.ALTERNATION) {
        return getLookaheadPathsForOr(occurrence, rule, maxLookahead);
      } else {
        return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);
      }
    }
    exports2.getLookaheadPaths = getLookaheadPaths;
    function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
      var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
      var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
      return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);
    }
    exports2.buildLookaheadFuncForOr = buildLookaheadFuncForOr;
    function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
      var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
      var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
      return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);
    }
    exports2.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;
    function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
      var numOfAlts = alts.length;
      var areAllOneTokenLookahead = (0, every_1.default)(alts, function(currAlt) {
        return (0, every_1.default)(currAlt, function(currPath) {
          return currPath.length === 1;
        });
      });
      if (hasPredicates) {
        return function(orAlts) {
          var predicates = (0, map_1.default)(orAlts, function(currAlt2) {
            return currAlt2.GATE;
          });
          for (var t = 0; t < numOfAlts; t++) {
            var currAlt = alts[t];
            var currNumOfPaths = currAlt.length;
            var currPredicate = predicates[t];
            if (currPredicate !== void 0 && currPredicate.call(this) === false) {
              continue;
            }
            nextPath:
              for (var j = 0; j < currNumOfPaths; j++) {
                var currPath = currAlt[j];
                var currPathLength = currPath.length;
                for (var i = 0; i < currPathLength; i++) {
                  var nextToken = this.LA(i + 1);
                  if (tokenMatcher(nextToken, currPath[i]) === false) {
                    continue nextPath;
                  }
                }
                return t;
              }
          }
          return void 0;
        };
      } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokenAlts = (0, map_1.default)(alts, function(currAlt) {
          return (0, flatten_1.default)(currAlt);
        });
        var choiceToAlt_1 = (0, reduce_1.default)(singleTokenAlts, function(result, currAlt, idx) {
          (0, forEach_1.default)(currAlt, function(currTokType) {
            if (!(0, has_1.default)(result, currTokType.tokenTypeIdx)) {
              result[currTokType.tokenTypeIdx] = idx;
            }
            (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
              if (!(0, has_1.default)(result, currExtendingType)) {
                result[currExtendingType] = idx;
              }
            });
          });
          return result;
        }, {});
        return function() {
          var nextToken = this.LA(1);
          return choiceToAlt_1[nextToken.tokenTypeIdx];
        };
      } else {
        return function() {
          for (var t = 0; t < numOfAlts; t++) {
            var currAlt = alts[t];
            var currNumOfPaths = currAlt.length;
            nextPath:
              for (var j = 0; j < currNumOfPaths; j++) {
                var currPath = currAlt[j];
                var currPathLength = currPath.length;
                for (var i = 0; i < currPathLength; i++) {
                  var nextToken = this.LA(i + 1);
                  if (tokenMatcher(nextToken, currPath[i]) === false) {
                    continue nextPath;
                  }
                }
                return t;
              }
          }
          return void 0;
        };
      }
    }
    exports2.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;
    function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {
      var areAllOneTokenLookahead = (0, every_1.default)(alt, function(currPath) {
        return currPath.length === 1;
      });
      var numOfPaths = alt.length;
      if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokensTypes = (0, flatten_1.default)(alt);
        if (singleTokensTypes.length === 1 && (0, isEmpty_1.default)(singleTokensTypes[0].categoryMatches)) {
          var expectedTokenType = singleTokensTypes[0];
          var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;
          return function() {
            return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;
          };
        } else {
          var choiceToAlt_2 = (0, reduce_1.default)(singleTokensTypes, function(result, currTokType, idx) {
            result[currTokType.tokenTypeIdx] = true;
            (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
              result[currExtendingType] = true;
            });
            return result;
          }, []);
          return function() {
            var nextToken = this.LA(1);
            return choiceToAlt_2[nextToken.tokenTypeIdx] === true;
          };
        }
      } else {
        return function() {
          nextPath:
            for (var j = 0; j < numOfPaths; j++) {
              var currPath = alt[j];
              var currPathLength = currPath.length;
              for (var i = 0; i < currPathLength; i++) {
                var nextToken = this.LA(i + 1);
                if (tokenMatcher(nextToken, currPath[i]) === false) {
                  continue nextPath;
                }
              }
              return true;
            }
          return false;
        };
      }
    }
    exports2.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;
    var RestDefinitionFinderWalker = (
      /** @class */
      function(_super) {
        __extends(RestDefinitionFinderWalker2, _super);
        function RestDefinitionFinderWalker2(topProd, targetOccurrence, targetProdType) {
          var _this = _super.call(this) || this;
          _this.topProd = topProd;
          _this.targetOccurrence = targetOccurrence;
          _this.targetProdType = targetProdType;
          return _this;
        }
        RestDefinitionFinderWalker2.prototype.startWalking = function() {
          this.walk(this.topProd);
          return this.restDef;
        };
        RestDefinitionFinderWalker2.prototype.checkIsTarget = function(node, expectedProdType, currRest, prevRest) {
          if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {
            this.restDef = currRest.concat(prevRest);
            return true;
          }
          return false;
        };
        RestDefinitionFinderWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
          if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
          if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
          if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
          if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);
          }
        };
        RestDefinitionFinderWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
          if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);
          }
        };
        return RestDefinitionFinderWalker2;
      }(rest_1.RestWalker)
    );
    var InsideDefinitionFinderVisitor = (
      /** @class */
      function(_super) {
        __extends(InsideDefinitionFinderVisitor2, _super);
        function InsideDefinitionFinderVisitor2(targetOccurrence, targetProdType, targetRef) {
          var _this = _super.call(this) || this;
          _this.targetOccurrence = targetOccurrence;
          _this.targetProdType = targetProdType;
          _this.targetRef = targetRef;
          _this.result = [];
          return _this;
        }
        InsideDefinitionFinderVisitor2.prototype.checkIsTarget = function(node, expectedProdName) {
          if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {
            this.result = node.definition;
          }
        };
        InsideDefinitionFinderVisitor2.prototype.visitOption = function(node) {
          this.checkIsTarget(node, PROD_TYPE.OPTION);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetition = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatory = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
        };
        InsideDefinitionFinderVisitor2.prototype.visitRepetitionWithSeparator = function(node) {
          this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
        };
        InsideDefinitionFinderVisitor2.prototype.visitAlternation = function(node) {
          this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
        };
        return InsideDefinitionFinderVisitor2;
      }(gast_2.GAstVisitor)
    );
    function initializeArrayOfArrays(size) {
      var result = new Array(size);
      for (var i = 0; i < size; i++) {
        result[i] = [];
      }
      return result;
    }
    function pathToHashKeys(path2) {
      var keys = [""];
      for (var i = 0; i < path2.length; i++) {
        var tokType = path2[i];
        var longerKeys = [];
        for (var j = 0; j < keys.length; j++) {
          var currShorterKey = keys[j];
          longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
          for (var t = 0; t < tokType.categoryMatches.length; t++) {
            var categoriesKeySuffix = "_" + tokType.categoryMatches[t];
            longerKeys.push(currShorterKey + categoriesKeySuffix);
          }
        }
        keys = longerKeys;
      }
      return keys;
    }
    function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
      for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
        if (currAltIdx === idx) {
          continue;
        }
        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
          var searchKey = searchPathKeys[searchIdx];
          if (otherAltKnownPathsKeys[searchKey] === true) {
            return false;
          }
        }
      }
      return true;
    }
    function lookAheadSequenceFromAlternatives(altsDefs, k) {
      var partialAlts = (0, map_1.default)(altsDefs, function(currAlt) {
        return (0, interpreter_1.possiblePathsFrom)([currAlt], 1);
      });
      var finalResult = initializeArrayOfArrays(partialAlts.length);
      var altsHashes = (0, map_1.default)(partialAlts, function(currAltPaths) {
        var dict = {};
        (0, forEach_1.default)(currAltPaths, function(item) {
          var keys = pathToHashKeys(item.partialPath);
          (0, forEach_1.default)(keys, function(currKey) {
            dict[currKey] = true;
          });
        });
        return dict;
      });
      var newData = partialAlts;
      for (var pathLength = 1; pathLength <= k; pathLength++) {
        var currDataset = newData;
        newData = initializeArrayOfArrays(currDataset.length);
        var _loop_1 = function(altIdx2) {
          var currAltPathsAndSuffixes = currDataset[altIdx2];
          for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
            var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
            var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
            var prefixKeys = pathToHashKeys(currPathPrefix);
            var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx2);
            if (isUnique || (0, isEmpty_1.default)(suffixDef) || currPathPrefix.length === k) {
              var currAltResult = finalResult[altIdx2];
              if (containsPath(currAltResult, currPathPrefix) === false) {
                currAltResult.push(currPathPrefix);
                for (var j = 0; j < prefixKeys.length; j++) {
                  var currKey = prefixKeys[j];
                  altsHashes[altIdx2][currKey] = true;
                }
              }
            } else {
              var newPartialPathsAndSuffixes = (0, interpreter_1.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);
              newData[altIdx2] = newData[altIdx2].concat(newPartialPathsAndSuffixes);
              (0, forEach_1.default)(newPartialPathsAndSuffixes, function(item) {
                var prefixKeys2 = pathToHashKeys(item.partialPath);
                (0, forEach_1.default)(prefixKeys2, function(key) {
                  altsHashes[altIdx2][key] = true;
                });
              });
            }
          }
        };
        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {
          _loop_1(altIdx);
        }
      }
      return finalResult;
    }
    exports2.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;
    function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
      var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
      ruleGrammar.accept(visitor);
      return lookAheadSequenceFromAlternatives(visitor.result, k);
    }
    exports2.getLookaheadPathsForOr = getLookaheadPathsForOr;
    function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
      var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
      ruleGrammar.accept(insideDefVisitor);
      var insideDef = insideDefVisitor.result;
      var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
      var afterDef = afterDefWalker.startWalking();
      var insideFlat = new gast_1.Alternative({ definition: insideDef });
      var afterFlat = new gast_1.Alternative({ definition: afterDef });
      return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
    }
    exports2.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;
    function containsPath(alternative, searchPath) {
      compareOtherPath:
        for (var i = 0; i < alternative.length; i++) {
          var otherPath = alternative[i];
          if (otherPath.length !== searchPath.length) {
            continue;
          }
          for (var j = 0; j < otherPath.length; j++) {
            var searchTok = searchPath[j];
            var otherTok = otherPath[j];
            var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;
            if (matchingTokens === false) {
              continue compareOtherPath;
            }
          }
          return true;
        }
      return false;
    }
    exports2.containsPath = containsPath;
    function isStrictPrefixOfPath(prefix, other) {
      return prefix.length < other.length && (0, every_1.default)(prefix, function(tokType, idx) {
        var otherTokType = other[idx];
        return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];
      });
    }
    exports2.isStrictPrefixOfPath = isStrictPrefixOfPath;
    function areTokenCategoriesNotUsed(lookAheadPaths) {
      return (0, every_1.default)(lookAheadPaths, function(singleAltPaths) {
        return (0, every_1.default)(singleAltPaths, function(singlePath) {
          return (0, every_1.default)(singlePath, function(token) {
            return (0, isEmpty_1.default)(token.categoryMatches);
          });
        });
      });
    }
    exports2.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/checks.js
var require_checks = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/checks.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkPrefixAlternativesAmbiguities = exports2.validateSomeNonEmptyLookaheadPath = exports2.validateTooManyAlts = exports2.RepetitionCollector = exports2.validateAmbiguousAlternationAlternatives = exports2.validateEmptyOrAlternative = exports2.getFirstNoneTerminal = exports2.validateNoLeftRecursion = exports2.validateRuleIsOverridden = exports2.validateRuleDoesNotAlreadyExist = exports2.OccurrenceValidationCollector = exports2.identifyProductionForDuplicates = exports2.validateGrammar = exports2.validateLookahead = void 0;
    var first_1 = __importDefault(require_first2());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var drop_1 = __importDefault(require_drop());
    var flatten_1 = __importDefault(require_flatten());
    var filter_1 = __importDefault(require_filter());
    var reject_1 = __importDefault(require_reject());
    var difference_1 = __importDefault(require_difference());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var groupBy_1 = __importDefault(require_groupBy());
    var reduce_1 = __importDefault(require_reduce());
    var pickBy_1 = __importDefault(require_pickBy());
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var flatMap_1 = __importDefault(require_flatMap());
    var clone_1 = __importDefault(require_clone());
    var parser_1 = require_parser();
    var gast_1 = require_api5();
    var lookahead_1 = require_lookahead();
    var interpreter_1 = require_interpreter();
    var gast_2 = require_api5();
    var gast_3 = require_api5();
    var dropRight_1 = __importDefault(require_dropRight());
    var compact_1 = __importDefault(require_compact());
    var tokens_1 = require_tokens();
    function validateLookahead(options) {
      var lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({
        rules: options.rules,
        tokenTypes: options.tokenTypes,
        grammarName: options.grammarName
      });
      return (0, map_1.default)(lookaheadValidationErrorMessages, function(errorMessage) {
        return __assign({ type: parser_1.ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage);
      });
    }
    exports2.validateLookahead = validateLookahead;
    function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {
      var duplicateErrors = (0, flatMap_1.default)(topLevels, function(currTopLevel) {
        return validateDuplicateProductions(currTopLevel, errMsgProvider);
      });
      var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
      var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function(curRule) {
        return validateTooManyAlts(curRule, errMsgProvider);
      });
      var duplicateRulesError = (0, flatMap_1.default)(topLevels, function(curRule) {
        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);
      });
      return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);
    }
    exports2.validateGrammar = validateGrammar;
    function validateDuplicateProductions(topLevelRule, errMsgProvider) {
      var collectorVisitor = new OccurrenceValidationCollector();
      topLevelRule.accept(collectorVisitor);
      var allRuleProductions = collectorVisitor.allProductions;
      var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);
      var duplicates = (0, pickBy_1.default)(productionGroups, function(currGroup) {
        return currGroup.length > 1;
      });
      var errors = (0, map_1.default)((0, values_1.default)(duplicates), function(currDuplicates) {
        var firstProd = (0, first_1.default)(currDuplicates);
        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
        var dslName = (0, gast_1.getProductionDslName)(firstProd);
        var defError = {
          message: msg,
          type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
          ruleName: topLevelRule.name,
          dslName,
          occurrence: firstProd.idx
        };
        var param = getExtraProductionArgument(firstProd);
        if (param) {
          defError.parameter = param;
        }
        return defError;
      });
      return errors;
    }
    function identifyProductionForDuplicates(prod) {
      return "".concat((0, gast_1.getProductionDslName)(prod), "_#_").concat(prod.idx, "_#_").concat(getExtraProductionArgument(prod));
    }
    exports2.identifyProductionForDuplicates = identifyProductionForDuplicates;
    function getExtraProductionArgument(prod) {
      if (prod instanceof gast_2.Terminal) {
        return prod.terminalType.name;
      } else if (prod instanceof gast_2.NonTerminal) {
        return prod.nonTerminalName;
      } else {
        return "";
      }
    }
    var OccurrenceValidationCollector = (
      /** @class */
      function(_super) {
        __extends(OccurrenceValidationCollector2, _super);
        function OccurrenceValidationCollector2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.allProductions = [];
          return _this;
        }
        OccurrenceValidationCollector2.prototype.visitNonTerminal = function(subrule) {
          this.allProductions.push(subrule);
        };
        OccurrenceValidationCollector2.prototype.visitOption = function(option) {
          this.allProductions.push(option);
        };
        OccurrenceValidationCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
          this.allProductions.push(manySep);
        };
        OccurrenceValidationCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
          this.allProductions.push(atLeastOne);
        };
        OccurrenceValidationCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
          this.allProductions.push(atLeastOneSep);
        };
        OccurrenceValidationCollector2.prototype.visitRepetition = function(many) {
          this.allProductions.push(many);
        };
        OccurrenceValidationCollector2.prototype.visitAlternation = function(or) {
          this.allProductions.push(or);
        };
        OccurrenceValidationCollector2.prototype.visitTerminal = function(terminal) {
          this.allProductions.push(terminal);
        };
        return OccurrenceValidationCollector2;
      }(gast_3.GAstVisitor)
    );
    exports2.OccurrenceValidationCollector = OccurrenceValidationCollector;
    function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
      var errors = [];
      var occurrences = (0, reduce_1.default)(allRules, function(result, curRule) {
        if (curRule.name === rule.name) {
          return result + 1;
        }
        return result;
      }, 0);
      if (occurrences > 1) {
        var errMsg = errMsgProvider.buildDuplicateRuleNameError({
          topLevelRule: rule,
          grammarName: className
        });
        errors.push({
          message: errMsg,
          type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
          ruleName: rule.name
        });
      }
      return errors;
    }
    exports2.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;
    function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
      var errors = [];
      var errMsg;
      if (!(0, includes_1.default)(definedRulesNames, ruleName)) {
        errMsg = "Invalid rule override, rule: ->".concat(ruleName, "<- cannot be overridden in the grammar: ->").concat(className, "<-") + "as it is not defined in any of the super grammars ";
        errors.push({
          message: errMsg,
          type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
          ruleName
        });
      }
      return errors;
    }
    exports2.validateRuleIsOverridden = validateRuleIsOverridden;
    function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path2) {
      if (path2 === void 0) {
        path2 = [];
      }
      var errors = [];
      var nextNonTerminals = getFirstNoneTerminal(currRule.definition);
      if ((0, isEmpty_1.default)(nextNonTerminals)) {
        return [];
      } else {
        var ruleName = topRule.name;
        var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);
        if (foundLeftRecursion) {
          errors.push({
            message: errMsgProvider.buildLeftRecursionError({
              topLevelRule: topRule,
              leftRecursionPath: path2
            }),
            type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,
            ruleName
          });
        }
        var validNextSteps = (0, difference_1.default)(nextNonTerminals, path2.concat([topRule]));
        var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function(currRefRule) {
          var newPath = (0, clone_1.default)(path2);
          newPath.push(currRefRule);
          return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
        });
        return errors.concat(errorsFromNextSteps);
      }
    }
    exports2.validateNoLeftRecursion = validateNoLeftRecursion;
    function getFirstNoneTerminal(definition) {
      var result = [];
      if ((0, isEmpty_1.default)(definition)) {
        return result;
      }
      var firstProd = (0, first_1.default)(definition);
      if (firstProd instanceof gast_2.NonTerminal) {
        result.push(firstProd.referencedRule);
      } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {
        result = result.concat(getFirstNoneTerminal(firstProd.definition));
      } else if (firstProd instanceof gast_2.Alternation) {
        result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function(currSubDef) {
          return getFirstNoneTerminal(currSubDef.definition);
        }));
      } else if (firstProd instanceof gast_2.Terminal) {
      } else {
        throw Error("non exhaustive match");
      }
      var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);
      var hasMore = definition.length > 1;
      if (isFirstOptional && hasMore) {
        var rest = (0, drop_1.default)(definition);
        return result.concat(getFirstNoneTerminal(rest));
      } else {
        return result;
      }
    }
    exports2.getFirstNoneTerminal = getFirstNoneTerminal;
    var OrCollector = (
      /** @class */
      function(_super) {
        __extends(OrCollector2, _super);
        function OrCollector2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.alternations = [];
          return _this;
        }
        OrCollector2.prototype.visitAlternation = function(node) {
          this.alternations.push(node);
        };
        return OrCollector2;
      }(gast_3.GAstVisitor)
    );
    function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        var exceptLast = (0, dropRight_1.default)(currOr.definition);
        return (0, flatMap_1.default)(exceptLast, function(currAlternative, currAltIdx) {
          var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);
          if ((0, isEmpty_1.default)(possibleFirstInAlt)) {
            return [
              {
                message: errMsgProvider.buildEmptyAlternationError({
                  topLevelRule,
                  alternation: currOr,
                  emptyChoiceIdx: currAltIdx
                }),
                type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
                ruleName: topLevelRule.name,
                occurrence: currOr.idx,
                alternative: currAltIdx + 1
              }
            ];
          } else {
            return [];
          }
        });
      });
      return errors;
    }
    exports2.validateEmptyOrAlternative = validateEmptyOrAlternative;
    function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      ors = (0, reject_1.default)(ors, function(currOr) {
        return currOr.ignoreAmbiguities === true;
      });
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        var currOccurrence = currOr.idx;
        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
        var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);
      });
      return errors;
    }
    exports2.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;
    var RepetitionCollector = (
      /** @class */
      function(_super) {
        __extends(RepetitionCollector2, _super);
        function RepetitionCollector2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.allProductions = [];
          return _this;
        }
        RepetitionCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
          this.allProductions.push(manySep);
        };
        RepetitionCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
          this.allProductions.push(atLeastOne);
        };
        RepetitionCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
          this.allProductions.push(atLeastOneSep);
        };
        RepetitionCollector2.prototype.visitRepetition = function(many) {
          this.allProductions.push(many);
        };
        return RepetitionCollector2;
      }(gast_3.GAstVisitor)
    );
    exports2.RepetitionCollector = RepetitionCollector;
    function validateTooManyAlts(topLevelRule, errMsgProvider) {
      var orCollector = new OrCollector();
      topLevelRule.accept(orCollector);
      var ors = orCollector.alternations;
      var errors = (0, flatMap_1.default)(ors, function(currOr) {
        if (currOr.definition.length > 255) {
          return [
            {
              message: errMsgProvider.buildTooManyAlternativesError({
                topLevelRule,
                alternation: currOr
              }),
              type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,
              ruleName: topLevelRule.name,
              occurrence: currOr.idx
            }
          ];
        } else {
          return [];
        }
      });
      return errors;
    }
    exports2.validateTooManyAlts = validateTooManyAlts;
    function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
      var errors = [];
      (0, forEach_1.default)(topLevelRules, function(currTopRule) {
        var collectorVisitor = new RepetitionCollector();
        currTopRule.accept(collectorVisitor);
        var allRuleProductions = collectorVisitor.allProductions;
        (0, forEach_1.default)(allRuleProductions, function(currProd) {
          var prodType = (0, lookahead_1.getProdType)(currProd);
          var actualMaxLookahead = currProd.maxLookahead || maxLookahead;
          var currOccurrence = currProd.idx;
          var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);
          var pathsInsideProduction = paths[0];
          if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {
            var errMsg = errMsgProvider.buildEmptyRepetitionError({
              topLevelRule: currTopRule,
              repetition: currProd
            });
            errors.push({
              message: errMsg,
              type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
              ruleName: currTopRule.name
            });
          }
        });
      });
      return errors;
    }
    exports2.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;
    function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
      var foundAmbiguousPaths = [];
      var identicalAmbiguities = (0, reduce_1.default)(alternatives, function(result, currAlt, currAltIdx) {
        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
          return result;
        }
        (0, forEach_1.default)(currAlt, function(currPath) {
          var altsCurrPathAppearsIn = [currAltIdx];
          (0, forEach_1.default)(alternatives, function(currOtherAlt, currOtherAltIdx) {
            if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) && // ignore (skip) ambiguities with this "other" alternative
            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {
              altsCurrPathAppearsIn.push(currOtherAltIdx);
            }
          });
          if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {
            foundAmbiguousPaths.push(currPath);
            result.push({
              alts: altsCurrPathAppearsIn,
              path: currPath
            });
          }
        });
        return result;
      }, []);
      var currErrors = (0, map_1.default)(identicalAmbiguities, function(currAmbDescriptor) {
        var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function(currAltIdx) {
          return currAltIdx + 1;
        });
        var currMessage = errMsgProvider.buildAlternationAmbiguityError({
          topLevelRule: rule,
          alternation,
          ambiguityIndices: ambgIndices,
          prefixPath: currAmbDescriptor.path
        });
        return {
          message: currMessage,
          type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
          ruleName: rule.name,
          occurrence: alternation.idx,
          alternatives: currAmbDescriptor.alts
        };
      });
      return currErrors;
    }
    function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
      var pathsAndIndices = (0, reduce_1.default)(alternatives, function(result, currAlt, idx) {
        var currPathsAndIdx = (0, map_1.default)(currAlt, function(currPath) {
          return { idx, path: currPath };
        });
        return result.concat(currPathsAndIdx);
      }, []);
      var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function(currPathAndIdx) {
        var alternativeGast = alternation.definition[currPathAndIdx.idx];
        if (alternativeGast.ignoreAmbiguities === true) {
          return [];
        }
        var targetIdx = currPathAndIdx.idx;
        var targetPath = currPathAndIdx.path;
        var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function(searchPathAndIdx) {
          return (
            // ignore (skip) ambiguities with this "other" alternative
            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads
            // will be be detected using a different validation.
            (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)
          );
        });
        var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function(currAmbPathAndIdx) {
          var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
          var occurrence = alternation.idx === 0 ? "" : alternation.idx;
          var message = errMsgProvider.buildAlternationPrefixAmbiguityError({
            topLevelRule: rule,
            alternation,
            ambiguityIndices: ambgIndices,
            prefixPath: currAmbPathAndIdx.path
          });
          return {
            message,
            type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
            ruleName: rule.name,
            occurrence,
            alternatives: ambgIndices
          };
        });
        return currPathPrefixErrors;
      }));
      return errors;
    }
    exports2.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;
    function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
      var errors = [];
      var tokenNames = (0, map_1.default)(tokenTypes, function(currToken) {
        return currToken.name;
      });
      (0, forEach_1.default)(topLevels, function(currRule) {
        var currRuleName = currRule.name;
        if ((0, includes_1.default)(tokenNames, currRuleName)) {
          var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
          errors.push({
            message: errMsg,
            type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
            ruleName: currRuleName
          });
        }
      });
      return errors;
    }
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js
var require_gast_resolver_public = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateGrammar = exports2.resolveGrammar = void 0;
    var forEach_1 = __importDefault(require_forEach());
    var defaults_1 = __importDefault(require_defaults());
    var resolver_1 = require_resolver();
    var checks_1 = require_checks();
    var errors_public_1 = require_errors_public();
    function resolveGrammar(options) {
      var actualOptions = (0, defaults_1.default)(options, {
        errMsgProvider: errors_public_1.defaultGrammarResolverErrorProvider
      });
      var topRulesTable = {};
      (0, forEach_1.default)(options.rules, function(rule) {
        topRulesTable[rule.name] = rule;
      });
      return (0, resolver_1.resolveGrammar)(topRulesTable, actualOptions.errMsgProvider);
    }
    exports2.resolveGrammar = resolveGrammar;
    function validateGrammar(options) {
      options = (0, defaults_1.default)(options, {
        errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider
      });
      return (0, checks_1.validateGrammar)(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);
    }
    exports2.validateGrammar = validateGrammar;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/exceptions_public.js
var require_exceptions_public = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/exceptions_public.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EarlyExitException = exports2.NotAllInputParsedException = exports2.NoViableAltException = exports2.MismatchedTokenException = exports2.isRecognitionException = void 0;
    var includes_1 = __importDefault(require_includes());
    var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
    var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
    var EARLY_EXIT_EXCEPTION = "EarlyExitException";
    var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
    var RECOGNITION_EXCEPTION_NAMES = [
      MISMATCHED_TOKEN_EXCEPTION,
      NO_VIABLE_ALT_EXCEPTION,
      EARLY_EXIT_EXCEPTION,
      NOT_ALL_INPUT_PARSED_EXCEPTION
    ];
    Object.freeze(RECOGNITION_EXCEPTION_NAMES);
    function isRecognitionException(error) {
      return (0, includes_1.default)(RECOGNITION_EXCEPTION_NAMES, error.name);
    }
    exports2.isRecognitionException = isRecognitionException;
    var RecognitionException = (
      /** @class */
      function(_super) {
        __extends(RecognitionException2, _super);
        function RecognitionException2(message, token) {
          var _newTarget = this.constructor;
          var _this = _super.call(this, message) || this;
          _this.token = token;
          _this.resyncedTokens = [];
          Object.setPrototypeOf(_this, _newTarget.prototype);
          if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _this.constructor);
          }
          return _this;
        }
        return RecognitionException2;
      }(Error)
    );
    var MismatchedTokenException = (
      /** @class */
      function(_super) {
        __extends(MismatchedTokenException2, _super);
        function MismatchedTokenException2(message, token, previousToken) {
          var _this = _super.call(this, message, token) || this;
          _this.previousToken = previousToken;
          _this.name = MISMATCHED_TOKEN_EXCEPTION;
          return _this;
        }
        return MismatchedTokenException2;
      }(RecognitionException)
    );
    exports2.MismatchedTokenException = MismatchedTokenException;
    var NoViableAltException = (
      /** @class */
      function(_super) {
        __extends(NoViableAltException2, _super);
        function NoViableAltException2(message, token, previousToken) {
          var _this = _super.call(this, message, token) || this;
          _this.previousToken = previousToken;
          _this.name = NO_VIABLE_ALT_EXCEPTION;
          return _this;
        }
        return NoViableAltException2;
      }(RecognitionException)
    );
    exports2.NoViableAltException = NoViableAltException;
    var NotAllInputParsedException = (
      /** @class */
      function(_super) {
        __extends(NotAllInputParsedException2, _super);
        function NotAllInputParsedException2(message, token) {
          var _this = _super.call(this, message, token) || this;
          _this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
          return _this;
        }
        return NotAllInputParsedException2;
      }(RecognitionException)
    );
    exports2.NotAllInputParsedException = NotAllInputParsedException;
    var EarlyExitException = (
      /** @class */
      function(_super) {
        __extends(EarlyExitException2, _super);
        function EarlyExitException2(message, token, previousToken) {
          var _this = _super.call(this, message, token) || this;
          _this.previousToken = previousToken;
          _this.name = EARLY_EXIT_EXCEPTION;
          return _this;
        }
        return EarlyExitException2;
      }(RecognitionException)
    );
    exports2.EarlyExitException = EarlyExitException;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js
var require_recoverable = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attemptInRepetitionRecovery = exports2.Recoverable = exports2.InRuleRecoveryException = exports2.IN_RULE_RECOVERY_EXCEPTION = exports2.EOF_FOLLOW_KEY = void 0;
    var tokens_public_1 = require_tokens_public();
    var isEmpty_1 = __importDefault(require_isEmpty());
    var dropRight_1 = __importDefault(require_dropRight());
    var flatten_1 = __importDefault(require_flatten());
    var map_1 = __importDefault(require_map());
    var find_1 = __importDefault(require_find());
    var has_1 = __importDefault(require_has());
    var includes_1 = __importDefault(require_includes());
    var clone_1 = __importDefault(require_clone());
    var exceptions_public_1 = require_exceptions_public();
    var constants_1 = require_constants();
    var parser_1 = require_parser();
    exports2.EOF_FOLLOW_KEY = {};
    exports2.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
    var InRuleRecoveryException = (
      /** @class */
      function(_super) {
        __extends(InRuleRecoveryException2, _super);
        function InRuleRecoveryException2(message) {
          var _this = _super.call(this, message) || this;
          _this.name = exports2.IN_RULE_RECOVERY_EXCEPTION;
          return _this;
        }
        return InRuleRecoveryException2;
      }(Error)
    );
    exports2.InRuleRecoveryException = InRuleRecoveryException;
    var Recoverable = (
      /** @class */
      function() {
        function Recoverable2() {
        }
        Recoverable2.prototype.initRecoverable = function(config) {
          this.firstAfterRepMap = {};
          this.resyncFollows = {};
          this.recoveryEnabled = (0, has_1.default)(config, "recoveryEnabled") ? config.recoveryEnabled : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;
          if (this.recoveryEnabled) {
            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
          }
        };
        Recoverable2.prototype.getTokenToInsert = function(tokType) {
          var tokToInsert = (0, tokens_public_1.createTokenInstance)(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
          tokToInsert.isInsertedInRecovery = true;
          return tokToInsert;
        };
        Recoverable2.prototype.canTokenTypeBeInsertedInRecovery = function(tokType) {
          return true;
        };
        Recoverable2.prototype.canTokenTypeBeDeletedInRecovery = function(tokType) {
          return true;
        };
        Recoverable2.prototype.tryInRepetitionRecovery = function(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
          var _this = this;
          var reSyncTokType = this.findReSyncTokenType();
          var savedLexerState = this.exportLexerState();
          var resyncedTokens = [];
          var passedResyncPoint = false;
          var nextTokenWithoutResync = this.LA(1);
          var currToken = this.LA(1);
          var generateErrorMessage = function() {
            var previousToken = _this.LA(0);
            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({
              expected: expectedTokType,
              actual: nextTokenWithoutResync,
              previous: previousToken,
              ruleName: _this.getCurrRuleFullName()
            });
            var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));
            error.resyncedTokens = (0, dropRight_1.default)(resyncedTokens);
            _this.SAVE_ERROR(error);
          };
          while (!passedResyncPoint) {
            if (this.tokenMatcher(currToken, expectedTokType)) {
              generateErrorMessage();
              return;
            } else if (lookAheadFunc.call(this)) {
              generateErrorMessage();
              grammarRule.apply(this, grammarRuleArgs);
              return;
            } else if (this.tokenMatcher(currToken, reSyncTokType)) {
              passedResyncPoint = true;
            } else {
              currToken = this.SKIP_TOKEN();
              this.addToResyncTokens(currToken, resyncedTokens);
            }
          }
          this.importLexerState(savedLexerState);
        };
        Recoverable2.prototype.shouldInRepetitionRecoveryBeTried = function(expectTokAfterLastMatch, nextTokIdx, notStuck) {
          if (notStuck === false) {
            return false;
          }
          if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
            return false;
          }
          if (this.isBackTracking()) {
            return false;
          }
          if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
            return false;
          }
          return true;
        };
        Recoverable2.prototype.getFollowsForInRuleRecovery = function(tokType, tokIdxInRule) {
          var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
          var follows = this.getNextPossibleTokenTypes(grammarPath);
          return follows;
        };
        Recoverable2.prototype.tryInRuleRecovery = function(expectedTokType, follows) {
          if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
            var tokToInsert = this.getTokenToInsert(expectedTokType);
            return tokToInsert;
          }
          if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
            var nextTok = this.SKIP_TOKEN();
            this.consumeToken();
            return nextTok;
          }
          throw new InRuleRecoveryException("sad sad panda");
        };
        Recoverable2.prototype.canPerformInRuleRecovery = function(expectedToken, follows) {
          return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);
        };
        Recoverable2.prototype.canRecoverWithSingleTokenInsertion = function(expectedTokType, follows) {
          var _this = this;
          if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
            return false;
          }
          if ((0, isEmpty_1.default)(follows)) {
            return false;
          }
          var mismatchedTok = this.LA(1);
          var isMisMatchedTokInFollows = (0, find_1.default)(follows, function(possibleFollowsTokType) {
            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
          }) !== void 0;
          return isMisMatchedTokInFollows;
        };
        Recoverable2.prototype.canRecoverWithSingleTokenDeletion = function(expectedTokType) {
          if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {
            return false;
          }
          var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
          return isNextTokenWhatIsExpected;
        };
        Recoverable2.prototype.isInCurrentRuleReSyncSet = function(tokenTypeIdx) {
          var followKey = this.getCurrFollowKey();
          var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
          return (0, includes_1.default)(currentRuleReSyncSet, tokenTypeIdx);
        };
        Recoverable2.prototype.findReSyncTokenType = function() {
          var allPossibleReSyncTokTypes = this.flattenFollowSet();
          var nextToken = this.LA(1);
          var k = 2;
          while (true) {
            var foundMatch = (0, find_1.default)(allPossibleReSyncTokTypes, function(resyncTokType) {
              var canMatch = (0, tokens_public_1.tokenMatcher)(nextToken, resyncTokType);
              return canMatch;
            });
            if (foundMatch !== void 0) {
              return foundMatch;
            }
            nextToken = this.LA(k);
            k++;
          }
        };
        Recoverable2.prototype.getCurrFollowKey = function() {
          if (this.RULE_STACK.length === 1) {
            return exports2.EOF_FOLLOW_KEY;
          }
          var currRuleShortName = this.getLastExplicitRuleShortName();
          var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
          var prevRuleShortName = this.getPreviousExplicitRuleShortName();
          return {
            ruleName: this.shortRuleNameToFullName(currRuleShortName),
            idxInCallingRule: currRuleIdx,
            inRule: this.shortRuleNameToFullName(prevRuleShortName)
          };
        };
        Recoverable2.prototype.buildFullFollowKeyStack = function() {
          var _this = this;
          var explicitRuleStack = this.RULE_STACK;
          var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
          return (0, map_1.default)(explicitRuleStack, function(ruleName, idx) {
            if (idx === 0) {
              return exports2.EOF_FOLLOW_KEY;
            }
            return {
              ruleName: _this.shortRuleNameToFullName(ruleName),
              idxInCallingRule: explicitOccurrenceStack[idx],
              inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
            };
          });
        };
        Recoverable2.prototype.flattenFollowSet = function() {
          var _this = this;
          var followStack = (0, map_1.default)(this.buildFullFollowKeyStack(), function(currKey) {
            return _this.getFollowSetFromFollowKey(currKey);
          });
          return (0, flatten_1.default)(followStack);
        };
        Recoverable2.prototype.getFollowSetFromFollowKey = function(followKey) {
          if (followKey === exports2.EOF_FOLLOW_KEY) {
            return [tokens_public_1.EOF];
          }
          var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;
          return this.resyncFollows[followName];
        };
        Recoverable2.prototype.addToResyncTokens = function(token, resyncTokens) {
          if (!this.tokenMatcher(token, tokens_public_1.EOF)) {
            resyncTokens.push(token);
          }
          return resyncTokens;
        };
        Recoverable2.prototype.reSyncTo = function(tokType) {
          var resyncedTokens = [];
          var nextTok = this.LA(1);
          while (this.tokenMatcher(nextTok, tokType) === false) {
            nextTok = this.SKIP_TOKEN();
            this.addToResyncTokens(nextTok, resyncedTokens);
          }
          return (0, dropRight_1.default)(resyncedTokens);
        };
        Recoverable2.prototype.attemptInRepetitionRecovery = function(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
        };
        Recoverable2.prototype.getCurrentGrammarPath = function(tokType, tokIdxInRule) {
          var pathRuleStack = this.getHumanReadableRuleStack();
          var pathOccurrenceStack = (0, clone_1.default)(this.RULE_OCCURRENCE_STACK);
          var grammarPath = {
            ruleStack: pathRuleStack,
            occurrenceStack: pathOccurrenceStack,
            lastTok: tokType,
            lastTokOccurrence: tokIdxInRule
          };
          return grammarPath;
        };
        Recoverable2.prototype.getHumanReadableRuleStack = function() {
          var _this = this;
          return (0, map_1.default)(this.RULE_STACK, function(currShortName) {
            return _this.shortRuleNameToFullName(currShortName);
          });
        };
        return Recoverable2;
      }()
    );
    exports2.Recoverable = Recoverable;
    function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
      var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
      var firstAfterRepInfo = this.firstAfterRepMap[key];
      if (firstAfterRepInfo === void 0) {
        var currRuleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[currRuleName];
        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);
        firstAfterRepInfo = walker.startWalking();
        this.firstAfterRepMap[key] = firstAfterRepInfo;
      }
      var expectTokAfterLastMatch = firstAfterRepInfo.token;
      var nextTokIdx = firstAfterRepInfo.occurrence;
      var isEndOfRule = firstAfterRepInfo.isEndOfRule;
      if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {
        expectTokAfterLastMatch = tokens_public_1.EOF;
        nextTokIdx = 1;
      }
      if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {
        return;
      }
      if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
      }
    }
    exports2.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/keys.js
var require_keys2 = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/keys.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKeyForAutomaticLookahead = exports2.AT_LEAST_ONE_SEP_IDX = exports2.MANY_SEP_IDX = exports2.AT_LEAST_ONE_IDX = exports2.MANY_IDX = exports2.OPTION_IDX = exports2.OR_IDX = exports2.BITS_FOR_ALT_IDX = exports2.BITS_FOR_RULE_IDX = exports2.BITS_FOR_OCCURRENCE_IDX = exports2.BITS_FOR_METHOD_TYPE = void 0;
    exports2.BITS_FOR_METHOD_TYPE = 4;
    exports2.BITS_FOR_OCCURRENCE_IDX = 8;
    exports2.BITS_FOR_RULE_IDX = 12;
    exports2.BITS_FOR_ALT_IDX = 8;
    exports2.OR_IDX = 1 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.OPTION_IDX = 2 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.MANY_IDX = 3 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.AT_LEAST_ONE_IDX = 4 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.MANY_SEP_IDX = 5 << exports2.BITS_FOR_OCCURRENCE_IDX;
    exports2.AT_LEAST_ONE_SEP_IDX = 6 << exports2.BITS_FOR_OCCURRENCE_IDX;
    function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
      return occurrence | dslMethodIdx | ruleIdx;
    }
    exports2.getKeyForAutomaticLookahead = getKeyForAutomaticLookahead;
    var BITS_START_FOR_ALT_IDX = 32 - exports2.BITS_FOR_ALT_IDX;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js
var require_llk_lookahead = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LLkLookaheadStrategy = void 0;
    var flatMap_1 = __importDefault(require_flatMap());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var errors_public_1 = require_errors_public();
    var parser_1 = require_parser();
    var checks_1 = require_checks();
    var lookahead_1 = require_lookahead();
    var LLkLookaheadStrategy = (
      /** @class */
      function() {
        function LLkLookaheadStrategy2(options) {
          var _a;
          this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
        }
        LLkLookaheadStrategy2.prototype.validate = function(options) {
          var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);
          if ((0, isEmpty_1.default)(leftRecursionErrors)) {
            var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);
            var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);
            var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);
            var allErrors = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], leftRecursionErrors, true), emptyAltErrors, true), ambiguousAltsErrors, true), emptyRepetitionErrors, true);
            return allErrors;
          }
          return leftRecursionErrors;
        };
        LLkLookaheadStrategy2.prototype.validateNoLeftRecursion = function(rules) {
          return (0, flatMap_1.default)(rules, function(currTopRule) {
            return (0, checks_1.validateNoLeftRecursion)(currTopRule, currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);
          });
        };
        LLkLookaheadStrategy2.prototype.validateEmptyOrAlternatives = function(rules) {
          return (0, flatMap_1.default)(rules, function(currTopRule) {
            return (0, checks_1.validateEmptyOrAlternative)(currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);
          });
        };
        LLkLookaheadStrategy2.prototype.validateAmbiguousAlternationAlternatives = function(rules, maxLookahead) {
          return (0, flatMap_1.default)(rules, function(currTopRule) {
            return (0, checks_1.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);
          });
        };
        LLkLookaheadStrategy2.prototype.validateSomeNonEmptyLookaheadPath = function(rules, maxLookahead) {
          return (0, checks_1.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);
        };
        LLkLookaheadStrategy2.prototype.buildLookaheadForAlternation = function(options) {
          return (0, lookahead_1.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, lookahead_1.buildAlternativesLookAheadFunc);
        };
        LLkLookaheadStrategy2.prototype.buildLookaheadForOptional = function(options) {
          return (0, lookahead_1.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0, lookahead_1.getProdType)(options.prodType), lookahead_1.buildSingleAlternativeLookaheadFunction);
        };
        return LLkLookaheadStrategy2;
      }()
    );
    exports2.LLkLookaheadStrategy = LLkLookaheadStrategy;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js
var require_looksahead = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.collectMethods = exports2.LooksAhead = void 0;
    var forEach_1 = __importDefault(require_forEach());
    var has_1 = __importDefault(require_has());
    var parser_1 = require_parser();
    var keys_1 = require_keys2();
    var gast_1 = require_api5();
    var gast_2 = require_api5();
    var llk_lookahead_1 = require_llk_lookahead();
    var LooksAhead = (
      /** @class */
      function() {
        function LooksAhead2() {
        }
        LooksAhead2.prototype.initLooksAhead = function(config) {
          this.dynamicTokensEnabled = (0, has_1.default)(config, "dynamicTokensEnabled") ? config.dynamicTokensEnabled : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
          this.maxLookahead = (0, has_1.default)(config, "maxLookahead") ? config.maxLookahead : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
          this.lookaheadStrategy = (0, has_1.default)(config, "lookaheadStrategy") ? config.lookaheadStrategy : new llk_lookahead_1.LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });
          this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
        };
        LooksAhead2.prototype.preComputeLookaheadFunctions = function(rules) {
          var _this = this;
          (0, forEach_1.default)(rules, function(currRule) {
            _this.TRACE_INIT("".concat(currRule.name, " Rule Lookahead"), function() {
              var _a = collectMethods(currRule), alternation = _a.alternation, repetition = _a.repetition, option = _a.option, repetitionMandatory = _a.repetitionMandatory, repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a.repetitionWithSeparator;
              (0, forEach_1.default)(alternation, function(currProd) {
                var prodIdx = currProd.idx === 0 ? "" : currProd.idx;
                _this.TRACE_INIT("".concat((0, gast_2.getProductionDslName)(currProd)).concat(prodIdx), function() {
                  var laFunc = _this.lookaheadStrategy.buildLookaheadForAlternation({
                    prodOccurrence: currProd.idx,
                    rule: currRule,
                    maxLookahead: currProd.maxLookahead || _this.maxLookahead,
                    hasPredicates: currProd.hasPredicates,
                    dynamicTokensEnabled: _this.dynamicTokensEnabled
                  });
                  var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);
                  _this.setLaFuncCache(key, laFunc);
                });
              });
              (0, forEach_1.default)(repetition, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, "Repetition", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(option, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, "Option", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(repetitionMandatory, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, "RepetitionMandatory", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(repetitionMandatoryWithSeparator, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, "RepetitionMandatoryWithSeparator", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
              (0, forEach_1.default)(repetitionWithSeparator, function(currProd) {
                _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, "RepetitionWithSeparator", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
              });
            });
          });
        };
        LooksAhead2.prototype.computeLookaheadFunc = function(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
          var _this = this;
          this.TRACE_INIT("".concat(dslMethodName).concat(prodOccurrence === 0 ? "" : prodOccurrence), function() {
            var laFunc = _this.lookaheadStrategy.buildLookaheadForOptional({
              prodOccurrence,
              rule,
              maxLookahead: prodMaxLookahead || _this.maxLookahead,
              dynamicTokensEnabled: _this.dynamicTokensEnabled,
              prodType
            });
            var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
            _this.setLaFuncCache(key, laFunc);
          });
        };
        LooksAhead2.prototype.getKeyForAutomaticLookahead = function(dslMethodIdx, occurrence) {
          var currRuleShortName = this.getLastExplicitRuleShortName();
          return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);
        };
        LooksAhead2.prototype.getLaFuncFromCache = function(key) {
          return this.lookAheadFuncsCache.get(key);
        };
        LooksAhead2.prototype.setLaFuncCache = function(key, value) {
          this.lookAheadFuncsCache.set(key, value);
        };
        return LooksAhead2;
      }()
    );
    exports2.LooksAhead = LooksAhead;
    var DslMethodsCollectorVisitor = (
      /** @class */
      function(_super) {
        __extends(DslMethodsCollectorVisitor2, _super);
        function DslMethodsCollectorVisitor2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
          };
          return _this;
        }
        DslMethodsCollectorVisitor2.prototype.reset = function() {
          this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
          };
        };
        DslMethodsCollectorVisitor2.prototype.visitOption = function(option) {
          this.dslMethods.option.push(option);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetitionWithSeparator = function(manySep) {
          this.dslMethods.repetitionWithSeparator.push(manySep);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatory = function(atLeastOne) {
          this.dslMethods.repetitionMandatory.push(atLeastOne);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
          this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
        };
        DslMethodsCollectorVisitor2.prototype.visitRepetition = function(many) {
          this.dslMethods.repetition.push(many);
        };
        DslMethodsCollectorVisitor2.prototype.visitAlternation = function(or) {
          this.dslMethods.alternation.push(or);
        };
        return DslMethodsCollectorVisitor2;
      }(gast_1.GAstVisitor)
    );
    var collectorVisitor = new DslMethodsCollectorVisitor();
    function collectMethods(rule) {
      collectorVisitor.reset();
      rule.accept(collectorVisitor);
      var dslMethods = collectorVisitor.dslMethods;
      collectorVisitor.reset();
      return dslMethods;
    }
    exports2.collectMethods = collectMethods;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/cst/cst.js
var require_cst = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/cst/cst.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addNoneTerminalToCst = exports2.addTerminalToCst = exports2.setNodeLocationFull = exports2.setNodeLocationOnlyOffset = void 0;
    function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
      if (isNaN(currNodeLocation.startOffset) === true) {
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
      }
    }
    exports2.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;
    function setNodeLocationFull(currNodeLocation, newLocationInfo) {
      if (isNaN(currNodeLocation.startOffset) === true) {
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.startColumn = newLocationInfo.startColumn;
        currNodeLocation.startLine = newLocationInfo.startLine;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
      }
    }
    exports2.setNodeLocationFull = setNodeLocationFull;
    function addTerminalToCst(node, token, tokenTypeName) {
      if (node.children[tokenTypeName] === void 0) {
        node.children[tokenTypeName] = [token];
      } else {
        node.children[tokenTypeName].push(token);
      }
    }
    exports2.addTerminalToCst = addTerminalToCst;
    function addNoneTerminalToCst(node, ruleName, ruleResult) {
      if (node.children[ruleName] === void 0) {
        node.children[ruleName] = [ruleResult];
      } else {
        node.children[ruleName].push(ruleResult);
      }
    }
    exports2.addNoneTerminalToCst = addNoneTerminalToCst;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/lang/lang_extensions.js
var require_lang_extensions = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/lang/lang_extensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defineNameProp = void 0;
    var NAME = "name";
    function defineNameProp(obj, nameValue) {
      Object.defineProperty(obj, NAME, {
        enumerable: false,
        configurable: true,
        writable: false,
        value: nameValue
      });
    }
    exports2.defineNameProp = defineNameProp;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js
var require_cst_visitor = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateMissingCstMethods = exports2.validateVisitor = exports2.CstVisitorDefinitionError = exports2.createBaseVisitorConstructorWithDefaults = exports2.createBaseSemanticVisitorConstructor = exports2.defaultVisit = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var compact_1 = __importDefault(require_compact());
    var isArray_1 = __importDefault(require_isArray());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var filter_1 = __importDefault(require_filter());
    var keys_1 = __importDefault(require_keys());
    var isFunction_1 = __importDefault(require_isFunction());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var lang_extensions_1 = require_lang_extensions();
    function defaultVisit(ctx, param) {
      var childrenNames = (0, keys_1.default)(ctx);
      var childrenNamesLength = childrenNames.length;
      for (var i = 0; i < childrenNamesLength; i++) {
        var currChildName = childrenNames[i];
        var currChildArray = ctx[currChildName];
        var currChildArrayLength = currChildArray.length;
        for (var j = 0; j < currChildArrayLength; j++) {
          var currChild = currChildArray[j];
          if (currChild.tokenTypeIdx === void 0) {
            this[currChild.name](currChild.children, param);
          }
        }
      }
    }
    exports2.defaultVisit = defaultVisit;
    function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
      var derivedConstructor = function() {
      };
      (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemantics");
      var semanticProto = {
        visit: function(cstNode, param) {
          if ((0, isArray_1.default)(cstNode)) {
            cstNode = cstNode[0];
          }
          if ((0, isUndefined_1.default)(cstNode)) {
            return void 0;
          }
          return this[cstNode.name](cstNode.children, param);
        },
        validateVisitor: function() {
          var semanticDefinitionErrors = validateVisitor(this, ruleNames);
          if (!(0, isEmpty_1.default)(semanticDefinitionErrors)) {
            var errorMessages = (0, map_1.default)(semanticDefinitionErrors, function(currDefError) {
              return currDefError.msg;
            });
            throw Error("Errors Detected in CST Visitor <".concat(this.constructor.name, ">:\n	") + "".concat(errorMessages.join("\n\n").replace(/\n/g, "\n	")));
          }
        }
      };
      derivedConstructor.prototype = semanticProto;
      derivedConstructor.prototype.constructor = derivedConstructor;
      derivedConstructor._RULE_NAMES = ruleNames;
      return derivedConstructor;
    }
    exports2.createBaseSemanticVisitorConstructor = createBaseSemanticVisitorConstructor;
    function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
      var derivedConstructor = function() {
      };
      (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
      var withDefaultsProto = Object.create(baseConstructor.prototype);
      (0, forEach_1.default)(ruleNames, function(ruleName) {
        withDefaultsProto[ruleName] = defaultVisit;
      });
      derivedConstructor.prototype = withDefaultsProto;
      derivedConstructor.prototype.constructor = derivedConstructor;
      return derivedConstructor;
    }
    exports2.createBaseVisitorConstructorWithDefaults = createBaseVisitorConstructorWithDefaults;
    var CstVisitorDefinitionError;
    (function(CstVisitorDefinitionError2) {
      CstVisitorDefinitionError2[CstVisitorDefinitionError2["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
      CstVisitorDefinitionError2[CstVisitorDefinitionError2["MISSING_METHOD"] = 1] = "MISSING_METHOD";
    })(CstVisitorDefinitionError = exports2.CstVisitorDefinitionError || (exports2.CstVisitorDefinitionError = {}));
    function validateVisitor(visitorInstance, ruleNames) {
      var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
      return missingErrors;
    }
    exports2.validateVisitor = validateVisitor;
    function validateMissingCstMethods(visitorInstance, ruleNames) {
      var missingRuleNames = (0, filter_1.default)(ruleNames, function(currRuleName) {
        return (0, isFunction_1.default)(visitorInstance[currRuleName]) === false;
      });
      var errors = (0, map_1.default)(missingRuleNames, function(currRuleName) {
        return {
          msg: "Missing visitor method: <".concat(currRuleName, "> on ").concat(visitorInstance.constructor.name, " CST Visitor."),
          type: CstVisitorDefinitionError.MISSING_METHOD,
          methodName: currRuleName
        };
      });
      return (0, compact_1.default)(errors);
    }
    exports2.validateMissingCstMethods = validateMissingCstMethods;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js
var require_tree_builder = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TreeBuilder = void 0;
    var cst_1 = require_cst();
    var noop_1 = __importDefault(require_noop());
    var has_1 = __importDefault(require_has());
    var keys_1 = __importDefault(require_keys());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var cst_visitor_1 = require_cst_visitor();
    var parser_1 = require_parser();
    var TreeBuilder = (
      /** @class */
      function() {
        function TreeBuilder2() {
        }
        TreeBuilder2.prototype.initTreeBuilder = function(config) {
          this.CST_STACK = [];
          this.outputCst = config.outputCst;
          this.nodeLocationTracking = (0, has_1.default)(config, "nodeLocationTracking") ? config.nodeLocationTracking : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;
          if (!this.outputCst) {
            this.cstInvocationStateUpdate = noop_1.default;
            this.cstFinallyStateUpdate = noop_1.default;
            this.cstPostTerminal = noop_1.default;
            this.cstPostNonTerminal = noop_1.default;
            this.cstPostRule = noop_1.default;
          } else {
            if (/full/i.test(this.nodeLocationTracking)) {
              if (this.recoveryEnabled) {
                this.setNodeLocationFromToken = cst_1.setNodeLocationFull;
                this.setNodeLocationFromNode = cst_1.setNodeLocationFull;
                this.cstPostRule = noop_1.default;
                this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
              } else {
                this.setNodeLocationFromToken = noop_1.default;
                this.setNodeLocationFromNode = noop_1.default;
                this.cstPostRule = this.cstPostRuleFull;
                this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
              }
            } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
              if (this.recoveryEnabled) {
                this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;
                this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;
                this.cstPostRule = noop_1.default;
                this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
              } else {
                this.setNodeLocationFromToken = noop_1.default;
                this.setNodeLocationFromNode = noop_1.default;
                this.cstPostRule = this.cstPostRuleOnlyOffset;
                this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
              }
            } else if (/none/i.test(this.nodeLocationTracking)) {
              this.setNodeLocationFromToken = noop_1.default;
              this.setNodeLocationFromNode = noop_1.default;
              this.cstPostRule = noop_1.default;
              this.setInitialNodeLocation = noop_1.default;
            } else {
              throw Error('Invalid <nodeLocationTracking> config option: "'.concat(config.nodeLocationTracking, '"'));
            }
          }
        };
        TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(cstNode) {
          cstNode.location = {
            startOffset: NaN,
            endOffset: NaN
          };
        };
        TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRegular = function(cstNode) {
          cstNode.location = {
            // without error recovery the starting Location of a new CstNode is guaranteed
            // To be the next Token's startOffset (for valid inputs).
            // For invalid inputs there won't be any CSTOutput so this potential
            // inaccuracy does not matter
            startOffset: this.LA(1).startOffset,
            endOffset: NaN
          };
        };
        TreeBuilder2.prototype.setInitialNodeLocationFullRecovery = function(cstNode) {
          cstNode.location = {
            startOffset: NaN,
            startLine: NaN,
            startColumn: NaN,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
          };
        };
        TreeBuilder2.prototype.setInitialNodeLocationFullRegular = function(cstNode) {
          var nextToken = this.LA(1);
          cstNode.location = {
            startOffset: nextToken.startOffset,
            startLine: nextToken.startLine,
            startColumn: nextToken.startColumn,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
          };
        };
        TreeBuilder2.prototype.cstInvocationStateUpdate = function(fullRuleName) {
          var cstNode = {
            name: fullRuleName,
            children: /* @__PURE__ */ Object.create(null)
          };
          this.setInitialNodeLocation(cstNode);
          this.CST_STACK.push(cstNode);
        };
        TreeBuilder2.prototype.cstFinallyStateUpdate = function() {
          this.CST_STACK.pop();
        };
        TreeBuilder2.prototype.cstPostRuleFull = function(ruleCstNode) {
          var prevToken = this.LA(0);
          var loc = ruleCstNode.location;
          if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
            loc.endLine = prevToken.endLine;
            loc.endColumn = prevToken.endColumn;
          } else {
            loc.startOffset = NaN;
            loc.startLine = NaN;
            loc.startColumn = NaN;
          }
        };
        TreeBuilder2.prototype.cstPostRuleOnlyOffset = function(ruleCstNode) {
          var prevToken = this.LA(0);
          var loc = ruleCstNode.location;
          if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
          } else {
            loc.startOffset = NaN;
          }
        };
        TreeBuilder2.prototype.cstPostTerminal = function(key, consumedToken) {
          var rootCst = this.CST_STACK[this.CST_STACK.length - 1];
          (0, cst_1.addTerminalToCst)(rootCst, consumedToken, key);
          this.setNodeLocationFromToken(rootCst.location, consumedToken);
        };
        TreeBuilder2.prototype.cstPostNonTerminal = function(ruleCstResult, ruleName) {
          var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
          (0, cst_1.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult);
          this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
        };
        TreeBuilder2.prototype.getBaseCstVisitorConstructor = function() {
          if ((0, isUndefined_1.default)(this.baseCstVisitorConstructor)) {
            var newBaseCstVisitorConstructor = (0, cst_visitor_1.createBaseSemanticVisitorConstructor)(this.className, (0, keys_1.default)(this.gastProductionsCache));
            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
            return newBaseCstVisitorConstructor;
          }
          return this.baseCstVisitorConstructor;
        };
        TreeBuilder2.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
          if ((0, isUndefined_1.default)(this.baseCstVisitorWithDefaultsConstructor)) {
            var newConstructor = (0, cst_visitor_1.createBaseVisitorConstructorWithDefaults)(this.className, (0, keys_1.default)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
            this.baseCstVisitorWithDefaultsConstructor = newConstructor;
            return newConstructor;
          }
          return this.baseCstVisitorWithDefaultsConstructor;
        };
        TreeBuilder2.prototype.getLastExplicitRuleShortName = function() {
          var ruleStack = this.RULE_STACK;
          return ruleStack[ruleStack.length - 1];
        };
        TreeBuilder2.prototype.getPreviousExplicitRuleShortName = function() {
          var ruleStack = this.RULE_STACK;
          return ruleStack[ruleStack.length - 2];
        };
        TreeBuilder2.prototype.getLastExplicitRuleOccurrenceIndex = function() {
          var occurrenceStack = this.RULE_OCCURRENCE_STACK;
          return occurrenceStack[occurrenceStack.length - 1];
        };
        return TreeBuilder2;
      }()
    );
    exports2.TreeBuilder = TreeBuilder;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js
var require_lexer_adapter = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerAdapter = void 0;
    var parser_1 = require_parser();
    var LexerAdapter = (
      /** @class */
      function() {
        function LexerAdapter2() {
        }
        LexerAdapter2.prototype.initLexerAdapter = function() {
          this.tokVector = [];
          this.tokVectorLength = 0;
          this.currIdx = -1;
        };
        Object.defineProperty(LexerAdapter2.prototype, "input", {
          get: function() {
            return this.tokVector;
          },
          set: function(newInput) {
            if (this.selfAnalysisDone !== true) {
              throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
            }
            this.reset();
            this.tokVector = newInput;
            this.tokVectorLength = newInput.length;
          },
          enumerable: false,
          configurable: true
        });
        LexerAdapter2.prototype.SKIP_TOKEN = function() {
          if (this.currIdx <= this.tokVector.length - 2) {
            this.consumeToken();
            return this.LA(1);
          } else {
            return parser_1.END_OF_FILE;
          }
        };
        LexerAdapter2.prototype.LA = function(howMuch) {
          var soughtIdx = this.currIdx + howMuch;
          if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
            return parser_1.END_OF_FILE;
          } else {
            return this.tokVector[soughtIdx];
          }
        };
        LexerAdapter2.prototype.consumeToken = function() {
          this.currIdx++;
        };
        LexerAdapter2.prototype.exportLexerState = function() {
          return this.currIdx;
        };
        LexerAdapter2.prototype.importLexerState = function(newState) {
          this.currIdx = newState;
        };
        LexerAdapter2.prototype.resetLexerState = function() {
          this.currIdx = -1;
        };
        LexerAdapter2.prototype.moveToTerminatedState = function() {
          this.currIdx = this.tokVector.length - 1;
        };
        LexerAdapter2.prototype.getLexerPosition = function() {
          return this.exportLexerState();
        };
        return LexerAdapter2;
      }()
    );
    exports2.LexerAdapter = LexerAdapter;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js
var require_recognizer_api = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecognizerApi = void 0;
    var values_1 = __importDefault(require_values());
    var includes_1 = __importDefault(require_includes());
    var exceptions_public_1 = require_exceptions_public();
    var parser_1 = require_parser();
    var errors_public_1 = require_errors_public();
    var checks_1 = require_checks();
    var gast_1 = require_api5();
    var RecognizerApi = (
      /** @class */
      function() {
        function RecognizerApi2() {
        }
        RecognizerApi2.prototype.ACTION = function(impl) {
          return impl.call(this);
        };
        RecognizerApi2.prototype.consume = function(idx, tokType, options) {
          return this.consumeInternal(tokType, idx, options);
        };
        RecognizerApi2.prototype.subrule = function(idx, ruleToCall, options) {
          return this.subruleInternal(ruleToCall, idx, options);
        };
        RecognizerApi2.prototype.option = function(idx, actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, idx);
        };
        RecognizerApi2.prototype.or = function(idx, altsOrOpts) {
          return this.orInternal(altsOrOpts, idx);
        };
        RecognizerApi2.prototype.many = function(idx, actionORMethodDef) {
          return this.manyInternal(idx, actionORMethodDef);
        };
        RecognizerApi2.prototype.atLeastOne = function(idx, actionORMethodDef) {
          return this.atLeastOneInternal(idx, actionORMethodDef);
        };
        RecognizerApi2.prototype.CONSUME = function(tokType, options) {
          return this.consumeInternal(tokType, 0, options);
        };
        RecognizerApi2.prototype.CONSUME1 = function(tokType, options) {
          return this.consumeInternal(tokType, 1, options);
        };
        RecognizerApi2.prototype.CONSUME2 = function(tokType, options) {
          return this.consumeInternal(tokType, 2, options);
        };
        RecognizerApi2.prototype.CONSUME3 = function(tokType, options) {
          return this.consumeInternal(tokType, 3, options);
        };
        RecognizerApi2.prototype.CONSUME4 = function(tokType, options) {
          return this.consumeInternal(tokType, 4, options);
        };
        RecognizerApi2.prototype.CONSUME5 = function(tokType, options) {
          return this.consumeInternal(tokType, 5, options);
        };
        RecognizerApi2.prototype.CONSUME6 = function(tokType, options) {
          return this.consumeInternal(tokType, 6, options);
        };
        RecognizerApi2.prototype.CONSUME7 = function(tokType, options) {
          return this.consumeInternal(tokType, 7, options);
        };
        RecognizerApi2.prototype.CONSUME8 = function(tokType, options) {
          return this.consumeInternal(tokType, 8, options);
        };
        RecognizerApi2.prototype.CONSUME9 = function(tokType, options) {
          return this.consumeInternal(tokType, 9, options);
        };
        RecognizerApi2.prototype.SUBRULE = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 0, options);
        };
        RecognizerApi2.prototype.SUBRULE1 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 1, options);
        };
        RecognizerApi2.prototype.SUBRULE2 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 2, options);
        };
        RecognizerApi2.prototype.SUBRULE3 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 3, options);
        };
        RecognizerApi2.prototype.SUBRULE4 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 4, options);
        };
        RecognizerApi2.prototype.SUBRULE5 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 5, options);
        };
        RecognizerApi2.prototype.SUBRULE6 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 6, options);
        };
        RecognizerApi2.prototype.SUBRULE7 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 7, options);
        };
        RecognizerApi2.prototype.SUBRULE8 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 8, options);
        };
        RecognizerApi2.prototype.SUBRULE9 = function(ruleToCall, options) {
          return this.subruleInternal(ruleToCall, 9, options);
        };
        RecognizerApi2.prototype.OPTION = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 0);
        };
        RecognizerApi2.prototype.OPTION1 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 1);
        };
        RecognizerApi2.prototype.OPTION2 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 2);
        };
        RecognizerApi2.prototype.OPTION3 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 3);
        };
        RecognizerApi2.prototype.OPTION4 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 4);
        };
        RecognizerApi2.prototype.OPTION5 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 5);
        };
        RecognizerApi2.prototype.OPTION6 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 6);
        };
        RecognizerApi2.prototype.OPTION7 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 7);
        };
        RecognizerApi2.prototype.OPTION8 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 8);
        };
        RecognizerApi2.prototype.OPTION9 = function(actionORMethodDef) {
          return this.optionInternal(actionORMethodDef, 9);
        };
        RecognizerApi2.prototype.OR = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 0);
        };
        RecognizerApi2.prototype.OR1 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 1);
        };
        RecognizerApi2.prototype.OR2 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 2);
        };
        RecognizerApi2.prototype.OR3 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 3);
        };
        RecognizerApi2.prototype.OR4 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 4);
        };
        RecognizerApi2.prototype.OR5 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 5);
        };
        RecognizerApi2.prototype.OR6 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 6);
        };
        RecognizerApi2.prototype.OR7 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 7);
        };
        RecognizerApi2.prototype.OR8 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 8);
        };
        RecognizerApi2.prototype.OR9 = function(altsOrOpts) {
          return this.orInternal(altsOrOpts, 9);
        };
        RecognizerApi2.prototype.MANY = function(actionORMethodDef) {
          this.manyInternal(0, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY1 = function(actionORMethodDef) {
          this.manyInternal(1, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY2 = function(actionORMethodDef) {
          this.manyInternal(2, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY3 = function(actionORMethodDef) {
          this.manyInternal(3, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY4 = function(actionORMethodDef) {
          this.manyInternal(4, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY5 = function(actionORMethodDef) {
          this.manyInternal(5, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY6 = function(actionORMethodDef) {
          this.manyInternal(6, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY7 = function(actionORMethodDef) {
          this.manyInternal(7, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY8 = function(actionORMethodDef) {
          this.manyInternal(8, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY9 = function(actionORMethodDef) {
          this.manyInternal(9, actionORMethodDef);
        };
        RecognizerApi2.prototype.MANY_SEP = function(options) {
          this.manySepFirstInternal(0, options);
        };
        RecognizerApi2.prototype.MANY_SEP1 = function(options) {
          this.manySepFirstInternal(1, options);
        };
        RecognizerApi2.prototype.MANY_SEP2 = function(options) {
          this.manySepFirstInternal(2, options);
        };
        RecognizerApi2.prototype.MANY_SEP3 = function(options) {
          this.manySepFirstInternal(3, options);
        };
        RecognizerApi2.prototype.MANY_SEP4 = function(options) {
          this.manySepFirstInternal(4, options);
        };
        RecognizerApi2.prototype.MANY_SEP5 = function(options) {
          this.manySepFirstInternal(5, options);
        };
        RecognizerApi2.prototype.MANY_SEP6 = function(options) {
          this.manySepFirstInternal(6, options);
        };
        RecognizerApi2.prototype.MANY_SEP7 = function(options) {
          this.manySepFirstInternal(7, options);
        };
        RecognizerApi2.prototype.MANY_SEP8 = function(options) {
          this.manySepFirstInternal(8, options);
        };
        RecognizerApi2.prototype.MANY_SEP9 = function(options) {
          this.manySepFirstInternal(9, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE = function(actionORMethodDef) {
          this.atLeastOneInternal(0, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE1 = function(actionORMethodDef) {
          return this.atLeastOneInternal(1, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE2 = function(actionORMethodDef) {
          this.atLeastOneInternal(2, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE3 = function(actionORMethodDef) {
          this.atLeastOneInternal(3, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE4 = function(actionORMethodDef) {
          this.atLeastOneInternal(4, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE5 = function(actionORMethodDef) {
          this.atLeastOneInternal(5, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE6 = function(actionORMethodDef) {
          this.atLeastOneInternal(6, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE7 = function(actionORMethodDef) {
          this.atLeastOneInternal(7, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE8 = function(actionORMethodDef) {
          this.atLeastOneInternal(8, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE9 = function(actionORMethodDef) {
          this.atLeastOneInternal(9, actionORMethodDef);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP = function(options) {
          this.atLeastOneSepFirstInternal(0, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP1 = function(options) {
          this.atLeastOneSepFirstInternal(1, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP2 = function(options) {
          this.atLeastOneSepFirstInternal(2, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP3 = function(options) {
          this.atLeastOneSepFirstInternal(3, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP4 = function(options) {
          this.atLeastOneSepFirstInternal(4, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP5 = function(options) {
          this.atLeastOneSepFirstInternal(5, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP6 = function(options) {
          this.atLeastOneSepFirstInternal(6, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP7 = function(options) {
          this.atLeastOneSepFirstInternal(7, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP8 = function(options) {
          this.atLeastOneSepFirstInternal(8, options);
        };
        RecognizerApi2.prototype.AT_LEAST_ONE_SEP9 = function(options) {
          this.atLeastOneSepFirstInternal(9, options);
        };
        RecognizerApi2.prototype.RULE = function(name, implementation, config) {
          if (config === void 0) {
            config = parser_1.DEFAULT_RULE_CONFIG;
          }
          if ((0, includes_1.default)(this.definedRulesNames, name)) {
            var errMsg = errors_public_1.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
              topLevelRule: name,
              grammarName: this.className
            });
            var error = {
              message: errMsg,
              type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
              ruleName: name
            };
            this.definitionErrors.push(error);
          }
          this.definedRulesNames.push(name);
          var ruleImplementation = this.defineRule(name, implementation, config);
          this[name] = ruleImplementation;
          return ruleImplementation;
        };
        RecognizerApi2.prototype.OVERRIDE_RULE = function(name, impl, config) {
          if (config === void 0) {
            config = parser_1.DEFAULT_RULE_CONFIG;
          }
          var ruleErrors = (0, checks_1.validateRuleIsOverridden)(name, this.definedRulesNames, this.className);
          this.definitionErrors = this.definitionErrors.concat(ruleErrors);
          var ruleImplementation = this.defineRule(name, impl, config);
          this[name] = ruleImplementation;
          return ruleImplementation;
        };
        RecognizerApi2.prototype.BACKTRACK = function(grammarRule, args) {
          return function() {
            this.isBackTrackingStack.push(1);
            var orgState = this.saveRecogState();
            try {
              grammarRule.apply(this, args);
              return true;
            } catch (e) {
              if ((0, exceptions_public_1.isRecognitionException)(e)) {
                return false;
              } else {
                throw e;
              }
            } finally {
              this.reloadRecogState(orgState);
              this.isBackTrackingStack.pop();
            }
          };
        };
        RecognizerApi2.prototype.getGAstProductions = function() {
          return this.gastProductionsCache;
        };
        RecognizerApi2.prototype.getSerializedGastProductions = function() {
          return (0, gast_1.serializeGrammar)((0, values_1.default)(this.gastProductionsCache));
        };
        return RecognizerApi2;
      }()
    );
    exports2.RecognizerApi = RecognizerApi;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js
var require_recognizer_engine = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecognizerEngine = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var isArray_1 = __importDefault(require_isArray());
    var flatten_1 = __importDefault(require_flatten());
    var every_1 = __importDefault(require_every());
    var uniq_1 = __importDefault(require_uniq());
    var isObject_1 = __importDefault(require_isObject());
    var has_1 = __importDefault(require_has());
    var values_1 = __importDefault(require_values());
    var reduce_1 = __importDefault(require_reduce());
    var clone_1 = __importDefault(require_clone());
    var keys_1 = require_keys2();
    var exceptions_public_1 = require_exceptions_public();
    var lookahead_1 = require_lookahead();
    var interpreter_1 = require_interpreter();
    var parser_1 = require_parser();
    var recoverable_1 = require_recoverable();
    var tokens_public_1 = require_tokens_public();
    var tokens_1 = require_tokens();
    var RecognizerEngine = (
      /** @class */
      function() {
        function RecognizerEngine2() {
        }
        RecognizerEngine2.prototype.initRecognizerEngine = function(tokenVocabulary, config) {
          this.className = this.constructor.name;
          this.shortRuleNameToFull = {};
          this.fullRuleNameToShort = {};
          this.ruleShortNameIdx = 256;
          this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;
          this.subruleIdx = 0;
          this.definedRulesNames = [];
          this.tokensMap = {};
          this.isBackTrackingStack = [];
          this.RULE_STACK = [];
          this.RULE_OCCURRENCE_STACK = [];
          this.gastProductionsCache = {};
          if ((0, has_1.default)(config, "serializedGrammar")) {
            throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n	For Further details.");
          }
          if ((0, isArray_1.default)(tokenVocabulary)) {
            if ((0, isEmpty_1.default)(tokenVocabulary)) {
              throw Error("A Token Vocabulary cannot be empty.\n	Note that the first argument for the parser constructor\n	is no longer a Token vector (since v4.0).");
            }
            if (typeof tokenVocabulary[0].startOffset === "number") {
              throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n	For Further details.");
            }
          }
          if ((0, isArray_1.default)(tokenVocabulary)) {
            this.tokensMap = (0, reduce_1.default)(tokenVocabulary, function(acc, tokType) {
              acc[tokType.name] = tokType;
              return acc;
            }, {});
          } else if ((0, has_1.default)(tokenVocabulary, "modes") && (0, every_1.default)((0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)), tokens_1.isTokenType)) {
            var allTokenTypes_1 = (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes));
            var uniqueTokens = (0, uniq_1.default)(allTokenTypes_1);
            this.tokensMap = (0, reduce_1.default)(uniqueTokens, function(acc, tokType) {
              acc[tokType.name] = tokType;
              return acc;
            }, {});
          } else if ((0, isObject_1.default)(tokenVocabulary)) {
            this.tokensMap = (0, clone_1.default)(tokenVocabulary);
          } else {
            throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
          }
          this.tokensMap["EOF"] = tokens_public_1.EOF;
          var allTokenTypes = (0, has_1.default)(tokenVocabulary, "modes") ? (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)) : (0, values_1.default)(tokenVocabulary);
          var noTokenCategoriesUsed = (0, every_1.default)(allTokenTypes, function(tokenConstructor) {
            return (0, isEmpty_1.default)(tokenConstructor.categoryMatches);
          });
          this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
          (0, tokens_1.augmentTokenTypes)((0, values_1.default)(this.tokensMap));
        };
        RecognizerEngine2.prototype.defineRule = function(ruleName, impl, config) {
          if (this.selfAnalysisDone) {
            throw Error("Grammar rule <".concat(ruleName, "> may not be defined after the 'performSelfAnalysis' method has been called'\n") + "Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
          }
          var resyncEnabled = (0, has_1.default)(config, "resyncEnabled") ? config.resyncEnabled : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;
          var recoveryValueFunc = (0, has_1.default)(config, "recoveryValueFunc") ? config.recoveryValueFunc : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;
          var shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;
          this.ruleShortNameIdx++;
          this.shortRuleNameToFull[shortName] = ruleName;
          this.fullRuleNameToShort[ruleName] = shortName;
          var invokeRuleWithTry;
          if (this.outputCst === true) {
            invokeRuleWithTry = function invokeRuleWithTry2() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              try {
                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                impl.apply(this, args);
                var cst = this.CST_STACK[this.CST_STACK.length - 1];
                this.cstPostRule(cst);
                return cst;
              } catch (e) {
                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
              } finally {
                this.ruleFinallyStateUpdate();
              }
            };
          } else {
            invokeRuleWithTry = function invokeRuleWithTryCst() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              try {
                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                return impl.apply(this, args);
              } catch (e) {
                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
              } finally {
                this.ruleFinallyStateUpdate();
              }
            };
          }
          var wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });
          return wrappedGrammarRule;
        };
        RecognizerEngine2.prototype.invokeRuleCatch = function(e, resyncEnabledConfig, recoveryValueFunc) {
          var isFirstInvokedRule = this.RULE_STACK.length === 1;
          var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;
          if ((0, exceptions_public_1.isRecognitionException)(e)) {
            var recogError = e;
            if (reSyncEnabled) {
              var reSyncTokType = this.findReSyncTokenType();
              if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
                recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
                if (this.outputCst) {
                  var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                  partialCstResult.recoveredNode = true;
                  return partialCstResult;
                } else {
                  return recoveryValueFunc();
                }
              } else {
                if (this.outputCst) {
                  var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                  partialCstResult.recoveredNode = true;
                  recogError.partialCstResult = partialCstResult;
                }
                throw recogError;
              }
            } else if (isFirstInvokedRule) {
              this.moveToTerminatedState();
              return recoveryValueFunc();
            } else {
              throw recogError;
            }
          } else {
            throw e;
          }
        };
        RecognizerEngine2.prototype.optionInternal = function(actionORMethodDef, occurrence) {
          var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);
          return this.optionInternalLogic(actionORMethodDef, occurrence, key);
        };
        RecognizerEngine2.prototype.optionInternalLogic = function(actionORMethodDef, occurrence, key) {
          var _this = this;
          var lookAheadFunc = this.getLaFuncFromCache(key);
          var action;
          if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            var predicate_1 = actionORMethodDef.GATE;
            if (predicate_1 !== void 0) {
              var orgLookaheadFunction_1 = lookAheadFunc;
              lookAheadFunc = function() {
                return predicate_1.call(_this) && orgLookaheadFunction_1.call(_this);
              };
            }
          } else {
            action = actionORMethodDef;
          }
          if (lookAheadFunc.call(this) === true) {
            return action.call(this);
          }
          return void 0;
        };
        RecognizerEngine2.prototype.atLeastOneInternal = function(prodOccurrence, actionORMethodDef) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);
          return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        };
        RecognizerEngine2.prototype.atLeastOneInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
          var _this = this;
          var lookAheadFunc = this.getLaFuncFromCache(key);
          var action;
          if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            var predicate_2 = actionORMethodDef.GATE;
            if (predicate_2 !== void 0) {
              var orgLookaheadFunction_2 = lookAheadFunc;
              lookAheadFunc = function() {
                return predicate_2.call(_this) && orgLookaheadFunction_2.call(_this);
              };
            }
          } else {
            action = actionORMethodDef;
          }
          if (lookAheadFunc.call(this) === true) {
            var notStuck = this.doSingleRepetition(action);
            while (lookAheadFunc.call(this) === true && notStuck === true) {
              notStuck = this.doSingleRepetition(action);
            }
          } else {
            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
          }
          this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);
        };
        RecognizerEngine2.prototype.atLeastOneSepFirstInternal = function(prodOccurrence, options) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);
          this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
        };
        RecognizerEngine2.prototype.atLeastOneSepFirstInternalLogic = function(prodOccurrence, options, key) {
          var _this = this;
          var action = options.DEF;
          var separator = options.SEP;
          var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
          if (firstIterationLookaheadFunc.call(this) === true) {
            ;
            action.call(this);
            var separatorLookAheadFunc = function() {
              return _this.tokenMatcher(_this.LA(1), separator);
            };
            while (this.tokenMatcher(this.LA(1), separator) === true) {
              this.CONSUME(separator);
              action.call(this);
            }
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
              prodOccurrence,
              separator,
              separatorLookAheadFunc,
              action,
              interpreter_1.NextTerminalAfterAtLeastOneSepWalker
            ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);
          } else {
            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
          }
        };
        RecognizerEngine2.prototype.manyInternal = function(prodOccurrence, actionORMethodDef) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);
          return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        };
        RecognizerEngine2.prototype.manyInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
          var _this = this;
          var lookaheadFunction = this.getLaFuncFromCache(key);
          var action;
          if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            var predicate_3 = actionORMethodDef.GATE;
            if (predicate_3 !== void 0) {
              var orgLookaheadFunction_3 = lookaheadFunction;
              lookaheadFunction = function() {
                return predicate_3.call(_this) && orgLookaheadFunction_3.call(_this);
              };
            }
          } else {
            action = actionORMethodDef;
          }
          var notStuck = true;
          while (lookaheadFunction.call(this) === true && notStuck === true) {
            notStuck = this.doSingleRepetition(action);
          }
          this.attemptInRepetitionRecovery(
            this.manyInternal,
            [prodOccurrence, actionORMethodDef],
            lookaheadFunction,
            keys_1.MANY_IDX,
            prodOccurrence,
            interpreter_1.NextTerminalAfterManyWalker,
            // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
            // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
            // An infinite loop cannot occur as:
            // - Either the lookahead is guaranteed to consume something (Single Token Separator)
            // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
            notStuck
          );
        };
        RecognizerEngine2.prototype.manySepFirstInternal = function(prodOccurrence, options) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);
          this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
        };
        RecognizerEngine2.prototype.manySepFirstInternalLogic = function(prodOccurrence, options, key) {
          var _this = this;
          var action = options.DEF;
          var separator = options.SEP;
          var firstIterationLaFunc = this.getLaFuncFromCache(key);
          if (firstIterationLaFunc.call(this) === true) {
            action.call(this);
            var separatorLookAheadFunc = function() {
              return _this.tokenMatcher(_this.LA(1), separator);
            };
            while (this.tokenMatcher(this.LA(1), separator) === true) {
              this.CONSUME(separator);
              action.call(this);
            }
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
              prodOccurrence,
              separator,
              separatorLookAheadFunc,
              action,
              interpreter_1.NextTerminalAfterManySepWalker
            ], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);
          }
        };
        RecognizerEngine2.prototype.repetitionSepSecondInternal = function(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
          while (separatorLookAheadFunc()) {
            this.CONSUME(separator);
            action.call(this);
          }
          this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
            prodOccurrence,
            separator,
            separatorLookAheadFunc,
            action,
            nextTerminalAfterWalker
          ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
        };
        RecognizerEngine2.prototype.doSingleRepetition = function(action) {
          var beforeIteration = this.getLexerPosition();
          action.call(this);
          var afterIteration = this.getLexerPosition();
          return afterIteration > beforeIteration;
        };
        RecognizerEngine2.prototype.orInternal = function(altsOrOpts, occurrence) {
          var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);
          var alts = (0, isArray_1.default)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;
          var laFunc = this.getLaFuncFromCache(laKey);
          var altIdxToTake = laFunc.call(this, alts);
          if (altIdxToTake !== void 0) {
            var chosenAlternative = alts[altIdxToTake];
            return chosenAlternative.ALT.call(this);
          }
          this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
        };
        RecognizerEngine2.prototype.ruleFinallyStateUpdate = function() {
          this.RULE_STACK.pop();
          this.RULE_OCCURRENCE_STACK.pop();
          this.cstFinallyStateUpdate();
          if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
            var firstRedundantTok = this.LA(1);
            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
              firstRedundant: firstRedundantTok,
              ruleName: this.getCurrRuleFullName()
            });
            this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));
          }
        };
        RecognizerEngine2.prototype.subruleInternal = function(ruleToCall, idx, options) {
          var ruleResult;
          try {
            var args = options !== void 0 ? options.ARGS : void 0;
            this.subruleIdx = idx;
            ruleResult = ruleToCall.apply(this, args);
            this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);
            return ruleResult;
          } catch (e) {
            throw this.subruleInternalError(e, options, ruleToCall.ruleName);
          }
        };
        RecognizerEngine2.prototype.subruleInternalError = function(e, options, ruleName) {
          if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== void 0) {
            this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);
            delete e.partialCstResult;
          }
          throw e;
        };
        RecognizerEngine2.prototype.consumeInternal = function(tokType, idx, options) {
          var consumedToken;
          try {
            var nextToken = this.LA(1);
            if (this.tokenMatcher(nextToken, tokType) === true) {
              this.consumeToken();
              consumedToken = nextToken;
            } else {
              this.consumeInternalError(tokType, nextToken, options);
            }
          } catch (eFromConsumption) {
            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
          }
          this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);
          return consumedToken;
        };
        RecognizerEngine2.prototype.consumeInternalError = function(tokType, nextToken, options) {
          var msg;
          var previousToken = this.LA(0);
          if (options !== void 0 && options.ERR_MSG) {
            msg = options.ERR_MSG;
          } else {
            msg = this.errorMessageProvider.buildMismatchTokenMessage({
              expected: tokType,
              actual: nextToken,
              previous: previousToken,
              ruleName: this.getCurrRuleFullName()
            });
          }
          throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));
        };
        RecognizerEngine2.prototype.consumeInternalRecovery = function(tokType, idx, eFromConsumption) {
          if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
          eFromConsumption.name === "MismatchedTokenException" && !this.isBackTracking()) {
            var follows = this.getFollowsForInRuleRecovery(tokType, idx);
            try {
              return this.tryInRuleRecovery(tokType, follows);
            } catch (eFromInRuleRecovery) {
              if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {
                throw eFromConsumption;
              } else {
                throw eFromInRuleRecovery;
              }
            }
          } else {
            throw eFromConsumption;
          }
        };
        RecognizerEngine2.prototype.saveRecogState = function() {
          var savedErrors = this.errors;
          var savedRuleStack = (0, clone_1.default)(this.RULE_STACK);
          return {
            errors: savedErrors,
            lexerState: this.exportLexerState(),
            RULE_STACK: savedRuleStack,
            CST_STACK: this.CST_STACK
          };
        };
        RecognizerEngine2.prototype.reloadRecogState = function(newState) {
          this.errors = newState.errors;
          this.importLexerState(newState.lexerState);
          this.RULE_STACK = newState.RULE_STACK;
        };
        RecognizerEngine2.prototype.ruleInvocationStateUpdate = function(shortName, fullName, idxInCallingRule) {
          this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
          this.RULE_STACK.push(shortName);
          this.cstInvocationStateUpdate(fullName);
        };
        RecognizerEngine2.prototype.isBackTracking = function() {
          return this.isBackTrackingStack.length !== 0;
        };
        RecognizerEngine2.prototype.getCurrRuleFullName = function() {
          var shortName = this.getLastExplicitRuleShortName();
          return this.shortRuleNameToFull[shortName];
        };
        RecognizerEngine2.prototype.shortRuleNameToFullName = function(shortName) {
          return this.shortRuleNameToFull[shortName];
        };
        RecognizerEngine2.prototype.isAtEndOfInput = function() {
          return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);
        };
        RecognizerEngine2.prototype.reset = function() {
          this.resetLexerState();
          this.subruleIdx = 0;
          this.isBackTrackingStack = [];
          this.errors = [];
          this.RULE_STACK = [];
          this.CST_STACK = [];
          this.RULE_OCCURRENCE_STACK = [];
        };
        return RecognizerEngine2;
      }()
    );
    exports2.RecognizerEngine = RecognizerEngine;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js
var require_error_handler = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorHandler = void 0;
    var exceptions_public_1 = require_exceptions_public();
    var has_1 = __importDefault(require_has());
    var clone_1 = __importDefault(require_clone());
    var lookahead_1 = require_lookahead();
    var parser_1 = require_parser();
    var ErrorHandler = (
      /** @class */
      function() {
        function ErrorHandler2() {
        }
        ErrorHandler2.prototype.initErrorHandler = function(config) {
          this._errors = [];
          this.errorMessageProvider = (0, has_1.default)(config, "errorMessageProvider") ? config.errorMessageProvider : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;
        };
        ErrorHandler2.prototype.SAVE_ERROR = function(error) {
          if ((0, exceptions_public_1.isRecognitionException)(error)) {
            error.context = {
              ruleStack: this.getHumanReadableRuleStack(),
              ruleOccurrenceStack: (0, clone_1.default)(this.RULE_OCCURRENCE_STACK)
            };
            this._errors.push(error);
            return error;
          } else {
            throw Error("Trying to save an Error which is not a RecognitionException");
          }
        };
        Object.defineProperty(ErrorHandler2.prototype, "errors", {
          get: function() {
            return (0, clone_1.default)(this._errors);
          },
          set: function(newErrors) {
            this._errors = newErrors;
          },
          enumerable: false,
          configurable: true
        });
        ErrorHandler2.prototype.raiseEarlyExitException = function(occurrence, prodType, userDefinedErrMsg) {
          var ruleName = this.getCurrRuleFullName();
          var ruleGrammar = this.getGAstProductions()[ruleName];
          var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);
          var insideProdPaths = lookAheadPathsPerAlternative[0];
          var actualTokens = [];
          for (var i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
          }
          var msg = this.errorMessageProvider.buildEarlyExitMessage({
            expectedIterationPaths: insideProdPaths,
            actual: actualTokens,
            previous: this.LA(0),
            customUserDescription: userDefinedErrMsg,
            ruleName
          });
          throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));
        };
        ErrorHandler2.prototype.raiseNoAltException = function(occurrence, errMsgTypes) {
          var ruleName = this.getCurrRuleFullName();
          var ruleGrammar = this.getGAstProductions()[ruleName];
          var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);
          var actualTokens = [];
          for (var i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
          }
          var previousToken = this.LA(0);
          var errMsg = this.errorMessageProvider.buildNoViableAltMessage({
            expectedPathsPerAlt: lookAheadPathsPerAlternative,
            actual: actualTokens,
            previous: previousToken,
            customUserDescription: errMsgTypes,
            ruleName: this.getCurrRuleFullName()
          });
          throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));
        };
        return ErrorHandler2;
      }()
    );
    exports2.ErrorHandler = ErrorHandler;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js
var require_context_assist = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContentAssist = void 0;
    var interpreter_1 = require_interpreter();
    var first_1 = __importDefault(require_first2());
    var isUndefined_1 = __importDefault(require_isUndefined());
    var ContentAssist = (
      /** @class */
      function() {
        function ContentAssist2() {
        }
        ContentAssist2.prototype.initContentAssist = function() {
        };
        ContentAssist2.prototype.computeContentAssist = function(startRuleName, precedingInput) {
          var startRuleGast = this.gastProductionsCache[startRuleName];
          if ((0, isUndefined_1.default)(startRuleGast)) {
            throw Error("Rule ->".concat(startRuleName, "<- does not exist in this grammar."));
          }
          return (0, interpreter_1.nextPossibleTokensAfter)([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
        };
        ContentAssist2.prototype.getNextPossibleTokenTypes = function(grammarPath) {
          var topRuleName = (0, first_1.default)(grammarPath.ruleStack);
          var gastProductions = this.getGAstProductions();
          var topProduction = gastProductions[topRuleName];
          var nextPossibleTokenTypes = new interpreter_1.NextAfterTokenWalker(topProduction, grammarPath).startWalking();
          return nextPossibleTokenTypes;
        };
        return ContentAssist2;
      }()
    );
    exports2.ContentAssist = ContentAssist;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js
var require_gast_recorder = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GastRecorder = void 0;
    var last_1 = __importDefault(require_last());
    var isArray_1 = __importDefault(require_isArray());
    var some_1 = __importDefault(require_some());
    var forEach_1 = __importDefault(require_forEach());
    var isFunction_1 = __importDefault(require_isFunction());
    var has_1 = __importDefault(require_has());
    var gast_1 = require_api5();
    var lexer_public_1 = require_lexer_public();
    var tokens_1 = require_tokens();
    var tokens_public_1 = require_tokens_public();
    var parser_1 = require_parser();
    var keys_1 = require_keys2();
    var RECORDING_NULL_OBJECT = {
      description: "This Object indicates the Parser is during Recording Phase"
    };
    Object.freeze(RECORDING_NULL_OBJECT);
    var HANDLE_SEPARATOR = true;
    var MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;
    var RFT = (0, tokens_public_1.createToken)({ name: "RECORDING_PHASE_TOKEN", pattern: lexer_public_1.Lexer.NA });
    (0, tokens_1.augmentTokenTypes)([RFT]);
    var RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(
      RFT,
      "This IToken indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
      // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
      // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    );
    Object.freeze(RECORDING_PHASE_TOKEN);
    var RECORDING_PHASE_CSTNODE = {
      name: "This CSTNode indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
      children: {}
    };
    var GastRecorder = (
      /** @class */
      function() {
        function GastRecorder2() {
        }
        GastRecorder2.prototype.initGastRecorder = function(config) {
          this.recordingProdStack = [];
          this.RECORDING_PHASE = false;
        };
        GastRecorder2.prototype.enableRecording = function() {
          var _this = this;
          this.RECORDING_PHASE = true;
          this.TRACE_INIT("Enable Recording", function() {
            var _loop_1 = function(i2) {
              var idx = i2 > 0 ? i2 : "";
              _this["CONSUME".concat(idx)] = function(arg1, arg2) {
                return this.consumeInternalRecord(arg1, i2, arg2);
              };
              _this["SUBRULE".concat(idx)] = function(arg1, arg2) {
                return this.subruleInternalRecord(arg1, i2, arg2);
              };
              _this["OPTION".concat(idx)] = function(arg1) {
                return this.optionInternalRecord(arg1, i2);
              };
              _this["OR".concat(idx)] = function(arg1) {
                return this.orInternalRecord(arg1, i2);
              };
              _this["MANY".concat(idx)] = function(arg1) {
                this.manyInternalRecord(i2, arg1);
              };
              _this["MANY_SEP".concat(idx)] = function(arg1) {
                this.manySepFirstInternalRecord(i2, arg1);
              };
              _this["AT_LEAST_ONE".concat(idx)] = function(arg1) {
                this.atLeastOneInternalRecord(i2, arg1);
              };
              _this["AT_LEAST_ONE_SEP".concat(idx)] = function(arg1) {
                this.atLeastOneSepFirstInternalRecord(i2, arg1);
              };
            };
            for (var i = 0; i < 10; i++) {
              _loop_1(i);
            }
            _this["consume"] = function(idx, arg1, arg2) {
              return this.consumeInternalRecord(arg1, idx, arg2);
            };
            _this["subrule"] = function(idx, arg1, arg2) {
              return this.subruleInternalRecord(arg1, idx, arg2);
            };
            _this["option"] = function(idx, arg1) {
              return this.optionInternalRecord(arg1, idx);
            };
            _this["or"] = function(idx, arg1) {
              return this.orInternalRecord(arg1, idx);
            };
            _this["many"] = function(idx, arg1) {
              this.manyInternalRecord(idx, arg1);
            };
            _this["atLeastOne"] = function(idx, arg1) {
              this.atLeastOneInternalRecord(idx, arg1);
            };
            _this.ACTION = _this.ACTION_RECORD;
            _this.BACKTRACK = _this.BACKTRACK_RECORD;
            _this.LA = _this.LA_RECORD;
          });
        };
        GastRecorder2.prototype.disableRecording = function() {
          var _this = this;
          this.RECORDING_PHASE = false;
          this.TRACE_INIT("Deleting Recording methods", function() {
            var that = _this;
            for (var i = 0; i < 10; i++) {
              var idx = i > 0 ? i : "";
              delete that["CONSUME".concat(idx)];
              delete that["SUBRULE".concat(idx)];
              delete that["OPTION".concat(idx)];
              delete that["OR".concat(idx)];
              delete that["MANY".concat(idx)];
              delete that["MANY_SEP".concat(idx)];
              delete that["AT_LEAST_ONE".concat(idx)];
              delete that["AT_LEAST_ONE_SEP".concat(idx)];
            }
            delete that["consume"];
            delete that["subrule"];
            delete that["option"];
            delete that["or"];
            delete that["many"];
            delete that["atLeastOne"];
            delete that.ACTION;
            delete that.BACKTRACK;
            delete that.LA;
          });
        };
        GastRecorder2.prototype.ACTION_RECORD = function(impl) {
        };
        GastRecorder2.prototype.BACKTRACK_RECORD = function(grammarRule, args) {
          return function() {
            return true;
          };
        };
        GastRecorder2.prototype.LA_RECORD = function(howMuch) {
          return parser_1.END_OF_FILE;
        };
        GastRecorder2.prototype.topLevelRuleRecord = function(name, def) {
          try {
            var newTopLevelRule = new gast_1.Rule({ definition: [], name });
            newTopLevelRule.name = name;
            this.recordingProdStack.push(newTopLevelRule);
            def.call(this);
            this.recordingProdStack.pop();
            return newTopLevelRule;
          } catch (originalError) {
            if (originalError.KNOWN_RECORDER_ERROR !== true) {
              try {
                originalError.message = originalError.message + '\n	 This error was thrown during the "grammar recording phase" For more info see:\n	https://chevrotain.io/docs/guide/internals.html#grammar-recording';
              } catch (mutabilityError) {
                throw originalError;
              }
            }
            throw originalError;
          }
        };
        GastRecorder2.prototype.optionInternalRecord = function(actionORMethodDef, occurrence) {
          return recordProd.call(this, gast_1.Option, actionORMethodDef, occurrence);
        };
        GastRecorder2.prototype.atLeastOneInternalRecord = function(occurrence, actionORMethodDef) {
          recordProd.call(this, gast_1.RepetitionMandatory, actionORMethodDef, occurrence);
        };
        GastRecorder2.prototype.atLeastOneSepFirstInternalRecord = function(occurrence, options) {
          recordProd.call(this, gast_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
        };
        GastRecorder2.prototype.manyInternalRecord = function(occurrence, actionORMethodDef) {
          recordProd.call(this, gast_1.Repetition, actionORMethodDef, occurrence);
        };
        GastRecorder2.prototype.manySepFirstInternalRecord = function(occurrence, options) {
          recordProd.call(this, gast_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
        };
        GastRecorder2.prototype.orInternalRecord = function(altsOrOpts, occurrence) {
          return recordOrProd.call(this, altsOrOpts, occurrence);
        };
        GastRecorder2.prototype.subruleInternalRecord = function(ruleToCall, occurrence, options) {
          assertMethodIdxIsValid(occurrence);
          if (!ruleToCall || (0, has_1.default)(ruleToCall, "ruleName") === false) {
            var error = new Error("<SUBRULE".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a Parser method reference but got: <".concat(JSON.stringify(ruleToCall), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
          }
          var prevProd = (0, last_1.default)(this.recordingProdStack);
          var ruleName = ruleToCall.ruleName;
          var newNoneTerminal = new gast_1.NonTerminal({
            idx: occurrence,
            nonTerminalName: ruleName,
            label: options === null || options === void 0 ? void 0 : options.LABEL,
            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
            referencedRule: void 0
          });
          prevProd.definition.push(newNoneTerminal);
          return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;
        };
        GastRecorder2.prototype.consumeInternalRecord = function(tokType, occurrence, options) {
          assertMethodIdxIsValid(occurrence);
          if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {
            var error = new Error("<CONSUME".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a TokenType reference but got: <".concat(JSON.stringify(tokType), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
          }
          var prevProd = (0, last_1.default)(this.recordingProdStack);
          var newNoneTerminal = new gast_1.Terminal({
            idx: occurrence,
            terminalType: tokType,
            label: options === null || options === void 0 ? void 0 : options.LABEL
          });
          prevProd.definition.push(newNoneTerminal);
          return RECORDING_PHASE_TOKEN;
        };
        return GastRecorder2;
      }()
    );
    exports2.GastRecorder = GastRecorder;
    function recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {
      if (handleSep === void 0) {
        handleSep = false;
      }
      assertMethodIdxIsValid(occurrence);
      var prevProd = (0, last_1.default)(this.recordingProdStack);
      var grammarAction = (0, isFunction_1.default)(mainProdArg) ? mainProdArg : mainProdArg.DEF;
      var newProd = new prodConstructor({ definition: [], idx: occurrence });
      if (handleSep) {
        newProd.separator = mainProdArg.SEP;
      }
      if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
      }
      this.recordingProdStack.push(newProd);
      grammarAction.call(this);
      prevProd.definition.push(newProd);
      this.recordingProdStack.pop();
      return RECORDING_NULL_OBJECT;
    }
    function recordOrProd(mainProdArg, occurrence) {
      var _this = this;
      assertMethodIdxIsValid(occurrence);
      var prevProd = (0, last_1.default)(this.recordingProdStack);
      var hasOptions = (0, isArray_1.default)(mainProdArg) === false;
      var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
      var newOrProd = new gast_1.Alternation({
        definition: [],
        idx: occurrence,
        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
      });
      if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
      }
      var hasPredicates = (0, some_1.default)(alts, function(currAlt) {
        return (0, isFunction_1.default)(currAlt.GATE);
      });
      newOrProd.hasPredicates = hasPredicates;
      prevProd.definition.push(newOrProd);
      (0, forEach_1.default)(alts, function(currAlt) {
        var currAltFlat = new gast_1.Alternative({ definition: [] });
        newOrProd.definition.push(currAltFlat);
        if ((0, has_1.default)(currAlt, "IGNORE_AMBIGUITIES")) {
          currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
        } else if ((0, has_1.default)(currAlt, "GATE")) {
          currAltFlat.ignoreAmbiguities = true;
        }
        _this.recordingProdStack.push(currAltFlat);
        currAlt.ALT.call(_this);
        _this.recordingProdStack.pop();
      });
      return RECORDING_NULL_OBJECT;
    }
    function getIdxSuffix(idx) {
      return idx === 0 ? "" : "".concat(idx);
    }
    function assertMethodIdxIsValid(idx) {
      if (idx < 0 || idx > MAX_METHOD_IDX) {
        var error = new Error(
          // The stack trace will contain all the needed details
          "Invalid DSL Method idx value: <".concat(idx, ">\n	") + "Idx value must be a none negative value smaller than ".concat(MAX_METHOD_IDX + 1)
        );
        error.KNOWN_RECORDER_ERROR = true;
        throw error;
      }
    }
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js
var require_perf_tracer = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PerformanceTracer = void 0;
    var has_1 = __importDefault(require_has());
    var utils_1 = require_api4();
    var parser_1 = require_parser();
    var PerformanceTracer = (
      /** @class */
      function() {
        function PerformanceTracer2() {
        }
        PerformanceTracer2.prototype.initPerformanceTracer = function(config) {
          if ((0, has_1.default)(config, "traceInitPerf")) {
            var userTraceInitPerf = config.traceInitPerf;
            var traceIsNumber = typeof userTraceInitPerf === "number";
            this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;
            this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;
          } else {
            this.traceInitMaxIdent = 0;
            this.traceInitPerf = parser_1.DEFAULT_PARSER_CONFIG.traceInitPerf;
          }
          this.traceInitIndent = -1;
        };
        PerformanceTracer2.prototype.TRACE_INIT = function(phaseDesc, phaseImpl) {
          if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            var indent = new Array(this.traceInitIndent + 1).join("	");
            if (this.traceInitIndent < this.traceInitMaxIdent) {
              console.log("".concat(indent, "--> <").concat(phaseDesc, ">"));
            }
            var _a = (0, utils_1.timer)(phaseImpl), time = _a.time, value = _a.value;
            var traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) {
              traceMethod("".concat(indent, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
            }
            this.traceInitIndent--;
            return value;
          } else {
            return phaseImpl();
          }
        };
        return PerformanceTracer2;
      }()
    );
    exports2.PerformanceTracer = PerformanceTracer;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js
var require_apply_mixins = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.applyMixins = void 0;
    function applyMixins(derivedCtor, baseCtors) {
      baseCtors.forEach(function(baseCtor) {
        var baseProto = baseCtor.prototype;
        Object.getOwnPropertyNames(baseProto).forEach(function(propName) {
          if (propName === "constructor") {
            return;
          }
          var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
          if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {
            Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
          } else {
            derivedCtor.prototype[propName] = baseCtor.prototype[propName];
          }
        });
      });
    }
    exports2.applyMixins = applyMixins;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/parser.js
var require_parser = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/parse/parser/parser.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmbeddedActionsParser = exports2.CstParser = exports2.Parser = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.DEFAULT_RULE_CONFIG = exports2.DEFAULT_PARSER_CONFIG = exports2.END_OF_FILE = void 0;
    var isEmpty_1 = __importDefault(require_isEmpty());
    var map_1 = __importDefault(require_map());
    var forEach_1 = __importDefault(require_forEach());
    var values_1 = __importDefault(require_values());
    var has_1 = __importDefault(require_has());
    var clone_1 = __importDefault(require_clone());
    var utils_1 = require_api4();
    var follow_1 = require_follow();
    var tokens_public_1 = require_tokens_public();
    var errors_public_1 = require_errors_public();
    var gast_resolver_public_1 = require_gast_resolver_public();
    var recoverable_1 = require_recoverable();
    var looksahead_1 = require_looksahead();
    var tree_builder_1 = require_tree_builder();
    var lexer_adapter_1 = require_lexer_adapter();
    var recognizer_api_1 = require_recognizer_api();
    var recognizer_engine_1 = require_recognizer_engine();
    var error_handler_1 = require_error_handler();
    var context_assist_1 = require_context_assist();
    var gast_recorder_1 = require_gast_recorder();
    var perf_tracer_1 = require_perf_tracer();
    var apply_mixins_1 = require_apply_mixins();
    var checks_1 = require_checks();
    exports2.END_OF_FILE = (0, tokens_public_1.createTokenInstance)(tokens_public_1.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
    Object.freeze(exports2.END_OF_FILE);
    exports2.DEFAULT_PARSER_CONFIG = Object.freeze({
      recoveryEnabled: false,
      maxLookahead: 3,
      dynamicTokensEnabled: false,
      outputCst: true,
      errorMessageProvider: errors_public_1.defaultParserErrorProvider,
      nodeLocationTracking: "none",
      traceInitPerf: false,
      skipValidations: false
    });
    exports2.DEFAULT_RULE_CONFIG = Object.freeze({
      recoveryValueFunc: function() {
        return void 0;
      },
      resyncEnabled: true
    });
    var ParserDefinitionErrorType;
    (function(ParserDefinitionErrorType2) {
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["CUSTOM_LOOKAHEAD_VALIDATION"] = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
    })(ParserDefinitionErrorType = exports2.ParserDefinitionErrorType || (exports2.ParserDefinitionErrorType = {}));
    function EMPTY_ALT(value) {
      if (value === void 0) {
        value = void 0;
      }
      return function() {
        return value;
      };
    }
    exports2.EMPTY_ALT = EMPTY_ALT;
    var Parser = (
      /** @class */
      function() {
        function Parser2(tokenVocabulary, config) {
          this.definitionErrors = [];
          this.selfAnalysisDone = false;
          var that = this;
          that.initErrorHandler(config);
          that.initLexerAdapter();
          that.initLooksAhead(config);
          that.initRecognizerEngine(tokenVocabulary, config);
          that.initRecoverable(config);
          that.initTreeBuilder(config);
          that.initContentAssist();
          that.initGastRecorder(config);
          that.initPerformanceTracer(config);
          if ((0, has_1.default)(config, "ignoredIssues")) {
            throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n	For further details.");
          }
          this.skipValidations = (0, has_1.default)(config, "skipValidations") ? config.skipValidations : exports2.DEFAULT_PARSER_CONFIG.skipValidations;
        }
        Parser2.performSelfAnalysis = function(parserInstance) {
          throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
        };
        Parser2.prototype.performSelfAnalysis = function() {
          var _this = this;
          this.TRACE_INIT("performSelfAnalysis", function() {
            var defErrorsMsgs;
            _this.selfAnalysisDone = true;
            var className = _this.className;
            _this.TRACE_INIT("toFastProps", function() {
              (0, utils_1.toFastProperties)(_this);
            });
            _this.TRACE_INIT("Grammar Recording", function() {
              try {
                _this.enableRecording();
                (0, forEach_1.default)(_this.definedRulesNames, function(currRuleName) {
                  var wrappedRule = _this[currRuleName];
                  var originalGrammarAction = wrappedRule["originalGrammarAction"];
                  var recordedRuleGast;
                  _this.TRACE_INIT("".concat(currRuleName, " Rule"), function() {
                    recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                  });
                  _this.gastProductionsCache[currRuleName] = recordedRuleGast;
                });
              } finally {
                _this.disableRecording();
              }
            });
            var resolverErrors = [];
            _this.TRACE_INIT("Grammar Resolving", function() {
              resolverErrors = (0, gast_resolver_public_1.resolveGrammar)({
                rules: (0, values_1.default)(_this.gastProductionsCache)
              });
              _this.definitionErrors = _this.definitionErrors.concat(resolverErrors);
            });
            _this.TRACE_INIT("Grammar Validations", function() {
              if ((0, isEmpty_1.default)(resolverErrors) && _this.skipValidations === false) {
                var validationErrors = (0, gast_resolver_public_1.validateGrammar)({
                  rules: (0, values_1.default)(_this.gastProductionsCache),
                  tokenTypes: (0, values_1.default)(_this.tokensMap),
                  errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider,
                  grammarName: className
                });
                var lookaheadValidationErrors = (0, checks_1.validateLookahead)({
                  lookaheadStrategy: _this.lookaheadStrategy,
                  rules: (0, values_1.default)(_this.gastProductionsCache),
                  tokenTypes: (0, values_1.default)(_this.tokensMap),
                  grammarName: className
                });
                _this.definitionErrors = _this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);
              }
            });
            if ((0, isEmpty_1.default)(_this.definitionErrors)) {
              if (_this.recoveryEnabled) {
                _this.TRACE_INIT("computeAllProdsFollows", function() {
                  var allFollows = (0, follow_1.computeAllProdsFollows)((0, values_1.default)(_this.gastProductionsCache));
                  _this.resyncFollows = allFollows;
                });
              }
              _this.TRACE_INIT("ComputeLookaheadFunctions", function() {
                var _a, _b;
                (_b = (_a = _this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {
                  rules: (0, values_1.default)(_this.gastProductionsCache)
                });
                _this.preComputeLookaheadFunctions((0, values_1.default)(_this.gastProductionsCache));
              });
            }
            if (!Parser2.DEFER_DEFINITION_ERRORS_HANDLING && !(0, isEmpty_1.default)(_this.definitionErrors)) {
              defErrorsMsgs = (0, map_1.default)(_this.definitionErrors, function(defError) {
                return defError.message;
              });
              throw new Error("Parser Definition Errors detected:\n ".concat(defErrorsMsgs.join("\n-------------------------------\n")));
            }
          });
        };
        Parser2.DEFER_DEFINITION_ERRORS_HANDLING = false;
        return Parser2;
      }()
    );
    exports2.Parser = Parser;
    (0, apply_mixins_1.applyMixins)(Parser, [
      recoverable_1.Recoverable,
      looksahead_1.LooksAhead,
      tree_builder_1.TreeBuilder,
      lexer_adapter_1.LexerAdapter,
      recognizer_engine_1.RecognizerEngine,
      recognizer_api_1.RecognizerApi,
      error_handler_1.ErrorHandler,
      context_assist_1.ContentAssist,
      gast_recorder_1.GastRecorder,
      perf_tracer_1.PerformanceTracer
    ]);
    var CstParser = (
      /** @class */
      function(_super) {
        __extends(CstParser2, _super);
        function CstParser2(tokenVocabulary, config) {
          if (config === void 0) {
            config = exports2.DEFAULT_PARSER_CONFIG;
          }
          var configClone = (0, clone_1.default)(config);
          configClone.outputCst = true;
          return _super.call(this, tokenVocabulary, configClone) || this;
        }
        return CstParser2;
      }(Parser)
    );
    exports2.CstParser = CstParser;
    var EmbeddedActionsParser = (
      /** @class */
      function(_super) {
        __extends(EmbeddedActionsParser2, _super);
        function EmbeddedActionsParser2(tokenVocabulary, config) {
          if (config === void 0) {
            config = exports2.DEFAULT_PARSER_CONFIG;
          }
          var configClone = (0, clone_1.default)(config);
          configClone.outputCst = false;
          return _super.call(this, tokenVocabulary, configClone) || this;
        }
        return EmbeddedActionsParser2;
      }(Parser)
    );
    exports2.EmbeddedActionsParser = EmbeddedActionsParser;
  }
});

// ../../node_modules/.pnpm/@chevrotain+cst-dts-gen@10.4.2/node_modules/@chevrotain/cst-dts-gen/lib/src/model.js
var require_model2 = __commonJS({
  "../../node_modules/.pnpm/@chevrotain+cst-dts-gen@10.4.2/node_modules/@chevrotain/cst-dts-gen/lib/src/model.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildModel = void 0;
    var gast_1 = require_api5();
    var map_1 = __importDefault(require_map());
    var flatten_1 = __importDefault(require_flatten());
    var values_1 = __importDefault(require_values());
    var some_1 = __importDefault(require_some());
    var groupBy_1 = __importDefault(require_groupBy());
    var assign_1 = __importDefault(require_assign());
    function buildModel(productions) {
      var generator = new CstNodeDefinitionGenerator();
      var allRules = (0, values_1.default)(productions);
      return (0, map_1.default)(allRules, function(rule) {
        return generator.visitRule(rule);
      });
    }
    exports2.buildModel = buildModel;
    var CstNodeDefinitionGenerator = (
      /** @class */
      function(_super) {
        __extends(CstNodeDefinitionGenerator2, _super);
        function CstNodeDefinitionGenerator2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        CstNodeDefinitionGenerator2.prototype.visitRule = function(node) {
          var rawElements = this.visitEach(node.definition);
          var grouped = (0, groupBy_1.default)(rawElements, function(el) {
            return el.propertyName;
          });
          var properties = (0, map_1.default)(grouped, function(group, propertyName) {
            var allNullable = !(0, some_1.default)(group, function(el) {
              return !el.canBeNull;
            });
            var propertyType = group[0].type;
            if (group.length > 1) {
              propertyType = (0, map_1.default)(group, function(g) {
                return g.type;
              });
            }
            return {
              name: propertyName,
              type: propertyType,
              optional: allNullable
            };
          });
          return {
            name: node.name,
            properties
          };
        };
        CstNodeDefinitionGenerator2.prototype.visitAlternative = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitOption = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetition = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatory = function(node) {
          return this.visitEach(node.definition);
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
          return this.visitEach(node.definition).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator)
          });
        };
        CstNodeDefinitionGenerator2.prototype.visitRepetitionWithSeparator = function(node) {
          return this.visitEachAndOverrideWith(node.definition, {
            canBeNull: true
          }).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator)
          });
        };
        CstNodeDefinitionGenerator2.prototype.visitAlternation = function(node) {
          return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
        };
        CstNodeDefinitionGenerator2.prototype.visitTerminal = function(node) {
          return [
            {
              propertyName: node.label || node.terminalType.name,
              canBeNull: false,
              type: getType(node)
            }
          ];
        };
        CstNodeDefinitionGenerator2.prototype.visitNonTerminal = function(node) {
          return [
            {
              propertyName: node.label || node.nonTerminalName,
              canBeNull: false,
              type: getType(node)
            }
          ];
        };
        CstNodeDefinitionGenerator2.prototype.visitEachAndOverrideWith = function(definition, override) {
          return (0, map_1.default)(this.visitEach(definition), function(definition2) {
            return (0, assign_1.default)({}, definition2, override);
          });
        };
        CstNodeDefinitionGenerator2.prototype.visitEach = function(definition) {
          var _this = this;
          return (0, flatten_1.default)((0, map_1.default)(definition, function(definition2) {
            return _this.visit(definition2);
          }));
        };
        return CstNodeDefinitionGenerator2;
      }(gast_1.GAstVisitor)
    );
    function getType(production) {
      if (production instanceof gast_1.NonTerminal) {
        return {
          kind: "rule",
          name: production.referencedRule.name
        };
      }
      return { kind: "token" };
    }
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castSlice.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    module2.exports = castSlice;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicode.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module2.exports = hasUnicode;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiToArray.js"(exports2, module2) {
    function asciiToArray(string) {
      return string.split("");
    }
    module2.exports = asciiToArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeToArray.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    module2.exports = unicodeToArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToArray.js"(exports2, module2) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    module2.exports = stringToArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCaseFirst.js"(exports2, module2) {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString = require_toString();
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module2.exports = createCaseFirst;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/upperFirst.js"(exports2, module2) {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module2.exports = upperFirst;
  }
});

// ../../node_modules/.pnpm/@chevrotain+cst-dts-gen@10.4.2/node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js
var require_generate = __commonJS({
  "../../node_modules/.pnpm/@chevrotain+cst-dts-gen@10.4.2/node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.genDts = void 0;
    var flatten_1 = __importDefault(require_flatten());
    var isArray_1 = __importDefault(require_isArray());
    var map_1 = __importDefault(require_map());
    var reduce_1 = __importDefault(require_reduce());
    var uniq_1 = __importDefault(require_uniq());
    var upperFirst_1 = __importDefault(require_upperFirst());
    function genDts(model, options) {
      var contentParts = [];
      contentParts = contentParts.concat('import type { CstNode, ICstVisitor, IToken } from "chevrotain";');
      contentParts = contentParts.concat((0, flatten_1.default)((0, map_1.default)(model, function(node) {
        return genCstNodeTypes(node);
      })));
      if (options.includeVisitorInterface) {
        contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));
      }
      return contentParts.join("\n\n") + "\n";
    }
    exports2.genDts = genDts;
    function genCstNodeTypes(node) {
      var nodeCstInterface = genNodeInterface(node);
      var nodeChildrenInterface = genNodeChildrenType(node);
      return [nodeCstInterface, nodeChildrenInterface];
    }
    function genNodeInterface(node) {
      var nodeInterfaceName = getNodeInterfaceName(node.name);
      var childrenTypeName = getNodeChildrenTypeName(node.name);
      return "export interface ".concat(nodeInterfaceName, ' extends CstNode {\n  name: "').concat(node.name, '";\n  children: ').concat(childrenTypeName, ";\n}");
    }
    function genNodeChildrenType(node) {
      var typeName = getNodeChildrenTypeName(node.name);
      return "export type ".concat(typeName, " = {\n  ").concat((0, map_1.default)(node.properties, function(property) {
        return genChildProperty(property);
      }).join("\n  "), "\n};");
    }
    function genChildProperty(prop) {
      var typeName = buildTypeString(prop.type);
      return "".concat(prop.name).concat(prop.optional ? "?" : "", ": ").concat(typeName, "[];");
    }
    function genVisitor(name, nodes) {
      return "export interface ".concat(name, "<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ").concat((0, map_1.default)(nodes, function(node) {
        return genVisitorFunction(node);
      }).join("\n  "), "\n}");
    }
    function genVisitorFunction(node) {
      var childrenTypeName = getNodeChildrenTypeName(node.name);
      return "".concat(node.name, "(children: ").concat(childrenTypeName, ", param?: IN): OUT;");
    }
    function buildTypeString(type) {
      if ((0, isArray_1.default)(type)) {
        var typeNames = (0, uniq_1.default)((0, map_1.default)(type, function(t) {
          return getTypeString(t);
        }));
        var typeString = (0, reduce_1.default)(typeNames, function(sum, t) {
          return sum + " | " + t;
        });
        return "(" + typeString + ")";
      } else {
        return getTypeString(type);
      }
    }
    function getTypeString(type) {
      if (type.kind === "token") {
        return "IToken";
      }
      return getNodeInterfaceName(type.name);
    }
    function getNodeInterfaceName(ruleName) {
      return (0, upperFirst_1.default)(ruleName) + "CstNode";
    }
    function getNodeChildrenTypeName(ruleName) {
      return (0, upperFirst_1.default)(ruleName) + "CstChildren";
    }
  }
});

// ../../node_modules/.pnpm/@chevrotain+cst-dts-gen@10.4.2/node_modules/@chevrotain/cst-dts-gen/lib/src/api.js
var require_api6 = __commonJS({
  "../../node_modules/.pnpm/@chevrotain+cst-dts-gen@10.4.2/node_modules/@chevrotain/cst-dts-gen/lib/src/api.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateCstDts = void 0;
    var model_1 = require_model2();
    var generate_1 = require_generate();
    var defaultOptions = {
      includeVisitorInterface: true,
      visitorInterfaceName: "ICstNodeVisitor"
    };
    function generateCstDts(productions, options) {
      var effectiveOptions = __assign(__assign({}, defaultOptions), options);
      var model = (0, model_1.buildModel)(productions);
      return (0, generate_1.genDts)(model, effectiveOptions);
    }
    exports2.generateCstDts = generateCstDts;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/diagrams/render_public.js
var require_render_public = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/diagrams/render_public.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createSyntaxDiagramsCode = void 0;
    var version_1 = require_version();
    function createSyntaxDiagramsCode(grammar, _a) {
      var _b = _a === void 0 ? {} : _a, _c = _b.resourceBase, resourceBase = _c === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/") : _c, _d = _b.css, css = _d === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/diagrams.css") : _d;
      var header = '\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset="utf-8">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n';
      var cssHtml = "\n<link rel='stylesheet' href='".concat(css, "'>\n");
      var scripts = "\n<script src='".concat(resourceBase, "vendor/railroad-diagrams.js'></script>\n<script src='").concat(resourceBase, "src/diagrams_builder.js'></script>\n<script src='").concat(resourceBase, "src/diagrams_behavior.js'></script>\n<script src='").concat(resourceBase, "src/main.js'></script>\n");
      var diagramsDiv = '\n<div id="diagrams" align="center"></div>    \n';
      var serializedGrammar = "\n<script>\n    window.serializedGrammar = ".concat(JSON.stringify(grammar, null, "  "), ";\n</script>\n");
      var initLogic = '\n<script>\n    var diagramsDiv = document.getElementById("diagrams");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n';
      return header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic;
    }
    exports2.createSyntaxDiagramsCode = createSyntaxDiagramsCode;
  }
});

// ../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/api.js
var require_api7 = __commonJS({
  "../../node_modules/.pnpm/chevrotain@10.4.2/node_modules/chevrotain/lib/src/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parser = exports2.createSyntaxDiagramsCode = exports2.clearCache = exports2.generateCstDts = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Rule = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Alternative = exports2.Alternation = exports2.defaultLexerErrorProvider = exports2.NoViableAltException = exports2.NotAllInputParsedException = exports2.MismatchedTokenException = exports2.isRecognitionException = exports2.EarlyExitException = exports2.defaultParserErrorProvider = exports2.LLkLookaheadStrategy = exports2.getLookaheadPaths = exports2.tokenName = exports2.tokenMatcher = exports2.tokenLabel = exports2.EOF = exports2.createTokenInstance = exports2.createToken = exports2.LexerDefinitionErrorType = exports2.Lexer = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.EmbeddedActionsParser = exports2.CstParser = exports2.VERSION = void 0;
    var version_1 = require_version();
    Object.defineProperty(exports2, "VERSION", { enumerable: true, get: function() {
      return version_1.VERSION;
    } });
    var parser_1 = require_parser();
    Object.defineProperty(exports2, "CstParser", { enumerable: true, get: function() {
      return parser_1.CstParser;
    } });
    Object.defineProperty(exports2, "EmbeddedActionsParser", { enumerable: true, get: function() {
      return parser_1.EmbeddedActionsParser;
    } });
    Object.defineProperty(exports2, "ParserDefinitionErrorType", { enumerable: true, get: function() {
      return parser_1.ParserDefinitionErrorType;
    } });
    Object.defineProperty(exports2, "EMPTY_ALT", { enumerable: true, get: function() {
      return parser_1.EMPTY_ALT;
    } });
    var lexer_public_1 = require_lexer_public();
    Object.defineProperty(exports2, "Lexer", { enumerable: true, get: function() {
      return lexer_public_1.Lexer;
    } });
    Object.defineProperty(exports2, "LexerDefinitionErrorType", { enumerable: true, get: function() {
      return lexer_public_1.LexerDefinitionErrorType;
    } });
    var tokens_public_1 = require_tokens_public();
    Object.defineProperty(exports2, "createToken", { enumerable: true, get: function() {
      return tokens_public_1.createToken;
    } });
    Object.defineProperty(exports2, "createTokenInstance", { enumerable: true, get: function() {
      return tokens_public_1.createTokenInstance;
    } });
    Object.defineProperty(exports2, "EOF", { enumerable: true, get: function() {
      return tokens_public_1.EOF;
    } });
    Object.defineProperty(exports2, "tokenLabel", { enumerable: true, get: function() {
      return tokens_public_1.tokenLabel;
    } });
    Object.defineProperty(exports2, "tokenMatcher", { enumerable: true, get: function() {
      return tokens_public_1.tokenMatcher;
    } });
    Object.defineProperty(exports2, "tokenName", { enumerable: true, get: function() {
      return tokens_public_1.tokenName;
    } });
    var lookahead_1 = require_lookahead();
    Object.defineProperty(exports2, "getLookaheadPaths", { enumerable: true, get: function() {
      return lookahead_1.getLookaheadPaths;
    } });
    var llk_lookahead_1 = require_llk_lookahead();
    Object.defineProperty(exports2, "LLkLookaheadStrategy", { enumerable: true, get: function() {
      return llk_lookahead_1.LLkLookaheadStrategy;
    } });
    var errors_public_1 = require_errors_public();
    Object.defineProperty(exports2, "defaultParserErrorProvider", { enumerable: true, get: function() {
      return errors_public_1.defaultParserErrorProvider;
    } });
    var exceptions_public_1 = require_exceptions_public();
    Object.defineProperty(exports2, "EarlyExitException", { enumerable: true, get: function() {
      return exceptions_public_1.EarlyExitException;
    } });
    Object.defineProperty(exports2, "isRecognitionException", { enumerable: true, get: function() {
      return exceptions_public_1.isRecognitionException;
    } });
    Object.defineProperty(exports2, "MismatchedTokenException", { enumerable: true, get: function() {
      return exceptions_public_1.MismatchedTokenException;
    } });
    Object.defineProperty(exports2, "NotAllInputParsedException", { enumerable: true, get: function() {
      return exceptions_public_1.NotAllInputParsedException;
    } });
    Object.defineProperty(exports2, "NoViableAltException", { enumerable: true, get: function() {
      return exceptions_public_1.NoViableAltException;
    } });
    var lexer_errors_public_1 = require_lexer_errors_public();
    Object.defineProperty(exports2, "defaultLexerErrorProvider", { enumerable: true, get: function() {
      return lexer_errors_public_1.defaultLexerErrorProvider;
    } });
    var gast_1 = require_api5();
    Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
      return gast_1.Alternation;
    } });
    Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
      return gast_1.Alternative;
    } });
    Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
      return gast_1.NonTerminal;
    } });
    Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
      return gast_1.Option;
    } });
    Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
      return gast_1.Repetition;
    } });
    Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
      return gast_1.RepetitionMandatory;
    } });
    Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
      return gast_1.RepetitionMandatoryWithSeparator;
    } });
    Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
      return gast_1.RepetitionWithSeparator;
    } });
    Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
      return gast_1.Rule;
    } });
    Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
      return gast_1.Terminal;
    } });
    var gast_2 = require_api5();
    Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
      return gast_2.serializeGrammar;
    } });
    Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
      return gast_2.serializeProduction;
    } });
    Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
      return gast_2.GAstVisitor;
    } });
    var cst_dts_gen_1 = require_api6();
    Object.defineProperty(exports2, "generateCstDts", { enumerable: true, get: function() {
      return cst_dts_gen_1.generateCstDts;
    } });
    function clearCache() {
      console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n	 It performs no action other than printing this message.\n	 Please avoid using it as it will be completely removed in the future");
    }
    exports2.clearCache = clearCache;
    var render_public_1 = require_render_public();
    Object.defineProperty(exports2, "createSyntaxDiagramsCode", { enumerable: true, get: function() {
      return render_public_1.createSyntaxDiagramsCode;
    } });
    var Parser = (
      /** @class */
      function() {
        function Parser2() {
          throw new Error("The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.	\nSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0");
        }
        return Parser2;
      }()
    );
    exports2.Parser = Parser;
  }
});

// ../../node_modules/.pnpm/chevrotain-allstar@0.1.7_chevrotain@10.4.2/node_modules/chevrotain-allstar/lib/atn.js
var require_atn = __commonJS({
  "../../node_modules/.pnpm/chevrotain-allstar@0.1.7_chevrotain@10.4.2/node_modules/chevrotain-allstar/lib/atn.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createATN = exports2.RuleTransition = exports2.EpsilonTransition = exports2.AtomTransition = exports2.AbstractTransition = exports2.ATN_LOOP_END = exports2.ATN_PLUS_LOOP_BACK = exports2.ATN_STAR_LOOP_ENTRY = exports2.ATN_STAR_LOOP_BACK = exports2.ATN_BLOCK_END = exports2.ATN_RULE_STOP = exports2.ATN_TOKEN_START = exports2.ATN_STAR_BLOCK_START = exports2.ATN_PLUS_BLOCK_START = exports2.ATN_RULE_START = exports2.ATN_BASIC = exports2.ATN_INVALID_TYPE = exports2.buildATNKey = void 0;
    var map_1 = __importDefault(require_map());
    var filter_1 = __importDefault(require_filter());
    var chevrotain_1 = require_api7();
    function buildATNKey(rule, type, occurrence) {
      return `${rule.name}_${type}_${occurrence}`;
    }
    exports2.buildATNKey = buildATNKey;
    exports2.ATN_INVALID_TYPE = 0;
    exports2.ATN_BASIC = 1;
    exports2.ATN_RULE_START = 2;
    exports2.ATN_PLUS_BLOCK_START = 4;
    exports2.ATN_STAR_BLOCK_START = 5;
    exports2.ATN_TOKEN_START = 6;
    exports2.ATN_RULE_STOP = 7;
    exports2.ATN_BLOCK_END = 8;
    exports2.ATN_STAR_LOOP_BACK = 9;
    exports2.ATN_STAR_LOOP_ENTRY = 10;
    exports2.ATN_PLUS_LOOP_BACK = 11;
    exports2.ATN_LOOP_END = 12;
    var AbstractTransition = class {
      constructor(target) {
        this.target = target;
      }
      isEpsilon() {
        return false;
      }
    };
    exports2.AbstractTransition = AbstractTransition;
    var AtomTransition = class extends AbstractTransition {
      constructor(target, tokenType) {
        super(target);
        this.tokenType = tokenType;
      }
    };
    exports2.AtomTransition = AtomTransition;
    var EpsilonTransition = class extends AbstractTransition {
      constructor(target) {
        super(target);
      }
      isEpsilon() {
        return true;
      }
    };
    exports2.EpsilonTransition = EpsilonTransition;
    var RuleTransition = class extends AbstractTransition {
      constructor(ruleStart, rule, followState) {
        super(ruleStart);
        this.rule = rule;
        this.followState = followState;
      }
      isEpsilon() {
        return true;
      }
    };
    exports2.RuleTransition = RuleTransition;
    function createATN(rules) {
      const atn = {
        decisionMap: {},
        decisionStates: [],
        ruleToStartState: /* @__PURE__ */ new Map(),
        ruleToStopState: /* @__PURE__ */ new Map(),
        states: []
      };
      createRuleStartAndStopATNStates(atn, rules);
      const ruleLength = rules.length;
      for (let i = 0; i < ruleLength; i++) {
        const rule = rules[i];
        const ruleBlock = block(atn, rule, rule);
        if (ruleBlock === void 0) {
          continue;
        }
        buildRuleHandle(atn, rule, ruleBlock);
      }
      return atn;
    }
    exports2.createATN = createATN;
    function createRuleStartAndStopATNStates(atn, rules) {
      const ruleLength = rules.length;
      for (let i = 0; i < ruleLength; i++) {
        const rule = rules[i];
        const start = newState(atn, rule, void 0, {
          type: exports2.ATN_RULE_START
        });
        const stop = newState(atn, rule, void 0, {
          type: exports2.ATN_RULE_STOP
        });
        start.stop = stop;
        atn.ruleToStartState.set(rule, start);
        atn.ruleToStopState.set(rule, stop);
      }
    }
    function atom(atn, rule, production) {
      if (production instanceof chevrotain_1.Terminal) {
        return tokenRef(atn, rule, production.terminalType, production);
      } else if (production instanceof chevrotain_1.NonTerminal) {
        return ruleRef(atn, rule, production);
      } else if (production instanceof chevrotain_1.Alternation) {
        return alternation(atn, rule, production);
      } else if (production instanceof chevrotain_1.Option) {
        return option(atn, rule, production);
      } else if (production instanceof chevrotain_1.Repetition) {
        return repetition(atn, rule, production);
      } else if (production instanceof chevrotain_1.RepetitionWithSeparator) {
        return repetitionSep(atn, rule, production);
      } else if (production instanceof chevrotain_1.RepetitionMandatory) {
        return repetitionMandatory(atn, rule, production);
      } else if (production instanceof chevrotain_1.RepetitionMandatoryWithSeparator) {
        return repetitionMandatorySep(atn, rule, production);
      } else {
        return block(atn, rule, production);
      }
    }
    function repetition(atn, rule, repetition2) {
      const starState = newState(atn, rule, repetition2, {
        type: exports2.ATN_STAR_BLOCK_START
      });
      defineDecisionState(atn, starState);
      const handle = makeAlts(atn, rule, starState, repetition2, block(atn, rule, repetition2));
      return star(atn, rule, repetition2, handle);
    }
    function repetitionSep(atn, rule, repetition2) {
      const starState = newState(atn, rule, repetition2, {
        type: exports2.ATN_STAR_BLOCK_START
      });
      defineDecisionState(atn, starState);
      const handle = makeAlts(atn, rule, starState, repetition2, block(atn, rule, repetition2));
      const sep = tokenRef(atn, rule, repetition2.separator, repetition2);
      return star(atn, rule, repetition2, handle, sep);
    }
    function repetitionMandatory(atn, rule, repetition2) {
      const plusState = newState(atn, rule, repetition2, {
        type: exports2.ATN_PLUS_BLOCK_START
      });
      defineDecisionState(atn, plusState);
      const handle = makeAlts(atn, rule, plusState, repetition2, block(atn, rule, repetition2));
      return plus(atn, rule, repetition2, handle);
    }
    function repetitionMandatorySep(atn, rule, repetition2) {
      const plusState = newState(atn, rule, repetition2, {
        type: exports2.ATN_PLUS_BLOCK_START
      });
      defineDecisionState(atn, plusState);
      const handle = makeAlts(atn, rule, plusState, repetition2, block(atn, rule, repetition2));
      const sep = tokenRef(atn, rule, repetition2.separator, repetition2);
      return plus(atn, rule, repetition2, handle, sep);
    }
    function alternation(atn, rule, alternation2) {
      const start = newState(atn, rule, alternation2, {
        type: exports2.ATN_BASIC
      });
      defineDecisionState(atn, start);
      const alts = (0, map_1.default)(alternation2.definition, (e) => atom(atn, rule, e));
      const handle = makeAlts(atn, rule, start, alternation2, ...alts);
      return handle;
    }
    function option(atn, rule, option2) {
      const start = newState(atn, rule, option2, {
        type: exports2.ATN_BASIC
      });
      defineDecisionState(atn, start);
      const handle = makeAlts(atn, rule, start, option2, block(atn, rule, option2));
      return optional(atn, rule, option2, handle);
    }
    function block(atn, rule, block2) {
      const handles = (0, filter_1.default)((0, map_1.default)(block2.definition, (e) => atom(atn, rule, e)), (e) => e !== void 0);
      if (handles.length === 1) {
        return handles[0];
      } else if (handles.length === 0) {
        return void 0;
      } else {
        return makeBlock(atn, handles);
      }
    }
    function plus(atn, rule, plus2, handle, sep) {
      const blkStart = handle.left;
      const blkEnd = handle.right;
      const loop = newState(atn, rule, plus2, {
        type: exports2.ATN_PLUS_LOOP_BACK
      });
      defineDecisionState(atn, loop);
      const end = newState(atn, rule, plus2, {
        type: exports2.ATN_LOOP_END
      });
      blkStart.loopback = loop;
      end.loopback = loop;
      atn.decisionMap[buildATNKey(rule, sep ? "RepetitionMandatoryWithSeparator" : "RepetitionMandatory", plus2.idx)] = loop;
      epsilon(blkEnd, loop);
      if (sep === void 0) {
        epsilon(loop, blkStart);
        epsilon(loop, end);
      } else {
        epsilon(loop, end);
        epsilon(loop, sep.left);
        epsilon(sep.right, blkStart);
      }
      return {
        left: blkStart,
        right: end
      };
    }
    function star(atn, rule, star2, handle, sep) {
      const start = handle.left;
      const end = handle.right;
      const entry = newState(atn, rule, star2, {
        type: exports2.ATN_STAR_LOOP_ENTRY
      });
      defineDecisionState(atn, entry);
      const loopEnd = newState(atn, rule, star2, {
        type: exports2.ATN_LOOP_END
      });
      const loop = newState(atn, rule, star2, {
        type: exports2.ATN_STAR_LOOP_BACK
      });
      entry.loopback = loop;
      loopEnd.loopback = loop;
      epsilon(entry, start);
      epsilon(entry, loopEnd);
      epsilon(end, loop);
      if (sep !== void 0) {
        epsilon(loop, loopEnd);
        epsilon(loop, sep.left);
        epsilon(sep.right, start);
      } else {
        epsilon(loop, entry);
      }
      atn.decisionMap[buildATNKey(rule, sep ? "RepetitionWithSeparator" : "Repetition", star2.idx)] = entry;
      return {
        left: entry,
        right: loopEnd
      };
    }
    function optional(atn, rule, optional2, handle) {
      const start = handle.left;
      const end = handle.right;
      epsilon(start, end);
      atn.decisionMap[buildATNKey(rule, "Option", optional2.idx)] = start;
      return handle;
    }
    function defineDecisionState(atn, state) {
      atn.decisionStates.push(state);
      state.decision = atn.decisionStates.length - 1;
      return state.decision;
    }
    function makeAlts(atn, rule, start, production, ...alts) {
      const end = newState(atn, rule, production, {
        type: exports2.ATN_BLOCK_END,
        start
      });
      start.end = end;
      for (const alt of alts) {
        if (alt !== void 0) {
          epsilon(start, alt.left);
          epsilon(alt.right, end);
        } else {
          epsilon(start, end);
        }
      }
      const handle = {
        left: start,
        right: end
      };
      atn.decisionMap[buildATNKey(rule, getProdType(production), production.idx)] = start;
      return handle;
    }
    function getProdType(production) {
      if (production instanceof chevrotain_1.Alternation) {
        return "Alternation";
      } else if (production instanceof chevrotain_1.Option) {
        return "Option";
      } else if (production instanceof chevrotain_1.Repetition) {
        return "Repetition";
      } else if (production instanceof chevrotain_1.RepetitionWithSeparator) {
        return "RepetitionWithSeparator";
      } else if (production instanceof chevrotain_1.RepetitionMandatory) {
        return "RepetitionMandatory";
      } else if (production instanceof chevrotain_1.RepetitionMandatoryWithSeparator) {
        return "RepetitionMandatoryWithSeparator";
      } else {
        throw new Error("Invalid production type encountered");
      }
    }
    function makeBlock(atn, alts) {
      const altsLength = alts.length;
      for (let i = 0; i < altsLength - 1; i++) {
        const handle = alts[i];
        let transition;
        if (handle.left.transitions.length === 1) {
          transition = handle.left.transitions[0];
        }
        const isRuleTransition = transition instanceof RuleTransition;
        const ruleTransition = transition;
        const next = alts[i + 1].left;
        if (handle.left.type === exports2.ATN_BASIC && handle.right.type === exports2.ATN_BASIC && transition !== void 0 && (isRuleTransition && ruleTransition.followState === handle.right || transition.target === handle.right)) {
          if (isRuleTransition) {
            ruleTransition.followState = next;
          } else {
            transition.target = next;
          }
          removeState(atn, handle.right);
        } else {
          epsilon(handle.right, next);
        }
      }
      const first = alts[0];
      const last = alts[altsLength - 1];
      return {
        left: first.left,
        right: last.right
      };
    }
    function tokenRef(atn, rule, tokenType, production) {
      const left = newState(atn, rule, production, {
        type: exports2.ATN_BASIC
      });
      const right = newState(atn, rule, production, {
        type: exports2.ATN_BASIC
      });
      addTransition(left, new AtomTransition(right, tokenType));
      return {
        left,
        right
      };
    }
    function ruleRef(atn, currentRule, nonTerminal) {
      const rule = nonTerminal.referencedRule;
      const start = atn.ruleToStartState.get(rule);
      const left = newState(atn, currentRule, nonTerminal, {
        type: exports2.ATN_BASIC
      });
      const right = newState(atn, currentRule, nonTerminal, {
        type: exports2.ATN_BASIC
      });
      const call = new RuleTransition(start, rule, right);
      addTransition(left, call);
      return {
        left,
        right
      };
    }
    function buildRuleHandle(atn, rule, block2) {
      const start = atn.ruleToStartState.get(rule);
      epsilon(start, block2.left);
      const stop = atn.ruleToStopState.get(rule);
      epsilon(block2.right, stop);
      const handle = {
        left: start,
        right: stop
      };
      return handle;
    }
    function epsilon(a, b) {
      const transition = new EpsilonTransition(b);
      addTransition(a, transition);
    }
    function newState(atn, rule, production, partial) {
      const t = Object.assign({
        atn,
        production,
        epsilonOnlyTransitions: false,
        rule,
        transitions: [],
        nextTokenWithinRule: [],
        stateNumber: atn.states.length
      }, partial);
      atn.states.push(t);
      return t;
    }
    function addTransition(state, transition) {
      if (state.transitions.length === 0) {
        state.epsilonOnlyTransitions = transition.isEpsilon();
      }
      state.transitions.push(transition);
    }
    function removeState(atn, state) {
      atn.states.splice(atn.states.indexOf(state), 1);
    }
  }
});

// ../../node_modules/.pnpm/chevrotain-allstar@0.1.7_chevrotain@10.4.2/node_modules/chevrotain-allstar/lib/dfa.js
var require_dfa = __commonJS({
  "../../node_modules/.pnpm/chevrotain-allstar@0.1.7_chevrotain@10.4.2/node_modules/chevrotain-allstar/lib/dfa.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getATNConfigKey = exports2.ATNConfigSet = exports2.DFA_ERROR = void 0;
    var map_1 = __importDefault(require_map());
    exports2.DFA_ERROR = {};
    var ATNConfigSet = class {
      constructor() {
        this.map = {};
        this.configs = [];
      }
      get size() {
        return this.configs.length;
      }
      finalize() {
        this.map = {};
      }
      add(config) {
        const key = getATNConfigKey(config);
        if (!(key in this.map)) {
          this.map[key] = this.configs.length;
          this.configs.push(config);
        }
      }
      get elements() {
        return this.configs;
      }
      get alts() {
        return (0, map_1.default)(this.configs, (e) => e.alt);
      }
      get key() {
        let value = "";
        for (const k in this.map) {
          value += k + ":";
        }
        return value;
      }
    };
    exports2.ATNConfigSet = ATNConfigSet;
    function getATNConfigKey(config, alt = true) {
      return `${alt ? `a${config.alt}` : ""}s${config.state.stateNumber}:${config.stack.map((e) => e.stateNumber.toString()).join("_")}`;
    }
    exports2.getATNConfigKey = getATNConfigKey;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseExtremum.js
var require_baseExtremum = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseExtremum.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    function baseExtremum(array, iteratee, comparator) {
      var index = -1, length = array.length;
      while (++index < length) {
        var value = array[index], current = iteratee(value);
        if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) {
          var computed = current, result = value;
        }
      }
      return result;
    }
    module2.exports = baseExtremum;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseLt.js
var require_baseLt = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseLt.js"(exports2, module2) {
    function baseLt(value, other) {
      return value < other;
    }
    module2.exports = baseLt;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/min.js
var require_min = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/min.js"(exports2, module2) {
    var baseExtremum = require_baseExtremum();
    var baseLt = require_baseLt();
    var identity = require_identity();
    function min(array) {
      return array && array.length ? baseExtremum(array, identity, baseLt) : void 0;
    }
    module2.exports = min;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniqBy.js
var require_uniqBy = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniqBy.js"(exports2, module2) {
    var baseIteratee = require_baseIteratee();
    var baseUniq = require_baseUniq();
    function uniqBy(array, iteratee) {
      return array && array.length ? baseUniq(array, baseIteratee(iteratee, 2)) : [];
    }
    module2.exports = uniqBy;
  }
});

// ../../node_modules/.pnpm/chevrotain-allstar@0.1.7_chevrotain@10.4.2/node_modules/chevrotain-allstar/lib/all-star-lookahead.js
var require_all_star_lookahead = __commonJS({
  "../../node_modules/.pnpm/chevrotain-allstar@0.1.7_chevrotain@10.4.2/node_modules/chevrotain-allstar/lib/all-star-lookahead.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LLStarLookaheadStrategy = void 0;
    var chevrotain_1 = require_api7();
    var atn_1 = require_atn();
    var dfa_1 = require_dfa();
    var min_1 = __importDefault(require_min());
    var flatMap_1 = __importDefault(require_flatMap());
    var uniqBy_1 = __importDefault(require_uniqBy());
    var map_1 = __importDefault(require_map());
    var flatten_1 = __importDefault(require_flatten());
    var forEach_1 = __importDefault(require_forEach());
    var isEmpty_1 = __importDefault(require_isEmpty());
    var reduce_1 = __importDefault(require_reduce());
    function createDFACache(startState, decision) {
      const map = {};
      return (predicateSet) => {
        const key = predicateSet.toString();
        let existing = map[key];
        if (existing !== void 0) {
          return existing;
        } else {
          existing = {
            atnStartState: startState,
            decision,
            states: {}
          };
          map[key] = existing;
          return existing;
        }
      };
    }
    var PredicateSet = class {
      constructor() {
        this.predicates = [];
      }
      is(index) {
        return index >= this.predicates.length || this.predicates[index];
      }
      set(index, value) {
        this.predicates[index] = value;
      }
      toString() {
        let value = "";
        const size = this.predicates.length;
        for (let i = 0; i < size; i++) {
          value += this.predicates[i] === true ? "1" : "0";
        }
        return value;
      }
    };
    var EMPTY_PREDICATES = new PredicateSet();
    var LLStarLookaheadStrategy = class extends chevrotain_1.LLkLookaheadStrategy {
      constructor(options) {
        var _a;
        super();
        this.logging = (_a = options === null || options === void 0 ? void 0 : options.logging) !== null && _a !== void 0 ? _a : (message) => console.log(message);
      }
      initialize(options) {
        this.atn = (0, atn_1.createATN)(options.rules);
        this.dfas = initATNSimulator(this.atn);
      }
      validateAmbiguousAlternationAlternatives() {
        return [];
      }
      validateEmptyOrAlternatives() {
        return [];
      }
      buildLookaheadForAlternation(options) {
        const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;
        const dfas = this.dfas;
        const logging = this.logging;
        const key = (0, atn_1.buildATNKey)(rule, "Alternation", prodOccurrence);
        const decisionState = this.atn.decisionMap[key];
        const decisionIndex = decisionState.decision;
        const partialAlts = (0, map_1.default)((0, chevrotain_1.getLookaheadPaths)({
          maxLookahead: 1,
          occurrence: prodOccurrence,
          prodType: "Alternation",
          rule
        }), (currAlt) => (0, map_1.default)(currAlt, (path2) => path2[0]));
        if (isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {
          const choiceToAlt = (0, reduce_1.default)(partialAlts, (result, currAlt, idx) => {
            (0, forEach_1.default)(currAlt, (currTokType) => {
              if (currTokType) {
                result[currTokType.tokenTypeIdx] = idx;
                (0, forEach_1.default)(currTokType.categoryMatches, (currExtendingType) => {
                  result[currExtendingType] = idx;
                });
              }
            });
            return result;
          }, {});
          if (hasPredicates) {
            return function(orAlts) {
              var _a;
              const nextToken = this.LA(1);
              const prediction = choiceToAlt[nextToken.tokenTypeIdx];
              if (orAlts !== void 0 && prediction !== void 0) {
                const gate = (_a = orAlts[prediction]) === null || _a === void 0 ? void 0 : _a.GATE;
                if (gate !== void 0 && gate.call(this) === false) {
                  return void 0;
                }
              }
              return prediction;
            };
          } else {
            return function() {
              const nextToken = this.LA(1);
              return choiceToAlt[nextToken.tokenTypeIdx];
            };
          }
        } else if (hasPredicates) {
          return function(orAlts) {
            const predicates = new PredicateSet();
            const length = orAlts === void 0 ? 0 : orAlts.length;
            for (let i = 0; i < length; i++) {
              const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;
              predicates.set(i, gate === void 0 || gate.call(this));
            }
            const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);
            return typeof result === "number" ? result : void 0;
          };
        } else {
          return function() {
            const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);
            return typeof result === "number" ? result : void 0;
          };
        }
      }
      buildLookaheadForOptional(options) {
        const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;
        const dfas = this.dfas;
        const logging = this.logging;
        const key = (0, atn_1.buildATNKey)(rule, prodType, prodOccurrence);
        const decisionState = this.atn.decisionMap[key];
        const decisionIndex = decisionState.decision;
        const alts = (0, map_1.default)((0, chevrotain_1.getLookaheadPaths)({
          maxLookahead: 1,
          occurrence: prodOccurrence,
          prodType,
          rule
        }), (e) => {
          return (0, map_1.default)(e, (g) => g[0]);
        });
        if (isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {
          const alt = alts[0];
          const singleTokensTypes = (0, flatten_1.default)(alt);
          if (singleTokensTypes.length === 1 && (0, isEmpty_1.default)(singleTokensTypes[0].categoryMatches)) {
            const expectedTokenType = singleTokensTypes[0];
            const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;
            return function() {
              return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;
            };
          } else {
            const choiceToAlt = (0, reduce_1.default)(singleTokensTypes, (result, currTokType) => {
              if (currTokType !== void 0) {
                result[currTokType.tokenTypeIdx] = true;
                (0, forEach_1.default)(currTokType.categoryMatches, (currExtendingType) => {
                  result[currExtendingType] = true;
                });
              }
              return result;
            }, {});
            return function() {
              const nextToken = this.LA(1);
              return choiceToAlt[nextToken.tokenTypeIdx] === true;
            };
          }
        }
        return function() {
          const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);
          return typeof result === "object" ? false : result === 0;
        };
      }
    };
    exports2.LLStarLookaheadStrategy = LLStarLookaheadStrategy;
    function isLL1Sequence(sequences, allowEmpty = true) {
      const fullSet = /* @__PURE__ */ new Set();
      for (const alt of sequences) {
        const altSet = /* @__PURE__ */ new Set();
        for (const tokType of alt) {
          if (tokType === void 0) {
            if (allowEmpty) {
              break;
            } else {
              return false;
            }
          }
          const indices = [tokType.tokenTypeIdx].concat(tokType.categoryMatches);
          for (const index of indices) {
            if (fullSet.has(index)) {
              if (!altSet.has(index)) {
                return false;
              }
            } else {
              fullSet.add(index);
              altSet.add(index);
            }
          }
        }
      }
      return true;
    }
    function initATNSimulator(atn) {
      const decisionLength = atn.decisionStates.length;
      const decisionToDFA = Array(decisionLength);
      for (let i = 0; i < decisionLength; i++) {
        decisionToDFA[i] = createDFACache(atn.decisionStates[i], i);
      }
      return decisionToDFA;
    }
    function adaptivePredict(dfaCaches, decision, predicateSet, logging) {
      const dfa = dfaCaches[decision](predicateSet);
      let start = dfa.start;
      if (start === void 0) {
        const closure2 = computeStartState(dfa.atnStartState);
        start = addDFAState(dfa, newDFAState(closure2));
        dfa.start = start;
      }
      const alt = performLookahead.apply(this, [dfa, start, predicateSet, logging]);
      return alt;
    }
    function performLookahead(dfa, s0, predicateSet, logging) {
      let previousD = s0;
      let i = 1;
      const path2 = [];
      let t = this.LA(i++);
      while (true) {
        let d = getExistingTargetState(previousD, t);
        if (d === void 0) {
          d = computeLookaheadTarget.apply(this, [dfa, previousD, t, i, predicateSet, logging]);
        }
        if (d === dfa_1.DFA_ERROR) {
          return buildAdaptivePredictError(path2, previousD, t);
        }
        if (d.isAcceptState === true) {
          return d.prediction;
        }
        previousD = d;
        path2.push(t);
        t = this.LA(i++);
      }
    }
    function computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {
      const reach = computeReachSet(previousD.configs, token, predicateSet);
      if (reach.size === 0) {
        addDFAEdge(dfa, previousD, token, dfa_1.DFA_ERROR);
        return dfa_1.DFA_ERROR;
      }
      let newState = newDFAState(reach);
      const predictedAlt = getUniqueAlt(reach, predicateSet);
      if (predictedAlt !== void 0) {
        newState.isAcceptState = true;
        newState.prediction = predictedAlt;
        newState.configs.uniqueAlt = predictedAlt;
      } else if (hasConflictTerminatingPrediction(reach)) {
        const prediction = (0, min_1.default)(reach.alts);
        newState.isAcceptState = true;
        newState.prediction = prediction;
        newState.configs.uniqueAlt = prediction;
        reportLookaheadAmbiguity.apply(this, [dfa, lookahead, reach.alts, logging]);
      }
      newState = addDFAEdge(dfa, previousD, token, newState);
      return newState;
    }
    function reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {
      const prefixPath = [];
      for (let i = 1; i <= lookahead; i++) {
        prefixPath.push(this.LA(i).tokenType);
      }
      const atnState = dfa.atnStartState;
      const topLevelRule = atnState.rule;
      const production = atnState.production;
      const message = buildAmbiguityError({
        topLevelRule,
        ambiguityIndices,
        production,
        prefixPath
      });
      logging(message);
    }
    function buildAmbiguityError(options) {
      const pathMsg = (0, map_1.default)(options.prefixPath, (currtok) => (0, chevrotain_1.tokenLabel)(currtok)).join(", ");
      const occurrence = options.production.idx === 0 ? "" : options.production.idx;
      let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(", ")}> in <${getProductionDslName(options.production)}${occurrence}> inside <${options.topLevelRule.name}> Rule,
<${pathMsg}> may appears as a prefix path in all these alternatives.
`;
      currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`;
      return currMessage;
    }
    function getProductionDslName(prod) {
      if (prod instanceof chevrotain_1.NonTerminal) {
        return "SUBRULE";
      } else if (prod instanceof chevrotain_1.Option) {
        return "OPTION";
      } else if (prod instanceof chevrotain_1.Alternation) {
        return "OR";
      } else if (prod instanceof chevrotain_1.RepetitionMandatory) {
        return "AT_LEAST_ONE";
      } else if (prod instanceof chevrotain_1.RepetitionMandatoryWithSeparator) {
        return "AT_LEAST_ONE_SEP";
      } else if (prod instanceof chevrotain_1.RepetitionWithSeparator) {
        return "MANY_SEP";
      } else if (prod instanceof chevrotain_1.Repetition) {
        return "MANY";
      } else if (prod instanceof chevrotain_1.Terminal) {
        return "CONSUME";
      } else {
        throw Error("non exhaustive match");
      }
    }
    function buildAdaptivePredictError(path2, previous, current) {
      const nextTransitions = (0, flatMap_1.default)(previous.configs.elements, (e) => e.state.transitions);
      const nextTokenTypes = (0, uniqBy_1.default)(nextTransitions.filter((e) => e instanceof atn_1.AtomTransition).map((e) => e.tokenType), (e) => e.tokenTypeIdx);
      return {
        actualToken: current,
        possibleTokenTypes: nextTokenTypes,
        tokenPath: path2
      };
    }
    function getExistingTargetState(state, token) {
      return state.edges[token.tokenTypeIdx];
    }
    function computeReachSet(configs, token, predicateSet) {
      const intermediate = new dfa_1.ATNConfigSet();
      const skippedStopStates = [];
      for (const c of configs.elements) {
        if (predicateSet.is(c.alt) === false) {
          continue;
        }
        if (c.state.type === atn_1.ATN_RULE_STOP) {
          skippedStopStates.push(c);
          continue;
        }
        const transitionLength = c.state.transitions.length;
        for (let i = 0; i < transitionLength; i++) {
          const transition = c.state.transitions[i];
          const target = getReachableTarget(transition, token);
          if (target !== void 0) {
            intermediate.add({
              state: target,
              alt: c.alt,
              stack: c.stack
            });
          }
        }
      }
      let reach;
      if (skippedStopStates.length === 0 && intermediate.size === 1) {
        reach = intermediate;
      }
      if (reach === void 0) {
        reach = new dfa_1.ATNConfigSet();
        for (const c of intermediate.elements) {
          closure(c, reach);
        }
      }
      if (skippedStopStates.length > 0 && !hasConfigInRuleStopState(reach)) {
        for (const c of skippedStopStates) {
          reach.add(c);
        }
      }
      return reach;
    }
    function getReachableTarget(transition, token) {
      if (transition instanceof atn_1.AtomTransition && (0, chevrotain_1.tokenMatcher)(token, transition.tokenType)) {
        return transition.target;
      }
      return void 0;
    }
    function getUniqueAlt(configs, predicateSet) {
      let alt;
      for (const c of configs.elements) {
        if (predicateSet.is(c.alt) === true) {
          if (alt === void 0) {
            alt = c.alt;
          } else if (alt !== c.alt) {
            return void 0;
          }
        }
      }
      return alt;
    }
    function newDFAState(closure2) {
      return {
        configs: closure2,
        edges: {},
        isAcceptState: false,
        prediction: -1
      };
    }
    function addDFAEdge(dfa, from, token, to) {
      to = addDFAState(dfa, to);
      from.edges[token.tokenTypeIdx] = to;
      return to;
    }
    function addDFAState(dfa, state) {
      if (state === dfa_1.DFA_ERROR) {
        return state;
      }
      const mapKey = state.configs.key;
      const existing = dfa.states[mapKey];
      if (existing !== void 0) {
        return existing;
      }
      state.configs.finalize();
      dfa.states[mapKey] = state;
      return state;
    }
    function computeStartState(atnState) {
      const configs = new dfa_1.ATNConfigSet();
      const numberOfTransitions = atnState.transitions.length;
      for (let i = 0; i < numberOfTransitions; i++) {
        const target = atnState.transitions[i].target;
        const config = {
          state: target,
          alt: i,
          stack: []
        };
        closure(config, configs);
      }
      return configs;
    }
    function closure(config, configs) {
      const p = config.state;
      if (p.type === atn_1.ATN_RULE_STOP) {
        if (config.stack.length > 0) {
          const atnStack = [...config.stack];
          const followState = atnStack.pop();
          const followConfig = {
            state: followState,
            alt: config.alt,
            stack: atnStack
          };
          closure(followConfig, configs);
        } else {
          configs.add(config);
        }
        return;
      }
      if (!p.epsilonOnlyTransitions) {
        configs.add(config);
      }
      const transitionLength = p.transitions.length;
      for (let i = 0; i < transitionLength; i++) {
        const transition = p.transitions[i];
        const c = getEpsilonTarget(config, transition);
        if (c !== void 0) {
          closure(c, configs);
        }
      }
    }
    function getEpsilonTarget(config, transition) {
      if (transition instanceof atn_1.EpsilonTransition) {
        return {
          state: transition.target,
          alt: config.alt,
          stack: config.stack
        };
      } else if (transition instanceof atn_1.RuleTransition) {
        const stack = [...config.stack, transition.followState];
        return {
          state: transition.target,
          alt: config.alt,
          stack
        };
      }
      return void 0;
    }
    function hasConfigInRuleStopState(configs) {
      for (const c of configs.elements) {
        if (c.state.type === atn_1.ATN_RULE_STOP) {
          return true;
        }
      }
      return false;
    }
    function allConfigsInRuleStopStates(configs) {
      for (const c of configs.elements) {
        if (c.state.type !== atn_1.ATN_RULE_STOP) {
          return false;
        }
      }
      return true;
    }
    function hasConflictTerminatingPrediction(configs) {
      if (allConfigsInRuleStopStates(configs)) {
        return true;
      }
      const altSets = getConflictingAltSets(configs.elements);
      const heuristic = hasConflictingAltSet(altSets) && !hasStateAssociatedWithOneAlt(altSets);
      return heuristic;
    }
    function getConflictingAltSets(configs) {
      const configToAlts = /* @__PURE__ */ new Map();
      for (const c of configs) {
        const key = (0, dfa_1.getATNConfigKey)(c, false);
        let alts = configToAlts.get(key);
        if (alts === void 0) {
          alts = {};
          configToAlts.set(key, alts);
        }
        alts[c.alt] = true;
      }
      return configToAlts;
    }
    function hasConflictingAltSet(altSets) {
      for (const value of Array.from(altSets.values())) {
        if (Object.keys(value).length > 1) {
          return true;
        }
      }
      return false;
    }
    function hasStateAssociatedWithOneAlt(altSets) {
      for (const value of Array.from(altSets.values())) {
        if (Object.keys(value).length === 1) {
          return true;
        }
      }
      return false;
    }
  }
});

// ../../node_modules/.pnpm/chevrotain-allstar@0.1.7_chevrotain@10.4.2/node_modules/chevrotain-allstar/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/chevrotain-allstar@0.1.7_chevrotain@10.4.2/node_modules/chevrotain-allstar/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LLStarLookaheadStrategy = void 0;
    var all_star_lookahead_1 = require_all_star_lookahead();
    Object.defineProperty(exports2, "LLStarLookaheadStrategy", { enumerable: true, get: function() {
      return all_star_lookahead_1.LLStarLookaheadStrategy;
    } });
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/cst-node-builder.js
var require_cst_node_builder = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/cst-node-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RootCstNodeImpl = exports2.CompositeCstNodeImpl = exports2.LeafCstNodeImpl = exports2.AbstractCstNode = exports2.CstNodeBuilder = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var syntax_tree_1 = require_syntax_tree();
    var cst_util_1 = require_cst_util();
    var CstNodeBuilder = class {
      constructor() {
        this.nodeStack = [];
      }
      get current() {
        return this.nodeStack[this.nodeStack.length - 1];
      }
      buildRootNode(input) {
        this.rootNode = new RootCstNodeImpl(input);
        this.nodeStack = [this.rootNode];
        return this.rootNode;
      }
      buildCompositeNode(feature) {
        const compositeNode = new CompositeCstNodeImpl();
        compositeNode.feature = feature;
        compositeNode.root = this.rootNode;
        this.current.children.push(compositeNode);
        this.nodeStack.push(compositeNode);
        return compositeNode;
      }
      buildLeafNode(token, feature) {
        const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, (0, cst_util_1.tokenToRange)(token), token.tokenType, false);
        leafNode.feature = feature;
        leafNode.root = this.rootNode;
        this.current.children.push(leafNode);
        return leafNode;
      }
      removeNode(node) {
        const parent = node.parent;
        if (parent) {
          const index = parent.children.indexOf(node);
          if (index >= 0) {
            parent.children.splice(index, 1);
          }
        }
      }
      construct(item) {
        const current = this.current;
        if (typeof item.$type === "string") {
          this.current.element = item;
        }
        item.$cstNode = current;
        const node = this.nodeStack.pop();
        if ((node === null || node === void 0 ? void 0 : node.children.length) === 0) {
          this.removeNode(node);
        }
      }
      addHiddenTokens(hiddenTokens) {
        for (const token of hiddenTokens) {
          const hiddenNode = new LeafCstNodeImpl(token.startOffset, token.image.length, (0, cst_util_1.tokenToRange)(token), token.tokenType, true);
          hiddenNode.root = this.rootNode;
          this.addHiddenToken(this.rootNode, hiddenNode);
        }
      }
      addHiddenToken(node, token) {
        const { offset: tokenStart, end: tokenEnd } = token;
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          const { offset: childStart, end: childEnd } = child;
          if ((0, syntax_tree_1.isCompositeCstNode)(child) && tokenStart > childStart && tokenEnd < childEnd) {
            this.addHiddenToken(child, token);
            return;
          } else if (tokenEnd <= childStart) {
            node.children.splice(i, 0, token);
            return;
          }
        }
        node.children.push(token);
      }
    };
    exports2.CstNodeBuilder = CstNodeBuilder;
    var AbstractCstNode = class {
      get hidden() {
        return false;
      }
      get element() {
        var _a, _b;
        const node = typeof ((_a = this._element) === null || _a === void 0 ? void 0 : _a.$type) === "string" ? this._element : (_b = this.parent) === null || _b === void 0 ? void 0 : _b.element;
        if (!node) {
          throw new Error("This node has no associated AST element");
        }
        return node;
      }
      set element(value) {
        this._element = value;
      }
      get text() {
        return this.root.fullText.substring(this.offset, this.end);
      }
    };
    exports2.AbstractCstNode = AbstractCstNode;
    var LeafCstNodeImpl = class extends AbstractCstNode {
      get offset() {
        return this._offset;
      }
      get length() {
        return this._length;
      }
      get end() {
        return this._offset + this._length;
      }
      get hidden() {
        return this._hidden;
      }
      get tokenType() {
        return this._tokenType;
      }
      get range() {
        return this._range;
      }
      constructor(offset, length, range, tokenType, hidden = false) {
        super();
        this._hidden = hidden;
        this._offset = offset;
        this._tokenType = tokenType;
        this._length = length;
        this._range = range;
      }
    };
    exports2.LeafCstNodeImpl = LeafCstNodeImpl;
    var CompositeCstNodeImpl = class extends AbstractCstNode {
      constructor() {
        super(...arguments);
        this.children = new CstNodeContainer(this);
      }
      get offset() {
        var _a, _b;
        return (_b = (_a = this.firstNonHiddenNode) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0;
      }
      get length() {
        return this.end - this.offset;
      }
      get end() {
        var _a, _b;
        return (_b = (_a = this.lastNonHiddenNode) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;
      }
      get range() {
        const firstNode = this.firstNonHiddenNode;
        const lastNode = this.lastNonHiddenNode;
        if (firstNode && lastNode) {
          if (this._rangeCache === void 0) {
            const { range: firstRange } = firstNode;
            const { range: lastRange } = lastNode;
            this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };
          }
          return this._rangeCache;
        } else {
          return { start: vscode_languageserver_types_1.Position.create(0, 0), end: vscode_languageserver_types_1.Position.create(0, 0) };
        }
      }
      get firstNonHiddenNode() {
        for (const child of this.children) {
          if (!child.hidden) {
            return child;
          }
        }
        return this.children[0];
      }
      get lastNonHiddenNode() {
        for (let i = this.children.length - 1; i >= 0; i--) {
          const child = this.children[i];
          if (!child.hidden) {
            return child;
          }
        }
        return this.children[this.children.length - 1];
      }
    };
    exports2.CompositeCstNodeImpl = CompositeCstNodeImpl;
    var CstNodeContainer = class extends Array {
      constructor(parent) {
        super();
        this.parent = parent;
        Object.setPrototypeOf(this, CstNodeContainer.prototype);
      }
      push(...items) {
        this.addParents(items);
        return super.push(...items);
      }
      unshift(...items) {
        this.addParents(items);
        return super.unshift(...items);
      }
      splice(start, count, ...items) {
        this.addParents(items);
        return super.splice(start, count, ...items);
      }
      addParents(items) {
        for (const item of items) {
          item.parent = this.parent;
        }
      }
    };
    var RootCstNodeImpl = class extends CompositeCstNodeImpl {
      get text() {
        return this._text.substring(this.offset, this.end);
      }
      get fullText() {
        return this._text;
      }
      constructor(input) {
        super();
        this._text = "";
        this._text = input !== null && input !== void 0 ? input : "";
      }
    };
    exports2.RootCstNodeImpl = RootCstNodeImpl;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/langium-parser.js
var require_langium_parser = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/langium-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LangiumCompletionParser = exports2.LangiumParserErrorMessageProvider = exports2.LangiumParser = exports2.AbstractLangiumParser = exports2.DatatypeSymbol = void 0;
    var chevrotain_1 = require_api7();
    var chevrotain_allstar_1 = require_lib();
    var ast_1 = require_ast();
    var internal_grammar_util_1 = require_internal_grammar_util();
    var ast_util_1 = require_ast_util();
    var cst_node_builder_1 = require_cst_node_builder();
    exports2.DatatypeSymbol = Symbol("Datatype");
    function isDataTypeNode(node) {
      return node.$type === exports2.DatatypeSymbol;
    }
    var ruleSuffix = "\u200B";
    var withRuleSuffix = (name) => name.endsWith(ruleSuffix) ? name : name + ruleSuffix;
    var AbstractLangiumParser = class {
      constructor(services) {
        this._unorderedGroups = /* @__PURE__ */ new Map();
        this.lexer = services.parser.Lexer;
        const tokens = this.lexer.definition;
        this.wrapper = new ChevrotainWrapper(tokens, services.parser.ParserConfig);
      }
      alternatives(idx, choices) {
        this.wrapper.wrapOr(idx, choices);
      }
      optional(idx, callback) {
        this.wrapper.wrapOption(idx, callback);
      }
      many(idx, callback) {
        this.wrapper.wrapMany(idx, callback);
      }
      atLeastOne(idx, callback) {
        this.wrapper.wrapAtLeastOne(idx, callback);
      }
      isRecording() {
        return this.wrapper.IS_RECORDING;
      }
      get unorderedGroups() {
        return this._unorderedGroups;
      }
      getRuleStack() {
        return this.wrapper.RULE_STACK;
      }
      finalize() {
        this.wrapper.wrapSelfAnalysis();
      }
    };
    exports2.AbstractLangiumParser = AbstractLangiumParser;
    var LangiumParser = class extends AbstractLangiumParser {
      get current() {
        return this.stack[this.stack.length - 1];
      }
      constructor(services) {
        super(services);
        this.nodeBuilder = new cst_node_builder_1.CstNodeBuilder();
        this.stack = [];
        this.assignmentMap = /* @__PURE__ */ new Map();
        this.linker = services.references.Linker;
        this.converter = services.parser.ValueConverter;
        this.astReflection = services.shared.AstReflection;
      }
      rule(rule, impl) {
        const type = rule.fragment ? void 0 : (0, internal_grammar_util_1.isDataTypeRule)(rule) ? exports2.DatatypeSymbol : (0, internal_grammar_util_1.getTypeName)(rule);
        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));
        if (rule.entry) {
          this.mainRule = ruleMethod;
        }
        return ruleMethod;
      }
      parse(input) {
        this.nodeBuilder.buildRootNode(input);
        const lexerResult = this.lexer.tokenize(input);
        this.wrapper.input = lexerResult.tokens;
        const result = this.mainRule.call(this.wrapper, {});
        this.nodeBuilder.addHiddenTokens(lexerResult.hidden);
        this.unorderedGroups.clear();
        return {
          value: result,
          lexerErrors: lexerResult.errors,
          parserErrors: this.wrapper.errors
        };
      }
      startImplementation($type, implementation) {
        return (args) => {
          if (!this.isRecording()) {
            const node = { $type };
            this.stack.push(node);
            if ($type === exports2.DatatypeSymbol) {
              node.value = "";
            }
          }
          let result;
          try {
            result = implementation(args);
          } catch (err) {
            result = void 0;
          }
          if (!this.isRecording() && result === void 0) {
            result = this.construct();
          }
          return result;
        };
      }
      consume(idx, tokenType, feature) {
        const token = this.wrapper.wrapConsume(idx, tokenType);
        if (!this.isRecording() && !token.isInsertedInRecovery) {
          const leafNode = this.nodeBuilder.buildLeafNode(token, feature);
          const { assignment, isCrossRef } = this.getAssignment(feature);
          const current = this.current;
          if (assignment) {
            const convertedValue = (0, ast_1.isKeyword)(feature) ? token.image : this.converter.convert(token.image, leafNode);
            this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);
          } else if (isDataTypeNode(current)) {
            let text = token.image;
            if (!(0, ast_1.isKeyword)(feature)) {
              text = this.converter.convert(text, leafNode).toString();
            }
            current.value += text;
          }
        }
      }
      subrule(idx, rule, feature, args) {
        let cstNode;
        if (!this.isRecording()) {
          cstNode = this.nodeBuilder.buildCompositeNode(feature);
        }
        const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);
        if (!this.isRecording() && cstNode && cstNode.length > 0) {
          this.performSubruleAssignment(subruleResult, feature, cstNode);
        }
      }
      performSubruleAssignment(result, feature, cstNode) {
        const { assignment, isCrossRef } = this.getAssignment(feature);
        if (assignment) {
          this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);
        } else if (!assignment) {
          const current = this.current;
          if (isDataTypeNode(current)) {
            current.value += result.toString();
          } else {
            const resultKind = result.$type;
            const object = this.assignWithoutOverride(result, current);
            if (resultKind) {
              object.$type = resultKind;
            }
            const newItem = object;
            this.stack.pop();
            this.stack.push(newItem);
          }
        }
      }
      action($type, action) {
        if (!this.isRecording()) {
          let last = this.current;
          if (!last.$cstNode && action.feature && action.operator) {
            last = this.construct(false);
            const feature = last.$cstNode.feature;
            this.nodeBuilder.buildCompositeNode(feature);
          }
          const newItem = { $type };
          this.stack.pop();
          this.stack.push(newItem);
          if (action.feature && action.operator) {
            this.assign(action.operator, action.feature, last, last.$cstNode, false);
          }
        }
      }
      construct(pop = true) {
        if (this.isRecording()) {
          return void 0;
        }
        const obj = this.current;
        (0, ast_util_1.linkContentToContainer)(obj);
        this.nodeBuilder.construct(obj);
        if (pop) {
          this.stack.pop();
        }
        if (isDataTypeNode(obj)) {
          return this.converter.convert(obj.value, obj.$cstNode);
        } else {
          this.assignMandatoryProperties(obj);
        }
        return obj;
      }
      assignMandatoryProperties(obj) {
        const typeMetaData = this.astReflection.getTypeMetaData(obj.$type);
        for (const mandatoryProperty of typeMetaData.mandatory) {
          const value = obj[mandatoryProperty.name];
          if (mandatoryProperty.type === "array" && !Array.isArray(value)) {
            obj[mandatoryProperty.name] = [];
          } else if (mandatoryProperty.type === "boolean" && value === void 0) {
            obj[mandatoryProperty.name] = false;
          }
        }
      }
      getAssignment(feature) {
        if (!this.assignmentMap.has(feature)) {
          const assignment = (0, ast_util_1.getContainerOfType)(feature, ast_1.isAssignment);
          this.assignmentMap.set(feature, {
            assignment,
            isCrossRef: assignment ? (0, ast_1.isCrossReference)(assignment.terminal) : false
          });
        }
        return this.assignmentMap.get(feature);
      }
      assign(operator, feature, value, cstNode, isCrossRef) {
        const obj = this.current;
        let item;
        if (isCrossRef && typeof value === "string") {
          item = this.linker.buildReference(obj, feature, cstNode, value);
        } else {
          item = value;
        }
        switch (operator) {
          case "=": {
            obj[feature] = item;
            break;
          }
          case "?=": {
            obj[feature] = true;
            break;
          }
          case "+=": {
            if (!Array.isArray(obj[feature])) {
              obj[feature] = [];
            }
            obj[feature].push(item);
          }
        }
      }
      assignWithoutOverride(target, source) {
        for (const [name, existingValue] of Object.entries(source)) {
          const newValue = target[name];
          if (newValue === void 0) {
            target[name] = existingValue;
          } else if (Array.isArray(newValue) && Array.isArray(existingValue)) {
            existingValue.push(...newValue);
            target[name] = existingValue;
          }
        }
        return target;
      }
      get definitionErrors() {
        return this.wrapper.definitionErrors;
      }
    };
    exports2.LangiumParser = LangiumParser;
    var LangiumParserErrorMessageProvider = class {
      buildMismatchTokenMessage({ expected, actual }) {
        const expectedMsg = expected.LABEL ? "`" + expected.LABEL + "`" : expected.name.endsWith(":KW") ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'` : `token of type '${expected.name}'`;
        return `Expecting ${expectedMsg} but found \`${actual.image}\`.`;
      }
      buildNotAllInputParsedMessage({ firstRedundant }) {
        return `Expecting end of file but found \`${firstRedundant.image}\`.`;
      }
      buildNoViableAltMessage(options) {
        return chevrotain_1.defaultParserErrorProvider.buildNoViableAltMessage(options);
      }
      buildEarlyExitMessage(options) {
        return chevrotain_1.defaultParserErrorProvider.buildEarlyExitMessage(options);
      }
    };
    exports2.LangiumParserErrorMessageProvider = LangiumParserErrorMessageProvider;
    var LangiumCompletionParser = class extends AbstractLangiumParser {
      constructor() {
        super(...arguments);
        this.tokens = [];
        this.elementStack = [];
        this.lastElementStack = [];
        this.nextTokenIndex = 0;
        this.stackSize = 0;
      }
      action() {
      }
      construct() {
        return void 0;
      }
      parse(input) {
        this.resetState();
        const tokens = this.lexer.tokenize(input);
        this.tokens = tokens.tokens;
        this.wrapper.input = [...this.tokens];
        this.mainRule.call(this.wrapper, {});
        this.unorderedGroups.clear();
        return {
          tokens: this.tokens,
          elementStack: [...this.lastElementStack],
          tokenIndex: this.nextTokenIndex
        };
      }
      rule(rule, impl) {
        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));
        if (rule.entry) {
          this.mainRule = ruleMethod;
        }
        return ruleMethod;
      }
      resetState() {
        this.elementStack = [];
        this.lastElementStack = [];
        this.nextTokenIndex = 0;
        this.stackSize = 0;
      }
      startImplementation(implementation) {
        return (args) => {
          const size = this.keepStackSize();
          try {
            implementation(args);
          } finally {
            this.resetStackSize(size);
          }
        };
      }
      removeUnexpectedElements() {
        this.elementStack.splice(this.stackSize);
      }
      keepStackSize() {
        const size = this.elementStack.length;
        this.stackSize = size;
        return size;
      }
      resetStackSize(size) {
        this.removeUnexpectedElements();
        this.stackSize = size;
      }
      consume(idx, tokenType, feature) {
        this.wrapper.wrapConsume(idx, tokenType);
        if (!this.isRecording()) {
          this.lastElementStack = [...this.elementStack, feature];
          this.nextTokenIndex = this.currIdx + 1;
        }
      }
      subrule(idx, rule, feature, args) {
        this.before(feature);
        this.wrapper.wrapSubrule(idx, rule, args);
        this.after(feature);
      }
      before(element) {
        if (!this.isRecording()) {
          this.elementStack.push(element);
        }
      }
      after(element) {
        if (!this.isRecording()) {
          const index = this.elementStack.lastIndexOf(element);
          if (index >= 0) {
            this.elementStack.splice(index);
          }
        }
      }
      get currIdx() {
        return this.wrapper.currIdx;
      }
    };
    exports2.LangiumCompletionParser = LangiumCompletionParser;
    var defaultConfig = {
      recoveryEnabled: true,
      nodeLocationTracking: "full",
      skipValidations: true,
      errorMessageProvider: new LangiumParserErrorMessageProvider()
    };
    var ChevrotainWrapper = class extends chevrotain_1.EmbeddedActionsParser {
      constructor(tokens, config) {
        const useDefaultLookahead = config && "maxLookahead" in config;
        super(tokens, Object.assign(Object.assign(Object.assign({}, defaultConfig), { lookaheadStrategy: useDefaultLookahead ? new chevrotain_1.LLkLookaheadStrategy({ maxLookahead: config.maxLookahead }) : new chevrotain_allstar_1.LLStarLookaheadStrategy({
          logging: (message) => {
          }
        }) }), config));
      }
      get IS_RECORDING() {
        return this.RECORDING_PHASE;
      }
      DEFINE_RULE(name, impl) {
        return this.RULE(name, impl);
      }
      wrapSelfAnalysis() {
        this.performSelfAnalysis();
      }
      wrapConsume(idx, tokenType) {
        return this.consume(idx, tokenType);
      }
      wrapSubrule(idx, rule, args) {
        return this.subrule(idx, rule, {
          ARGS: [args]
        });
      }
      wrapOr(idx, choices) {
        this.or(idx, choices);
      }
      wrapOption(idx, callback) {
        this.option(idx, callback);
      }
      wrapMany(idx, callback) {
        this.many(idx, callback);
      }
      wrapAtLeastOne(idx, callback) {
        this.atLeastOne(idx, callback);
      }
    };
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/errors.js
var require_errors = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertUnreachable = exports2.ErrorWithLocation = void 0;
    var ErrorWithLocation = class extends Error {
      constructor(node, message) {
        super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);
      }
    };
    exports2.ErrorWithLocation = ErrorWithLocation;
    function assertUnreachable(_) {
      throw new Error("Error! The input value was not handled.");
    }
    exports2.assertUnreachable = assertUnreachable;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/parser-builder-base.js
var require_parser_builder_base = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/parser-builder-base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createParser = void 0;
    var chevrotain_1 = require_api7();
    var ast_1 = require_ast();
    var errors_1 = require_errors();
    var stream_1 = require_stream();
    var internal_grammar_util_1 = require_internal_grammar_util();
    var grammar_util_1 = require_grammar_util();
    function createParser(grammar, parser, tokens) {
      const rules = /* @__PURE__ */ new Map();
      const parserContext = {
        parser,
        tokens,
        rules,
        ruleNames: /* @__PURE__ */ new Map()
      };
      buildRules(parserContext, grammar);
      return parser;
    }
    exports2.createParser = createParser;
    function buildRules(parserContext, grammar) {
      const reachable = (0, grammar_util_1.getAllReachableRules)(grammar, false);
      const parserRules = (0, stream_1.stream)(grammar.rules).filter(ast_1.isParserRule).filter((rule) => reachable.has(rule));
      for (const rule of parserRules) {
        const ctx = Object.assign(Object.assign({}, parserContext), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });
        ctx.rules.set(rule.name, parserContext.parser.rule(rule, buildElement(ctx, rule.definition)));
      }
    }
    function buildElement(ctx, element, ignoreGuard = false) {
      let method;
      if ((0, ast_1.isKeyword)(element)) {
        method = buildKeyword(ctx, element);
      } else if ((0, ast_1.isAction)(element)) {
        method = buildAction(ctx, element);
      } else if ((0, ast_1.isAssignment)(element)) {
        method = buildElement(ctx, element.terminal);
      } else if ((0, ast_1.isCrossReference)(element)) {
        method = buildCrossReference(ctx, element);
      } else if ((0, ast_1.isRuleCall)(element)) {
        method = buildRuleCall(ctx, element);
      } else if ((0, ast_1.isAlternatives)(element)) {
        method = buildAlternatives(ctx, element);
      } else if ((0, ast_1.isUnorderedGroup)(element)) {
        method = buildUnorderedGroup(ctx, element);
      } else if ((0, ast_1.isGroup)(element)) {
        method = buildGroup(ctx, element);
      } else {
        throw new errors_1.ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);
      }
      return wrap(ctx, ignoreGuard ? void 0 : getGuardCondition(element), method, element.cardinality);
    }
    function buildAction(ctx, action) {
      const actionType = (0, internal_grammar_util_1.getTypeName)(action);
      return () => ctx.parser.action(actionType, action);
    }
    function buildRuleCall(ctx, ruleCall) {
      const rule = ruleCall.rule.ref;
      if ((0, ast_1.isParserRule)(rule)) {
        const idx = ctx.subrule++;
        const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});
        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), ruleCall, predicate(args));
      } else if ((0, ast_1.isTerminalRule)(rule)) {
        const idx = ctx.consume++;
        const method = getToken(ctx, rule.name);
        return () => ctx.parser.consume(idx, method, ruleCall);
      } else if (!rule) {
        throw new errors_1.ErrorWithLocation(ruleCall.$cstNode, `Undefined rule type: ${ruleCall.$type}`);
      } else {
        (0, errors_1.assertUnreachable)(rule);
      }
    }
    function buildRuleCallPredicate(rule, namedArgs) {
      const predicates = namedArgs.map((e) => buildPredicate(e.value));
      return (args) => {
        const ruleArgs = {};
        for (let i = 0; i < predicates.length; i++) {
          const ruleTarget = rule.parameters[i];
          const predicate = predicates[i];
          ruleArgs[ruleTarget.name] = predicate(args);
        }
        return ruleArgs;
      };
    }
    function buildPredicate(condition) {
      if ((0, ast_1.isDisjunction)(condition)) {
        const left = buildPredicate(condition.left);
        const right = buildPredicate(condition.right);
        return (args) => left(args) || right(args);
      } else if ((0, ast_1.isConjunction)(condition)) {
        const left = buildPredicate(condition.left);
        const right = buildPredicate(condition.right);
        return (args) => left(args) && right(args);
      } else if ((0, ast_1.isNegation)(condition)) {
        const value = buildPredicate(condition.value);
        return (args) => !value(args);
      } else if ((0, ast_1.isParameterReference)(condition)) {
        const name = condition.parameter.ref.name;
        return (args) => args !== void 0 && args[name] === true;
      } else if ((0, ast_1.isLiteralCondition)(condition)) {
        const value = Boolean(condition.true);
        return () => value;
      }
      (0, errors_1.assertUnreachable)(condition);
    }
    function buildAlternatives(ctx, alternatives) {
      if (alternatives.elements.length === 1) {
        return buildElement(ctx, alternatives.elements[0]);
      } else {
        const methods = [];
        for (const element of alternatives.elements) {
          const predicatedMethod = {
            // Since we handle the guard condition in the alternative already
            // We can ignore the group guard condition inside
            ALT: buildElement(ctx, element, true)
          };
          const guard = getGuardCondition(element);
          if (guard) {
            predicatedMethod.GATE = buildPredicate(guard);
          }
          methods.push(predicatedMethod);
        }
        const idx = ctx.or++;
        return (args) => ctx.parser.alternatives(idx, methods.map((method) => {
          const alt = {
            ALT: () => method.ALT(args)
          };
          const gate = method.GATE;
          if (gate) {
            alt.GATE = () => gate(args);
          }
          return alt;
        }));
      }
    }
    function buildUnorderedGroup(ctx, group) {
      if (group.elements.length === 1) {
        return buildElement(ctx, group.elements[0]);
      }
      const methods = [];
      for (const element of group.elements) {
        const predicatedMethod = {
          // Since we handle the guard condition in the alternative already
          // We can ignore the group guard condition inside
          ALT: buildElement(ctx, element, true)
        };
        const guard = getGuardCondition(element);
        if (guard) {
          predicatedMethod.GATE = buildPredicate(guard);
        }
        methods.push(predicatedMethod);
      }
      const orIdx = ctx.or++;
      const idFunc = (groupIdx, lParser) => {
        const stackId = lParser.getRuleStack().join("-");
        return `uGroup_${groupIdx}_${stackId}`;
      };
      const alternatives = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {
        const alt = { ALT: () => true };
        const parser = ctx.parser;
        alt.ALT = () => {
          method.ALT(args);
          if (!parser.isRecording()) {
            const key = idFunc(orIdx, parser);
            if (!parser.unorderedGroups.get(key)) {
              parser.unorderedGroups.set(key, []);
            }
            const groupState = parser.unorderedGroups.get(key);
            if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === "undefined") {
              groupState[idx] = true;
            }
          }
        };
        const gate = method.GATE;
        if (gate) {
          alt.GATE = () => gate(args);
        } else {
          alt.GATE = () => {
            const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));
            const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);
            return allow;
          };
        }
        return alt;
      }));
      const wrapped = wrap(ctx, getGuardCondition(group), alternatives, "*");
      return (args) => {
        wrapped(args);
        if (!ctx.parser.isRecording()) {
          ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));
        }
      };
    }
    function buildGroup(ctx, group) {
      const methods = group.elements.map((e) => buildElement(ctx, e));
      return (args) => methods.forEach((method) => method(args));
    }
    function getGuardCondition(element) {
      if ((0, ast_1.isGroup)(element)) {
        return element.guardCondition;
      }
      return void 0;
    }
    function buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {
      if (!terminal) {
        if (!crossRef.type.ref) {
          throw new Error("Could not resolve reference to type: " + crossRef.type.$refText);
        }
        const assignment = (0, grammar_util_1.findNameAssignment)(crossRef.type.ref);
        const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;
        if (!assignTerminal) {
          throw new Error("Could not find name assignment for type: " + (0, internal_grammar_util_1.getTypeName)(crossRef.type.ref));
        }
        return buildCrossReference(ctx, crossRef, assignTerminal);
      } else if ((0, ast_1.isRuleCall)(terminal) && (0, ast_1.isParserRule)(terminal.rule.ref)) {
        const idx = ctx.subrule++;
        return (args) => ctx.parser.subrule(idx, getRule(ctx, terminal.rule.ref), crossRef, args);
      } else if ((0, ast_1.isRuleCall)(terminal) && (0, ast_1.isTerminalRule)(terminal.rule.ref)) {
        const idx = ctx.consume++;
        const terminalRule = getToken(ctx, terminal.rule.ref.name);
        return () => ctx.parser.consume(idx, terminalRule, crossRef);
      } else if ((0, ast_1.isKeyword)(terminal)) {
        const idx = ctx.consume++;
        const keyword = getToken(ctx, terminal.value);
        return () => ctx.parser.consume(idx, keyword, crossRef);
      } else {
        throw new Error("Could not build cross reference parser");
      }
    }
    function buildKeyword(ctx, keyword) {
      const idx = ctx.consume++;
      const token = ctx.tokens[keyword.value];
      if (!token) {
        throw new Error("Could not find token for keyword: " + keyword.value);
      }
      return () => ctx.parser.consume(idx, token, keyword);
    }
    function wrap(ctx, guard, method, cardinality) {
      const gate = guard && buildPredicate(guard);
      if (!cardinality) {
        if (gate) {
          const idx = ctx.or++;
          return (args) => ctx.parser.alternatives(idx, [
            {
              ALT: () => method(args),
              GATE: () => gate(args)
            },
            {
              ALT: (0, chevrotain_1.EMPTY_ALT)(),
              GATE: () => !gate(args)
            }
          ]);
        } else {
          return method;
        }
      }
      if (cardinality === "*") {
        const idx = ctx.many++;
        return (args) => ctx.parser.many(idx, {
          DEF: () => method(args),
          GATE: gate ? () => gate(args) : void 0
        });
      } else if (cardinality === "+") {
        const idx = ctx.many++;
        if (gate) {
          const orIdx = ctx.or++;
          return (args) => ctx.parser.alternatives(orIdx, [
            {
              ALT: () => ctx.parser.atLeastOne(idx, {
                DEF: () => method(args)
              }),
              GATE: () => gate(args)
            },
            {
              ALT: (0, chevrotain_1.EMPTY_ALT)(),
              GATE: () => !gate(args)
            }
          ]);
        } else {
          return (args) => ctx.parser.atLeastOne(idx, {
            DEF: () => method(args)
          });
        }
      } else if (cardinality === "?") {
        const idx = ctx.optional++;
        return (args) => ctx.parser.optional(idx, {
          DEF: () => method(args),
          GATE: gate ? () => gate(args) : void 0
        });
      } else {
        (0, errors_1.assertUnreachable)(cardinality);
      }
    }
    function getRule(ctx, element) {
      const name = getRuleName(ctx, element);
      const rule = ctx.rules.get(name);
      if (!rule)
        throw new Error(`Rule "${name}" not found."`);
      return rule;
    }
    function getRuleName(ctx, element) {
      if ((0, ast_1.isParserRule)(element)) {
        return element.name;
      } else if (ctx.ruleNames.has(element)) {
        return ctx.ruleNames.get(element);
      } else {
        let item = element;
        let parent = item.$container;
        let ruleName = element.$type;
        while (!(0, ast_1.isParserRule)(parent)) {
          if ((0, ast_1.isGroup)(parent) || (0, ast_1.isAlternatives)(parent) || (0, ast_1.isUnorderedGroup)(parent)) {
            const index = parent.elements.indexOf(item);
            ruleName = index.toString() + ":" + ruleName;
          }
          item = parent;
          parent = parent.$container;
        }
        const rule = parent;
        ruleName = rule.name + ":" + ruleName;
        ctx.ruleNames.set(element, ruleName);
        return ruleName;
      }
    }
    function getToken(ctx, name) {
      const token = ctx.tokens[name];
      if (!token)
        throw new Error(`Token "${name}" not found."`);
      return token;
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/completion-parser-builder.js
var require_completion_parser_builder = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/completion-parser-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createCompletionParser = void 0;
    var langium_parser_1 = require_langium_parser();
    var parser_builder_base_1 = require_parser_builder_base();
    function createCompletionParser(services) {
      const grammar = services.Grammar;
      const lexer = services.parser.Lexer;
      const parser = new langium_parser_1.LangiumCompletionParser(services);
      (0, parser_builder_base_1.createParser)(grammar, parser, lexer.definition);
      parser.finalize();
      return parser;
    }
    exports2.createCompletionParser = createCompletionParser;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/langium-parser-builder.js
var require_langium_parser_builder = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/langium-parser-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareLangiumParser = exports2.createLangiumParser = void 0;
    var langium_parser_1 = require_langium_parser();
    var parser_builder_base_1 = require_parser_builder_base();
    function createLangiumParser(services) {
      const parser = prepareLangiumParser(services);
      parser.finalize();
      return parser;
    }
    exports2.createLangiumParser = createLangiumParser;
    function prepareLangiumParser(services) {
      const grammar = services.Grammar;
      const lexer = services.parser.Lexer;
      const parser = new langium_parser_1.LangiumParser(services);
      return (0, parser_builder_base_1.createParser)(grammar, parser, lexer.definition);
    }
    exports2.prepareLangiumParser = prepareLangiumParser;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/token-builder.js
var require_token_builder = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/token-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultTokenBuilder = void 0;
    var chevrotain_1 = require_api7();
    var ast_1 = require_ast();
    var internal_grammar_util_1 = require_internal_grammar_util();
    var ast_util_1 = require_ast_util();
    var grammar_util_1 = require_grammar_util();
    var regex_util_1 = require_regex_util();
    var stream_1 = require_stream();
    var DefaultTokenBuilder = class {
      buildTokens(grammar, options) {
        const reachableRules = (0, stream_1.stream)((0, grammar_util_1.getAllReachableRules)(grammar, false));
        const terminalTokens = this.buildTerminalTokens(reachableRules);
        const tokens = this.buildKeywordTokens(reachableRules, terminalTokens, options);
        terminalTokens.forEach((terminalToken) => {
          const pattern = terminalToken.PATTERN;
          if (typeof pattern === "object" && pattern && "test" in pattern && (0, regex_util_1.isWhitespaceRegExp)(pattern)) {
            tokens.unshift(terminalToken);
          } else {
            tokens.push(terminalToken);
          }
        });
        return tokens;
      }
      buildTerminalTokens(rules) {
        return rules.filter(ast_1.isTerminalRule).filter((e) => !e.fragment).map((terminal) => this.buildTerminalToken(terminal)).toArray();
      }
      buildTerminalToken(terminal) {
        const regex2 = (0, internal_grammar_util_1.terminalRegex)(terminal);
        const token = { name: terminal.name, PATTERN: new RegExp(regex2) };
        if (terminal.hidden) {
          token.GROUP = (0, regex_util_1.isWhitespaceRegExp)(regex2) ? chevrotain_1.Lexer.SKIPPED : "hidden";
        }
        return token;
      }
      buildKeywordTokens(rules, terminalTokens, options) {
        return rules.filter(ast_1.isParserRule).flatMap((rule) => (0, ast_util_1.streamAllContents)(rule).filter(ast_1.isKeyword)).distinct((e) => e.value).toArray().sort((a, b) => b.value.length - a.value.length).map((keyword) => this.buildKeywordToken(keyword, terminalTokens, Boolean(options === null || options === void 0 ? void 0 : options.caseInsensitive)));
      }
      buildKeywordToken(keyword, terminalTokens, caseInsensitive) {
        return {
          name: keyword.value,
          PATTERN: this.buildKeywordPattern(keyword, caseInsensitive),
          LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)
        };
      }
      buildKeywordPattern(keyword, caseInsensitive) {
        return caseInsensitive ? new RegExp((0, regex_util_1.getCaseInsensitivePattern)(keyword.value)) : keyword.value;
      }
      findLongerAlt(keyword, terminalTokens) {
        return terminalTokens.reduce((longerAlts, token) => {
          const pattern = token === null || token === void 0 ? void 0 : token.PATTERN;
          if ((pattern === null || pattern === void 0 ? void 0 : pattern.source) && (0, regex_util_1.partialMatches)("^" + pattern.source + "$", keyword.value)) {
            longerAlts.push(token);
          }
          return longerAlts;
        }, []);
      }
    };
    exports2.DefaultTokenBuilder = DefaultTokenBuilder;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/value-converter.js
var require_value_converter = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/value-converter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertBoolean = exports2.convertNumber = exports2.convertDate = exports2.convertBigint = exports2.convertInt = exports2.convertID = exports2.convertRegexLiteral = exports2.convertString = exports2.DefaultValueConverter = void 0;
    var ast_1 = require_ast();
    var internal_grammar_util_1 = require_internal_grammar_util();
    var grammar_util_1 = require_grammar_util();
    var DefaultValueConverter = class {
      convert(input, cstNode) {
        let feature = cstNode.feature;
        if ((0, ast_1.isCrossReference)(feature)) {
          feature = (0, grammar_util_1.getCrossReferenceTerminal)(feature);
        }
        if ((0, ast_1.isRuleCall)(feature)) {
          const rule = feature.rule.ref;
          if (!rule) {
            throw new Error("This cst node was not parsed by a rule.");
          }
          return this.runConverter(rule, input, cstNode);
        }
        return input;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      runConverter(rule, input, cstNode) {
        var _a;
        switch (rule.name.toUpperCase()) {
          case "INT":
            return convertInt(input);
          case "STRING":
            return convertString(input);
          case "ID":
            return convertID(input);
          case "REGEXLITERAL":
            return convertRegexLiteral(input);
        }
        switch ((_a = (0, internal_grammar_util_1.getRuleType)(rule)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) {
          case "number":
            return convertNumber(input);
          case "boolean":
            return convertBoolean(input);
          case "bigint":
            return convertBigint(input);
          case "date":
            return convertDate(input);
          default:
            return input;
        }
      }
    };
    exports2.DefaultValueConverter = DefaultValueConverter;
    function convertString(input) {
      let result = "";
      for (let i = 1; i < input.length - 1; i++) {
        const c = input.charAt(i);
        if (c === "\\") {
          const c1 = input.charAt(++i);
          result += convertEscapeCharacter(c1);
        } else {
          result += c;
        }
      }
      return result;
    }
    exports2.convertString = convertString;
    function convertEscapeCharacter(char) {
      switch (char) {
        case "b":
          return "\b";
        case "f":
          return "\f";
        case "n":
          return "\n";
        case "r":
          return "\r";
        case "t":
          return "	";
        case "v":
          return "\v";
        case "0":
          return "\0";
        default:
          return char;
      }
    }
    function convertRegexLiteral(input) {
      return input.substring(1, input.length - 1);
    }
    exports2.convertRegexLiteral = convertRegexLiteral;
    function convertID(input) {
      if (input.charAt(0) === "^") {
        return input.substring(1);
      } else {
        return input;
      }
    }
    exports2.convertID = convertID;
    function convertInt(input) {
      return parseInt(input);
    }
    exports2.convertInt = convertInt;
    function convertBigint(input) {
      return BigInt(input);
    }
    exports2.convertBigint = convertBigint;
    function convertDate(input) {
      return new Date(input);
    }
    exports2.convertDate = convertDate;
    function convertNumber(input) {
      return Number(input);
    }
    exports2.convertNumber = convertNumber;
    function convertBoolean(input) {
      return input.toLowerCase() === "true";
    }
    exports2.convertBoolean = convertBoolean;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/references/linker.js
var require_linker = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/references/linker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultLinker = void 0;
    var vscode_languageserver_1 = require_main4();
    var syntax_tree_1 = require_syntax_tree();
    var ast_util_1 = require_ast_util();
    var promise_util_1 = require_promise_util();
    var documents_1 = require_documents();
    var DefaultLinker = class {
      constructor(services) {
        this.reflection = services.shared.AstReflection;
        this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;
        this.scopeProvider = services.references.ScopeProvider;
        this.astNodeLocator = services.workspace.AstNodeLocator;
      }
      async link(document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        for (const node of (0, ast_util_1.streamAst)(document.parseResult.value)) {
          await (0, promise_util_1.interruptAndCheck)(cancelToken);
          (0, ast_util_1.streamReferences)(node).forEach((ref) => this.doLink(ref, document));
        }
        document.state = documents_1.DocumentState.Linked;
      }
      doLink(refInfo, document) {
        const ref = refInfo.reference;
        if (ref._ref === void 0) {
          try {
            const description = this.getCandidate(refInfo);
            if ((0, syntax_tree_1.isLinkingError)(description)) {
              ref._ref = description;
            } else {
              ref._nodeDescription = description;
              if (this.langiumDocuments().hasDocument(description.documentUri)) {
                const linkedNode = this.loadAstNode(description);
                ref._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);
              }
            }
          } catch (err) {
            ref._ref = Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${ref.$refText}': ${err}` });
          }
        }
        document.references.push(ref);
      }
      unlink(document) {
        for (const ref of document.references) {
          delete ref._ref;
          delete ref._nodeDescription;
        }
        document.references = [];
      }
      getCandidate(refInfo) {
        const scope = this.scopeProvider.getScope(refInfo);
        const description = scope.getElement(refInfo.reference.$refText);
        return description !== null && description !== void 0 ? description : this.createLinkingError(refInfo);
      }
      buildReference(node, property, refNode, refText) {
        const linker = this;
        const reference = {
          $refNode: refNode,
          $refText: refText,
          get ref() {
            var _a;
            if ((0, syntax_tree_1.isAstNode)(this._ref)) {
              return this._ref;
            } else if ((0, syntax_tree_1.isAstNodeDescription)(this._nodeDescription)) {
              const linkedNode = linker.loadAstNode(this._nodeDescription);
              this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);
            } else if (this._ref === void 0) {
              const refData = linker.getLinkedNode({ reference, container: node, property });
              if (refData.error && (0, ast_util_1.getDocument)(node).state < documents_1.DocumentState.ComputedScopes) {
                return void 0;
              }
              this._ref = (_a = refData.node) !== null && _a !== void 0 ? _a : refData.error;
              this._nodeDescription = refData.descr;
            }
            return (0, syntax_tree_1.isAstNode)(this._ref) ? this._ref : void 0;
          },
          get $nodeDescription() {
            return this._nodeDescription;
          },
          get error() {
            return (0, syntax_tree_1.isLinkingError)(this._ref) ? this._ref : void 0;
          }
        };
        return reference;
      }
      getLinkedNode(refInfo) {
        try {
          const description = this.getCandidate(refInfo);
          if ((0, syntax_tree_1.isLinkingError)(description)) {
            return { error: description };
          }
          const linkedNode = this.loadAstNode(description);
          if (linkedNode) {
            return { node: linkedNode, descr: description };
          } else {
            return {
              descr: description,
              error: this.createLinkingError(refInfo, description)
            };
          }
        } catch (err) {
          return {
            error: Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${err}` })
          };
        }
      }
      loadAstNode(nodeDescription) {
        if (nodeDescription.node) {
          return nodeDescription.node;
        }
        const doc = this.langiumDocuments().getOrCreateDocument(nodeDescription.documentUri);
        return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);
      }
      createLinkingError(refInfo, targetDescription) {
        const document = (0, ast_util_1.getDocument)(refInfo.container);
        if (document.state < documents_1.DocumentState.ComputedScopes) {
          console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);
        }
        const referenceType = this.reflection.getReferenceType(refInfo);
        return Object.assign(Object.assign({}, refInfo), { message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`, targetDescription });
      }
    };
    exports2.DefaultLinker = DefaultLinker;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/serializer/json-serializer.js
var require_json_serializer = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/serializer/json-serializer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultJsonSerializer = void 0;
    var syntax_tree_1 = require_syntax_tree();
    var ast_util_1 = require_ast_util();
    var grammar_util_1 = require_grammar_util();
    function isIntermediateReference(obj) {
      return typeof obj === "object" && !!obj && ("$ref" in obj || "$error" in obj);
    }
    var DefaultJsonSerializer = class {
      constructor(services) {
        this.ignoreProperties = /* @__PURE__ */ new Set(["$container", "$containerProperty", "$containerIndex", "$document", "$cstNode"]);
        this.astNodeLocator = services.workspace.AstNodeLocator;
        this.nameProvider = services.references.NameProvider;
      }
      serialize(node, options) {
        const specificReplacer = options === null || options === void 0 ? void 0 : options.replacer;
        const defaultReplacer = (key, value) => this.replacer(key, value, options);
        const replacer = specificReplacer ? (key, value) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;
        return JSON.stringify(node, replacer, options === null || options === void 0 ? void 0 : options.space);
      }
      deserialize(content) {
        const root = JSON.parse(content);
        this.linkNode(root, root);
        return root;
      }
      replacer(key, value, { refText, sourceText, textRegions } = {}) {
        var _a, _b, _c;
        if (this.ignoreProperties.has(key)) {
          return void 0;
        } else if ((0, syntax_tree_1.isReference)(value)) {
          const refValue = value.ref;
          const $refText = refText ? value.$refText : void 0;
          if (refValue) {
            return {
              $refText,
              $ref: "#" + (refValue && this.astNodeLocator.getAstNodePath(refValue))
            };
          } else {
            return {
              $refText,
              $error: (_b = (_a = value.error) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : "Could not resolve reference"
            };
          }
        } else {
          let astNode = void 0;
          if (textRegions && (0, syntax_tree_1.isAstNode)(value)) {
            astNode = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, value));
            if ((!key || value.$document) && (astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion)) {
              try {
                astNode.$textRegion.documentURI = (0, ast_util_1.getDocument)(value).uri.toString();
              } catch (e) {
              }
            }
          }
          if (sourceText && !key && (0, syntax_tree_1.isAstNode)(value)) {
            astNode !== null && astNode !== void 0 ? astNode : astNode = Object.assign({}, value);
            astNode.$sourceText = (_c = value.$cstNode) === null || _c === void 0 ? void 0 : _c.text;
          }
          return astNode !== null && astNode !== void 0 ? astNode : value;
        }
      }
      addAstNodeRegionWithAssignmentsTo(node) {
        const createDocumentSegment = (cstNode) => ({
          offset: cstNode.offset,
          end: cstNode.end,
          length: cstNode.length,
          range: cstNode.range
        });
        if (node.$cstNode) {
          const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);
          const assignments = textRegion.assignments = {};
          Object.keys(node).filter((key) => !key.startsWith("$")).forEach((key) => {
            const propertyAssignments = (0, grammar_util_1.findNodesForProperty)(node.$cstNode, key).map(createDocumentSegment);
            if (propertyAssignments.length !== 0) {
              assignments[key] = propertyAssignments;
            }
          });
          return node;
        }
        return void 0;
      }
      linkNode(node, root, container, containerProperty, containerIndex) {
        for (const [propertyName, item] of Object.entries(node)) {
          if (Array.isArray(item)) {
            for (let index = 0; index < item.length; index++) {
              const element = item[index];
              if (isIntermediateReference(element)) {
                item[index] = this.reviveReference(node, propertyName, root, element);
              } else if ((0, syntax_tree_1.isAstNode)(element)) {
                this.linkNode(element, root, node, propertyName, index);
              }
            }
          } else if (isIntermediateReference(item)) {
            node[propertyName] = this.reviveReference(node, propertyName, root, item);
          } else if ((0, syntax_tree_1.isAstNode)(item)) {
            this.linkNode(item, root, node, propertyName);
          }
        }
        const mutable = node;
        mutable.$container = container;
        mutable.$containerProperty = containerProperty;
        mutable.$containerIndex = containerIndex;
      }
      reviveReference(container, property, root, reference) {
        let refText = reference.$refText;
        if (reference.$ref) {
          const ref = this.getRefNode(root, reference.$ref);
          if (!refText) {
            refText = this.nameProvider.getName(ref);
          }
          return {
            $refText: refText !== null && refText !== void 0 ? refText : "",
            ref
          };
        } else if (reference.$error) {
          const ref = {
            $refText: refText !== null && refText !== void 0 ? refText : ""
          };
          ref.error = {
            container,
            property,
            message: reference.$error,
            reference: ref
          };
          return ref;
        } else {
          return void 0;
        }
      }
      getRefNode(root, path2) {
        return this.astNodeLocator.getAstNode(root, path2.substring(1));
      }
    };
    exports2.DefaultJsonSerializer = DefaultJsonSerializer;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/service-registry.js
var require_service_registry = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/service-registry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultServiceRegistry = void 0;
    var vscode_uri_1 = require_umd();
    var DefaultServiceRegistry = class {
      register(language) {
        if (!this.singleton && !this.map) {
          this.singleton = language;
          return;
        }
        if (!this.map) {
          this.map = {};
          if (this.singleton) {
            for (const ext of this.singleton.LanguageMetaData.fileExtensions) {
              this.map[ext] = this.singleton;
            }
            this.singleton = void 0;
          }
        }
        for (const ext of language.LanguageMetaData.fileExtensions) {
          if (this.map[ext] !== void 0 && this.map[ext] !== language) {
            console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${language.LanguageMetaData.languageId}'.`);
          }
          this.map[ext] = language;
        }
      }
      getServices(uri) {
        if (this.singleton !== void 0) {
          return this.singleton;
        }
        if (this.map === void 0) {
          throw new Error("The service registry is empty. Use `register` to register the services of a language.");
        }
        const ext = vscode_uri_1.Utils.extname(uri);
        const services = this.map[ext];
        if (!services) {
          throw new Error(`The service registry contains no services for the extension '${ext}'.`);
        }
        return services;
      }
      get all() {
        if (this.singleton !== void 0) {
          return [this.singleton];
        }
        if (this.map !== void 0) {
          return Object.values(this.map);
        }
        return [];
      }
    };
    exports2.DefaultServiceRegistry = DefaultServiceRegistry;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/validation/validation-registry.js
var require_validation_registry = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/validation/validation-registry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidationRegistry = void 0;
    var collections_1 = require_collections();
    var promise_util_1 = require_promise_util();
    var ValidationRegistry = class {
      constructor(services) {
        this.validationChecks = new collections_1.MultiMap();
        this.reflection = services.shared.AstReflection;
      }
      register(checksRecord, thisObj = this) {
        for (const [type, ch] of Object.entries(checksRecord)) {
          const callbacks = ch;
          if (Array.isArray(callbacks)) {
            for (const check of callbacks) {
              this.doRegister(type, this.wrapValidationException(check, thisObj));
            }
          } else if (typeof callbacks === "function") {
            this.doRegister(type, this.wrapValidationException(callbacks, thisObj));
          }
        }
      }
      wrapValidationException(check, thisObj) {
        return async (node, accept, cancelToken) => {
          try {
            await check.call(thisObj, node, accept, cancelToken);
          } catch (err) {
            if ((0, promise_util_1.isOperationCancelled)(err)) {
              throw err;
            }
            console.error("An error occurred during validation:", err);
            const message = err instanceof Error ? err.message : String(err);
            if (err instanceof Error && err.stack) {
              console.error(err.stack);
            }
            accept("error", "An error occurred during validation: " + message, { node });
          }
        };
      }
      doRegister(type, check) {
        if (type === "AstNode") {
          this.validationChecks.add("AstNode", check);
          return;
        }
        for (const subtype of this.reflection.getAllSubTypes(type)) {
          this.validationChecks.add(subtype, check);
        }
      }
      getChecks(type) {
        return this.validationChecks.get(type).concat(this.validationChecks.get("AstNode"));
      }
    };
    exports2.ValidationRegistry = ValidationRegistry;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/ast-descriptions.js
var require_ast_descriptions = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/ast-descriptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultReferenceDescriptionProvider = exports2.DefaultAstNodeDescriptionProvider = void 0;
    var vscode_languageserver_1 = require_main4();
    var syntax_tree_1 = require_syntax_tree();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var promise_util_1 = require_promise_util();
    var uri_util_1 = require_uri_util();
    var DefaultAstNodeDescriptionProvider = class {
      constructor(services) {
        this.astNodeLocator = services.workspace.AstNodeLocator;
        this.nameProvider = services.references.NameProvider;
      }
      createDescription(node, name, document = (0, ast_util_1.getDocument)(node)) {
        var _a;
        name !== null && name !== void 0 ? name : name = this.nameProvider.getName(node);
        const path2 = this.astNodeLocator.getAstNodePath(node);
        if (!name) {
          throw new Error(`Node at path ${path2} has no name.`);
        }
        const nameNode = (_a = this.nameProvider.getNameNode(node)) !== null && _a !== void 0 ? _a : node.$cstNode;
        return {
          node,
          name,
          nameSegment: (0, cst_util_1.toDocumentSegment)(nameNode),
          selectionSegment: (0, cst_util_1.toDocumentSegment)(node.$cstNode),
          type: node.$type,
          documentUri: document.uri,
          path: path2
        };
      }
    };
    exports2.DefaultAstNodeDescriptionProvider = DefaultAstNodeDescriptionProvider;
    var DefaultReferenceDescriptionProvider = class {
      constructor(services) {
        this.nodeLocator = services.workspace.AstNodeLocator;
      }
      async createDescriptions(document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const descr = [];
        const rootNode = document.parseResult.value;
        for (const astNode of (0, ast_util_1.streamAst)(rootNode)) {
          await (0, promise_util_1.interruptAndCheck)(cancelToken);
          (0, ast_util_1.streamReferences)(astNode).filter((refInfo) => !(0, syntax_tree_1.isLinkingError)(refInfo)).forEach((refInfo) => {
            const description = this.createDescription(refInfo);
            if (description) {
              descr.push(description);
            }
          });
        }
        return descr;
      }
      createDescription(refInfo) {
        const targetNodeDescr = refInfo.reference.$nodeDescription;
        const refCstNode = refInfo.reference.$refNode;
        if (!targetNodeDescr || !refCstNode) {
          return void 0;
        }
        const docUri = (0, ast_util_1.getDocument)(refInfo.container).uri;
        return {
          sourceUri: docUri,
          sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),
          targetUri: targetNodeDescr.documentUri,
          targetPath: targetNodeDescr.path,
          segment: (0, cst_util_1.toDocumentSegment)(refCstNode),
          local: (0, uri_util_1.equalURI)(targetNodeDescr.documentUri, docUri)
        };
      }
    };
    exports2.DefaultReferenceDescriptionProvider = DefaultReferenceDescriptionProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/ast-node-locator.js
var require_ast_node_locator = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/ast-node-locator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultAstNodeLocator = void 0;
    var DefaultAstNodeLocator = class {
      constructor() {
        this.segmentSeparator = "/";
        this.indexSeparator = "@";
      }
      getAstNodePath(node) {
        if (node.$container) {
          const containerPath = this.getAstNodePath(node.$container);
          const newSegment = this.getPathSegment(node);
          const nodePath = containerPath + this.segmentSeparator + newSegment;
          return nodePath;
        }
        return "";
      }
      getPathSegment({ $containerProperty, $containerIndex }) {
        if (!$containerProperty) {
          throw new Error("Missing '$containerProperty' in AST node.");
        }
        if ($containerIndex !== void 0) {
          return $containerProperty + this.indexSeparator + $containerIndex;
        }
        return $containerProperty;
      }
      getAstNode(node, path2) {
        const segments = path2.split(this.segmentSeparator);
        return segments.reduce((previousValue, currentValue) => {
          if (!previousValue || currentValue.length === 0) {
            return previousValue;
          }
          const propertyIndex = currentValue.indexOf(this.indexSeparator);
          if (propertyIndex > 0) {
            const property = currentValue.substring(0, propertyIndex);
            const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));
            const array = previousValue[property];
            return array === null || array === void 0 ? void 0 : array[arrayIndex];
          }
          return previousValue[currentValue];
        }, node);
      }
    };
    exports2.DefaultAstNodeLocator = DefaultAstNodeLocator;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/configuration.js
var require_configuration2 = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultConfigurationProvider = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var DefaultConfigurationProvider = class {
      constructor(services) {
        this.settings = {};
        this.workspaceConfig = false;
        this.initialized = false;
        this.serviceRegistry = services.ServiceRegistry;
        this.connection = services.lsp.Connection;
        services.lsp.LanguageServer.onInitialize((params) => {
          var _a, _b;
          this.workspaceConfig = (_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration) !== null && _b !== void 0 ? _b : false;
        });
        services.lsp.LanguageServer.onInitialized((_params) => {
          var _a;
          const languages = this.serviceRegistry.all;
          (_a = services.lsp.Connection) === null || _a === void 0 ? void 0 : _a.client.register(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, {
            // Listen to configuration changes for all languages
            section: languages.map((lang) => this.toSectionName(lang.LanguageMetaData.languageId))
          });
        });
      }
      async initialize() {
        if (this.workspaceConfig && this.connection) {
          const languages = this.serviceRegistry.all;
          const configToUpdate = languages.map((lang) => {
            return { section: this.toSectionName(lang.LanguageMetaData.languageId) };
          });
          const configs = await this.connection.workspace.getConfiguration(configToUpdate);
          configToUpdate.forEach((conf, idx) => {
            this.updateSectionConfiguration(conf.section, configs[idx]);
          });
        }
        this.initialized = true;
      }
      updateConfiguration(change) {
        if (!change.settings) {
          return;
        }
        Object.keys(change.settings).forEach((section) => {
          this.updateSectionConfiguration(section, change.settings[section]);
        });
      }
      updateSectionConfiguration(section, configuration) {
        this.settings[section] = configuration;
      }
      async getConfiguration(language, configuration) {
        if (!this.initialized) {
          await this.initialize();
        }
        const sectionName = this.toSectionName(language);
        if (this.settings[sectionName]) {
          return this.settings[sectionName][configuration];
        }
      }
      toSectionName(languageId) {
        return `${languageId}`;
      }
    };
    exports2.DefaultConfigurationProvider = DefaultConfigurationProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/document-builder.js
var require_document_builder = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/document-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultDocumentBuilder = void 0;
    var vscode_languageserver_1 = require_main4();
    var collections_1 = require_collections();
    var promise_util_1 = require_promise_util();
    var documents_1 = require_documents();
    var DefaultDocumentBuilder = class {
      constructor(services) {
        this.updateListeners = [];
        this.buildPhaseListeners = new collections_1.MultiMap();
        this.langiumDocuments = services.workspace.LangiumDocuments;
        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;
        this.indexManager = services.workspace.IndexManager;
        this.serviceRegistry = services.ServiceRegistry;
      }
      async build(documents, options = {}, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        await this.buildDocuments(documents, options, cancelToken);
      }
      async update(changed, deleted, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        for (const deletedDocument of deleted) {
          this.langiumDocuments.deleteDocument(deletedDocument);
        }
        this.indexManager.remove(deleted);
        for (const changedUri of changed) {
          this.langiumDocuments.invalidateDocument(changedUri);
        }
        for (const listener of this.updateListeners) {
          listener(changed, deleted);
        }
        await (0, promise_util_1.interruptAndCheck)(cancelToken);
        const changedDocuments = changed.map((e) => this.langiumDocuments.getOrCreateDocument(e));
        const rebuildDocuments = this.collectDocuments(changedDocuments, deleted);
        const buildOptions = {
          // This method is meant to be called after receiving a change notification from the client,
          // so we assume that we want diagnostics to be reported in the editor.
          validationChecks: "all"
        };
        await this.buildDocuments(rebuildDocuments, buildOptions, cancelToken);
      }
      onUpdate(callback) {
        this.updateListeners.push(callback);
        return vscode_languageserver_1.Disposable.create(() => {
          const index = this.updateListeners.indexOf(callback);
          if (index >= 0) {
            this.updateListeners.splice(index, 1);
          }
        });
      }
      collectDocuments(changed, deleted) {
        const allUris = changed.map((e) => e.uri).concat(deleted);
        const affected = this.indexManager.getAffectedDocuments(allUris).toArray();
        affected.forEach((e) => {
          const linker = this.serviceRegistry.getServices(e.uri).references.Linker;
          linker.unlink(e);
          e.state = Math.min(e.state, documents_1.DocumentState.ComputedScopes);
        });
        const docSet = /* @__PURE__ */ new Set([
          ...changed,
          ...affected,
          // Also include all documents haven't completed the document lifecycle yet
          ...this.langiumDocuments.all.filter((e) => e.state < documents_1.DocumentState.Validated)
        ]);
        return Array.from(docSet);
      }
      async buildDocuments(documents, options, cancelToken) {
        await this.runCancelable(documents, documents_1.DocumentState.Parsed, cancelToken, (doc) => this.langiumDocumentFactory.update(doc));
        await this.runCancelable(documents, documents_1.DocumentState.IndexedContent, cancelToken, (doc) => this.indexManager.updateContent(doc, cancelToken));
        await this.runCancelable(documents, documents_1.DocumentState.ComputedScopes, cancelToken, (doc) => this.computeScopes(doc, cancelToken));
        await this.runCancelable(documents, documents_1.DocumentState.Linked, cancelToken, (doc) => this.serviceRegistry.getServices(doc.uri).references.Linker.link(doc, cancelToken));
        await this.runCancelable(documents, documents_1.DocumentState.IndexedReferences, cancelToken, (doc) => this.indexManager.updateReferences(doc, cancelToken));
        const validateDocs = documents.filter((doc) => this.shouldValidate(doc, options));
        await this.runCancelable(validateDocs, documents_1.DocumentState.Validated, cancelToken, (doc) => this.validate(doc, cancelToken));
      }
      async runCancelable(documents, targetState, cancelToken, callback) {
        const filtered = documents.filter((e) => e.state < targetState);
        for (const document of filtered) {
          await (0, promise_util_1.interruptAndCheck)(cancelToken);
          await callback(document);
        }
        await this.notifyBuildPhase(filtered, targetState, cancelToken);
      }
      onBuildPhase(targetState, callback) {
        this.buildPhaseListeners.add(targetState, callback);
        return vscode_languageserver_1.Disposable.create(() => {
          this.buildPhaseListeners.delete(targetState, callback);
        });
      }
      async notifyBuildPhase(documents, state, cancelToken) {
        if (documents.length === 0) {
          return;
        }
        const listeners = this.buildPhaseListeners.get(state);
        for (const listener of listeners) {
          await (0, promise_util_1.interruptAndCheck)(cancelToken);
          await listener(documents, cancelToken);
        }
      }
      /**
       * Precompute the local scopes of the given document. The resulting data structure is used by
       * the `ScopeProvider` service to determine the visible scope of any cross-reference.
       *
       * _Note:_ You should not resolve any cross-references during this phase. Once the phase is completed,
       * you may follow the `ref` property of a reference, which triggers lazy resolution. The result is
       * either the respective target AST node or `undefined` in case the target is not in scope.
       */
      async computeScopes(document, cancelToken) {
        const scopeComputation = this.serviceRegistry.getServices(document.uri).references.ScopeComputation;
        document.precomputedScopes = await scopeComputation.computeLocalScopes(document, cancelToken);
        document.state = documents_1.DocumentState.ComputedScopes;
      }
      /**
       * Determine whether the given document should be validated during a build. The default
       * implementation checks the `validationChecks` property of the build options.
       */
      shouldValidate(_document, options) {
        return options.validationChecks === "all";
      }
      /**
       * Run validation checks on the given document and store the resulting diagnostics in the document.
       */
      async validate(document, cancelToken) {
        const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;
        const diagnostics = await validator.validateDocument(document, cancelToken);
        document.diagnostics = diagnostics;
        document.state = documents_1.DocumentState.Validated;
      }
    };
    exports2.DefaultDocumentBuilder = DefaultDocumentBuilder;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/index-manager.js
var require_index_manager = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/index-manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultIndexManager = void 0;
    var vscode_languageserver_1 = require_main4();
    var ast_util_1 = require_ast_util();
    var stream_1 = require_stream();
    var uri_util_1 = require_uri_util();
    var documents_1 = require_documents();
    var DefaultIndexManager = class {
      constructor(services) {
        this.simpleIndex = /* @__PURE__ */ new Map();
        this.referenceIndex = /* @__PURE__ */ new Map();
        this.globalScopeCache = /* @__PURE__ */ new Map();
        this.serviceRegistry = services.ServiceRegistry;
        this.astReflection = services.AstReflection;
        this.langiumDocuments = () => services.workspace.LangiumDocuments;
      }
      findAllReferences(targetNode, astNodePath) {
        const targetDocUri = (0, ast_util_1.getDocument)(targetNode).uri;
        const result = [];
        this.referenceIndex.forEach((docRefs) => {
          docRefs.forEach((refDescr) => {
            if ((0, uri_util_1.equalURI)(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {
              result.push(refDescr);
            }
          });
        });
        return (0, stream_1.stream)(result);
      }
      allElements(nodeType = "") {
        if (!this.globalScopeCache.has("")) {
          this.globalScopeCache.set("", Array.from(this.simpleIndex.values()).flat());
        }
        const cached = this.globalScopeCache.get(nodeType);
        if (cached) {
          return (0, stream_1.stream)(cached);
        } else {
          const elements = this.globalScopeCache.get("").filter((e) => this.astReflection.isSubtype(e.type, nodeType));
          this.globalScopeCache.set(nodeType, elements);
          return (0, stream_1.stream)(elements);
        }
      }
      remove(uris) {
        for (const uri of uris) {
          const uriString = uri.toString();
          this.simpleIndex.delete(uriString);
          this.referenceIndex.delete(uriString);
          this.globalScopeCache.clear();
        }
      }
      async updateContent(document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        this.globalScopeCache.clear();
        const services = this.serviceRegistry.getServices(document.uri);
        const exports3 = await services.references.ScopeComputation.computeExports(document, cancelToken);
        for (const data of exports3) {
          data.node = void 0;
        }
        this.simpleIndex.set(document.uri.toString(), exports3);
        document.state = documents_1.DocumentState.IndexedContent;
      }
      async updateReferences(document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const services = this.serviceRegistry.getServices(document.uri);
        const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);
        this.referenceIndex.set(document.uri.toString(), indexData);
        document.state = documents_1.DocumentState.IndexedReferences;
      }
      getAffectedDocuments(uris) {
        return this.langiumDocuments().all.filter((e) => {
          if (uris.some((uri) => (0, uri_util_1.equalURI)(e.uri, uri))) {
            return false;
          }
          for (const uri of uris) {
            if (this.isAffected(e, uri)) {
              return true;
            }
          }
          return false;
        });
      }
      /**
       * Determine whether the given document could be affected by a change of the document
       * identified by the given URI (second parameter).
       */
      isAffected(document, changed) {
        const changedUriString = changed.toString();
        const documentUri = document.uri.toString();
        if (document.references.some((e) => e.error !== void 0)) {
          return true;
        }
        const references = this.referenceIndex.get(documentUri);
        if (references) {
          return references.filter((e) => !e.local).some((e) => (0, uri_util_1.equalURI)(e.targetUri, changedUriString));
        }
        return false;
      }
    };
    exports2.DefaultIndexManager = DefaultIndexManager;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/workspace-manager.js
var require_workspace_manager = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/workspace-manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultWorkspaceManager = void 0;
    var vscode_languageserver_1 = require_main4();
    var vscode_uri_1 = require_umd();
    var promise_util_1 = require_promise_util();
    var DefaultWorkspaceManager = class {
      constructor(services) {
        this.serviceRegistry = services.ServiceRegistry;
        this.langiumDocuments = services.workspace.LangiumDocuments;
        this.documentBuilder = services.workspace.DocumentBuilder;
        this.fileSystemProvider = services.workspace.FileSystemProvider;
        this.mutex = services.workspace.MutexLock;
        services.lsp.LanguageServer.onInitialize((params) => {
          var _a;
          this.folders = (_a = params.workspaceFolders) !== null && _a !== void 0 ? _a : void 0;
        });
        services.lsp.LanguageServer.onInitialized((_params) => {
          this.mutex.lock((token) => {
            var _a;
            return this.initializeWorkspace((_a = this.folders) !== null && _a !== void 0 ? _a : [], token);
          });
        });
      }
      async initializeWorkspace(folders, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const fileExtensions = this.serviceRegistry.all.flatMap((e) => e.LanguageMetaData.fileExtensions);
        const documents = [];
        const collector = (document) => {
          documents.push(document);
          if (!this.langiumDocuments.hasDocument(document.uri)) {
            this.langiumDocuments.addDocument(document);
          }
        };
        await this.loadAdditionalDocuments(folders, collector);
        await Promise.all(folders.map((wf) => [wf, this.getRootFolder(wf)]).map(async (entry) => this.traverseFolder(...entry, fileExtensions, collector)));
        await (0, promise_util_1.interruptAndCheck)(cancelToken);
        await this.documentBuilder.build(documents, void 0, cancelToken);
      }
      /**
       * Load all additional documents that shall be visible in the context of the given workspace
       * folders and add them to the collector. This can be used to include built-in libraries of
       * your language, which can be either loaded from provided files or constructed in memory.
       */
      loadAdditionalDocuments(_folders, _collector) {
        return Promise.resolve();
      }
      /**
       * Determine the root folder of the source documents in the given workspace folder.
       * The default implementation returns the URI of the workspace folder, but you can override
       * this to return a subfolder like `src` instead.
       */
      getRootFolder(workspaceFolder) {
        return vscode_uri_1.URI.parse(workspaceFolder.uri);
      }
      /**
       * Traverse the file system folder identified by the given URI and its subfolders. All
       * contained files that match the file extensions are added to the collector.
       */
      async traverseFolder(workspaceFolder, folderPath, fileExtensions, collector) {
        const content = await this.fileSystemProvider.readDirectory(folderPath);
        await Promise.all(content.map(async (entry) => {
          if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {
            if (entry.isDirectory) {
              await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);
            } else if (entry.isFile) {
              const document = this.langiumDocuments.getOrCreateDocument(entry.uri);
              collector(document);
            }
          }
        }));
      }
      /**
       * Determine whether the given folder entry shall be included while indexing the workspace.
       */
      includeEntry(workspaceFolder, entry, fileExtensions) {
        const name = vscode_uri_1.Utils.basename(entry.uri);
        if (name.startsWith(".")) {
          return false;
        }
        if (entry.isDirectory) {
          return name !== "node_modules" && name !== "out";
        } else if (entry.isFile) {
          const extname = vscode_uri_1.Utils.extname(entry.uri);
          return fileExtensions.includes(extname);
        }
        return false;
      }
    };
    exports2.DefaultWorkspaceManager = DefaultWorkspaceManager;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/lexer.js
var require_lexer2 = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/lexer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTokenTypeDictionary = exports2.isIMultiModeLexerDefinition = exports2.isTokenTypeArray = exports2.DefaultLexer = void 0;
    var chevrotain_1 = require_api7();
    var DefaultLexer = class {
      constructor(services) {
        const tokens = services.parser.TokenBuilder.buildTokens(services.Grammar, {
          caseInsensitive: services.LanguageMetaData.caseInsensitive
        });
        this.tokenTypes = this.toTokenTypeDictionary(tokens);
        const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;
        this.chevrotainLexer = new chevrotain_1.Lexer(lexerTokens);
      }
      get definition() {
        return this.tokenTypes;
      }
      tokenize(text) {
        var _a;
        const chevrotainResult = this.chevrotainLexer.tokenize(text);
        return {
          tokens: chevrotainResult.tokens,
          errors: chevrotainResult.errors,
          hidden: (_a = chevrotainResult.groups.hidden) !== null && _a !== void 0 ? _a : []
        };
      }
      toTokenTypeDictionary(buildTokens) {
        if (isTokenTypeDictionary(buildTokens))
          return buildTokens;
        const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;
        const res = {};
        tokens.forEach((token) => res[token.name] = token);
        return res;
      }
    };
    exports2.DefaultLexer = DefaultLexer;
    function isTokenTypeArray(tokenVocabulary) {
      return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || "name" in tokenVocabulary[0]);
    }
    exports2.isTokenTypeArray = isTokenTypeArray;
    function isIMultiModeLexerDefinition(tokenVocabulary) {
      return tokenVocabulary && "modes" in tokenVocabulary && "defaultMode" in tokenVocabulary;
    }
    exports2.isIMultiModeLexerDefinition = isIMultiModeLexerDefinition;
    function isTokenTypeDictionary(tokenVocabulary) {
      return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);
    }
    exports2.isTokenTypeDictionary = isTokenTypeDictionary;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/documentation/jsdoc.js
var require_jsdoc = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/documentation/jsdoc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isJSDoc = exports2.parseJSDoc = void 0;
    var vscode_languageserver_1 = require_main4();
    var vscode_uri_1 = require_umd();
    var template_string_1 = require_template_string();
    var regex_util_1 = require_regex_util();
    function parseJSDoc(node, start, options) {
      let opts;
      let position;
      if (typeof node === "string") {
        position = start;
        opts = options;
      } else {
        position = node.range.start;
        opts = start;
      }
      if (!position) {
        position = vscode_languageserver_1.Position.create(0, 0);
      }
      const lines = getLines(node);
      const normalizedOptions = normalizeOptions(opts);
      const tokens = tokenize({
        lines,
        position,
        options: normalizedOptions
      });
      return parseJSDocComment({
        index: 0,
        tokens,
        position
      });
    }
    exports2.parseJSDoc = parseJSDoc;
    function isJSDoc(node, options) {
      const normalizedOptions = normalizeOptions(options);
      const lines = getLines(node);
      if (lines.length === 0) {
        return false;
      }
      const first = lines[0];
      const last = lines[lines.length - 1];
      const firstRegex = normalizedOptions.start;
      const lastRegex = normalizedOptions.end;
      return Boolean(firstRegex === null || firstRegex === void 0 ? void 0 : firstRegex.exec(first)) && Boolean(lastRegex === null || lastRegex === void 0 ? void 0 : lastRegex.exec(last));
    }
    exports2.isJSDoc = isJSDoc;
    function getLines(node) {
      let content = "";
      if (typeof node === "string") {
        content = node;
      } else {
        content = node.text;
      }
      const lines = content.split(template_string_1.NEWLINE_REGEXP);
      return lines;
    }
    var tagRegex = /\s*(@([\p{L}][\p{L}\p{N}]*)?)/uy;
    var inlineTagRegex = /\{(@[\p{L}][\p{L}\p{N}]*)(\s*)([^\r\n}]+)?\}/gu;
    function tokenize(context) {
      var _a, _b, _c;
      const tokens = [];
      let currentLine = context.position.line;
      let currentCharacter = context.position.character;
      for (let i = 0; i < context.lines.length; i++) {
        const first = i === 0;
        const last = i === context.lines.length - 1;
        let line = context.lines[i];
        let index = 0;
        if (first && context.options.start) {
          const match = (_a = context.options.start) === null || _a === void 0 ? void 0 : _a.exec(line);
          if (match) {
            index = match.index + match[0].length;
          }
        } else {
          const match = (_b = context.options.line) === null || _b === void 0 ? void 0 : _b.exec(line);
          if (match) {
            index = match.index + match[0].length;
          }
        }
        if (last) {
          const match = (_c = context.options.end) === null || _c === void 0 ? void 0 : _c.exec(line);
          if (match) {
            line = line.substring(0, match.index);
          }
        }
        line = line.substring(0, lastCharacter(line));
        const whitespaceEnd = skipWhitespace(line, 0);
        if (whitespaceEnd >= line.length) {
          if (tokens.length > 0) {
            const position = vscode_languageserver_1.Position.create(currentLine, currentCharacter);
            tokens.push({
              type: "break",
              content: "",
              range: vscode_languageserver_1.Range.create(position, position)
            });
          }
        } else {
          tagRegex.lastIndex = index;
          const tagMatch = tagRegex.exec(line);
          if (tagMatch) {
            const fullMatch = tagMatch[0];
            const value = tagMatch[1];
            const start = vscode_languageserver_1.Position.create(currentLine, currentCharacter + index);
            const end = vscode_languageserver_1.Position.create(currentLine, currentCharacter + index + fullMatch.length);
            tokens.push({
              type: "tag",
              content: value,
              range: vscode_languageserver_1.Range.create(start, end)
            });
            index += fullMatch.length;
            index = skipWhitespace(line, index);
          }
          if (index < line.length) {
            const rest = line.substring(index);
            const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));
            tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));
          }
        }
        currentLine++;
        currentCharacter = 0;
      }
      if (tokens.length > 0 && tokens[tokens.length - 1].type === "break") {
        return tokens.slice(0, -1);
      }
      return tokens;
    }
    function buildInlineTokens(tags, line, lineIndex, characterIndex) {
      const tokens = [];
      if (tags.length === 0) {
        const start = vscode_languageserver_1.Position.create(lineIndex, characterIndex);
        const end = vscode_languageserver_1.Position.create(lineIndex, characterIndex + line.length);
        tokens.push({
          type: "text",
          content: line,
          range: vscode_languageserver_1.Range.create(start, end)
        });
      } else {
        let lastIndex = 0;
        for (const match of tags) {
          const matchIndex = match.index;
          const startContent = line.substring(lastIndex, matchIndex);
          if (startContent.length > 0) {
            tokens.push({
              type: "text",
              content: line.substring(lastIndex, matchIndex),
              range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lineIndex, lastIndex + characterIndex), vscode_languageserver_1.Position.create(lineIndex, matchIndex + characterIndex))
            });
          }
          let offset = startContent.length + 1;
          const tagName = match[1];
          tokens.push({
            type: "inline-tag",
            content: tagName,
            range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lineIndex, lastIndex + offset + characterIndex), vscode_languageserver_1.Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex))
          });
          offset += tagName.length;
          if (match.length === 4) {
            offset += match[2].length;
            const value = match[3];
            tokens.push({
              type: "text",
              content: value,
              range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lineIndex, lastIndex + offset + characterIndex), vscode_languageserver_1.Position.create(lineIndex, lastIndex + offset + value.length + characterIndex))
            });
          } else {
            tokens.push({
              type: "text",
              content: "",
              range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lineIndex, lastIndex + offset + characterIndex), vscode_languageserver_1.Position.create(lineIndex, lastIndex + offset + characterIndex))
            });
          }
          lastIndex = matchIndex + match[0].length;
        }
        const endContent = line.substring(lastIndex);
        if (endContent.length > 0) {
          tokens.push({
            type: "text",
            content: endContent,
            range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lineIndex, lastIndex + characterIndex), vscode_languageserver_1.Position.create(lineIndex, lastIndex + characterIndex + endContent.length))
          });
        }
      }
      return tokens;
    }
    var nonWhitespaceRegex = /\S/;
    var whitespaceEndRegex = /\s*$/;
    function skipWhitespace(line, index) {
      const match = line.substring(index).match(nonWhitespaceRegex);
      if (match) {
        return index + match.index;
      } else {
        return line.length;
      }
    }
    function lastCharacter(line) {
      const match = line.match(whitespaceEndRegex);
      if (match && typeof match.index === "number") {
        return match.index;
      }
      return void 0;
    }
    function parseJSDocComment(context) {
      var _a, _b, _c, _d;
      const startPosition = vscode_languageserver_1.Position.create(context.position.line, context.position.character);
      if (context.tokens.length === 0) {
        return new JSDocCommentImpl([], vscode_languageserver_1.Range.create(startPosition, startPosition));
      }
      const elements = [];
      while (context.index < context.tokens.length) {
        const element = parseJSDocElement(context, elements[elements.length - 1]);
        if (element) {
          elements.push(element);
        }
      }
      const start = (_b = (_a = elements[0]) === null || _a === void 0 ? void 0 : _a.range.start) !== null && _b !== void 0 ? _b : startPosition;
      const end = (_d = (_c = elements[elements.length - 1]) === null || _c === void 0 ? void 0 : _c.range.end) !== null && _d !== void 0 ? _d : startPosition;
      return new JSDocCommentImpl(elements, vscode_languageserver_1.Range.create(start, end));
    }
    function parseJSDocElement(context, last) {
      const next = context.tokens[context.index];
      if (next.type === "tag") {
        return parseJSDocTag(context, false);
      } else if (next.type === "text" || next.type === "inline-tag") {
        return parseJSDocText(context);
      } else {
        appendEmptyLine(next, last);
        context.index++;
        return void 0;
      }
    }
    function appendEmptyLine(token, element) {
      if (element) {
        const line = new JSDocLineImpl("", token.range);
        if ("inlines" in element) {
          element.inlines.push(line);
        } else {
          element.content.inlines.push(line);
        }
      }
    }
    function parseJSDocText(context) {
      let token = context.tokens[context.index];
      const firstToken = token;
      let lastToken = token;
      const lines = [];
      while (token && token.type !== "break" && token.type !== "tag") {
        lines.push(parseJSDocInline(context));
        lastToken = token;
        token = context.tokens[context.index];
      }
      return new JSDocTextImpl(lines, vscode_languageserver_1.Range.create(firstToken.range.start, lastToken.range.end));
    }
    function parseJSDocInline(context) {
      const token = context.tokens[context.index];
      if (token.type === "inline-tag") {
        return parseJSDocTag(context, true);
      } else {
        return parseJSDocLine(context);
      }
    }
    function parseJSDocTag(context, inline) {
      const tagToken = context.tokens[context.index++];
      const name = tagToken.content.substring(1);
      const nextToken = context.tokens[context.index];
      if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === "text") {
        if (inline) {
          const docLine = parseJSDocLine(context);
          return new JSDocTagImpl(name, new JSDocTextImpl([docLine], docLine.range), inline, vscode_languageserver_1.Range.create(tagToken.range.start, docLine.range.end));
        } else {
          const textDoc = parseJSDocText(context);
          return new JSDocTagImpl(name, textDoc, inline, vscode_languageserver_1.Range.create(tagToken.range.start, textDoc.range.end));
        }
      } else {
        const range = tagToken.range;
        return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);
      }
    }
    function parseJSDocLine(context) {
      const token = context.tokens[context.index++];
      return new JSDocLineImpl(token.content, token.range);
    }
    function normalizeOptions(options) {
      if (!options) {
        return normalizeOptions({
          start: "/**",
          end: "*/",
          line: "*"
        });
      }
      const { start, end, line } = options;
      return {
        start: normalizeOption(start, true),
        end: normalizeOption(end, false),
        line: normalizeOption(line, true)
      };
    }
    function normalizeOption(option, start) {
      if (typeof option === "string" || typeof option === "object") {
        const escaped = typeof option === "string" ? (0, regex_util_1.escapeRegExp)(option) : option.source;
        if (start) {
          return new RegExp(`^\\s*${escaped}`);
        } else {
          return new RegExp(`\\s*${escaped}\\s*$`);
        }
      } else {
        return option;
      }
    }
    var JSDocCommentImpl = class {
      constructor(elements, range) {
        this.elements = elements;
        this.range = range;
      }
      getTag(name) {
        return this.getAllTags().find((e) => e.name === name);
      }
      getTags(name) {
        return this.getAllTags().filter((e) => e.name === name);
      }
      getAllTags() {
        return this.elements.filter((e) => "name" in e);
      }
      toString() {
        let value = "";
        for (const element of this.elements) {
          if (value.length === 0) {
            value = element.toString();
          } else {
            const text = element.toString();
            value += fillNewlines(value) + text;
          }
        }
        return value.trim();
      }
      toMarkdown(options) {
        let value = "";
        for (const element of this.elements) {
          if (value.length === 0) {
            value = element.toMarkdown(options);
          } else {
            const text = element.toMarkdown(options);
            value += fillNewlines(value) + text;
          }
        }
        return value.trim();
      }
    };
    var JSDocTagImpl = class {
      constructor(name, content, inline, range) {
        this.name = name;
        this.content = content;
        this.inline = inline;
        this.range = range;
      }
      toString() {
        let text = `@${this.name}`;
        const content = this.content.toString();
        if (this.content.inlines.length === 1) {
          text = `${text} ${content}`;
        } else if (this.content.inlines.length > 1) {
          text = `${text}
${content}`;
        }
        if (this.inline) {
          return `{${text}}`;
        } else {
          return text;
        }
      }
      toMarkdown(options) {
        const content = this.content.toMarkdown(options);
        if (this.inline) {
          const rendered = renderInlineTag(this.name, content, options !== null && options !== void 0 ? options : {});
          if (typeof rendered === "string") {
            return rendered;
          }
        }
        let marker = "";
        if ((options === null || options === void 0 ? void 0 : options.tag) === "italic" || (options === null || options === void 0 ? void 0 : options.tag) === void 0) {
          marker = "*";
        } else if ((options === null || options === void 0 ? void 0 : options.tag) === "bold") {
          marker = "**";
        } else if ((options === null || options === void 0 ? void 0 : options.tag) === "bold-italic") {
          marker = "***";
        }
        let text = `${marker}@${this.name}${marker}`;
        if (this.content.inlines.length === 1) {
          text = `${text} \u2014 ${content}`;
        } else if (this.content.inlines.length > 1) {
          text = `${text}
${content}`;
        }
        if (this.inline) {
          return `{${text}}`;
        } else {
          return text;
        }
      }
    };
    function renderInlineTag(tag, content, options) {
      var _a, _b;
      if (tag === "linkplain" || tag === "linkcode" || tag === "link") {
        const index = content.indexOf(" ");
        let display = content;
        if (index > 0) {
          const displayStart = skipWhitespace(content, index);
          display = content.substring(displayStart);
          content = content.substring(0, index);
        }
        if (tag === "linkcode" || tag === "link" && options.link === "code") {
          display = `\`${display}\``;
        }
        const renderedLink = (_b = (_a = options.renderLink) === null || _a === void 0 ? void 0 : _a.call(options, content, display)) !== null && _b !== void 0 ? _b : renderLinkDefault(content, display);
        return renderedLink;
      }
      return void 0;
    }
    function renderLinkDefault(content, display) {
      try {
        vscode_uri_1.URI.parse(content, true);
        return `[${display}](${content})`;
      } catch (_a) {
        return content;
      }
    }
    var JSDocTextImpl = class {
      constructor(lines, range) {
        this.inlines = lines;
        this.range = range;
      }
      toString() {
        let text = "";
        for (let i = 0; i < this.inlines.length; i++) {
          const inline = this.inlines[i];
          const next = this.inlines[i + 1];
          text += inline.toString();
          if (next && next.range.start.line > inline.range.start.line) {
            text += "\n";
          }
        }
        return text;
      }
      toMarkdown(options) {
        let text = "";
        for (let i = 0; i < this.inlines.length; i++) {
          const inline = this.inlines[i];
          const next = this.inlines[i + 1];
          text += inline.toMarkdown(options);
          if (next && next.range.start.line > inline.range.start.line) {
            text += "\n";
          }
        }
        return text;
      }
    };
    var JSDocLineImpl = class {
      constructor(text, range) {
        this.text = text;
        this.range = range;
      }
      toString() {
        return this.text;
      }
      toMarkdown() {
        return this.text;
      }
    };
    function fillNewlines(text) {
      if (text.endsWith("\n")) {
        return "\n";
      } else {
        return "\n\n";
      }
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/documentation/documentation-provider.js
var require_documentation_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/documentation/documentation-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JSDocDocumentationProvider = void 0;
    var syntax_tree_1 = require_syntax_tree();
    var ast_util_1 = require_ast_util();
    var cst_util_1 = require_cst_util();
    var jsdoc_1 = require_jsdoc();
    var JSDocDocumentationProvider = class {
      constructor(services) {
        this.indexManager = services.shared.workspace.IndexManager;
        this.grammarConfig = services.parser.GrammarConfig;
      }
      getDocumentation(node) {
        const lastNode = (0, cst_util_1.findCommentNode)(node.$cstNode, this.grammarConfig.multilineCommentRules);
        if ((0, syntax_tree_1.isLeafCstNode)(lastNode) && (0, jsdoc_1.isJSDoc)(lastNode)) {
          const parsedJSDoc = (0, jsdoc_1.parseJSDoc)(lastNode);
          return parsedJSDoc.toMarkdown({
            renderLink: (link, display) => {
              return this.documentationLinkRenderer(node, link, display);
            }
          });
        }
        return void 0;
      }
      documentationLinkRenderer(node, name, display) {
        var _a;
        const description = (_a = this.findNameInPrecomputedScopes(node, name)) !== null && _a !== void 0 ? _a : this.findNameInGlobalScope(node, name);
        if (description && description.nameSegment) {
          const line = description.nameSegment.range.start.line + 1;
          const character = description.nameSegment.range.start.character + 1;
          const uri = description.documentUri.with({ fragment: `L${line},${character}` });
          return `[${display}](${uri.toString()})`;
        } else {
          return void 0;
        }
      }
      findNameInPrecomputedScopes(node, name) {
        const document = (0, ast_util_1.getDocument)(node);
        const precomputed = document.precomputedScopes;
        if (!precomputed) {
          return void 0;
        }
        let currentNode = node;
        do {
          const allDescriptions = precomputed.get(currentNode);
          const description = allDescriptions.find((e) => e.name === name);
          if (description) {
            return description;
          }
          currentNode = currentNode.$container;
        } while (currentNode);
        return void 0;
      }
      findNameInGlobalScope(node, name) {
        const description = this.indexManager.allElements().find((e) => e.name === name);
        return description;
      }
    };
    exports2.JSDocDocumentationProvider = JSDocDocumentationProvider;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/documentation/index.js
var require_documentation = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/documentation/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_documentation_provider(), exports2);
    __exportStar(require_jsdoc(), exports2);
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/default-module.js
var require_default_module = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/default-module.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultSharedModule = exports2.createDefaultModule = void 0;
    var vscode_languageserver_1 = require_main4();
    var vscode_languageserver_textdocument_1 = require_main5();
    var grammar_config_1 = require_grammar_config();
    var completion_parser_builder_1 = require_completion_parser_builder();
    var completion_provider_1 = require_completion_provider();
    var document_highlight_provider_1 = require_document_highlight_provider();
    var document_symbol_provider_1 = require_document_symbol_provider();
    var folding_range_provider_1 = require_folding_range_provider();
    var definition_provider_1 = require_definition_provider();
    var hover_provider_1 = require_hover_provider();
    var language_server_1 = require_language_server();
    var references_provider_1 = require_references_provider();
    var rename_provider_1 = require_rename_provider();
    var langium_parser_builder_1 = require_langium_parser_builder();
    var token_builder_1 = require_token_builder();
    var value_converter_1 = require_value_converter();
    var linker_1 = require_linker();
    var name_provider_1 = require_name_provider();
    var references_1 = require_references();
    var scope_computation_1 = require_scope_computation();
    var scope_provider_1 = require_scope_provider();
    var json_serializer_1 = require_json_serializer();
    var service_registry_1 = require_service_registry();
    var promise_util_1 = require_promise_util();
    var document_validator_1 = require_document_validator();
    var validation_registry_1 = require_validation_registry();
    var ast_descriptions_1 = require_ast_descriptions();
    var ast_node_locator_1 = require_ast_node_locator();
    var configuration_1 = require_configuration2();
    var document_builder_1 = require_document_builder();
    var documents_1 = require_documents();
    var index_manager_1 = require_index_manager();
    var workspace_manager_1 = require_workspace_manager();
    var lexer_1 = require_lexer2();
    var documentation_1 = require_documentation();
    function createDefaultModule(context) {
      return {
        documentation: {
          DocumentationProvider: (services) => new documentation_1.JSDocDocumentationProvider(services)
        },
        parser: {
          GrammarConfig: (services) => (0, grammar_config_1.createGrammarConfig)(services),
          LangiumParser: (services) => (0, langium_parser_builder_1.createLangiumParser)(services),
          CompletionParser: (services) => (0, completion_parser_builder_1.createCompletionParser)(services),
          ValueConverter: () => new value_converter_1.DefaultValueConverter(),
          TokenBuilder: () => new token_builder_1.DefaultTokenBuilder(),
          Lexer: (services) => new lexer_1.DefaultLexer(services)
        },
        lsp: {
          CompletionProvider: (services) => new completion_provider_1.DefaultCompletionProvider(services),
          DocumentSymbolProvider: (services) => new document_symbol_provider_1.DefaultDocumentSymbolProvider(services),
          HoverProvider: (services) => new hover_provider_1.MultilineCommentHoverProvider(services),
          FoldingRangeProvider: (services) => new folding_range_provider_1.DefaultFoldingRangeProvider(services),
          ReferencesProvider: (services) => new references_provider_1.DefaultReferencesProvider(services),
          DefinitionProvider: (services) => new definition_provider_1.DefaultDefinitionProvider(services),
          DocumentHighlightProvider: (services) => new document_highlight_provider_1.DefaultDocumentHighlightProvider(services),
          RenameProvider: (services) => new rename_provider_1.DefaultRenameProvider(services)
        },
        workspace: {
          AstNodeLocator: () => new ast_node_locator_1.DefaultAstNodeLocator(),
          AstNodeDescriptionProvider: (services) => new ast_descriptions_1.DefaultAstNodeDescriptionProvider(services),
          ReferenceDescriptionProvider: (services) => new ast_descriptions_1.DefaultReferenceDescriptionProvider(services)
        },
        references: {
          Linker: (services) => new linker_1.DefaultLinker(services),
          NameProvider: () => new name_provider_1.DefaultNameProvider(),
          ScopeProvider: (services) => new scope_provider_1.DefaultScopeProvider(services),
          ScopeComputation: (services) => new scope_computation_1.DefaultScopeComputation(services),
          References: (services) => new references_1.DefaultReferences(services)
        },
        serializer: {
          JsonSerializer: (services) => new json_serializer_1.DefaultJsonSerializer(services)
        },
        validation: {
          DocumentValidator: (services) => new document_validator_1.DefaultDocumentValidator(services),
          ValidationRegistry: (services) => new validation_registry_1.ValidationRegistry(services)
        },
        shared: () => context.shared
      };
    }
    exports2.createDefaultModule = createDefaultModule;
    function createDefaultSharedModule(context) {
      return {
        ServiceRegistry: () => new service_registry_1.DefaultServiceRegistry(),
        lsp: {
          Connection: () => context.connection,
          LanguageServer: (services) => new language_server_1.DefaultLanguageServer(services)
        },
        workspace: {
          LangiumDocuments: (services) => new documents_1.DefaultLangiumDocuments(services),
          LangiumDocumentFactory: (services) => new documents_1.DefaultLangiumDocumentFactory(services),
          DocumentBuilder: (services) => new document_builder_1.DefaultDocumentBuilder(services),
          TextDocuments: () => new vscode_languageserver_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument),
          IndexManager: (services) => new index_manager_1.DefaultIndexManager(services),
          WorkspaceManager: (services) => new workspace_manager_1.DefaultWorkspaceManager(services),
          FileSystemProvider: (services) => context.fileSystemProvider(services),
          MutexLock: () => new promise_util_1.MutexLock(),
          ConfigurationProvider: (services) => new configuration_1.DefaultConfigurationProvider(services)
        }
      };
    }
    exports2.createDefaultSharedModule = createDefaultSharedModule;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/services.js
var require_services = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/services.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/node-joiner.js
var require_node_joiner = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/node-joiner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinTracedToNodeIf = exports2.joinTracedToNode = exports2.joinToNode = void 0;
    var generator_node_1 = require_generator_node();
    function joinToNode(iterable, toGenerated = String, { filter, prefix, suffix, separator, appendNewLineIfNotEmpty } = {}) {
      return reduceWithIsLast(iterable, (node, it, i, isLast) => {
        if (filter && !filter(it, i, isLast)) {
          return node;
        }
        const content = toGenerated(it, i, isLast);
        return (node !== null && node !== void 0 ? node : node = new generator_node_1.CompositeGeneratorNode()).append(prefix && prefix(it, i, isLast)).append(content).append(suffix && suffix(it, i, isLast)).appendIf(!isLast && content !== void 0, separator).appendNewLineIfNotEmptyIf(
          // append 'newLineIfNotEmpty' elements only if 'node' has some content already,
          //  as if the parent is an IndentNode with 'indentImmediately' set to 'false'
          //  the indentation is not properly applied to the first non-empty line of the (this) child node
          !node.isEmpty() && !!appendNewLineIfNotEmpty
        );
      });
    }
    exports2.joinToNode = joinToNode;
    function joinTracedToNode(source, property) {
      return (iterable, toGenerated = String, options) => {
        return (0, generator_node_1.traceToNode)(source, property)(joinToNode(iterable, source && property ? (element, index, isLast) => (0, generator_node_1.traceToNode)(source, property, index)(toGenerated(element, index, isLast)) : toGenerated, options));
      };
    }
    exports2.joinTracedToNode = joinTracedToNode;
    function joinTracedToNodeIf(condition, source, property) {
      return condition ? joinTracedToNode(typeof source === "function" ? source() : source, property) : () => void 0;
    }
    exports2.joinTracedToNodeIf = joinTracedToNodeIf;
    function reduceWithIsLast(iterable, callbackfn, initial) {
      const iterator = iterable[Symbol.iterator]();
      let next = iterator.next();
      let index = 0;
      let result = initial;
      while (!next.done) {
        const nextNext = iterator.next();
        result = callbackfn(result, next.value, index, Boolean(nextNext.done));
        next = nextNext;
        index++;
      }
      return result;
    }
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/index.js
var require_generator = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/generator/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalizeEOL = exports2.expandToStringWithNL = exports2.expandToString = void 0;
    __exportStar(require_generator_node(), exports2);
    __exportStar(require_node_joiner(), exports2);
    __exportStar(require_template_node(), exports2);
    var template_string_1 = require_template_string();
    Object.defineProperty(exports2, "expandToString", { enumerable: true, get: function() {
      return template_string_1.expandToString;
    } });
    Object.defineProperty(exports2, "expandToStringWithNL", { enumerable: true, get: function() {
      return template_string_1.expandToStringWithNL;
    } });
    Object.defineProperty(exports2, "normalizeEOL", { enumerable: true, get: function() {
      return template_string_1.normalizeEOL;
    } });
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/language-meta-data.js
var require_language_meta_data = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/language-meta-data.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/index.js
var require_grammar2 = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/grammar/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_ast_reflection_interpreter(), exports2);
    __exportStar(require_grammar_config(), exports2);
    __exportStar(require_langium_grammar_module(), exports2);
    __exportStar(require_language_meta_data(), exports2);
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/parser-config.js
var require_parser_config = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/parser-config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/index.js
var require_parser2 = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/parser/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_completion_parser_builder(), exports2);
    __exportStar(require_cst_node_builder(), exports2);
    __exportStar(require_langium_parser_builder(), exports2);
    __exportStar(require_langium_parser(), exports2);
    __exportStar(require_lexer2(), exports2);
    __exportStar(require_parser_config(), exports2);
    __exportStar(require_token_builder(), exports2);
    __exportStar(require_value_converter(), exports2);
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/references/index.js
var require_references2 = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/references/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_linker(), exports2);
    __exportStar(require_name_provider(), exports2);
    __exportStar(require_references(), exports2);
    __exportStar(require_scope_computation(), exports2);
    __exportStar(require_scope_provider(), exports2);
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/serializer/index.js
var require_serializer = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/serializer/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_json_serializer(), exports2);
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/index.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/utils/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_ast_util(), exports2);
    __exportStar(require_collections(), exports2);
    __exportStar(require_cst_util(), exports2);
    __exportStar(require_errors(), exports2);
    __exportStar(require_grammar_util(), exports2);
    __exportStar(require_promise_util(), exports2);
    __exportStar(require_regex_util(), exports2);
    __exportStar(require_stream(), exports2);
    __exportStar(require_uri_util(), exports2);
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/validation/index.js
var require_validation = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/validation/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_document_validator(), exports2);
    __exportStar(require_validation_registry(), exports2);
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/index.js
var require_workspace = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/workspace/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_ast_descriptions(), exports2);
    __exportStar(require_ast_node_locator(), exports2);
    __exportStar(require_configuration2(), exports2);
    __exportStar(require_document_builder(), exports2);
    __exportStar(require_documents(), exports2);
    __exportStar(require_file_system_provider(), exports2);
    __exportStar(require_index_manager(), exports2);
    __exportStar(require_workspace_manager(), exports2);
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GrammarAST = void 0;
    __exportStar(require_default_module(), exports2);
    __exportStar(require_dependency_injection(), exports2);
    __exportStar(require_service_registry(), exports2);
    __exportStar(require_services(), exports2);
    __exportStar(require_syntax_tree(), exports2);
    __exportStar(require_documentation(), exports2);
    __exportStar(require_generator(), exports2);
    __exportStar(require_grammar2(), exports2);
    __exportStar(require_lsp(), exports2);
    __exportStar(require_parser2(), exports2);
    __exportStar(require_references2(), exports2);
    __exportStar(require_serializer(), exports2);
    __exportStar(require_utils(), exports2);
    __exportStar(require_validation(), exports2);
    __exportStar(require_workspace(), exports2);
    var GrammarAST = __importStar(require_ast());
    exports2.GrammarAST = GrammarAST;
  }
});

// ../syside-languageserver/lib/generated/ast.js
var require_ast2 = __commonJS({
  "../syside-languageserver/lib/generated/ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Featuring = exports2.isFeatureInverting = exports2.FeatureInverting = exports2.isFeatureChaining = exports2.FeatureChaining = exports2.isDisjoining = exports2.Disjoining = exports2.isDifferencing = exports2.Differencing = exports2.isDependency = exports2.Dependency = exports2.isConnector = exports2.Connector = exports2.isAssociation = exports2.Association = exports2.isAnnotation = exports2.Annotation = exports2.isType = exports2.Type = exports2.isPackage = exports2.Package = exports2.isTextualAnnotatingElement = exports2.TextualAnnotatingElement = exports2.isMetadataFeature = exports2.MetadataFeature = exports2.isNamespaceReference = exports2.NamespaceReference = exports2.isMembershipReference = exports2.MembershipReference = exports2.isRelationship = exports2.Relationship = exports2.isNamespace = exports2.Namespace = exports2.isAnnotatingElement = exports2.AnnotatingElement = exports2.isElementReference = exports2.ElementReference = exports2.isElement = exports2.Element = exports2.isTypeRelationship = exports2.TypeRelationship = exports2.isTransparentElement = exports2.TransparentElement = exports2.isNonOwnerType = exports2.NonOwnerType = exports2.isName = exports2.isInlineExpression = exports2.InlineExpression = exports2.isFeatureRelationship = exports2.FeatureRelationship = void 0;
    exports2.Specialization = exports2.isConjugation = exports2.Conjugation = exports2.isNamespaceImport = exports2.NamespaceImport = exports2.isMembershipImport = exports2.MembershipImport = exports2.isExpose = exports2.Expose = exports2.isTypeFeaturing = exports2.TypeFeaturing = exports2.isFeatureMembership = exports2.FeatureMembership = exports2.isSuccession = exports2.Succession = exports2.isItemFlow = exports2.ItemFlow = exports2.isConnectorAsUsage = exports2.ConnectorAsUsage = exports2.isBindingConnector = exports2.BindingConnector = exports2.isInteraction = exports2.Interaction = exports2.isAssociationStructure = exports2.AssociationStructure = exports2.isFeature = exports2.Feature = exports2.isClassifier = exports2.Classifier = exports2.isLibraryPackage = exports2.LibraryPackage = exports2.isTextualRepresentation = exports2.TextualRepresentation = exports2.isComment = exports2.Comment = exports2.isMetadataUsage = exports2.MetadataUsage = exports2.isTypeReference = exports2.TypeReference = exports2.isUnioning = exports2.Unioning = exports2.isMembership = exports2.Membership = exports2.isIntersecting = exports2.Intersecting = exports2.isInheritance = exports2.Inheritance = exports2.isImport = exports2.Import = exports2.isFeaturing = void 0;
    exports2.StateSubactionMembership = exports2.isResultExpressionMembership = exports2.ResultExpressionMembership = exports2.isRequirementConstraintMembership = exports2.RequirementConstraintMembership = exports2.isParameterMembership = exports2.ParameterMembership = exports2.isObjectiveMembership = exports2.ObjectiveMembership = exports2.isEndFeatureMembership = exports2.EndFeatureMembership = exports2.isSuccessionItemFlow = exports2.SuccessionItemFlow = exports2.isSuccessionAsUsage = exports2.SuccessionAsUsage = exports2.isFlowConnectionUsage = exports2.FlowConnectionUsage = exports2.isConnectionUsage = exports2.ConnectionUsage = exports2.isBindingConnectorAsUsage = exports2.BindingConnectorAsUsage = exports2.isFlowConnectionDefinition = exports2.FlowConnectionDefinition = exports2.isConnectionDefinition = exports2.ConnectionDefinition = exports2.isUsage = exports2.Usage = exports2.isStep = exports2.Step = exports2.isMultiplicity = exports2.Multiplicity = exports2.isItemFlowEnd = exports2.ItemFlowEnd = exports2.isItemFeature = exports2.ItemFeature = exports2.isDefinition = exports2.Definition = exports2.isDataType = exports2.DataType = exports2.isClass = exports2.Class = exports2.isDocumentation = exports2.Documentation = exports2.isFeatureReference = exports2.FeatureReference = exports2.isClassifierReference = exports2.ClassifierReference = exports2.isOwningMembership = exports2.OwningMembership = exports2.isSpecialization = void 0;
    exports2.AllocationDefinition = exports2.isReferenceUsage = exports2.ReferenceUsage = exports2.isOccurrenceUsage = exports2.OccurrenceUsage = exports2.isAttributeUsage = exports2.AttributeUsage = exports2.isExpression = exports2.Expression = exports2.isActionUsage = exports2.ActionUsage = exports2.isMultiplicityRange = exports2.MultiplicityRange = exports2.isAttributeDefinition = exports2.AttributeDefinition = exports2.isStructure = exports2.Structure = exports2.isOccurrenceDefinition = exports2.OccurrenceDefinition = exports2.isLifeClass = exports2.LifeClass = exports2.isBehavior = exports2.Behavior = exports2.isMetaclassReference = exports2.MetaclassReference = exports2.isConjugatedPortReference = exports2.ConjugatedPortReference = exports2.isVariantMembership = exports2.VariantMembership = exports2.isFeatureValue = exports2.FeatureValue = exports2.isElementFilterMembership = exports2.ElementFilterMembership = exports2.isSubsetting = exports2.Subsetting = exports2.isSubclassification = exports2.Subclassification = exports2.isFeatureTyping = exports2.FeatureTyping = exports2.isPortConjugation = exports2.PortConjugation = exports2.isNamespaceExpose = exports2.NamespaceExpose = exports2.isMembershipExpose = exports2.MembershipExpose = exports2.isViewRenderingMembership = exports2.ViewRenderingMembership = exports2.isTransitionFeatureMembership = exports2.TransitionFeatureMembership = exports2.isStateSubactionMembership = void 0;
    exports2.ControlNode = exports2.isCalculationUsage = exports2.CalculationUsage = exports2.isAssignmentActionUsage = exports2.AssignmentActionUsage = exports2.isAcceptActionUsage = exports2.AcceptActionUsage = exports2.isEnumerationDefinition = exports2.EnumerationDefinition = exports2.isMetaclass = exports2.Metaclass = exports2.isPortDefinition = exports2.PortDefinition = exports2.isItemDefinition = exports2.ItemDefinition = exports2.isConstraintDefinition = exports2.ConstraintDefinition = exports2.isSysMLFunction = exports2.SysMLFunction = exports2.isActionDefinition = exports2.ActionDefinition = exports2.isReferenceSubsetting = exports2.ReferenceSubsetting = exports2.isRedefinition = exports2.Redefinition = exports2.isCrossSubsetting = exports2.CrossSubsetting = exports2.isConjugatedPortTyping = exports2.ConjugatedPortTyping = exports2.isRequirementVerificationMembership = exports2.RequirementVerificationMembership = exports2.isFramedConcernMembership = exports2.FramedConcernMembership = exports2.isSubjectMembership = exports2.SubjectMembership = exports2.isStakeholderMembership = exports2.StakeholderMembership = exports2.isReturnParameterMembership = exports2.ReturnParameterMembership = exports2.isActorMembership = exports2.ActorMembership = exports2.isSuccessionFlowConnectionUsage = exports2.SuccessionFlowConnectionUsage = exports2.isInterfaceUsage = exports2.InterfaceUsage = exports2.isAllocationUsage = exports2.AllocationUsage = exports2.isInterfaceDefinition = exports2.InterfaceDefinition = exports2.isAllocationDefinition = void 0;
    exports2.ConjugatedPortDefinition = exports2.isPartDefinition = exports2.PartDefinition = exports2.isMetadataDefinition = exports2.MetadataDefinition = exports2.isRequirementDefinition = exports2.RequirementDefinition = exports2.isPredicate = exports2.Predicate = exports2.isStateDefinition = exports2.StateDefinition = exports2.isCalculationDefinition = exports2.CalculationDefinition = exports2.isPortUsage = exports2.PortUsage = exports2.isItemUsage = exports2.ItemUsage = exports2.isEventOccurrenceUsage = exports2.EventOccurrenceUsage = exports2.isConstraintUsage = exports2.ConstraintUsage = exports2.isEnumerationUsage = exports2.EnumerationUsage = exports2.isNullExpression = exports2.NullExpression = exports2.isMetadataAccessExpression = exports2.MetadataAccessExpression = exports2.isLiteralExpression = exports2.LiteralExpression = exports2.isInvocationExpression = exports2.InvocationExpression = exports2.isFeatureReferenceExpression = exports2.FeatureReferenceExpression = exports2.isBooleanExpression = exports2.BooleanExpression = exports2.isTransitionUsage = exports2.TransitionUsage = exports2.isTerminateActionUsage = exports2.TerminateActionUsage = exports2.isStateUsage = exports2.StateUsage = exports2.isSendActionUsage = exports2.SendActionUsage = exports2.isPerformActionUsage = exports2.PerformActionUsage = exports2.isLoopActionUsage = exports2.LoopActionUsage = exports2.isIfActionUsage = exports2.IfActionUsage = exports2.isControlNode = void 0;
    exports2.AnalysisCaseUsage = exports2.isViewDefinition = exports2.ViewDefinition = exports2.isRenderingDefinition = exports2.RenderingDefinition = exports2.isViewpointDefinition = exports2.ViewpointDefinition = exports2.isConcernDefinition = exports2.ConcernDefinition = exports2.isCaseDefinition = exports2.CaseDefinition = exports2.isPartUsage = exports2.PartUsage = exports2.isRequirementUsage = exports2.RequirementUsage = exports2.isAssertConstraintUsage = exports2.AssertConstraintUsage = exports2.isLiteralString = exports2.LiteralString = exports2.isLiteralNumber = exports2.LiteralNumber = exports2.isLiteralInfinity = exports2.LiteralInfinity = exports2.isLiteralBoolean = exports2.LiteralBoolean = exports2.isTriggerInvocationExpression = exports2.TriggerInvocationExpression = exports2.isOperatorExpression = exports2.OperatorExpression = exports2.isInvariant = exports2.Invariant = exports2.isIncludeUseCaseUsage = exports2.IncludeUseCaseUsage = exports2.isExhibitStateUsage = exports2.ExhibitStateUsage = exports2.isWhileLoopActionUsage = exports2.WhileLoopActionUsage = exports2.isForLoopActionUsage = exports2.ForLoopActionUsage = exports2.isMergeNode = exports2.MergeNode = exports2.isJoinNode = exports2.JoinNode = exports2.isForkNode = exports2.ForkNode = exports2.isDecisionNode = exports2.DecisionNode = exports2.isCaseUsage = exports2.CaseUsage = exports2.isConjugatedPortDefinition = void 0;
    exports2.reflection = exports2.SysMlAstReflection = exports2.isVerificationCaseDefinition = exports2.VerificationCaseDefinition = exports2.isUseCaseDefinition = exports2.UseCaseDefinition = exports2.isAnalysisCaseDefinition = exports2.AnalysisCaseDefinition = exports2.isViewUsage = exports2.ViewUsage = exports2.isRenderingUsage = exports2.RenderingUsage = exports2.isViewpointUsage = exports2.ViewpointUsage = exports2.isConcernUsage = exports2.ConcernUsage = exports2.isSatisfyRequirementUsage = exports2.SatisfyRequirementUsage = exports2.isSelectExpression = exports2.SelectExpression = exports2.isIndexExpression = exports2.IndexExpression = exports2.isFeatureChainExpression = exports2.FeatureChainExpression = exports2.isCollectExpression = exports2.CollectExpression = exports2.isVerificationCaseUsage = exports2.VerificationCaseUsage = exports2.isUseCaseUsage = exports2.UseCaseUsage = exports2.isAnalysisCaseUsage = void 0;
    var langium_1 = require_lib2();
    exports2.FeatureRelationship = "FeatureRelationship";
    function isFeatureRelationship(item) {
      return exports2.reflection.isInstance(item, exports2.FeatureRelationship);
    }
    exports2.isFeatureRelationship = isFeatureRelationship;
    exports2.InlineExpression = "InlineExpression";
    function isInlineExpression(item) {
      return exports2.reflection.isInstance(item, exports2.InlineExpression);
    }
    exports2.isInlineExpression = isInlineExpression;
    function isName(item) {
      return typeof item === "string" && (/[_a-zA-Z][\w_\d]*/.test(item) || /'(\\['"bftnr\\]|[^'\\])*'/.test(item));
    }
    exports2.isName = isName;
    exports2.NonOwnerType = "NonOwnerType";
    function isNonOwnerType(item) {
      return exports2.reflection.isInstance(item, exports2.NonOwnerType);
    }
    exports2.isNonOwnerType = isNonOwnerType;
    exports2.TransparentElement = "TransparentElement";
    function isTransparentElement(item) {
      return exports2.reflection.isInstance(item, exports2.TransparentElement);
    }
    exports2.isTransparentElement = isTransparentElement;
    exports2.TypeRelationship = "TypeRelationship";
    function isTypeRelationship(item) {
      return exports2.reflection.isInstance(item, exports2.TypeRelationship);
    }
    exports2.isTypeRelationship = isTypeRelationship;
    exports2.Element = "Element";
    function isElement(item) {
      return exports2.reflection.isInstance(item, exports2.Element);
    }
    exports2.isElement = isElement;
    exports2.ElementReference = "ElementReference";
    function isElementReference(item) {
      return exports2.reflection.isInstance(item, exports2.ElementReference);
    }
    exports2.isElementReference = isElementReference;
    exports2.AnnotatingElement = "AnnotatingElement";
    function isAnnotatingElement(item) {
      return exports2.reflection.isInstance(item, exports2.AnnotatingElement);
    }
    exports2.isAnnotatingElement = isAnnotatingElement;
    exports2.Namespace = "Namespace";
    function isNamespace(item) {
      return exports2.reflection.isInstance(item, exports2.Namespace);
    }
    exports2.isNamespace = isNamespace;
    exports2.Relationship = "Relationship";
    function isRelationship(item) {
      return exports2.reflection.isInstance(item, exports2.Relationship);
    }
    exports2.isRelationship = isRelationship;
    exports2.MembershipReference = "MembershipReference";
    function isMembershipReference(item) {
      return exports2.reflection.isInstance(item, exports2.MembershipReference);
    }
    exports2.isMembershipReference = isMembershipReference;
    exports2.NamespaceReference = "NamespaceReference";
    function isNamespaceReference(item) {
      return exports2.reflection.isInstance(item, exports2.NamespaceReference);
    }
    exports2.isNamespaceReference = isNamespaceReference;
    exports2.MetadataFeature = "MetadataFeature";
    function isMetadataFeature(item) {
      return exports2.reflection.isInstance(item, exports2.MetadataFeature);
    }
    exports2.isMetadataFeature = isMetadataFeature;
    exports2.TextualAnnotatingElement = "TextualAnnotatingElement";
    function isTextualAnnotatingElement(item) {
      return exports2.reflection.isInstance(item, exports2.TextualAnnotatingElement);
    }
    exports2.isTextualAnnotatingElement = isTextualAnnotatingElement;
    exports2.Package = "Package";
    function isPackage(item) {
      return exports2.reflection.isInstance(item, exports2.Package);
    }
    exports2.isPackage = isPackage;
    exports2.Type = "Type";
    function isType(item) {
      return exports2.reflection.isInstance(item, exports2.Type);
    }
    exports2.isType = isType;
    exports2.Annotation = "Annotation";
    function isAnnotation(item) {
      return exports2.reflection.isInstance(item, exports2.Annotation);
    }
    exports2.isAnnotation = isAnnotation;
    exports2.Association = "Association";
    function isAssociation(item) {
      return exports2.reflection.isInstance(item, exports2.Association);
    }
    exports2.isAssociation = isAssociation;
    exports2.Connector = "Connector";
    function isConnector(item) {
      return exports2.reflection.isInstance(item, exports2.Connector);
    }
    exports2.isConnector = isConnector;
    exports2.Dependency = "Dependency";
    function isDependency(item) {
      return exports2.reflection.isInstance(item, exports2.Dependency);
    }
    exports2.isDependency = isDependency;
    exports2.Differencing = "Differencing";
    function isDifferencing(item) {
      return exports2.reflection.isInstance(item, exports2.Differencing);
    }
    exports2.isDifferencing = isDifferencing;
    exports2.Disjoining = "Disjoining";
    function isDisjoining(item) {
      return exports2.reflection.isInstance(item, exports2.Disjoining);
    }
    exports2.isDisjoining = isDisjoining;
    exports2.FeatureChaining = "FeatureChaining";
    function isFeatureChaining(item) {
      return exports2.reflection.isInstance(item, exports2.FeatureChaining);
    }
    exports2.isFeatureChaining = isFeatureChaining;
    exports2.FeatureInverting = "FeatureInverting";
    function isFeatureInverting(item) {
      return exports2.reflection.isInstance(item, exports2.FeatureInverting);
    }
    exports2.isFeatureInverting = isFeatureInverting;
    exports2.Featuring = "Featuring";
    function isFeaturing(item) {
      return exports2.reflection.isInstance(item, exports2.Featuring);
    }
    exports2.isFeaturing = isFeaturing;
    exports2.Import = "Import";
    function isImport(item) {
      return exports2.reflection.isInstance(item, exports2.Import);
    }
    exports2.isImport = isImport;
    exports2.Inheritance = "Inheritance";
    function isInheritance(item) {
      return exports2.reflection.isInstance(item, exports2.Inheritance);
    }
    exports2.isInheritance = isInheritance;
    exports2.Intersecting = "Intersecting";
    function isIntersecting(item) {
      return exports2.reflection.isInstance(item, exports2.Intersecting);
    }
    exports2.isIntersecting = isIntersecting;
    exports2.Membership = "Membership";
    function isMembership(item) {
      return exports2.reflection.isInstance(item, exports2.Membership);
    }
    exports2.isMembership = isMembership;
    exports2.Unioning = "Unioning";
    function isUnioning(item) {
      return exports2.reflection.isInstance(item, exports2.Unioning);
    }
    exports2.isUnioning = isUnioning;
    exports2.TypeReference = "TypeReference";
    function isTypeReference(item) {
      return exports2.reflection.isInstance(item, exports2.TypeReference);
    }
    exports2.isTypeReference = isTypeReference;
    exports2.MetadataUsage = "MetadataUsage";
    function isMetadataUsage(item) {
      return exports2.reflection.isInstance(item, exports2.MetadataUsage);
    }
    exports2.isMetadataUsage = isMetadataUsage;
    exports2.Comment = "Comment";
    function isComment(item) {
      return exports2.reflection.isInstance(item, exports2.Comment);
    }
    exports2.isComment = isComment;
    exports2.TextualRepresentation = "TextualRepresentation";
    function isTextualRepresentation(item) {
      return exports2.reflection.isInstance(item, exports2.TextualRepresentation);
    }
    exports2.isTextualRepresentation = isTextualRepresentation;
    exports2.LibraryPackage = "LibraryPackage";
    function isLibraryPackage(item) {
      return exports2.reflection.isInstance(item, exports2.LibraryPackage);
    }
    exports2.isLibraryPackage = isLibraryPackage;
    exports2.Classifier = "Classifier";
    function isClassifier(item) {
      return exports2.reflection.isInstance(item, exports2.Classifier);
    }
    exports2.isClassifier = isClassifier;
    exports2.Feature = "Feature";
    function isFeature(item) {
      return exports2.reflection.isInstance(item, exports2.Feature);
    }
    exports2.isFeature = isFeature;
    exports2.AssociationStructure = "AssociationStructure";
    function isAssociationStructure(item) {
      return exports2.reflection.isInstance(item, exports2.AssociationStructure);
    }
    exports2.isAssociationStructure = isAssociationStructure;
    exports2.Interaction = "Interaction";
    function isInteraction(item) {
      return exports2.reflection.isInstance(item, exports2.Interaction);
    }
    exports2.isInteraction = isInteraction;
    exports2.BindingConnector = "BindingConnector";
    function isBindingConnector(item) {
      return exports2.reflection.isInstance(item, exports2.BindingConnector);
    }
    exports2.isBindingConnector = isBindingConnector;
    exports2.ConnectorAsUsage = "ConnectorAsUsage";
    function isConnectorAsUsage(item) {
      return exports2.reflection.isInstance(item, exports2.ConnectorAsUsage);
    }
    exports2.isConnectorAsUsage = isConnectorAsUsage;
    exports2.ItemFlow = "ItemFlow";
    function isItemFlow(item) {
      return exports2.reflection.isInstance(item, exports2.ItemFlow);
    }
    exports2.isItemFlow = isItemFlow;
    exports2.Succession = "Succession";
    function isSuccession(item) {
      return exports2.reflection.isInstance(item, exports2.Succession);
    }
    exports2.isSuccession = isSuccession;
    exports2.FeatureMembership = "FeatureMembership";
    function isFeatureMembership(item) {
      return exports2.reflection.isInstance(item, exports2.FeatureMembership);
    }
    exports2.isFeatureMembership = isFeatureMembership;
    exports2.TypeFeaturing = "TypeFeaturing";
    function isTypeFeaturing(item) {
      return exports2.reflection.isInstance(item, exports2.TypeFeaturing);
    }
    exports2.isTypeFeaturing = isTypeFeaturing;
    exports2.Expose = "Expose";
    function isExpose(item) {
      return exports2.reflection.isInstance(item, exports2.Expose);
    }
    exports2.isExpose = isExpose;
    exports2.MembershipImport = "MembershipImport";
    function isMembershipImport(item) {
      return exports2.reflection.isInstance(item, exports2.MembershipImport);
    }
    exports2.isMembershipImport = isMembershipImport;
    exports2.NamespaceImport = "NamespaceImport";
    function isNamespaceImport(item) {
      return exports2.reflection.isInstance(item, exports2.NamespaceImport);
    }
    exports2.isNamespaceImport = isNamespaceImport;
    exports2.Conjugation = "Conjugation";
    function isConjugation(item) {
      return exports2.reflection.isInstance(item, exports2.Conjugation);
    }
    exports2.isConjugation = isConjugation;
    exports2.Specialization = "Specialization";
    function isSpecialization(item) {
      return exports2.reflection.isInstance(item, exports2.Specialization);
    }
    exports2.isSpecialization = isSpecialization;
    exports2.OwningMembership = "OwningMembership";
    function isOwningMembership(item) {
      return exports2.reflection.isInstance(item, exports2.OwningMembership);
    }
    exports2.isOwningMembership = isOwningMembership;
    exports2.ClassifierReference = "ClassifierReference";
    function isClassifierReference(item) {
      return exports2.reflection.isInstance(item, exports2.ClassifierReference);
    }
    exports2.isClassifierReference = isClassifierReference;
    exports2.FeatureReference = "FeatureReference";
    function isFeatureReference(item) {
      return exports2.reflection.isInstance(item, exports2.FeatureReference);
    }
    exports2.isFeatureReference = isFeatureReference;
    exports2.Documentation = "Documentation";
    function isDocumentation(item) {
      return exports2.reflection.isInstance(item, exports2.Documentation);
    }
    exports2.isDocumentation = isDocumentation;
    exports2.Class = "Class";
    function isClass(item) {
      return exports2.reflection.isInstance(item, exports2.Class);
    }
    exports2.isClass = isClass;
    exports2.DataType = "DataType";
    function isDataType(item) {
      return exports2.reflection.isInstance(item, exports2.DataType);
    }
    exports2.isDataType = isDataType;
    exports2.Definition = "Definition";
    function isDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.Definition);
    }
    exports2.isDefinition = isDefinition;
    exports2.ItemFeature = "ItemFeature";
    function isItemFeature(item) {
      return exports2.reflection.isInstance(item, exports2.ItemFeature);
    }
    exports2.isItemFeature = isItemFeature;
    exports2.ItemFlowEnd = "ItemFlowEnd";
    function isItemFlowEnd(item) {
      return exports2.reflection.isInstance(item, exports2.ItemFlowEnd);
    }
    exports2.isItemFlowEnd = isItemFlowEnd;
    exports2.Multiplicity = "Multiplicity";
    function isMultiplicity(item) {
      return exports2.reflection.isInstance(item, exports2.Multiplicity);
    }
    exports2.isMultiplicity = isMultiplicity;
    exports2.Step = "Step";
    function isStep(item) {
      return exports2.reflection.isInstance(item, exports2.Step);
    }
    exports2.isStep = isStep;
    exports2.Usage = "Usage";
    function isUsage(item) {
      return exports2.reflection.isInstance(item, exports2.Usage);
    }
    exports2.isUsage = isUsage;
    exports2.ConnectionDefinition = "ConnectionDefinition";
    function isConnectionDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.ConnectionDefinition);
    }
    exports2.isConnectionDefinition = isConnectionDefinition;
    exports2.FlowConnectionDefinition = "FlowConnectionDefinition";
    function isFlowConnectionDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.FlowConnectionDefinition);
    }
    exports2.isFlowConnectionDefinition = isFlowConnectionDefinition;
    exports2.BindingConnectorAsUsage = "BindingConnectorAsUsage";
    function isBindingConnectorAsUsage(item) {
      return exports2.reflection.isInstance(item, exports2.BindingConnectorAsUsage);
    }
    exports2.isBindingConnectorAsUsage = isBindingConnectorAsUsage;
    exports2.ConnectionUsage = "ConnectionUsage";
    function isConnectionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.ConnectionUsage);
    }
    exports2.isConnectionUsage = isConnectionUsage;
    exports2.FlowConnectionUsage = "FlowConnectionUsage";
    function isFlowConnectionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.FlowConnectionUsage);
    }
    exports2.isFlowConnectionUsage = isFlowConnectionUsage;
    exports2.SuccessionAsUsage = "SuccessionAsUsage";
    function isSuccessionAsUsage(item) {
      return exports2.reflection.isInstance(item, exports2.SuccessionAsUsage);
    }
    exports2.isSuccessionAsUsage = isSuccessionAsUsage;
    exports2.SuccessionItemFlow = "SuccessionItemFlow";
    function isSuccessionItemFlow(item) {
      return exports2.reflection.isInstance(item, exports2.SuccessionItemFlow);
    }
    exports2.isSuccessionItemFlow = isSuccessionItemFlow;
    exports2.EndFeatureMembership = "EndFeatureMembership";
    function isEndFeatureMembership(item) {
      return exports2.reflection.isInstance(item, exports2.EndFeatureMembership);
    }
    exports2.isEndFeatureMembership = isEndFeatureMembership;
    exports2.ObjectiveMembership = "ObjectiveMembership";
    function isObjectiveMembership(item) {
      return exports2.reflection.isInstance(item, exports2.ObjectiveMembership);
    }
    exports2.isObjectiveMembership = isObjectiveMembership;
    exports2.ParameterMembership = "ParameterMembership";
    function isParameterMembership(item) {
      return exports2.reflection.isInstance(item, exports2.ParameterMembership);
    }
    exports2.isParameterMembership = isParameterMembership;
    exports2.RequirementConstraintMembership = "RequirementConstraintMembership";
    function isRequirementConstraintMembership(item) {
      return exports2.reflection.isInstance(item, exports2.RequirementConstraintMembership);
    }
    exports2.isRequirementConstraintMembership = isRequirementConstraintMembership;
    exports2.ResultExpressionMembership = "ResultExpressionMembership";
    function isResultExpressionMembership(item) {
      return exports2.reflection.isInstance(item, exports2.ResultExpressionMembership);
    }
    exports2.isResultExpressionMembership = isResultExpressionMembership;
    exports2.StateSubactionMembership = "StateSubactionMembership";
    function isStateSubactionMembership(item) {
      return exports2.reflection.isInstance(item, exports2.StateSubactionMembership);
    }
    exports2.isStateSubactionMembership = isStateSubactionMembership;
    exports2.TransitionFeatureMembership = "TransitionFeatureMembership";
    function isTransitionFeatureMembership(item) {
      return exports2.reflection.isInstance(item, exports2.TransitionFeatureMembership);
    }
    exports2.isTransitionFeatureMembership = isTransitionFeatureMembership;
    exports2.ViewRenderingMembership = "ViewRenderingMembership";
    function isViewRenderingMembership(item) {
      return exports2.reflection.isInstance(item, exports2.ViewRenderingMembership);
    }
    exports2.isViewRenderingMembership = isViewRenderingMembership;
    exports2.MembershipExpose = "MembershipExpose";
    function isMembershipExpose(item) {
      return exports2.reflection.isInstance(item, exports2.MembershipExpose);
    }
    exports2.isMembershipExpose = isMembershipExpose;
    exports2.NamespaceExpose = "NamespaceExpose";
    function isNamespaceExpose(item) {
      return exports2.reflection.isInstance(item, exports2.NamespaceExpose);
    }
    exports2.isNamespaceExpose = isNamespaceExpose;
    exports2.PortConjugation = "PortConjugation";
    function isPortConjugation(item) {
      return exports2.reflection.isInstance(item, exports2.PortConjugation);
    }
    exports2.isPortConjugation = isPortConjugation;
    exports2.FeatureTyping = "FeatureTyping";
    function isFeatureTyping(item) {
      return exports2.reflection.isInstance(item, exports2.FeatureTyping);
    }
    exports2.isFeatureTyping = isFeatureTyping;
    exports2.Subclassification = "Subclassification";
    function isSubclassification(item) {
      return exports2.reflection.isInstance(item, exports2.Subclassification);
    }
    exports2.isSubclassification = isSubclassification;
    exports2.Subsetting = "Subsetting";
    function isSubsetting(item) {
      return exports2.reflection.isInstance(item, exports2.Subsetting);
    }
    exports2.isSubsetting = isSubsetting;
    exports2.ElementFilterMembership = "ElementFilterMembership";
    function isElementFilterMembership(item) {
      return exports2.reflection.isInstance(item, exports2.ElementFilterMembership);
    }
    exports2.isElementFilterMembership = isElementFilterMembership;
    exports2.FeatureValue = "FeatureValue";
    function isFeatureValue(item) {
      return exports2.reflection.isInstance(item, exports2.FeatureValue);
    }
    exports2.isFeatureValue = isFeatureValue;
    exports2.VariantMembership = "VariantMembership";
    function isVariantMembership(item) {
      return exports2.reflection.isInstance(item, exports2.VariantMembership);
    }
    exports2.isVariantMembership = isVariantMembership;
    exports2.ConjugatedPortReference = "ConjugatedPortReference";
    function isConjugatedPortReference(item) {
      return exports2.reflection.isInstance(item, exports2.ConjugatedPortReference);
    }
    exports2.isConjugatedPortReference = isConjugatedPortReference;
    exports2.MetaclassReference = "MetaclassReference";
    function isMetaclassReference(item) {
      return exports2.reflection.isInstance(item, exports2.MetaclassReference);
    }
    exports2.isMetaclassReference = isMetaclassReference;
    exports2.Behavior = "Behavior";
    function isBehavior(item) {
      return exports2.reflection.isInstance(item, exports2.Behavior);
    }
    exports2.isBehavior = isBehavior;
    exports2.LifeClass = "LifeClass";
    function isLifeClass(item) {
      return exports2.reflection.isInstance(item, exports2.LifeClass);
    }
    exports2.isLifeClass = isLifeClass;
    exports2.OccurrenceDefinition = "OccurrenceDefinition";
    function isOccurrenceDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.OccurrenceDefinition);
    }
    exports2.isOccurrenceDefinition = isOccurrenceDefinition;
    exports2.Structure = "Structure";
    function isStructure(item) {
      return exports2.reflection.isInstance(item, exports2.Structure);
    }
    exports2.isStructure = isStructure;
    exports2.AttributeDefinition = "AttributeDefinition";
    function isAttributeDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.AttributeDefinition);
    }
    exports2.isAttributeDefinition = isAttributeDefinition;
    exports2.MultiplicityRange = "MultiplicityRange";
    function isMultiplicityRange(item) {
      return exports2.reflection.isInstance(item, exports2.MultiplicityRange);
    }
    exports2.isMultiplicityRange = isMultiplicityRange;
    exports2.ActionUsage = "ActionUsage";
    function isActionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.ActionUsage);
    }
    exports2.isActionUsage = isActionUsage;
    exports2.Expression = "Expression";
    function isExpression(item) {
      return exports2.reflection.isInstance(item, exports2.Expression);
    }
    exports2.isExpression = isExpression;
    exports2.AttributeUsage = "AttributeUsage";
    function isAttributeUsage(item) {
      return exports2.reflection.isInstance(item, exports2.AttributeUsage);
    }
    exports2.isAttributeUsage = isAttributeUsage;
    exports2.OccurrenceUsage = "OccurrenceUsage";
    function isOccurrenceUsage(item) {
      return exports2.reflection.isInstance(item, exports2.OccurrenceUsage);
    }
    exports2.isOccurrenceUsage = isOccurrenceUsage;
    exports2.ReferenceUsage = "ReferenceUsage";
    function isReferenceUsage(item) {
      return exports2.reflection.isInstance(item, exports2.ReferenceUsage);
    }
    exports2.isReferenceUsage = isReferenceUsage;
    exports2.AllocationDefinition = "AllocationDefinition";
    function isAllocationDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.AllocationDefinition);
    }
    exports2.isAllocationDefinition = isAllocationDefinition;
    exports2.InterfaceDefinition = "InterfaceDefinition";
    function isInterfaceDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.InterfaceDefinition);
    }
    exports2.isInterfaceDefinition = isInterfaceDefinition;
    exports2.AllocationUsage = "AllocationUsage";
    function isAllocationUsage(item) {
      return exports2.reflection.isInstance(item, exports2.AllocationUsage);
    }
    exports2.isAllocationUsage = isAllocationUsage;
    exports2.InterfaceUsage = "InterfaceUsage";
    function isInterfaceUsage(item) {
      return exports2.reflection.isInstance(item, exports2.InterfaceUsage);
    }
    exports2.isInterfaceUsage = isInterfaceUsage;
    exports2.SuccessionFlowConnectionUsage = "SuccessionFlowConnectionUsage";
    function isSuccessionFlowConnectionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.SuccessionFlowConnectionUsage);
    }
    exports2.isSuccessionFlowConnectionUsage = isSuccessionFlowConnectionUsage;
    exports2.ActorMembership = "ActorMembership";
    function isActorMembership(item) {
      return exports2.reflection.isInstance(item, exports2.ActorMembership);
    }
    exports2.isActorMembership = isActorMembership;
    exports2.ReturnParameterMembership = "ReturnParameterMembership";
    function isReturnParameterMembership(item) {
      return exports2.reflection.isInstance(item, exports2.ReturnParameterMembership);
    }
    exports2.isReturnParameterMembership = isReturnParameterMembership;
    exports2.StakeholderMembership = "StakeholderMembership";
    function isStakeholderMembership(item) {
      return exports2.reflection.isInstance(item, exports2.StakeholderMembership);
    }
    exports2.isStakeholderMembership = isStakeholderMembership;
    exports2.SubjectMembership = "SubjectMembership";
    function isSubjectMembership(item) {
      return exports2.reflection.isInstance(item, exports2.SubjectMembership);
    }
    exports2.isSubjectMembership = isSubjectMembership;
    exports2.FramedConcernMembership = "FramedConcernMembership";
    function isFramedConcernMembership(item) {
      return exports2.reflection.isInstance(item, exports2.FramedConcernMembership);
    }
    exports2.isFramedConcernMembership = isFramedConcernMembership;
    exports2.RequirementVerificationMembership = "RequirementVerificationMembership";
    function isRequirementVerificationMembership(item) {
      return exports2.reflection.isInstance(item, exports2.RequirementVerificationMembership);
    }
    exports2.isRequirementVerificationMembership = isRequirementVerificationMembership;
    exports2.ConjugatedPortTyping = "ConjugatedPortTyping";
    function isConjugatedPortTyping(item) {
      return exports2.reflection.isInstance(item, exports2.ConjugatedPortTyping);
    }
    exports2.isConjugatedPortTyping = isConjugatedPortTyping;
    exports2.CrossSubsetting = "CrossSubsetting";
    function isCrossSubsetting(item) {
      return exports2.reflection.isInstance(item, exports2.CrossSubsetting);
    }
    exports2.isCrossSubsetting = isCrossSubsetting;
    exports2.Redefinition = "Redefinition";
    function isRedefinition(item) {
      return exports2.reflection.isInstance(item, exports2.Redefinition);
    }
    exports2.isRedefinition = isRedefinition;
    exports2.ReferenceSubsetting = "ReferenceSubsetting";
    function isReferenceSubsetting(item) {
      return exports2.reflection.isInstance(item, exports2.ReferenceSubsetting);
    }
    exports2.isReferenceSubsetting = isReferenceSubsetting;
    exports2.ActionDefinition = "ActionDefinition";
    function isActionDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.ActionDefinition);
    }
    exports2.isActionDefinition = isActionDefinition;
    exports2.SysMLFunction = "SysMLFunction";
    function isSysMLFunction(item) {
      return exports2.reflection.isInstance(item, exports2.SysMLFunction);
    }
    exports2.isSysMLFunction = isSysMLFunction;
    exports2.ConstraintDefinition = "ConstraintDefinition";
    function isConstraintDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.ConstraintDefinition);
    }
    exports2.isConstraintDefinition = isConstraintDefinition;
    exports2.ItemDefinition = "ItemDefinition";
    function isItemDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.ItemDefinition);
    }
    exports2.isItemDefinition = isItemDefinition;
    exports2.PortDefinition = "PortDefinition";
    function isPortDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.PortDefinition);
    }
    exports2.isPortDefinition = isPortDefinition;
    exports2.Metaclass = "Metaclass";
    function isMetaclass(item) {
      return exports2.reflection.isInstance(item, exports2.Metaclass);
    }
    exports2.isMetaclass = isMetaclass;
    exports2.EnumerationDefinition = "EnumerationDefinition";
    function isEnumerationDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.EnumerationDefinition);
    }
    exports2.isEnumerationDefinition = isEnumerationDefinition;
    exports2.AcceptActionUsage = "AcceptActionUsage";
    function isAcceptActionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.AcceptActionUsage);
    }
    exports2.isAcceptActionUsage = isAcceptActionUsage;
    exports2.AssignmentActionUsage = "AssignmentActionUsage";
    function isAssignmentActionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.AssignmentActionUsage);
    }
    exports2.isAssignmentActionUsage = isAssignmentActionUsage;
    exports2.CalculationUsage = "CalculationUsage";
    function isCalculationUsage(item) {
      return exports2.reflection.isInstance(item, exports2.CalculationUsage);
    }
    exports2.isCalculationUsage = isCalculationUsage;
    exports2.ControlNode = "ControlNode";
    function isControlNode(item) {
      return exports2.reflection.isInstance(item, exports2.ControlNode);
    }
    exports2.isControlNode = isControlNode;
    exports2.IfActionUsage = "IfActionUsage";
    function isIfActionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.IfActionUsage);
    }
    exports2.isIfActionUsage = isIfActionUsage;
    exports2.LoopActionUsage = "LoopActionUsage";
    function isLoopActionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.LoopActionUsage);
    }
    exports2.isLoopActionUsage = isLoopActionUsage;
    exports2.PerformActionUsage = "PerformActionUsage";
    function isPerformActionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.PerformActionUsage);
    }
    exports2.isPerformActionUsage = isPerformActionUsage;
    exports2.SendActionUsage = "SendActionUsage";
    function isSendActionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.SendActionUsage);
    }
    exports2.isSendActionUsage = isSendActionUsage;
    exports2.StateUsage = "StateUsage";
    function isStateUsage(item) {
      return exports2.reflection.isInstance(item, exports2.StateUsage);
    }
    exports2.isStateUsage = isStateUsage;
    exports2.TerminateActionUsage = "TerminateActionUsage";
    function isTerminateActionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.TerminateActionUsage);
    }
    exports2.isTerminateActionUsage = isTerminateActionUsage;
    exports2.TransitionUsage = "TransitionUsage";
    function isTransitionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.TransitionUsage);
    }
    exports2.isTransitionUsage = isTransitionUsage;
    exports2.BooleanExpression = "BooleanExpression";
    function isBooleanExpression(item) {
      return exports2.reflection.isInstance(item, exports2.BooleanExpression);
    }
    exports2.isBooleanExpression = isBooleanExpression;
    exports2.FeatureReferenceExpression = "FeatureReferenceExpression";
    function isFeatureReferenceExpression(item) {
      return exports2.reflection.isInstance(item, exports2.FeatureReferenceExpression);
    }
    exports2.isFeatureReferenceExpression = isFeatureReferenceExpression;
    exports2.InvocationExpression = "InvocationExpression";
    function isInvocationExpression(item) {
      return exports2.reflection.isInstance(item, exports2.InvocationExpression);
    }
    exports2.isInvocationExpression = isInvocationExpression;
    exports2.LiteralExpression = "LiteralExpression";
    function isLiteralExpression(item) {
      return exports2.reflection.isInstance(item, exports2.LiteralExpression);
    }
    exports2.isLiteralExpression = isLiteralExpression;
    exports2.MetadataAccessExpression = "MetadataAccessExpression";
    function isMetadataAccessExpression(item) {
      return exports2.reflection.isInstance(item, exports2.MetadataAccessExpression);
    }
    exports2.isMetadataAccessExpression = isMetadataAccessExpression;
    exports2.NullExpression = "NullExpression";
    function isNullExpression(item) {
      return exports2.reflection.isInstance(item, exports2.NullExpression);
    }
    exports2.isNullExpression = isNullExpression;
    exports2.EnumerationUsage = "EnumerationUsage";
    function isEnumerationUsage(item) {
      return exports2.reflection.isInstance(item, exports2.EnumerationUsage);
    }
    exports2.isEnumerationUsage = isEnumerationUsage;
    exports2.ConstraintUsage = "ConstraintUsage";
    function isConstraintUsage(item) {
      return exports2.reflection.isInstance(item, exports2.ConstraintUsage);
    }
    exports2.isConstraintUsage = isConstraintUsage;
    exports2.EventOccurrenceUsage = "EventOccurrenceUsage";
    function isEventOccurrenceUsage(item) {
      return exports2.reflection.isInstance(item, exports2.EventOccurrenceUsage);
    }
    exports2.isEventOccurrenceUsage = isEventOccurrenceUsage;
    exports2.ItemUsage = "ItemUsage";
    function isItemUsage(item) {
      return exports2.reflection.isInstance(item, exports2.ItemUsage);
    }
    exports2.isItemUsage = isItemUsage;
    exports2.PortUsage = "PortUsage";
    function isPortUsage(item) {
      return exports2.reflection.isInstance(item, exports2.PortUsage);
    }
    exports2.isPortUsage = isPortUsage;
    exports2.CalculationDefinition = "CalculationDefinition";
    function isCalculationDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.CalculationDefinition);
    }
    exports2.isCalculationDefinition = isCalculationDefinition;
    exports2.StateDefinition = "StateDefinition";
    function isStateDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.StateDefinition);
    }
    exports2.isStateDefinition = isStateDefinition;
    exports2.Predicate = "Predicate";
    function isPredicate(item) {
      return exports2.reflection.isInstance(item, exports2.Predicate);
    }
    exports2.isPredicate = isPredicate;
    exports2.RequirementDefinition = "RequirementDefinition";
    function isRequirementDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.RequirementDefinition);
    }
    exports2.isRequirementDefinition = isRequirementDefinition;
    exports2.MetadataDefinition = "MetadataDefinition";
    function isMetadataDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.MetadataDefinition);
    }
    exports2.isMetadataDefinition = isMetadataDefinition;
    exports2.PartDefinition = "PartDefinition";
    function isPartDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.PartDefinition);
    }
    exports2.isPartDefinition = isPartDefinition;
    exports2.ConjugatedPortDefinition = "ConjugatedPortDefinition";
    function isConjugatedPortDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.ConjugatedPortDefinition);
    }
    exports2.isConjugatedPortDefinition = isConjugatedPortDefinition;
    exports2.CaseUsage = "CaseUsage";
    function isCaseUsage(item) {
      return exports2.reflection.isInstance(item, exports2.CaseUsage);
    }
    exports2.isCaseUsage = isCaseUsage;
    exports2.DecisionNode = "DecisionNode";
    function isDecisionNode(item) {
      return exports2.reflection.isInstance(item, exports2.DecisionNode);
    }
    exports2.isDecisionNode = isDecisionNode;
    exports2.ForkNode = "ForkNode";
    function isForkNode(item) {
      return exports2.reflection.isInstance(item, exports2.ForkNode);
    }
    exports2.isForkNode = isForkNode;
    exports2.JoinNode = "JoinNode";
    function isJoinNode(item) {
      return exports2.reflection.isInstance(item, exports2.JoinNode);
    }
    exports2.isJoinNode = isJoinNode;
    exports2.MergeNode = "MergeNode";
    function isMergeNode(item) {
      return exports2.reflection.isInstance(item, exports2.MergeNode);
    }
    exports2.isMergeNode = isMergeNode;
    exports2.ForLoopActionUsage = "ForLoopActionUsage";
    function isForLoopActionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.ForLoopActionUsage);
    }
    exports2.isForLoopActionUsage = isForLoopActionUsage;
    exports2.WhileLoopActionUsage = "WhileLoopActionUsage";
    function isWhileLoopActionUsage(item) {
      return exports2.reflection.isInstance(item, exports2.WhileLoopActionUsage);
    }
    exports2.isWhileLoopActionUsage = isWhileLoopActionUsage;
    exports2.ExhibitStateUsage = "ExhibitStateUsage";
    function isExhibitStateUsage(item) {
      return exports2.reflection.isInstance(item, exports2.ExhibitStateUsage);
    }
    exports2.isExhibitStateUsage = isExhibitStateUsage;
    exports2.IncludeUseCaseUsage = "IncludeUseCaseUsage";
    function isIncludeUseCaseUsage(item) {
      return exports2.reflection.isInstance(item, exports2.IncludeUseCaseUsage);
    }
    exports2.isIncludeUseCaseUsage = isIncludeUseCaseUsage;
    exports2.Invariant = "Invariant";
    function isInvariant(item) {
      return exports2.reflection.isInstance(item, exports2.Invariant);
    }
    exports2.isInvariant = isInvariant;
    exports2.OperatorExpression = "OperatorExpression";
    function isOperatorExpression(item) {
      return exports2.reflection.isInstance(item, exports2.OperatorExpression);
    }
    exports2.isOperatorExpression = isOperatorExpression;
    exports2.TriggerInvocationExpression = "TriggerInvocationExpression";
    function isTriggerInvocationExpression(item) {
      return exports2.reflection.isInstance(item, exports2.TriggerInvocationExpression);
    }
    exports2.isTriggerInvocationExpression = isTriggerInvocationExpression;
    exports2.LiteralBoolean = "LiteralBoolean";
    function isLiteralBoolean(item) {
      return exports2.reflection.isInstance(item, exports2.LiteralBoolean);
    }
    exports2.isLiteralBoolean = isLiteralBoolean;
    exports2.LiteralInfinity = "LiteralInfinity";
    function isLiteralInfinity(item) {
      return exports2.reflection.isInstance(item, exports2.LiteralInfinity);
    }
    exports2.isLiteralInfinity = isLiteralInfinity;
    exports2.LiteralNumber = "LiteralNumber";
    function isLiteralNumber(item) {
      return exports2.reflection.isInstance(item, exports2.LiteralNumber);
    }
    exports2.isLiteralNumber = isLiteralNumber;
    exports2.LiteralString = "LiteralString";
    function isLiteralString(item) {
      return exports2.reflection.isInstance(item, exports2.LiteralString);
    }
    exports2.isLiteralString = isLiteralString;
    exports2.AssertConstraintUsage = "AssertConstraintUsage";
    function isAssertConstraintUsage(item) {
      return exports2.reflection.isInstance(item, exports2.AssertConstraintUsage);
    }
    exports2.isAssertConstraintUsage = isAssertConstraintUsage;
    exports2.RequirementUsage = "RequirementUsage";
    function isRequirementUsage(item) {
      return exports2.reflection.isInstance(item, exports2.RequirementUsage);
    }
    exports2.isRequirementUsage = isRequirementUsage;
    exports2.PartUsage = "PartUsage";
    function isPartUsage(item) {
      return exports2.reflection.isInstance(item, exports2.PartUsage);
    }
    exports2.isPartUsage = isPartUsage;
    exports2.CaseDefinition = "CaseDefinition";
    function isCaseDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.CaseDefinition);
    }
    exports2.isCaseDefinition = isCaseDefinition;
    exports2.ConcernDefinition = "ConcernDefinition";
    function isConcernDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.ConcernDefinition);
    }
    exports2.isConcernDefinition = isConcernDefinition;
    exports2.ViewpointDefinition = "ViewpointDefinition";
    function isViewpointDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.ViewpointDefinition);
    }
    exports2.isViewpointDefinition = isViewpointDefinition;
    exports2.RenderingDefinition = "RenderingDefinition";
    function isRenderingDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.RenderingDefinition);
    }
    exports2.isRenderingDefinition = isRenderingDefinition;
    exports2.ViewDefinition = "ViewDefinition";
    function isViewDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.ViewDefinition);
    }
    exports2.isViewDefinition = isViewDefinition;
    exports2.AnalysisCaseUsage = "AnalysisCaseUsage";
    function isAnalysisCaseUsage(item) {
      return exports2.reflection.isInstance(item, exports2.AnalysisCaseUsage);
    }
    exports2.isAnalysisCaseUsage = isAnalysisCaseUsage;
    exports2.UseCaseUsage = "UseCaseUsage";
    function isUseCaseUsage(item) {
      return exports2.reflection.isInstance(item, exports2.UseCaseUsage);
    }
    exports2.isUseCaseUsage = isUseCaseUsage;
    exports2.VerificationCaseUsage = "VerificationCaseUsage";
    function isVerificationCaseUsage(item) {
      return exports2.reflection.isInstance(item, exports2.VerificationCaseUsage);
    }
    exports2.isVerificationCaseUsage = isVerificationCaseUsage;
    exports2.CollectExpression = "CollectExpression";
    function isCollectExpression(item) {
      return exports2.reflection.isInstance(item, exports2.CollectExpression);
    }
    exports2.isCollectExpression = isCollectExpression;
    exports2.FeatureChainExpression = "FeatureChainExpression";
    function isFeatureChainExpression(item) {
      return exports2.reflection.isInstance(item, exports2.FeatureChainExpression);
    }
    exports2.isFeatureChainExpression = isFeatureChainExpression;
    exports2.IndexExpression = "IndexExpression";
    function isIndexExpression(item) {
      return exports2.reflection.isInstance(item, exports2.IndexExpression);
    }
    exports2.isIndexExpression = isIndexExpression;
    exports2.SelectExpression = "SelectExpression";
    function isSelectExpression(item) {
      return exports2.reflection.isInstance(item, exports2.SelectExpression);
    }
    exports2.isSelectExpression = isSelectExpression;
    exports2.SatisfyRequirementUsage = "SatisfyRequirementUsage";
    function isSatisfyRequirementUsage(item) {
      return exports2.reflection.isInstance(item, exports2.SatisfyRequirementUsage);
    }
    exports2.isSatisfyRequirementUsage = isSatisfyRequirementUsage;
    exports2.ConcernUsage = "ConcernUsage";
    function isConcernUsage(item) {
      return exports2.reflection.isInstance(item, exports2.ConcernUsage);
    }
    exports2.isConcernUsage = isConcernUsage;
    exports2.ViewpointUsage = "ViewpointUsage";
    function isViewpointUsage(item) {
      return exports2.reflection.isInstance(item, exports2.ViewpointUsage);
    }
    exports2.isViewpointUsage = isViewpointUsage;
    exports2.RenderingUsage = "RenderingUsage";
    function isRenderingUsage(item) {
      return exports2.reflection.isInstance(item, exports2.RenderingUsage);
    }
    exports2.isRenderingUsage = isRenderingUsage;
    exports2.ViewUsage = "ViewUsage";
    function isViewUsage(item) {
      return exports2.reflection.isInstance(item, exports2.ViewUsage);
    }
    exports2.isViewUsage = isViewUsage;
    exports2.AnalysisCaseDefinition = "AnalysisCaseDefinition";
    function isAnalysisCaseDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.AnalysisCaseDefinition);
    }
    exports2.isAnalysisCaseDefinition = isAnalysisCaseDefinition;
    exports2.UseCaseDefinition = "UseCaseDefinition";
    function isUseCaseDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.UseCaseDefinition);
    }
    exports2.isUseCaseDefinition = isUseCaseDefinition;
    exports2.VerificationCaseDefinition = "VerificationCaseDefinition";
    function isVerificationCaseDefinition(item) {
      return exports2.reflection.isInstance(item, exports2.VerificationCaseDefinition);
    }
    exports2.isVerificationCaseDefinition = isVerificationCaseDefinition;
    var SysMlAstReflection = class extends langium_1.AbstractAstReflection {
      getAllTypes() {
        return ["AcceptActionUsage", "ActionDefinition", "ActionUsage", "ActorMembership", "AllocationDefinition", "AllocationUsage", "AnalysisCaseDefinition", "AnalysisCaseUsage", "AnnotatingElement", "Annotation", "AssertConstraintUsage", "AssignmentActionUsage", "Association", "AssociationStructure", "AttributeDefinition", "AttributeUsage", "Behavior", "BindingConnector", "BindingConnectorAsUsage", "BooleanExpression", "CalculationDefinition", "CalculationUsage", "CaseDefinition", "CaseUsage", "Class", "Classifier", "ClassifierReference", "CollectExpression", "Comment", "ConcernDefinition", "ConcernUsage", "ConjugatedPortDefinition", "ConjugatedPortReference", "ConjugatedPortTyping", "Conjugation", "ConnectionDefinition", "ConnectionUsage", "Connector", "ConnectorAsUsage", "ConstraintDefinition", "ConstraintUsage", "ControlNode", "CrossSubsetting", "DataType", "DecisionNode", "Definition", "Dependency", "Differencing", "Disjoining", "Documentation", "Element", "ElementFilterMembership", "ElementReference", "EndFeatureMembership", "EnumerationDefinition", "EnumerationUsage", "EventOccurrenceUsage", "ExhibitStateUsage", "Expose", "Expression", "Feature", "FeatureChainExpression", "FeatureChaining", "FeatureInverting", "FeatureMembership", "FeatureReference", "FeatureReferenceExpression", "FeatureRelationship", "FeatureTyping", "FeatureValue", "Featuring", "FlowConnectionDefinition", "FlowConnectionUsage", "ForLoopActionUsage", "ForkNode", "FramedConcernMembership", "IfActionUsage", "Import", "IncludeUseCaseUsage", "IndexExpression", "Inheritance", "InlineExpression", "Interaction", "InterfaceDefinition", "InterfaceUsage", "Intersecting", "Invariant", "InvocationExpression", "ItemDefinition", "ItemFeature", "ItemFlow", "ItemFlowEnd", "ItemUsage", "JoinNode", "LibraryPackage", "LifeClass", "LiteralBoolean", "LiteralExpression", "LiteralInfinity", "LiteralNumber", "LiteralString", "LoopActionUsage", "Membership", "MembershipExpose", "MembershipImport", "MembershipReference", "MergeNode", "Metaclass", "MetaclassReference", "MetadataAccessExpression", "MetadataDefinition", "MetadataFeature", "MetadataUsage", "Multiplicity", "MultiplicityRange", "Namespace", "NamespaceExpose", "NamespaceImport", "NamespaceReference", "NonOwnerType", "NullExpression", "ObjectiveMembership", "OccurrenceDefinition", "OccurrenceUsage", "OperatorExpression", "OwningMembership", "Package", "ParameterMembership", "PartDefinition", "PartUsage", "PerformActionUsage", "PortConjugation", "PortDefinition", "PortUsage", "Predicate", "Redefinition", "ReferenceSubsetting", "ReferenceUsage", "Relationship", "RenderingDefinition", "RenderingUsage", "RequirementConstraintMembership", "RequirementDefinition", "RequirementUsage", "RequirementVerificationMembership", "ResultExpressionMembership", "ReturnParameterMembership", "SatisfyRequirementUsage", "SelectExpression", "SendActionUsage", "Specialization", "StakeholderMembership", "StateDefinition", "StateSubactionMembership", "StateUsage", "Step", "Structure", "Subclassification", "SubjectMembership", "Subsetting", "Succession", "SuccessionAsUsage", "SuccessionFlowConnectionUsage", "SuccessionItemFlow", "SysMLFunction", "TerminateActionUsage", "TextualAnnotatingElement", "TextualRepresentation", "TransitionFeatureMembership", "TransitionUsage", "TransparentElement", "TriggerInvocationExpression", "Type", "TypeFeaturing", "TypeReference", "TypeRelationship", "Unioning", "Usage", "UseCaseDefinition", "UseCaseUsage", "VariantMembership", "VerificationCaseDefinition", "VerificationCaseUsage", "ViewDefinition", "ViewRenderingMembership", "ViewUsage", "ViewpointDefinition", "ViewpointUsage", "WhileLoopActionUsage"];
      }
      computeIsSubtype(subtype, supertype) {
        switch (subtype) {
          case exports2.AcceptActionUsage:
          case exports2.AssignmentActionUsage:
          case exports2.ControlNode:
          case exports2.IfActionUsage:
          case exports2.SendActionUsage:
          case exports2.StateUsage:
          case exports2.TerminateActionUsage:
          case exports2.TransitionUsage: {
            return this.isSubtype(exports2.ActionUsage, supertype);
          }
          case exports2.ActionDefinition: {
            return this.isSubtype(exports2.Behavior, supertype) || this.isSubtype(exports2.OccurrenceDefinition, supertype);
          }
          case exports2.ActionUsage: {
            return this.isSubtype(exports2.OccurrenceUsage, supertype) || this.isSubtype(exports2.Step, supertype);
          }
          case exports2.ActorMembership:
          case exports2.ReturnParameterMembership:
          case exports2.StakeholderMembership:
          case exports2.SubjectMembership: {
            return this.isSubtype(exports2.ParameterMembership, supertype);
          }
          case exports2.AllocationDefinition:
          case exports2.InterfaceDefinition: {
            return this.isSubtype(exports2.ConnectionDefinition, supertype);
          }
          case exports2.AllocationUsage:
          case exports2.InterfaceUsage: {
            return this.isSubtype(exports2.ConnectionUsage, supertype);
          }
          case exports2.AnalysisCaseDefinition:
          case exports2.UseCaseDefinition:
          case exports2.VerificationCaseDefinition: {
            return this.isSubtype(exports2.CaseDefinition, supertype);
          }
          case exports2.AnalysisCaseUsage:
          case exports2.UseCaseUsage:
          case exports2.VerificationCaseUsage: {
            return this.isSubtype(exports2.CaseUsage, supertype);
          }
          case exports2.AnnotatingElement:
          case exports2.Namespace:
          case exports2.Relationship: {
            return this.isSubtype(exports2.Element, supertype);
          }
          case exports2.Annotation:
          case exports2.Membership: {
            return this.isSubtype(exports2.NonOwnerType, supertype) || this.isSubtype(exports2.Relationship, supertype);
          }
          case exports2.AssertConstraintUsage: {
            return this.isSubtype(exports2.ConstraintUsage, supertype) || this.isSubtype(exports2.Invariant, supertype);
          }
          case exports2.Association: {
            return this.isSubtype(exports2.Classifier, supertype) || this.isSubtype(exports2.Relationship, supertype);
          }
          case exports2.AssociationStructure: {
            return this.isSubtype(exports2.Association, supertype) || this.isSubtype(exports2.Structure, supertype);
          }
          case exports2.AttributeDefinition: {
            return this.isSubtype(exports2.DataType, supertype) || this.isSubtype(exports2.Definition, supertype);
          }
          case exports2.AttributeUsage:
          case exports2.OccurrenceUsage:
          case exports2.ReferenceUsage: {
            return this.isSubtype(exports2.Usage, supertype);
          }
          case exports2.Behavior:
          case exports2.LifeClass:
          case exports2.Structure: {
            return this.isSubtype(exports2.Class, supertype);
          }
          case exports2.BindingConnector:
          case exports2.Succession: {
            return this.isSubtype(exports2.Connector, supertype);
          }
          case exports2.BindingConnectorAsUsage: {
            return this.isSubtype(exports2.BindingConnector, supertype) || this.isSubtype(exports2.ConnectorAsUsage, supertype);
          }
          case exports2.BooleanExpression: {
            return this.isSubtype(exports2.Expression, supertype);
          }
          case exports2.CalculationDefinition: {
            return this.isSubtype(exports2.ActionDefinition, supertype) || this.isSubtype(exports2.SysMLFunction, supertype);
          }
          case exports2.CalculationUsage: {
            return this.isSubtype(exports2.ActionUsage, supertype) || this.isSubtype(exports2.Expression, supertype);
          }
          case exports2.CaseDefinition: {
            return this.isSubtype(exports2.CalculationDefinition, supertype);
          }
          case exports2.CaseUsage: {
            return this.isSubtype(exports2.CalculationUsage, supertype);
          }
          case exports2.Class:
          case exports2.DataType:
          case exports2.Definition: {
            return this.isSubtype(exports2.Classifier, supertype);
          }
          case exports2.Classifier:
          case exports2.Feature: {
            return this.isSubtype(exports2.Type, supertype);
          }
          case exports2.ClassifierReference:
          case exports2.FeatureReference: {
            return this.isSubtype(exports2.TypeReference, supertype);
          }
          case exports2.CollectExpression:
          case exports2.FeatureChainExpression:
          case exports2.IndexExpression:
          case exports2.SelectExpression: {
            return this.isSubtype(exports2.InlineExpression, supertype) || this.isSubtype(exports2.OperatorExpression, supertype);
          }
          case exports2.Comment:
          case exports2.TextualRepresentation: {
            return this.isSubtype(exports2.TextualAnnotatingElement, supertype);
          }
          case exports2.ConcernDefinition:
          case exports2.ViewpointDefinition: {
            return this.isSubtype(exports2.RequirementDefinition, supertype);
          }
          case exports2.ConcernUsage:
          case exports2.ViewpointUsage: {
            return this.isSubtype(exports2.RequirementUsage, supertype);
          }
          case exports2.ConjugatedPortDefinition: {
            return this.isSubtype(exports2.PortDefinition, supertype);
          }
          case exports2.ConjugatedPortReference:
          case exports2.MetaclassReference: {
            return this.isSubtype(exports2.ClassifierReference, supertype);
          }
          case exports2.ConjugatedPortTyping: {
            return this.isSubtype(exports2.FeatureTyping, supertype);
          }
          case exports2.Conjugation:
          case exports2.Specialization: {
            return this.isSubtype(exports2.Inheritance, supertype);
          }
          case exports2.ConnectionDefinition: {
            return this.isSubtype(exports2.AssociationStructure, supertype) || this.isSubtype(exports2.PartDefinition, supertype);
          }
          case exports2.ConnectionUsage: {
            return this.isSubtype(exports2.ConnectorAsUsage, supertype) || this.isSubtype(exports2.PartUsage, supertype);
          }
          case exports2.Connector: {
            return this.isSubtype(exports2.Feature, supertype) || this.isSubtype(exports2.Relationship, supertype);
          }
          case exports2.ConnectorAsUsage: {
            return this.isSubtype(exports2.Connector, supertype) || this.isSubtype(exports2.Usage, supertype);
          }
          case exports2.ConstraintDefinition: {
            return this.isSubtype(exports2.OccurrenceDefinition, supertype) || this.isSubtype(exports2.Predicate, supertype);
          }
          case exports2.ConstraintUsage: {
            return this.isSubtype(exports2.BooleanExpression, supertype) || this.isSubtype(exports2.OccurrenceUsage, supertype);
          }
          case exports2.CrossSubsetting:
          case exports2.Redefinition:
          case exports2.ReferenceSubsetting: {
            return this.isSubtype(exports2.Subsetting, supertype);
          }
          case exports2.DecisionNode:
          case exports2.ForkNode:
          case exports2.JoinNode:
          case exports2.MergeNode: {
            return this.isSubtype(exports2.ControlNode, supertype);
          }
          case exports2.Dependency:
          case exports2.Featuring:
          case exports2.Import:
          case exports2.Inheritance: {
            return this.isSubtype(exports2.Relationship, supertype);
          }
          case exports2.Differencing:
          case exports2.Disjoining:
          case exports2.Intersecting:
          case exports2.Unioning: {
            return this.isSubtype(exports2.Relationship, supertype) || this.isSubtype(exports2.TypeRelationship, supertype);
          }
          case exports2.Documentation: {
            return this.isSubtype(exports2.Comment, supertype);
          }
          case exports2.ElementFilterMembership:
          case exports2.FeatureValue:
          case exports2.VariantMembership: {
            return this.isSubtype(exports2.OwningMembership, supertype);
          }
          case exports2.EndFeatureMembership:
          case exports2.ObjectiveMembership:
          case exports2.ParameterMembership:
          case exports2.RequirementConstraintMembership:
          case exports2.ResultExpressionMembership:
          case exports2.StateSubactionMembership:
          case exports2.TransitionFeatureMembership:
          case exports2.ViewRenderingMembership: {
            return this.isSubtype(exports2.FeatureMembership, supertype);
          }
          case exports2.EnumerationDefinition: {
            return this.isSubtype(exports2.AttributeDefinition, supertype);
          }
          case exports2.EnumerationUsage: {
            return this.isSubtype(exports2.AttributeUsage, supertype);
          }
          case exports2.EventOccurrenceUsage:
          case exports2.ItemUsage:
          case exports2.PortUsage: {
            return this.isSubtype(exports2.OccurrenceUsage, supertype);
          }
          case exports2.ExhibitStateUsage: {
            return this.isSubtype(exports2.PerformActionUsage, supertype) || this.isSubtype(exports2.StateUsage, supertype);
          }
          case exports2.Expose:
          case exports2.MembershipImport:
          case exports2.NamespaceImport: {
            return this.isSubtype(exports2.Import, supertype);
          }
          case exports2.Expression: {
            return this.isSubtype(exports2.Step, supertype);
          }
          case exports2.FeatureChaining:
          case exports2.FeatureInverting: {
            return this.isSubtype(exports2.FeatureRelationship, supertype) || this.isSubtype(exports2.Relationship, supertype);
          }
          case exports2.FeatureMembership: {
            return this.isSubtype(exports2.Featuring, supertype) || this.isSubtype(exports2.OwningMembership, supertype);
          }
          case exports2.FeatureReferenceExpression:
          case exports2.InvocationExpression:
          case exports2.LiteralExpression:
          case exports2.MetadataAccessExpression:
          case exports2.NullExpression: {
            return this.isSubtype(exports2.Expression, supertype) || this.isSubtype(exports2.InlineExpression, supertype);
          }
          case exports2.FeatureTyping:
          case exports2.Subclassification:
          case exports2.Subsetting: {
            return this.isSubtype(exports2.Specialization, supertype);
          }
          case exports2.FlowConnectionDefinition: {
            return this.isSubtype(exports2.ActionDefinition, supertype) || this.isSubtype(exports2.Interaction, supertype);
          }
          case exports2.FlowConnectionUsage: {
            return this.isSubtype(exports2.ActionUsage, supertype) || this.isSubtype(exports2.ConnectorAsUsage, supertype) || this.isSubtype(exports2.ItemFlow, supertype);
          }
          case exports2.ForLoopActionUsage:
          case exports2.WhileLoopActionUsage: {
            return this.isSubtype(exports2.LoopActionUsage, supertype);
          }
          case exports2.FramedConcernMembership:
          case exports2.RequirementVerificationMembership: {
            return this.isSubtype(exports2.RequirementConstraintMembership, supertype);
          }
          case exports2.IncludeUseCaseUsage: {
            return this.isSubtype(exports2.PerformActionUsage, supertype) || this.isSubtype(exports2.UseCaseUsage, supertype);
          }
          case exports2.Interaction: {
            return this.isSubtype(exports2.Association, supertype) || this.isSubtype(exports2.Behavior, supertype);
          }
          case exports2.Invariant: {
            return this.isSubtype(exports2.BooleanExpression, supertype);
          }
          case exports2.ItemDefinition:
          case exports2.PortDefinition: {
            return this.isSubtype(exports2.OccurrenceDefinition, supertype) || this.isSubtype(exports2.Structure, supertype);
          }
          case exports2.ItemFeature:
          case exports2.ItemFlowEnd:
          case exports2.Multiplicity:
          case exports2.Step:
          case exports2.Usage: {
            return this.isSubtype(exports2.Feature, supertype);
          }
          case exports2.ItemFlow: {
            return this.isSubtype(exports2.Connector, supertype) || this.isSubtype(exports2.Step, supertype);
          }
          case exports2.LibraryPackage: {
            return this.isSubtype(exports2.Package, supertype);
          }
          case exports2.LiteralBoolean:
          case exports2.LiteralInfinity:
          case exports2.LiteralNumber:
          case exports2.LiteralString: {
            return this.isSubtype(exports2.LiteralExpression, supertype);
          }
          case exports2.LoopActionUsage: {
            return this.isSubtype(exports2.ActionUsage, supertype) || this.isSubtype(exports2.TransparentElement, supertype);
          }
          case exports2.MembershipExpose: {
            return this.isSubtype(exports2.Expose, supertype) || this.isSubtype(exports2.MembershipImport, supertype);
          }
          case exports2.MembershipReference:
          case exports2.NamespaceReference: {
            return this.isSubtype(exports2.ElementReference, supertype);
          }
          case exports2.Metaclass: {
            return this.isSubtype(exports2.Structure, supertype);
          }
          case exports2.MetadataDefinition: {
            return this.isSubtype(exports2.ItemDefinition, supertype) || this.isSubtype(exports2.Metaclass, supertype);
          }
          case exports2.MetadataFeature: {
            return this.isSubtype(exports2.AnnotatingElement, supertype) || this.isSubtype(exports2.Feature, supertype);
          }
          case exports2.MetadataUsage: {
            return this.isSubtype(exports2.ItemUsage, supertype) || this.isSubtype(exports2.MetadataFeature, supertype);
          }
          case exports2.MultiplicityRange: {
            return this.isSubtype(exports2.Multiplicity, supertype);
          }
          case exports2.NamespaceExpose: {
            return this.isSubtype(exports2.Expose, supertype) || this.isSubtype(exports2.NamespaceImport, supertype);
          }
          case exports2.NonOwnerType: {
            return this.isSubtype(exports2.TransparentElement, supertype);
          }
          case exports2.OccurrenceDefinition: {
            return this.isSubtype(exports2.Class, supertype) || this.isSubtype(exports2.Definition, supertype);
          }
          case exports2.OperatorExpression: {
            return this.isSubtype(exports2.InlineExpression, supertype) || this.isSubtype(exports2.InvocationExpression, supertype);
          }
          case exports2.OwningMembership: {
            return this.isSubtype(exports2.Membership, supertype);
          }
          case exports2.Package:
          case exports2.Type: {
            return this.isSubtype(exports2.Namespace, supertype);
          }
          case exports2.PartDefinition: {
            return this.isSubtype(exports2.ItemDefinition, supertype);
          }
          case exports2.PartUsage: {
            return this.isSubtype(exports2.ItemUsage, supertype);
          }
          case exports2.PerformActionUsage: {
            return this.isSubtype(exports2.ActionUsage, supertype) || this.isSubtype(exports2.EventOccurrenceUsage, supertype);
          }
          case exports2.PortConjugation: {
            return this.isSubtype(exports2.Conjugation, supertype);
          }
          case exports2.Predicate: {
            return this.isSubtype(exports2.SysMLFunction, supertype);
          }
          case exports2.RenderingDefinition:
          case exports2.ViewDefinition: {
            return this.isSubtype(exports2.PartDefinition, supertype);
          }
          case exports2.RenderingUsage:
          case exports2.ViewUsage: {
            return this.isSubtype(exports2.PartUsage, supertype);
          }
          case exports2.RequirementDefinition: {
            return this.isSubtype(exports2.ConstraintDefinition, supertype);
          }
          case exports2.RequirementUsage: {
            return this.isSubtype(exports2.ConstraintUsage, supertype);
          }
          case exports2.SatisfyRequirementUsage: {
            return this.isSubtype(exports2.AssertConstraintUsage, supertype) || this.isSubtype(exports2.RequirementUsage, supertype);
          }
          case exports2.StateDefinition: {
            return this.isSubtype(exports2.ActionDefinition, supertype);
          }
          case exports2.SuccessionAsUsage: {
            return this.isSubtype(exports2.ConnectorAsUsage, supertype) || this.isSubtype(exports2.Succession, supertype);
          }
          case exports2.SuccessionFlowConnectionUsage: {
            return this.isSubtype(exports2.FlowConnectionUsage, supertype) || this.isSubtype(exports2.SuccessionItemFlow, supertype);
          }
          case exports2.SuccessionItemFlow: {
            return this.isSubtype(exports2.ItemFlow, supertype) || this.isSubtype(exports2.Succession, supertype);
          }
          case exports2.SysMLFunction: {
            return this.isSubtype(exports2.Behavior, supertype);
          }
          case exports2.TextualAnnotatingElement: {
            return this.isSubtype(exports2.AnnotatingElement, supertype);
          }
          case exports2.TriggerInvocationExpression: {
            return this.isSubtype(exports2.InvocationExpression, supertype);
          }
          case exports2.TypeFeaturing: {
            return this.isSubtype(exports2.FeatureRelationship, supertype) || this.isSubtype(exports2.Featuring, supertype);
          }
          case exports2.TypeReference: {
            return this.isSubtype(exports2.NamespaceReference, supertype);
          }
          case exports2.TypeRelationship: {
            return this.isSubtype(exports2.FeatureRelationship, supertype);
          }
          default: {
            return false;
          }
        }
      }
      getReferenceType(refInfo) {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
          case "ClassifierReference:parts":
          case "ConjugatedPortReference:parts":
          case "ElementReference:parts":
          case "FeatureReference:parts":
          case "MembershipReference:parts":
          case "MetaclassReference:parts":
          case "NamespaceReference:parts":
          case "TypeReference:parts": {
            return exports2.Element;
          }
          default: {
            throw new Error(`${referenceId} is not a valid reference id.`);
          }
        }
      }
      getTypeMetaData(type) {
        switch (type) {
          case "ElementReference": {
            return {
              name: "ElementReference",
              mandatory: [
                { name: "parts", type: "array" }
              ]
            };
          }
          case "AnnotatingElement": {
            return {
              name: "AnnotatingElement",
              mandatory: [
                { name: "about", type: "array" }
              ]
            };
          }
          case "Namespace": {
            return {
              name: "Namespace",
              mandatory: [
                { name: "children", type: "array" },
                { name: "prefixes", type: "array" }
              ]
            };
          }
          case "Relationship": {
            return {
              name: "Relationship",
              mandatory: [
                { name: "elements", type: "array" }
              ]
            };
          }
          case "Type": {
            return {
              name: "Type",
              mandatory: [
                { name: "heritage", type: "array" },
                { name: "isSufficient", type: "boolean" },
                { name: "typeRelationships", type: "array" }
              ]
            };
          }
          case "Connector": {
            return {
              name: "Connector",
              mandatory: [
                { name: "ends", type: "array" }
              ]
            };
          }
          case "Dependency": {
            return {
              name: "Dependency",
              mandatory: [
                { name: "client", type: "array" },
                { name: "prefixes", type: "array" },
                { name: "supplier", type: "array" }
              ]
            };
          }
          case "Import": {
            return {
              name: "Import",
              mandatory: [
                { name: "importsAll", type: "boolean" },
                { name: "isRecursive", type: "boolean" }
              ]
            };
          }
          case "Membership": {
            return {
              name: "Membership",
              mandatory: [
                { name: "isAlias", type: "boolean" }
              ]
            };
          }
          case "LibraryPackage": {
            return {
              name: "LibraryPackage",
              mandatory: [
                { name: "isStandard", type: "boolean" }
              ]
            };
          }
          case "Feature": {
            return {
              name: "Feature",
              mandatory: [
                { name: "isNonunique", type: "boolean" },
                { name: "isOrdered", type: "boolean" }
              ]
            };
          }
          case "Definition": {
            return {
              name: "Definition",
              mandatory: [
                { name: "isIndividual", type: "boolean" },
                { name: "isVariation", type: "boolean" }
              ]
            };
          }
          case "Usage": {
            return {
              name: "Usage",
              mandatory: [
                { name: "isIndividual", type: "boolean" },
                { name: "isReference", type: "boolean" },
                { name: "isVariation", type: "boolean" }
              ]
            };
          }
          case "FlowConnectionUsage": {
            return {
              name: "FlowConnectionUsage",
              mandatory: [
                { name: "messages", type: "array" }
              ]
            };
          }
          case "FeatureValue": {
            return {
              name: "FeatureValue",
              mandatory: [
                { name: "isDefault", type: "boolean" },
                { name: "isInitial", type: "boolean" }
              ]
            };
          }
          case "StateUsage": {
            return {
              name: "StateUsage",
              mandatory: [
                { name: "isParallel", type: "boolean" }
              ]
            };
          }
          case "InvocationExpression": {
            return {
              name: "InvocationExpression",
              mandatory: [
                { name: "operands", type: "array" }
              ]
            };
          }
          case "StateDefinition": {
            return {
              name: "StateDefinition",
              mandatory: [
                { name: "isParallel", type: "boolean" }
              ]
            };
          }
          case "Invariant": {
            return {
              name: "Invariant",
              mandatory: [
                { name: "isNegated", type: "boolean" }
              ]
            };
          }
          case "LiteralBoolean": {
            return {
              name: "LiteralBoolean",
              mandatory: [
                { name: "literal", type: "boolean" }
              ]
            };
          }
          default: {
            return {
              name: type,
              mandatory: []
            };
          }
        }
      }
    };
    exports2.SysMlAstReflection = SysMlAstReflection;
    exports2.reflection = new SysMlAstReflection();
  }
});

// ../syside-languageserver/lib/generated/grammar.js
var require_grammar3 = __commonJS({
  "../syside-languageserver/lib/generated/grammar.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLGrammar = exports2.KerMLGrammar = void 0;
    var langium_1 = require_lib2();
    var loadedKerMLGrammar;
    var KerMLGrammar = () => loadedKerMLGrammar !== null && loadedKerMLGrammar !== void 0 ? loadedKerMLGrammar : loadedKerMLGrammar = (0, langium_1.loadGrammarFromJson)(`{
  "$type": "Grammar",
  "isDeclared": true,
  "name": "KerML",
  "imports": [],
  "rules": [
    {
      "$type": "ParserRule",
      "name": "RootNamespace",
      "entry": true,
      "returnType": {
        "$ref": "#/interfaces@7"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@11"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypedByToken",
      "fragment": true,
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ":"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "typed"
              },
              {
                "$type": "Keyword",
                "value": "by"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConjugatesToken",
      "fragment": true,
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "~"
          },
          {
            "$type": "Keyword",
            "value": "conjugates"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RelationshipBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@4"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RelationshipOwnedElements",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@5"
        },
        "arguments": [],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RelationshipOwnedElement",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "elements",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@7"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "elements",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@25"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "elements",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@24"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "elements",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@23"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Dependency",
      "returnType": {
        "$ref": "#/interfaces@54"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "prefixes",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@153"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": "dependency"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": "from"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "client",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@252"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "client",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@252"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": "to"
          },
          {
            "$type": "Assignment",
            "feature": "supplier",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@252"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "supplier",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@252"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedAnnotation",
      "returnType": {
        "$ref": "#/interfaces@0"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "source",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@8"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AnnotatingElement",
      "returnType": {
        "$ref": "#/interfaces@1"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@248"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@249"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@250"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@157"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Namespace",
      "returnType": {
        "$ref": "#/interfaces@7"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@155"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "namespace"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@228"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@10"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamespaceBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@11"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamespaceBodyElements",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@12"
        },
        "arguments": [],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamespaceBodyElement",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@20"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@16"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@13"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@14"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@15"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NonFeatureMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@238"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@24"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamespaceFeatureMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@238"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@25"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RelationshipMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@238"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@23"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AnnotatingMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@238"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@8"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AliasMember",
      "returnType": {
        "$ref": "#/interfaces@58"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@238"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "isAlias",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "alias"
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@228"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "for"
          },
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@252"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImportPrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@238"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "import"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@244"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImportedReference",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@252"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "isNamespace",
            "operator": "=",
            "terminal": {
              "$type": "Keyword",
              "value": "::*"
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "isRecursive",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "::**"
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Import",
      "returnType": {
        "$ref": "#/interfaces@55"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@18"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@19"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@21"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FilterPackage",
      "returnType": {
        "$ref": "#/interfaces@35"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "children",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@22"
          },
          "arguments": []
        },
        "cardinality": "+"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FilterPackageMember",
      "returnType": {
        "$ref": "#/interfaces@61"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "["
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@166"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "]"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RelationshipElement",
      "returnType": {
        "$ref": "#/interfaces@37"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@6"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@48"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@50"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@91"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@61"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@52"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@92"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@96"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@89"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NonFeatureElement",
      "returnType": {
        "$ref": "#/interfaces@7"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@9"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@26"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@27"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@102"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@33"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@57"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@110"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@152"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@109"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@112"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@113"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@139"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@126"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@129"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@136"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureElement",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@66"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@127"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@134"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@137"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@138"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@114"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@122"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@124"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@140"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@141"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Package",
      "returnType": {
        "$ref": "#/interfaces@35"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@155"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "package"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@228"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@28"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LibraryPackage",
      "returnType": {
        "$ref": "#/interfaces@36"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@243"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "library"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@155"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "package"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@228"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@28"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PackageBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@29"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PackageBodyElements",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@30"
        },
        "arguments": [],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PackageBodyElement",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@14"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@13"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@16"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@15"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@20"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@31"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ElementFilterMember",
      "returnType": {
        "$ref": "#/interfaces@61"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@238"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "filter"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@166"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypePrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@237"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@155"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Type",
      "returnType": {
        "$ref": "#/interfaces@8"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "type"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@34"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@242"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@228"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "multiplicity",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@105"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@35"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@36"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@37"
            },
            "arguments": [],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SpecializationPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@229"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@49"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@49"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConjugationPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@2"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@51"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeRelationshipPart",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@38"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@39"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@40"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@41"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DisjoiningPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "disjoint"
          },
          {
            "$type": "Keyword",
            "value": "from"
          },
          {
            "$type": "Assignment",
            "feature": "typeRelationships",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@53"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "typeRelationships",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@53"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnioningPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "unions"
          },
          {
            "$type": "Assignment",
            "feature": "typeRelationships",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@54"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "typeRelationships",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@54"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "IntersectingPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "intersects"
          },
          {
            "$type": "Assignment",
            "feature": "typeRelationships",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@55"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "typeRelationships",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@55"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DifferencingPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "differences"
          },
          {
            "$type": "Assignment",
            "feature": "typeRelationships",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@56"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "typeRelationships",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@56"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@43"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeBodyElements",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@44"
        },
        "arguments": [],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeBodyElement",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@45"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@13"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@16"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@15"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@20"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@46"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@47"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeFeatureMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@238"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "member"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@25"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedFeatureMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@238"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@25"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Specialization",
      "returnType": {
        "$ref": "#/interfaces@43"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "specialization"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "subtype"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "sourceRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@254"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "sourceChain",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@275"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@229"
            },
            "arguments": []
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "targetRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@254"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "targetChain",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@275"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedSpecialization",
      "returnType": {
        "$ref": "#/interfaces@43"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@254"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Conjugation",
      "returnType": {
        "$ref": "#/interfaces@50"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "conjugation"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "conjugate"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "sourceRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@254"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "sourceChain",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@275"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@2"
            },
            "arguments": []
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "targetRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@254"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "targetChain",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@275"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedConjugation",
      "returnType": {
        "$ref": "#/interfaces@50"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@254"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Disjoining",
      "returnType": {
        "$ref": "#/interfaces@44"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "disjoining"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "disjoint"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "sourceRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@254"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "sourceChain",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@275"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": "from"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "targetRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@254"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "targetChain",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@275"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedDisjoining",
      "returnType": {
        "$ref": "#/interfaces@44"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@254"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Unioning",
      "returnType": {
        "$ref": "#/interfaces@39"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@254"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Intersecting",
      "returnType": {
        "$ref": "#/interfaces@41"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@254"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Differencing",
      "returnType": {
        "$ref": "#/interfaces@40"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@254"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Classifier",
      "returnType": {
        "$ref": "#/interfaces@9"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "classifier"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@58"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ClassifierDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@242"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@228"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "multiplicity",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@105"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@59"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@60"
                },
                "arguments": []
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@37"
            },
            "arguments": [],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SuperclassingPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@229"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@62"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@62"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ClassifierConjugationPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@2"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@63"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Subclassification",
      "returnType": {
        "$ref": "#/interfaces@48"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "specialization"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "subclassifier"
          },
          {
            "$type": "Assignment",
            "feature": "sourceRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@255"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@229"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@255"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedSubclassification",
      "returnType": {
        "$ref": "#/interfaces@48"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@255"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ClassifierConjugation",
      "returnType": {
        "$ref": "#/interfaces@50"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@255"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BasicFeaturePrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "direction",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@234"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@237"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "isComposite",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "composite"
                }
              },
              {
                "$type": "Assignment",
                "feature": "isPortion",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "portion"
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@239"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@240"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeaturePrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@241"
                    },
                    "arguments": []
                  },
                  {
                    "$type": "Assignment",
                    "feature": "crossingFeature",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@69"
                      },
                      "arguments": []
                    },
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@64"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@155"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Feature",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@241"
                    },
                    "arguments": []
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@67"
                    },
                    "arguments": []
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@64"
                    },
                    "arguments": []
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@68"
                    },
                    "arguments": []
                  }
                ]
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@100"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EndFeatureDeclarationPart",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@68"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "crossingFeature",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@69"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@68"
                },
                "arguments": []
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureDeclarationPart",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@155"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": "feature",
                "cardinality": "?"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@71"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@155"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": "feature"
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@155"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedCrossingFeatureMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@70"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedCrossingFeature",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@64"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@71"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@242"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@228"
                    },
                    "arguments": []
                  },
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@76"
                        },
                        "arguments": []
                      },
                      {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@98"
                        },
                        "arguments": []
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@76"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@98"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@72"
            },
            "arguments": [],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureRelationshipPart",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@37"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@73"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@74"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@75"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ChainingPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "chains"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "typeRelationships",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@278"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@276"
                },
                "arguments": []
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InvertingPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "inverse"
          },
          {
            "$type": "Keyword",
            "value": "of"
          },
          {
            "$type": "Assignment",
            "feature": "typeRelationships",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@88"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeFeaturingPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "featured"
          },
          {
            "$type": "Keyword",
            "value": "by"
          },
          {
            "$type": "Assignment",
            "feature": "typeRelationships",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@90"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "typeRelationships",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@90"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureSpecializationPart",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@78"
            },
            "arguments": [],
            "cardinality": "+"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@78"
                },
                "arguments": [],
                "cardinality": "+"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@77"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@78"
                },
                "arguments": [],
                "cardinality": "*"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@77"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@78"
                },
                "arguments": [],
                "cardinality": "*"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicityPart",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "multiplicity",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@105"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@245"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@245"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureSpecialization",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@79"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@81"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@83"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@84"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@85"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Typings",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@80"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@264"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypedBy",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@1"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@264"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Subsettings",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@82"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@93"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Subsets",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@230"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@93"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "References",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@231"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@94"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Crosses",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@232"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@95"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Redefinitions",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@86"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@97"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Redefines",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@233"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@97"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureInverting",
      "returnType": {
        "$ref": "#/interfaces@45"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "inverting"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "inverse"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "sourceRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@256"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "sourceChain",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@275"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": "of"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "targetRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@256"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "targetChain",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@275"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedFeatureInverting",
      "returnType": {
        "$ref": "#/interfaces@45"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@256"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeFeaturing",
      "returnType": {
        "$ref": "#/interfaces@46"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "featuring"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": "of"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "sourceRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@256"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "by"
          },
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@254"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedTypeFeaturing",
      "returnType": {
        "$ref": "#/interfaces@46"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@254"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureTyping",
      "returnType": {
        "$ref": "#/interfaces@47"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "specialization"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "typing"
          },
          {
            "$type": "Assignment",
            "feature": "sourceRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@256"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@1"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@265"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Subsetting",
      "returnType": {
        "$ref": "#/interfaces@49"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "specialization"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "subset"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "sourceRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@256"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "sourceChain",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@275"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@230"
            },
            "arguments": []
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "targetRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@256"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "targetChain",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@275"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedSubsetting",
      "returnType": {
        "$ref": "#/interfaces@49"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@256"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedReferenceSubsetting",
      "returnType": {
        "$ref": "#/interfaces@52"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@256"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedCrossSubsetting",
      "returnType": {
        "$ref": "#/interfaces@53"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@256"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Redefinition",
      "returnType": {
        "$ref": "#/interfaces@51"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "specialization"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "redefinition"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "sourceRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@256"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "sourceChain",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@275"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@233"
            },
            "arguments": []
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "targetRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@256"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "targetChain",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@275"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedRedefinition",
      "returnType": {
        "$ref": "#/interfaces@51"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@256"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureConjugationPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@2"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@99"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureConjugation",
      "returnType": {
        "$ref": "#/interfaces@50"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@256"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ValuePart",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@101"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureValue",
      "returnType": {
        "$ref": "#/interfaces@60"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "="
              },
              {
                "$type": "Assignment",
                "feature": "isInitial",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": ":="
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "isDefault",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "default"
                    }
                  },
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "="
                      },
                      {
                        "$type": "Assignment",
                        "feature": "isInitial",
                        "operator": "?=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": ":="
                        }
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@166"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Multiplicity",
      "returnType": {
        "$ref": "#/interfaces@22"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@103"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@104"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicitySubset",
      "returnType": {
        "$ref": "#/interfaces@22"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "multiplicity"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@228"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@82"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicityRange",
      "returnType": {
        "$ref": "#/interfaces@23"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "multiplicity"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@228"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@107"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedMultiplicity",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@106"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedMultiplicityRange",
      "returnType": {
        "$ref": "#/interfaces@23"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@107"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicityBounds",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "["
          },
          {
            "$type": "Assignment",
            "feature": "range",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@108"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "]"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicityExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@166"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DataType",
      "returnType": {
        "$ref": "#/interfaces@10"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "datatype"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@58"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Class",
      "returnType": {
        "$ref": "#/interfaces@11"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "class"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@58"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Structure",
      "returnType": {
        "$ref": "#/interfaces@12"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "struct"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@58"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Association",
      "returnType": {
        "$ref": "#/interfaces@14"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "assoc"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@58"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AssociationStructure",
      "returnType": {
        "$ref": "#/interfaces@15"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "assoc"
          },
          {
            "$type": "Keyword",
            "value": "struct"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@58"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Connector",
      "returnType": {
        "$ref": "#/interfaces@26"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@65"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "connector"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@71"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@100"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@115"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConnectorDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@116"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@117"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BinaryConnectorDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@71"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  },
                  {
                    "$type": "Keyword",
                    "value": "from"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@242"
                    },
                    "arguments": []
                  },
                  {
                    "$type": "Keyword",
                    "value": "from",
                    "cardinality": "?"
                  }
                ]
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@118"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "to"
          },
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@118"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NaryConnectorDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@71"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@118"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "ends",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@118"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "+"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConnectorEndMember",
      "returnType": {
        "$ref": "#/interfaces@64"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@119"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConnectorEnd",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "crossingFeature",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@120"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@227"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@231"
                },
                "arguments": []
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@94"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedCrossMultiplicityMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@121"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedCrossMultiplicity",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "multiplicity",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@105"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BindingConnector",
      "returnType": {
        "$ref": "#/interfaces@29"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@65"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "binding"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@123"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BindingConnectorDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@71"
                },
                "arguments": []
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "of"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "ends",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@118"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "="
                  },
                  {
                    "$type": "Assignment",
                    "feature": "ends",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@118"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@242"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "of",
                    "cardinality": "?"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "ends",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@118"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "="
                  },
                  {
                    "$type": "Assignment",
                    "feature": "ends",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@118"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Succession",
      "returnType": {
        "$ref": "#/interfaces@28"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@65"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "succession"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@125"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SuccessionDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@71"
                },
                "arguments": []
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "first"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "ends",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@118"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "then"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "ends",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@118"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@242"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "first",
                    "cardinality": "?"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "ends",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@118"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "then"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "ends",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@118"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Behavior",
      "returnType": {
        "$ref": "#/interfaces@13"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "behavior"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@58"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Step",
      "returnType": {
        "$ref": "#/interfaces@25"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@65"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "step"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@128"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StepDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@71"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@100"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SysMLFunction",
      "returnType": {
        "$ref": "#/interfaces@17"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "function"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@58"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@130"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FunctionBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@131"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FunctionBodyPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@13"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@16"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@15"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@45"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@17"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@20"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@132"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Assignment",
            "feature": "result",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@133"
              },
              "arguments": []
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReturnFeatureMember",
      "returnType": {
        "$ref": "#/interfaces@67"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@238"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "return"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@25"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ResultExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@66"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@238"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@166"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Expression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@65"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "expr"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@135"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@130"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExpressionDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@71"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@100"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Predicate",
      "returnType": {
        "$ref": "#/interfaces@18"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "predicate"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@58"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@130"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BooleanExpression",
      "returnType": {
        "$ref": "#/interfaces@33"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@65"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "bool"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@135"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@130"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Invariant",
      "returnType": {
        "$ref": "#/interfaces@34"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@65"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "inv"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "true"
              },
              {
                "$type": "Assignment",
                "feature": "isNegated",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "false"
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@135"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@130"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Interaction",
      "returnType": {
        "$ref": "#/interfaces@19"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "interaction"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@58"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemFlow",
      "returnType": {
        "$ref": "#/interfaces@31"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@65"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "flow"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@142"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SuccessionItemFlow",
      "returnType": {
        "$ref": "#/interfaces@32"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@65"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "succession"
          },
          {
            "$type": "Keyword",
            "value": "flow"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@142"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemFlowDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@71"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@100"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "of"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "item",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@143"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "from"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "ends",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@146"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "to"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "ends",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@146"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@242"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Assignment",
                "feature": "ends",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@146"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": "to"
              },
              {
                "$type": "Assignment",
                "feature": "ends",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@146"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemFeatureMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@144"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemFeature",
      "returnType": {
        "$ref": "#/interfaces@24"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@145"
                        },
                        "arguments": []
                      },
                      {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@100"
                        },
                        "arguments": [],
                        "cardinality": "?"
                      }
                    ]
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@100"
                    },
                    "arguments": []
                  }
                ]
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@264"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "multiplicity",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@105"
                  },
                  "arguments": []
                },
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "multiplicity",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@105"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@264"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemFeatureSpecializationPart",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@78"
                },
                "arguments": [],
                "cardinality": "+"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@77"
                    },
                    "arguments": []
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@78"
                    },
                    "arguments": [],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@77"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@78"
                },
                "arguments": [],
                "cardinality": "+"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemFlowEndMember",
      "returnType": {
        "$ref": "#/interfaces@64"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@147"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemFlowEnd",
      "returnType": {
        "$ref": "#/interfaces@27"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@148"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@149"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemFlowEndSubsetting",
      "returnType": {
        "$ref": "#/interfaces@52"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "targetRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@256"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": "."
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@277"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemFlowFeatureMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@150"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemFlowFeature",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "heritage",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@151"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemFlowRedefinition",
      "returnType": {
        "$ref": "#/interfaces@51"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@256"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Metaclass",
      "returnType": {
        "$ref": "#/interfaces@16"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "metaclass"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@58"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@42"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrefixMetadataAnnotation",
      "returnType": {
        "$ref": "#/interfaces@0"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "source",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@156"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrefixMetadataMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@156"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrefixMetadata",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "prefixes",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@154"
          },
          "arguments": []
        },
        "cardinality": "+"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrefixMetadataFeature",
      "returnType": {
        "$ref": "#/interfaces@21"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "#"
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@263"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataFeature",
      "returnType": {
        "$ref": "#/interfaces@21"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@155"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "@"
              },
              {
                "$type": "Keyword",
                "value": "metadata"
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@158"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "about"
              },
              {
                "$type": "Assignment",
                "feature": "about",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@246"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "about",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@246"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@159"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataFeatureDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@1"
                },
                "arguments": []
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@263"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@160"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataBodyElements",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@161"
        },
        "arguments": [],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataBodyElement",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@13"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@16"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@15"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@162"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@20"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataBodyFeatureMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@163"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataBodyFeature",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "feature",
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@233"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@97"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@76"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@100"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@159"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExpressionBody",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "{"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@131"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "}"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@166"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@169"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedExpressionReference",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@165"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConcreteConditionalExpression",
      "returnType": {
        "$ref": "#/interfaces@83"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "operator",
            "operator": "=",
            "terminal": {
              "$type": "Keyword",
              "value": "if"
            }
          },
          {
            "$type": "Assignment",
            "feature": "operands",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@170"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "?"
          },
          {
            "$type": "Assignment",
            "feature": "operands",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@167"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "else"
          },
          {
            "$type": "Assignment",
            "feature": "operands",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@167"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConditionalExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@170"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@168"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NullCoalescingExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@173"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "??"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@171"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImpliesExpressionReference",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@172"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImpliesExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@173"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImpliesExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@176"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "implies"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@174"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OrExpressionReference",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@175"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OrExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@176"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OrExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@179"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "operator",
                        "operator": "=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "|"
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operands",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@179"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "operator",
                        "operator": "=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "or"
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operands",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@177"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  }
                ]
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "XorExpressionReference",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@178"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "XorExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@179"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "XorExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@180"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "xor"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@180"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AndExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@183"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "operator",
                        "operator": "=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "&"
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operands",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@183"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "operator",
                        "operator": "=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "and"
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operands",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@181"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  }
                ]
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EqualityExpressionReference",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@182"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EqualityExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@183"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EqualityExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@184"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@262"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@184"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ClassificationExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@185"
                },
                "arguments": []
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Action",
                    "type": {
                      "$ref": "#/interfaces@83"
                    },
                    "feature": "operands",
                    "operator": "+="
                  },
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Assignment",
                            "feature": "operator",
                            "operator": "=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@260"
                              },
                              "arguments": []
                            }
                          },
                          {
                            "$type": "Assignment",
                            "feature": "children",
                            "operator": "+=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@267"
                              },
                              "arguments": []
                            }
                          }
                        ]
                      },
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Assignment",
                            "feature": "operator",
                            "operator": "=",
                            "terminal": {
                              "$type": "Keyword",
                              "value": "as"
                            }
                          },
                          {
                            "$type": "Assignment",
                            "feature": "children",
                            "operator": "+=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@268"
                              },
                              "arguments": []
                            }
                          }
                        ]
                      }
                    ]
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@260"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@267"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@266"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "@@"
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@267"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "as"
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@268"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@266"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "meta"
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@268"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RelationalExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@186"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@261"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@186"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RangeExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@187"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": ".."
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@187"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AdditiveExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@188"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "+"
                    },
                    {
                      "$type": "Keyword",
                      "value": "-"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@188"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicativeExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@189"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "*"
                    },
                    {
                      "$type": "Keyword",
                      "value": "/"
                    },
                    {
                      "$type": "Keyword",
                      "value": "%"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@189"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExponentiationExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@190"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "**"
                    },
                    {
                      "$type": "Keyword",
                      "value": "^"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@189"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnaryExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@259"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@191"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@191"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExtentExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "all"
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@268"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@192"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrimaryExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@193"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@84"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Keyword",
                "value": "."
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@274"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Action",
                        "type": {
                          "$ref": "#/interfaces@81"
                        },
                        "feature": "operands",
                        "operator": "+="
                      },
                      {
                        "$type": "Keyword",
                        "value": "#"
                      },
                      {
                        "$type": "Keyword",
                        "value": "("
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operands",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@196"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Keyword",
                        "value": ")"
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Action",
                        "type": {
                          "$ref": "#/interfaces@83"
                        },
                        "feature": "operands",
                        "operator": "+="
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operator",
                        "operator": "=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "["
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operands",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@196"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Keyword",
                        "value": "]"
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Action",
                        "type": {
                          "$ref": "#/interfaces@82"
                        },
                        "feature": "operands",
                        "operator": "+="
                      },
                      {
                        "$type": "Keyword",
                        "value": "->"
                      },
                      {
                        "$type": "Assignment",
                        "feature": "heritage",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@270"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Alternatives",
                        "elements": [
                          {
                            "$type": "Assignment",
                            "feature": "children",
                            "operator": "+=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@195"
                              },
                              "arguments": []
                            }
                          },
                          {
                            "$type": "Assignment",
                            "feature": "children",
                            "operator": "+=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@272"
                              },
                              "arguments": []
                            }
                          },
                          {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@198"
                            },
                            "arguments": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Action",
                        "type": {
                          "$ref": "#/interfaces@85"
                        },
                        "feature": "operands",
                        "operator": "+="
                      },
                      {
                        "$type": "Keyword",
                        "value": "."
                      },
                      {
                        "$type": "Assignment",
                        "feature": "children",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@195"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Action",
                        "type": {
                          "$ref": "#/interfaces@86"
                        },
                        "feature": "operands",
                        "operator": "+="
                      },
                      {
                        "$type": "Keyword",
                        "value": ".?"
                      },
                      {
                        "$type": "Assignment",
                        "feature": "children",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@195"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Action",
                    "type": {
                      "$ref": "#/interfaces@84"
                    },
                    "feature": "operands",
                    "operator": "+="
                  },
                  {
                    "$type": "Keyword",
                    "value": "."
                  },
                  {
                    "$type": "Assignment",
                    "feature": "children",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@274"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BaseExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@225"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@224"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@279"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@281"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@197"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@194"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@196"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BodyExpression",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@195"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExpressionBodyMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@164"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SequenceExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@166"
            },
            "arguments": []
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Action",
                    "type": {
                      "$ref": "#/interfaces@83"
                    },
                    "feature": "operands",
                    "operator": "+="
                  },
                  {
                    "$type": "Assignment",
                    "feature": "operator",
                    "operator": "=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": ","
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "operands",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@196"
                      },
                      "arguments": []
                    }
                  }
                ]
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InvocationExpression",
      "returnType": {
        "$ref": "#/interfaces@82"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@264"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@198"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ArgumentList",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@199"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@202"
                },
                "arguments": []
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PositionalArgumentList",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@200"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@200"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ArgumentMember",
      "returnType": {
        "$ref": "#/interfaces@65"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@201"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Argument",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@206"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamedArgumentList",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@203"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@203"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamedArgumentMember",
      "returnType": {
        "$ref": "#/interfaces@65"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@204"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamedArgument",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@205"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "="
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@206"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParameterRedefinition",
      "returnType": {
        "$ref": "#/interfaces@51"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@256"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ArgumentValue",
      "returnType": {
        "$ref": "#/interfaces@60"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@166"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "TerminalRule",
      "fragment": true,
      "name": "DECIMAL",
      "definition": {
        "$type": "RegexToken",
        "regex": "[0-9]+"
      },
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "fragment": true,
      "name": "FRACTION",
      "definition": {
        "$type": "TerminalGroup",
        "elements": [
          {
            "$type": "CharacterRange",
            "left": {
              "$type": "Keyword",
              "value": "."
            }
          },
          {
            "$type": "TerminalRuleCall",
            "rule": {
              "$ref": "#/rules@207"
            }
          }
        ]
      },
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "fragment": true,
      "name": "FLOAT",
      "definition": {
        "$type": "TerminalAlternatives",
        "elements": [
          {
            "$type": "TerminalGroup",
            "elements": [
              {
                "$type": "TerminalRuleCall",
                "rule": {
                  "$ref": "#/rules@207"
                }
              },
              {
                "$type": "TerminalRuleCall",
                "rule": {
                  "$ref": "#/rules@208"
                },
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "TerminalRuleCall",
            "rule": {
              "$ref": "#/rules@208"
            }
          }
        ]
      },
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "fragment": true,
      "name": "EXPONENT",
      "definition": {
        "$type": "TerminalGroup",
        "elements": [
          {
            "$type": "RegexToken",
            "regex": "[eE][\\\\-\\\\+]*"
          },
          {
            "$type": "TerminalRuleCall",
            "rule": {
              "$ref": "#/rules@207"
            }
          }
        ]
      },
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "NUMBER",
      "type": {
        "$type": "ReturnType",
        "name": "number"
      },
      "definition": {
        "$type": "TerminalGroup",
        "elements": [
          {
            "$type": "TerminalRuleCall",
            "rule": {
              "$ref": "#/rules@209"
            }
          },
          {
            "$type": "TerminalRuleCall",
            "rule": {
              "$ref": "#/rules@210"
            },
            "cardinality": "?"
          }
        ]
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "ID",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "[_a-zA-Z][\\\\w_\\\\d]*"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "UNRESTRICTED_NAME",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "'(\\\\\\\\['\\"bftnr\\\\\\\\]|[^'\\\\\\\\])*'"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "STRING_VALUE",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "\\"[^\\"]*\\""
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "REGULAR_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "ML_NOTE",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "SL_NOTE",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\/[^\\\\n\\\\r]*"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "WS",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\s+"
      },
      "fragment": false
    },
    {
      "$type": "ParserRule",
      "name": "Name",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@212"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@213"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LiteralBoolean",
      "returnType": {
        "$ref": "#/interfaces@76"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "false"
          },
          {
            "$type": "Assignment",
            "feature": "literal",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "true"
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LiteralString",
      "returnType": {
        "$ref": "#/interfaces@77"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "literal",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@214"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LiteralNumber",
      "returnType": {
        "$ref": "#/interfaces@78"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "literal",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@211"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LiteralInfinity",
      "returnType": {
        "$ref": "#/interfaces@79"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "type": {
              "$ref": "#/interfaces@79"
            }
          },
          {
            "$type": "Keyword",
            "value": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LiteralExpression",
      "returnType": {
        "$ref": "#/interfaces@75"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@220"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@221"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@222"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@223"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NullExpression",
      "returnType": {
        "$ref": "#/interfaces@80"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "type": {
              "$ref": "#/interfaces@80"
            }
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "null"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ShortName",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "<"
          },
          {
            "$type": "Assignment",
            "feature": "declaredShortName",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@219"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ">"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RegularName",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "declaredName",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@219"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Identification",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@226"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@227"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@227"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SpecializesToken",
      "fragment": true,
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ":>"
          },
          {
            "$type": "Keyword",
            "value": "specializes"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SubsetsToken",
      "fragment": true,
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ":>"
          },
          {
            "$type": "Keyword",
            "value": "subsets"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReferencesToken",
      "fragment": true,
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "::>"
          },
          {
            "$type": "Keyword",
            "value": "references"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CrossesToken",
      "fragment": true,
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "=>"
          },
          {
            "$type": "Keyword",
            "value": "crosses"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RedefinesToken",
      "fragment": true,
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ":>>"
          },
          {
            "$type": "Keyword",
            "value": "redefines"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureDirectionKind",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "in"
          },
          {
            "$type": "Keyword",
            "value": "inout"
          },
          {
            "$type": "Keyword",
            "value": "out"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "VisibilityKind",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "private"
          },
          {
            "$type": "Keyword",
            "value": "protected"
          },
          {
            "$type": "Keyword",
            "value": "public"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImportKind",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "::*"
          },
          {
            "$type": "Keyword",
            "value": "::**"
          },
          {
            "$type": "Keyword",
            "value": "::*::**"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Abstract",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isAbstract",
        "operator": "=",
        "terminal": {
          "$type": "Keyword",
          "value": "abstract"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Visibility",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "visibility",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@235"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Readonly",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isReadOnly",
        "operator": "=",
        "terminal": {
          "$type": "Keyword",
          "value": "readonly"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Derived",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isDerived",
        "operator": "=",
        "terminal": {
          "$type": "Keyword",
          "value": "derived"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "End",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isEnd",
        "operator": "=",
        "terminal": {
          "$type": "Keyword",
          "value": "end"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Sufficient",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isSufficient",
        "operator": "?=",
        "terminal": {
          "$type": "Keyword",
          "value": "all"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Standard",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isStandard",
        "operator": "?=",
        "terminal": {
          "$type": "Keyword",
          "value": "standard"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImportAll",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "importsAll",
        "operator": "?=",
        "terminal": {
          "$type": "Keyword",
          "value": "all"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicityProperties",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "isOrdered",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "ordered"
                }
              },
              {
                "$type": "Assignment",
                "feature": "isNonunique",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "nonunique"
                },
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "isNonunique",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "nonunique"
                }
              },
              {
                "$type": "Assignment",
                "feature": "isOrdered",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "ordered"
                },
                "cardinality": "?"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Annotation",
      "returnType": {
        "$ref": "#/interfaces@0"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@252"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TextualAnnotatingElementBody",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "body",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@215"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Comment",
      "returnType": {
        "$ref": "#/interfaces@3"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "comment"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "about"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "about",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@246"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "about",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@246"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "locale"
              },
              {
                "$type": "Assignment",
                "feature": "locale",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@214"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@247"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Documentation",
      "returnType": {
        "$ref": "#/interfaces@4"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "doc"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@228"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "locale"
              },
              {
                "$type": "Assignment",
                "feature": "locale",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@214"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@247"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TextualRepresentation",
      "returnType": {
        "$ref": "#/interfaces@5"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "rep"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@228"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "language"
          },
          {
            "$type": "Assignment",
            "feature": "language",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@214"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@247"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "QualifiedReferenceChain",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "parts",
            "operator": "+=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/interfaces@6"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@219"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "::"
              },
              {
                "$type": "Assignment",
                "feature": "parts",
                "operator": "+=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/interfaces@6"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@219"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ElementReference",
      "returnType": {
        "$ref": "#/interfaces@68"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@251"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamespaceReference",
      "returnType": {
        "$ref": "#/interfaces@69"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@251"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeReference",
      "returnType": {
        "$ref": "#/interfaces@70"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@251"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ClassifierReference",
      "returnType": {
        "$ref": "#/interfaces@71"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@251"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureReference",
      "returnType": {
        "$ref": "#/interfaces@72"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@251"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetaclassReference",
      "returnType": {
        "$ref": "#/interfaces@73"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@251"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MembershipReference",
      "returnType": {
        "$ref": "#/interfaces@74"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@251"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnaryOperator",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "+"
          },
          {
            "$type": "Keyword",
            "value": "-"
          },
          {
            "$type": "Keyword",
            "value": "~"
          },
          {
            "$type": "Keyword",
            "value": "not"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ClassificationTestOperator",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "istype"
          },
          {
            "$type": "Keyword",
            "value": "hastype"
          },
          {
            "$type": "Keyword",
            "value": "@"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RelationalOperator",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "<"
          },
          {
            "$type": "Keyword",
            "value": ">"
          },
          {
            "$type": "Keyword",
            "value": "<="
          },
          {
            "$type": "Keyword",
            "value": ">="
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EqualityOperator",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "=="
          },
          {
            "$type": "Keyword",
            "value": "!="
          },
          {
            "$type": "Keyword",
            "value": "==="
          },
          {
            "$type": "Keyword",
            "value": "!=="
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataTyping",
      "returnType": {
        "$ref": "#/interfaces@47"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@257"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedFeatureTyping",
      "returnType": {
        "$ref": "#/interfaces@47"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@265"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureType",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@254"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataReference",
      "returnType": {
        "$ref": "#/interfaces@88"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "reference",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@252"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeReferenceMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@269"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeResultMember",
      "returnType": {
        "$ref": "#/interfaces@67"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@269"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeReferenceFeature",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "heritage",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@270"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReferenceTyping",
      "returnType": {
        "$ref": "#/interfaces@47"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@254"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FunctionReferenceExpression",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@272"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FunctionReferenceMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@273"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FunctionReference",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "heritage",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@270"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureChainMember",
      "returnType": {
        "$ref": "#/interfaces@58"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@256"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@59"
                }
              },
              {
                "$type": "Assignment",
                "feature": "target",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@275"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedFeatureChain",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@276"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureChain",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "typeRelationships",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@278"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "."
              },
              {
                "$type": "Assignment",
                "feature": "typeRelationships",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@278"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "+"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureChainPrefix",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "typeRelationships",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@278"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": "."
              }
            ],
            "cardinality": "+"
          },
          {
            "$type": "Assignment",
            "feature": "typeRelationships",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@278"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "."
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedFeatureChaining",
      "returnType": {
        "$ref": "#/interfaces@42"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@256"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureReferenceExpression",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@280"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureReferenceMember",
      "returnType": {
        "$ref": "#/interfaces@58"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@256"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataAccessExpression",
      "returnType": {
        "$ref": "#/interfaces@88"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "reference",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@252"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "."
          },
          {
            "$type": "Keyword",
            "value": "metadata"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    }
  ],
  "definesHiddenTokens": false,
  "hiddenTokens": [],
  "interfaces": [
    {
      "$type": "Interface",
      "name": "Annotation",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "about",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@0"
              }
            }
          },
          "isOptional": false
        }
      ],
      "name": "AnnotatingElement",
      "superTypes": [
        {
          "$ref": "#/interfaces@6"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "body",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          },
          "isOptional": false
        }
      ],
      "name": "TextualAnnotatingElement",
      "superTypes": [
        {
          "$ref": "#/interfaces@1"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "locale",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          }
        }
      ],
      "name": "Comment",
      "superTypes": [
        {
          "$ref": "#/interfaces@2"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "Documentation",
      "superTypes": [
        {
          "$ref": "#/interfaces@3"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "language",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          },
          "isOptional": false
        }
      ],
      "name": "TextualRepresentation",
      "superTypes": [
        {
          "$ref": "#/interfaces@2"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "declaredName",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "declaredShortName",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          }
        }
      ],
      "name": "Element",
      "superTypes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "prefixes",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@59"
              }
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "children",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "UnionType",
              "types": [
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/interfaces@55"
                  }
                },
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/interfaces@58"
                  }
                }
              ]
            }
          },
          "isOptional": false
        }
      ],
      "name": "Namespace",
      "superTypes": [
        {
          "$ref": "#/interfaces@6"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isSufficient",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "isAbstract",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "abstract"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "heritage",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@38"
              }
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "typeRelationships",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "UnionType",
              "types": [
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/types@9"
                  }
                },
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/types@10"
                  }
                }
              ]
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "multiplicity",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@59"
            }
          }
        }
      ],
      "name": "Type",
      "superTypes": [
        {
          "$ref": "#/interfaces@7"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "Classifier",
      "superTypes": [
        {
          "$ref": "#/interfaces@8"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "DataType",
      "superTypes": [
        {
          "$ref": "#/interfaces@9"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Class",
      "superTypes": [
        {
          "$ref": "#/interfaces@9"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Structure",
      "superTypes": [
        {
          "$ref": "#/interfaces@11"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Behavior",
      "superTypes": [
        {
          "$ref": "#/interfaces@11"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Association",
      "superTypes": [
        {
          "$ref": "#/interfaces@9"
        },
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "AssociationStructure",
      "superTypes": [
        {
          "$ref": "#/interfaces@14"
        },
        {
          "$ref": "#/interfaces@12"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Metaclass",
      "superTypes": [
        {
          "$ref": "#/interfaces@12"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "result",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@66"
            }
          }
        }
      ],
      "name": "SysMLFunction",
      "superTypes": [
        {
          "$ref": "#/interfaces@13"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "Predicate",
      "superTypes": [
        {
          "$ref": "#/interfaces@17"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Interaction",
      "superTypes": [
        {
          "$ref": "#/interfaces@14"
        },
        {
          "$ref": "#/interfaces@13"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isNonunique",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "isOrdered",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "direction",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/types@1"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "isComposite",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "composite"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "isDerived",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "derived"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "isEnd",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "end"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "isPortion",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "portion"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "isReadOnly",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "readonly"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "value",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@60"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "write",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@58"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "crossingFeature",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@59"
            }
          }
        }
      ],
      "name": "Feature",
      "superTypes": [
        {
          "$ref": "#/interfaces@8"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "MetadataFeature",
      "superTypes": [
        {
          "$ref": "#/interfaces@20"
        },
        {
          "$ref": "#/interfaces@1"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Multiplicity",
      "superTypes": [
        {
          "$ref": "#/interfaces@20"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "range",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@59"
            }
          }
        }
      ],
      "name": "MultiplicityRange",
      "superTypes": [
        {
          "$ref": "#/interfaces@22"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "ItemFeature",
      "superTypes": [
        {
          "$ref": "#/interfaces@20"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Step",
      "superTypes": [
        {
          "$ref": "#/interfaces@20"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "ends",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@64"
              }
            }
          },
          "isOptional": false
        }
      ],
      "name": "Connector",
      "superTypes": [
        {
          "$ref": "#/interfaces@20"
        },
        {
          "$ref": "#/interfaces@37"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "ItemFlowEnd",
      "superTypes": [
        {
          "$ref": "#/interfaces@20"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Succession",
      "superTypes": [
        {
          "$ref": "#/interfaces@26"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "BindingConnector",
      "superTypes": [
        {
          "$ref": "#/interfaces@26"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "result",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@66"
            }
          }
        }
      ],
      "name": "Expression",
      "superTypes": [
        {
          "$ref": "#/interfaces@25"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "item",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@63"
            }
          }
        }
      ],
      "name": "ItemFlow",
      "superTypes": [
        {
          "$ref": "#/interfaces@26"
        },
        {
          "$ref": "#/interfaces@25"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "SuccessionItemFlow",
      "superTypes": [
        {
          "$ref": "#/interfaces@31"
        },
        {
          "$ref": "#/interfaces@28"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "BooleanExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@30"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isNegated",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "Invariant",
      "superTypes": [
        {
          "$ref": "#/interfaces@33"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "Package",
      "superTypes": [
        {
          "$ref": "#/interfaces@7"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isStandard",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "LibraryPackage",
      "superTypes": [
        {
          "$ref": "#/interfaces@35"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "visibility",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/types@0"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "elements",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "UnionType",
              "types": [
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/interfaces@7"
                  }
                },
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/interfaces@37"
                  }
                },
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/interfaces@20"
                  }
                },
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/interfaces@0"
                  }
                }
              ]
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "source",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@6"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "sourceRef",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@68"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "sourceChain",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@20"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "target",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@6"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "targetRef",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@68"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "targetChain",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@20"
            }
          }
        }
      ],
      "name": "Relationship",
      "superTypes": [
        {
          "$ref": "#/interfaces@6"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "Inheritance",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Unioning",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Differencing",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Intersecting",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "FeatureChaining",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Specialization",
      "superTypes": [
        {
          "$ref": "#/interfaces@38"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Disjoining",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "FeatureInverting",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "TypeFeaturing",
      "superTypes": [
        {
          "$ref": "#/interfaces@62"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "FeatureTyping",
      "superTypes": [
        {
          "$ref": "#/interfaces@43"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Subclassification",
      "superTypes": [
        {
          "$ref": "#/interfaces@43"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Subsetting",
      "superTypes": [
        {
          "$ref": "#/interfaces@43"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Conjugation",
      "superTypes": [
        {
          "$ref": "#/interfaces@38"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Redefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@49"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ReferenceSubsetting",
      "superTypes": [
        {
          "$ref": "#/interfaces@49"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "CrossSubsetting",
      "superTypes": [
        {
          "$ref": "#/interfaces@49"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "prefixes",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@0"
              }
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "client",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@68"
              }
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "supplier",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@68"
              }
            }
          },
          "isOptional": false
        }
      ],
      "name": "Dependency",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "importsAll",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "isRecursive",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "isNamespace",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "::*"
          }
        }
      ],
      "name": "Import",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "MembershipImport",
      "superTypes": [
        {
          "$ref": "#/interfaces@55"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "NamespaceImport",
      "superTypes": [
        {
          "$ref": "#/interfaces@55"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isAlias",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "Membership",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "OwningMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@58"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isDefault",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "isInitial",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "FeatureValue",
      "superTypes": [
        {
          "$ref": "#/interfaces@59"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "ElementFilterMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@59"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Featuring",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "FeatureMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@62"
        },
        {
          "$ref": "#/interfaces@59"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "EndFeatureMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@63"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ParameterMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@63"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ResultExpressionMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@63"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ReturnParameterMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@65"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "parts",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "ReferenceType",
              "referenceType": {
                "$type": "SimpleType",
                "typeRef": {
                  "$ref": "#/interfaces@6"
                }
              }
            }
          },
          "isOptional": false
        }
      ],
      "name": "ElementReference",
      "superTypes": []
    },
    {
      "$type": "Interface",
      "name": "NamespaceReference",
      "superTypes": [
        {
          "$ref": "#/interfaces@68"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "TypeReference",
      "superTypes": [
        {
          "$ref": "#/interfaces@69"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ClassifierReference",
      "superTypes": [
        {
          "$ref": "#/interfaces@70"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "FeatureReference",
      "superTypes": [
        {
          "$ref": "#/interfaces@70"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "MetaclassReference",
      "superTypes": [
        {
          "$ref": "#/interfaces@71"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "MembershipReference",
      "superTypes": [
        {
          "$ref": "#/interfaces@68"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "LiteralExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@30"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "literal",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "LiteralBoolean",
      "superTypes": [
        {
          "$ref": "#/interfaces@75"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "literal",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          },
          "isOptional": false
        }
      ],
      "name": "LiteralString",
      "superTypes": [
        {
          "$ref": "#/interfaces@75"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "literal",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "number"
          },
          "isOptional": false
        }
      ],
      "name": "LiteralNumber",
      "superTypes": [
        {
          "$ref": "#/interfaces@75"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "LiteralInfinity",
      "superTypes": [
        {
          "$ref": "#/interfaces@75"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "NullExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@30"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "IndexExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@83"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "operands",
          "isOptional": true,
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@30"
              }
            }
          }
        }
      ],
      "name": "InvocationExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@30"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "operator",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          }
        }
      ],
      "name": "OperatorExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@82"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "FeatureChainExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@83"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "CollectExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@83"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "SelectExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@83"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "expression",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@58"
            }
          },
          "isOptional": false
        }
      ],
      "name": "FeatureReferenceExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@30"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "reference",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@68"
            }
          },
          "isOptional": false
        }
      ],
      "name": "MetadataAccessExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@30"
        }
      ]
    }
  ],
  "types": [
    {
      "$type": "Type",
      "name": "VisibilityKind",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "private"
          },
          {
            "$type": "SimpleType",
            "stringType": "protected"
          },
          {
            "$type": "SimpleType",
            "stringType": "public"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "FeatureDirectionKind",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "in"
          },
          {
            "$type": "SimpleType",
            "stringType": "inout"
          },
          {
            "$type": "SimpleType",
            "stringType": "out"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "UnaryOperator",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "+"
          },
          {
            "$type": "SimpleType",
            "stringType": "-"
          },
          {
            "$type": "SimpleType",
            "stringType": "not"
          },
          {
            "$type": "SimpleType",
            "stringType": "~"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "ClassificationTestOperator",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "@"
          },
          {
            "$type": "SimpleType",
            "stringType": "hastype"
          },
          {
            "$type": "SimpleType",
            "stringType": "istype"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "EqualityOperator",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "!="
          },
          {
            "$type": "SimpleType",
            "stringType": "!=="
          },
          {
            "$type": "SimpleType",
            "stringType": "=="
          },
          {
            "$type": "SimpleType",
            "stringType": "==="
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "ImportKind",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "::*"
          },
          {
            "$type": "SimpleType",
            "stringType": "::**"
          },
          {
            "$type": "SimpleType",
            "stringType": "::*::**"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "RelationalOperator",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "<"
          },
          {
            "$type": "SimpleType",
            "stringType": "<="
          },
          {
            "$type": "SimpleType",
            "stringType": ">"
          },
          {
            "$type": "SimpleType",
            "stringType": ">="
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "InlineExpression",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@84"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@81"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@82"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@75"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@88"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@80"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@83"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@85"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@86"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@87"
            }
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "NonOwnerType",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@58"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@0"
            }
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "TypeRelationship",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@39"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@40"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@44"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@41"
            }
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "FeatureRelationship",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/types@9"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@42"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@45"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@46"
            }
          }
        ]
      }
    }
  ],
  "usedGrammars": []
}`);
    exports2.KerMLGrammar = KerMLGrammar;
    var loadedSysMLGrammar;
    var SysMLGrammar = () => loadedSysMLGrammar !== null && loadedSysMLGrammar !== void 0 ? loadedSysMLGrammar : loadedSysMLGrammar = (0, langium_1.loadGrammarFromJson)(`{
  "$type": "Grammar",
  "isDeclared": true,
  "name": "SysML",
  "imports": [],
  "rules": [
    {
      "$type": "ParserRule",
      "name": "DefinedByToken",
      "fragment": true,
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ":"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "defined"
              },
              {
                "$type": "Keyword",
                "value": "by"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PortionKind",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "timeslice"
          },
          {
            "$type": "Keyword",
            "value": "snapshot"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RequirementConstraintKind",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "assume"
          },
          {
            "$type": "Keyword",
            "value": "require"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Variation",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isVariation",
        "operator": "?=",
        "terminal": {
          "$type": "Keyword",
          "value": "variation"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Individual",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isIndividual",
        "operator": "?=",
        "terminal": {
          "$type": "Keyword",
          "value": "individual"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Portion",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "portionKind",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@1"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Model",
      "entry": true,
      "returnType": {
        "$ref": "#/interfaces@7"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@28"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Dependency",
      "returnType": {
        "$ref": "#/interfaces@54"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "prefixes",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@14"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": "dependency"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@399"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": "from"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "client",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@423"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "client",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@423"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": "to"
          },
          {
            "$type": "Assignment",
            "feature": "supplier",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@423"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "supplier",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@423"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@11"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedAnnotation",
      "returnType": {
        "$ref": "#/interfaces@0"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "source",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@10"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AnnotatingMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@10"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AnnotatingElement",
      "returnType": {
        "$ref": "#/interfaces@1"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@419"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@420"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@421"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@18"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RelationshipBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@12"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RelationshipBodyElements",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "elements",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@8"
          },
          "arguments": []
        },
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataDefinition",
      "returnType": {
        "$ref": "#/interfaces@91"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@408"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@16"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "metadata"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@66"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrefixMetadataAnnotation",
      "returnType": {
        "$ref": "#/interfaces@0"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "source",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@17"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrefixMetadataMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@17"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrefixMetadata",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "prefixes",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@15"
          },
          "arguments": []
        },
        "cardinality": "+"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrefixMetadataUsage",
      "returnType": {
        "$ref": "#/interfaces@92"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "#"
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@434"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataUsage",
      "returnType": {
        "$ref": "#/interfaces@92"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@16"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "metadata"
              },
              {
                "$type": "Keyword",
                "value": "@"
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@19"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "about"
              },
              {
                "$type": "Assignment",
                "feature": "about",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@417"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "about",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@417"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@20"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataUsageDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@399"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@0"
                },
                "arguments": []
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@434"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@21"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataBodyItems",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@71"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@31"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@72"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@22"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@33"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@36"
              },
              "arguments": []
            }
          }
        ],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataBodyUsageMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@23"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataBodyUsage",
      "returnType": {
        "$ref": "#/interfaces@93"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "ref",
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@404"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@44"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@91"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@20"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Package",
      "returnType": {
        "$ref": "#/interfaces@35"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@16"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@26"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@27"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LibraryPackage",
      "returnType": {
        "$ref": "#/interfaces@36"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@414"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "library"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@16"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@26"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@27"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PackageDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "package"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@399"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PackageBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@28"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PackageBodyItems",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@29"
        },
        "arguments": [],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PackageBodyElement",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@36"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@33"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@32"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@72"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@30"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@71"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@31"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UsageMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@40"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RelationshipMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@7"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ElementFilterMember",
      "returnType": {
        "$ref": "#/interfaces@61"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "filter"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@337"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AliasMember",
      "returnType": {
        "$ref": "#/interfaces@58"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "isAlias",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "alias"
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@399"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "for"
          },
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@423"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@11"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImportPrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "import"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@415"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImportedReference",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@423"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "isNamespace",
            "operator": "=",
            "terminal": {
              "$type": "Keyword",
              "value": "::*"
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "isRecursive",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "::**"
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Import",
      "returnType": {
        "$ref": "#/interfaces@55"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@34"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@35"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@37"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@11"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FilterPackage",
      "returnType": {
        "$ref": "#/interfaces@35"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "children",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@38"
          },
          "arguments": []
        },
        "cardinality": "+"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FilterPackageMember",
      "returnType": {
        "$ref": "#/interfaces@61"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "["
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@337"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "]"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefinitionElement",
      "returnType": {
        "$ref": "#/interfaces@7"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@24"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@25"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@103"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@105"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@112"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@113"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@124"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@13"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@126"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@136"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@141"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@159"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@177"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@128"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@180"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@270"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@236"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@277"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@281"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@301"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@303"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@310"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@312"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@316"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@319"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@331"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@333"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@101"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UsageElement",
      "returnType": {
        "$ref": "#/interfaces@90"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@96"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@97"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SubclassificationPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@400"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@42"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@42"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedSubclassification",
      "returnType": {
        "$ref": "#/interfaces@48"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@426"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@399"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@44"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@44"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureSpecializationPart",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@46"
            },
            "arguments": [],
            "cardinality": "+"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@46"
                },
                "arguments": [],
                "cardinality": "+"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@45"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@46"
                },
                "arguments": [],
                "cardinality": "*"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@45"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@46"
                },
                "arguments": [],
                "cardinality": "*"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicityPart",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "multiplicity",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@60"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@416"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@416"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureSpecialization",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@47"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@49"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@51"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@52"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@53"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Typings",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@48"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@55"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypedBy",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@0"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@55"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Subsettings",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@50"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@56"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Subsets",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@401"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@56"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "References",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@402"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@57"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Crosses",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@403"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@58"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Redefinitions",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@54"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@59"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Redefines",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@404"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureTyping",
      "returnType": {
        "$ref": "#/interfaces@47"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@435"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@129"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedSubsetting",
      "returnType": {
        "$ref": "#/interfaces@49"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@427"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@446"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedReferenceSubsetting",
      "returnType": {
        "$ref": "#/interfaces@52"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@427"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@446"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedCrossSubsetting",
      "returnType": {
        "$ref": "#/interfaces@53"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@427"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@446"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedRedefinition",
      "returnType": {
        "$ref": "#/interfaces@51"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@427"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@446"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedMultiplicity",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@61"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicityRange",
      "returnType": {
        "$ref": "#/interfaces@23"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "["
          },
          {
            "$type": "Assignment",
            "feature": "range",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@62"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "]"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicityExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@337"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BasicDefinitionPrefix",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@408"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefinitionExtensionKeyword",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "prefixes",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@15"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefinitionPrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@63"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@64"
            },
            "arguments": [],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefinitionSuffix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@68"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefinitionDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@399"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@41"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefinitionBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@69"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefinitionBodyItems",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@70"
        },
        "arguments": [],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefinitionBodyItem",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@36"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@33"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@72"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@31"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@71"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@73"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@74"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@120"
                  },
                  "arguments": []
                },
                "cardinality": "?"
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@75"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefinitionMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@39"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "VisibleAnnotatingMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@10"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "VariantUsageMember",
      "returnType": {
        "$ref": "#/interfaces@166"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "variant"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@100"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NonOccurrenceUsageMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@96"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OccurrenceUsageMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@97"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StructureUsageMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@98"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BehaviorUsageMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@99"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RefPrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "direction",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@405"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@63"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@410"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@411"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Reference",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isReference",
        "operator": "?=",
        "terminal": {
          "$type": "Keyword",
          "value": "ref"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BasicUsagePrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@78"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@79"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EndUsagePrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@412"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "crossingFeature",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@84"
              },
              "arguments": []
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UsageExtensionKeyword",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "prefixes",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@15"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnextendedUsagePrefix",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@81"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@80"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedCrossingFeatureMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@85"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedCrossingFeature",
      "returnType": {
        "$ref": "#/interfaces@93"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@80"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@88"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UsagePrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@83"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@82"
            },
            "arguments": [],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UsageSuffix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@88"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@89"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UsageDeclaration",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@43"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UsageCompletion",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@91"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@90"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UsageBody",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@68"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ValuePart",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@92"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureValue",
      "returnType": {
        "$ref": "#/interfaces@60"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "="
              },
              {
                "$type": "Assignment",
                "feature": "isInitial",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": ":="
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "isDefault",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "default"
                    }
                  },
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "="
                      },
                      {
                        "$type": "Assignment",
                        "feature": "isInitial",
                        "operator": "?=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": ":="
                        }
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@337"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefaultReferenceUsage",
      "returnType": {
        "$ref": "#/interfaces@93"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@412"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@78"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReferenceUsage",
      "returnType": {
        "$ref": "#/interfaces@93"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@81"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@78"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": "ref"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "VariantReference",
      "returnType": {
        "$ref": "#/interfaces@93"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@57"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@46"
            },
            "arguments": [],
            "cardinality": "*"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@90"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NonOccurrenceUsageElement",
      "returnType": {
        "$ref": "#/interfaces@90"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@93"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@94"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@104"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@110"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@134"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@135"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@102"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OccurrenceUsageElement",
      "returnType": {
        "$ref": "#/interfaces@90"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@98"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@99"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StructureUsageElement",
      "returnType": {
        "$ref": "#/interfaces@90"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@116"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@117"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@118"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@119"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@125"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@127"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@325"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@334"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@131"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@137"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@168"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@178"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@142"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@146"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@147"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BehaviorUsageElement",
      "returnType": {
        "$ref": "#/interfaces@90"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@188"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@276"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@252"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@278"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@295"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@302"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@309"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@311"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@313"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@317"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@332"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@189"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@253"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@318"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@279"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@296"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "VariantUsageElement",
      "returnType": {
        "$ref": "#/interfaces@90"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@95"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@94"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@104"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@134"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@135"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@116"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@117"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@118"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@119"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@125"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@127"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@325"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@334"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@131"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@137"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@168"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@178"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@142"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@146"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@147"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@99"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExtendedDefinition",
      "returnType": {
        "$ref": "#/interfaces@89"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@63"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@64"
            },
            "arguments": [],
            "cardinality": "+"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@66"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExtendedUsage",
      "returnType": {
        "$ref": "#/interfaces@90"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@83"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@82"
            },
            "arguments": [],
            "cardinality": "+"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AttributeDefinition",
      "returnType": {
        "$ref": "#/interfaces@96"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@65"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "attribute"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@66"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AttributeUsage",
      "returnType": {
        "$ref": "#/interfaces@97"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@86"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "attribute"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EnumerationDefinition",
      "returnType": {
        "$ref": "#/interfaces@140"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@16"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "enum"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@106"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EnumerationBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@107"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EnumerationItems",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@9"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@108"
              },
              "arguments": []
            }
          }
        ],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EnumerationUsageMember",
      "returnType": {
        "$ref": "#/interfaces@166"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@109"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EnumeratedValue",
      "returnType": {
        "$ref": "#/interfaces@141"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@16"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "enum",
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EnumerationUsage",
      "returnType": {
        "$ref": "#/interfaces@141"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@86"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "enum"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OccurrenceDefinitionPrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@63"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@4"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@64"
            },
            "arguments": [],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OccurrenceDefinition",
      "returnType": {
        "$ref": "#/interfaces@94"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "occurrence"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@66"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "IndividualDefinition",
      "returnType": {
        "$ref": "#/interfaces@94"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@63"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@4"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@64"
            },
            "arguments": [],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@66"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BasicOccurrenceUsagePrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@80"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@4"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@5"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OccurrenceUsagePrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@81"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@114"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@82"
            },
            "arguments": [],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OccurrenceUsage",
      "returnType": {
        "$ref": "#/interfaces@95"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "occurrence"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "IndividualUsage",
      "returnType": {
        "$ref": "#/interfaces@95"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@80"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@4"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@82"
            },
            "arguments": [],
            "cardinality": "*"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PortionUsage",
      "returnType": {
        "$ref": "#/interfaces@95"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@80"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@4"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@5"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@82"
            },
            "arguments": [],
            "cardinality": "*"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EventOccurrenceUsage",
      "returnType": {
        "$ref": "#/interfaces@153"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "event"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "heritage",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@57"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@44"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "occurrence"
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@88"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  }
                ]
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@89"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EmptySuccessionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@121"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EmptySuccession",
      "returnType": {
        "$ref": "#/interfaces@163"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "then"
          },
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@122"
              },
              "arguments": []
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicitySourceEndMember",
      "returnType": {
        "$ref": "#/interfaces@64"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@123"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicitySourceEnd",
      "returnType": {
        "$ref": "#/interfaces@93"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "multiplicity",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@60"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemDefinition",
      "returnType": {
        "$ref": "#/interfaces@98"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "item"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@66"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemUsage",
      "returnType": {
        "$ref": "#/interfaces@99"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "item"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PartDefinition",
      "returnType": {
        "$ref": "#/interfaces@100"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "part"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@66"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PartUsage",
      "returnType": {
        "$ref": "#/interfaces@101"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "part"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PortDefinition",
      "returnType": {
        "$ref": "#/interfaces@102"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@65"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "port"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@66"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConjugatedPortTyping",
      "returnType": {
        "$ref": "#/interfaces@169"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "~"
          },
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@130"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConjugatedPortReference",
      "returnType": {
        "$ref": "#/interfaces@165"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@422"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PortUsage",
      "returnType": {
        "$ref": "#/interfaces@103"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "port"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConnectorEndMember",
      "returnType": {
        "$ref": "#/interfaces@64"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@133"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConnectorEnd",
      "returnType": {
        "$ref": "#/interfaces@93"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "crossingFeature",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@175"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@398"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@402"
                },
                "arguments": []
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@57"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BindingConnectorAsUsage",
      "returnType": {
        "$ref": "#/interfaces@127"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@86"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "binding"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@88"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "bind"
          },
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@132"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "="
          },
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@132"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@68"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SuccessionAsUsage",
      "returnType": {
        "$ref": "#/interfaces@163"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@86"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "succession"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@88"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "first"
          },
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@132"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "then"
          },
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@132"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@68"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConnectionDefinition",
      "returnType": {
        "$ref": "#/interfaces@128"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "connection"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@66"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConnectionUsage",
      "returnType": {
        "$ref": "#/interfaces@129"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "connection"
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@88"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@91"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "connect"
                      },
                      {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@138"
                        },
                        "arguments": []
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "connect"
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@138"
                    },
                    "arguments": []
                  }
                ]
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@90"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConnectorPart",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@139"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@140"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BinaryConnectorPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@132"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "to"
          },
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@132"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NaryConnectorPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@132"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "ends",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@132"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "+"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FlowConnectionDefinition",
      "returnType": {
        "$ref": "#/interfaces@147"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "flow"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@66"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Message",
      "returnType": {
        "$ref": "#/interfaces@148"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "message"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@143"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@68"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MessageDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@88"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@91"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "of"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "item",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@149"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "from"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "messages",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@144"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "to"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "messages",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@144"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "messages",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@144"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": "to"
              },
              {
                "$type": "Assignment",
                "feature": "messages",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@144"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MessageEventMember",
      "returnType": {
        "$ref": "#/interfaces@65"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@145"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MessageEvent",
      "returnType": {
        "$ref": "#/interfaces@153"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "heritage",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@57"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FlowConnectionUsage",
      "returnType": {
        "$ref": "#/interfaces@148"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "flow"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@148"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@68"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SuccessionFlowConnectionUsage",
      "returnType": {
        "$ref": "#/interfaces@149"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "succession"
          },
          {
            "$type": "Keyword",
            "value": "flow"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@148"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@68"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FlowConnectionDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@88"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@91"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "of"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "item",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@149"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "from"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "ends",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@153"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "to"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "ends",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@153"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "ends",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@153"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": "to"
              },
              {
                "$type": "Assignment",
                "feature": "ends",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@153"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemFeatureMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@150"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ItemFeature",
      "returnType": {
        "$ref": "#/interfaces@24"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@151"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PayloadFeature",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@399"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@152"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@91"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@399"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@91"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@435"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "multiplicity",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@60"
                  },
                  "arguments": []
                },
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "multiplicity",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@60"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@435"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PayloadFeatureSpecializationPart",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@46"
                },
                "arguments": [],
                "cardinality": "+"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@45"
                    },
                    "arguments": []
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@46"
                    },
                    "arguments": [],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@45"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@46"
                },
                "arguments": [],
                "cardinality": "+"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FlowEndMember",
      "returnType": {
        "$ref": "#/interfaces@64"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@154"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FlowEnd",
      "returnType": {
        "$ref": "#/interfaces@27"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@155"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@156"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FlowEndSubsetting",
      "returnType": {
        "$ref": "#/interfaces@52"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "targetRef",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@427"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": "."
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@448"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FlowFeatureMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@157"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FlowFeature",
      "returnType": {
        "$ref": "#/interfaces@93"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "heritage",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@158"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FlowRedefinition",
      "returnType": {
        "$ref": "#/interfaces@51"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@427"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InterfaceDefinition",
      "returnType": {
        "$ref": "#/interfaces@130"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "interface"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@160"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InterfaceBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@161"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InterfaceBodyItems",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@162"
        },
        "arguments": [],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InterfaceBodyItem",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@71"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@31"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@72"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@73"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@163"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@120"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@165"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@33"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@36"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InterfaceNonOccurrenceUsageMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@164"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InterfaceNonOccurrenceUsageElement",
      "returnType": {
        "$ref": "#/interfaces@90"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@94"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@104"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@110"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@134"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@135"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InterfaceOccurrenceUsageMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@166"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InterfaceOccurrenceUsageElement",
      "returnType": {
        "$ref": "#/interfaces@90"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@167"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@98"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@99"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefaultInterfaceEnd",
      "returnType": {
        "$ref": "#/interfaces@103"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@412"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InterfaceUsage",
      "returnType": {
        "$ref": "#/interfaces@131"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "interface"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@169"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@160"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InterfaceUsageDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@88"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "connect"
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@170"
                    },
                    "arguments": []
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@170"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InterfacePart",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@171"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@172"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BinaryInterfacePart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@173"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "to"
          },
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@173"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NaryInterfacePart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@173"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "ends",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@173"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "+"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InterfaceEndMember",
      "returnType": {
        "$ref": "#/interfaces@64"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@174"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InterfaceEnd",
      "returnType": {
        "$ref": "#/interfaces@103"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "crossingFeature",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@175"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@398"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@402"
                },
                "arguments": []
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@57"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedCrossMultiplicityMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@176"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedCrossMultiplicity",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "multiplicity",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@60"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AllocationDefinition",
      "returnType": {
        "$ref": "#/interfaces@142"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "allocation"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@66"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AllocationUsage",
      "returnType": {
        "$ref": "#/interfaces@143"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@179"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@90"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AllocationUsageDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "allocation"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@88"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "allocate"
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@138"
                    },
                    "arguments": []
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "allocate"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@138"
                },
                "arguments": []
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionDefinition",
      "returnType": {
        "$ref": "#/interfaces@104"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "action"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@181"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@182"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionBodyItems",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@183"
        },
        "arguments": [],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionBodyItem",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@36"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@33"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@71"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@31"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@72"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@73"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@74"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@184"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@187"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@120"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@76"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@77"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@185"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@186"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InitialNodeMember",
      "returnType": {
        "$ref": "#/interfaces@58"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "first"
          },
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@427"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@11"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionNodeMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@192"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TargetSuccessionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@231"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "GuardedSuccessionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@235"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionUsage",
      "returnType": {
        "$ref": "#/interfaces@105"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "action"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@191"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@181"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PerformActionUsage",
      "returnType": {
        "$ref": "#/interfaces@152"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "perform"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@190"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@181"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PerformActionUsageDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "heritage",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@57"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@44"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "action"
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@88"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  }
                ]
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@91"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionUsageDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@88"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@91"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionNode",
      "returnType": {
        "$ref": "#/interfaces@105"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@206"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@195"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@211"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@213"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@215"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@219"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@220"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@223"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionNodeUsageDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "action"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@88"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionNodePrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@193"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AcceptNode",
      "returnType": {
        "$ref": "#/interfaces@114"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@196"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@181"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AcceptNodeDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@193"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "accept"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@197"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AcceptParameterPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "payload",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@198"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "via"
              },
              {
                "$type": "Assignment",
                "feature": "receiver",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@208"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PayloadParameterMember",
      "returnType": {
        "$ref": "#/interfaces@65"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@199"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PayloadParameter",
      "returnType": {
        "$ref": "#/interfaces@93"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@151"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@399"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@152"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@200"
                },
                "arguments": []
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TriggerValuePart",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@201"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TriggerFeatureValue",
      "returnType": {
        "$ref": "#/interfaces@60"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@202"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TriggerExpression",
      "returnType": {
        "$ref": "#/interfaces@151"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "kind",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "at"
                    },
                    {
                      "$type": "Keyword",
                      "value": "after"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@371"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "kind",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "when"
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@203"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ArgumentExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@65"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@204"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ArgumentExpression",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@205"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ArgumentExpressionValue",
      "returnType": {
        "$ref": "#/interfaces@60"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@338"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SendNode",
      "returnType": {
        "$ref": "#/interfaces@157"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@207"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@181"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SendNodeDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@193"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "send"
          },
          {
            "$type": "Assignment",
            "feature": "payload",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@208"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "via"
              },
              {
                "$type": "Assignment",
                "feature": "sender",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@208"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "to"
              },
              {
                "$type": "Assignment",
                "feature": "receiver",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@208"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NodeParameterMember",
      "returnType": {
        "$ref": "#/interfaces@65"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@209"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NodeParameter",
      "returnType": {
        "$ref": "#/interfaces@93"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@210"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureBinding",
      "returnType": {
        "$ref": "#/interfaces@60"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@337"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AssignmentNode",
      "returnType": {
        "$ref": "#/interfaces@150"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@212"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@181"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AssignmentNodeDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@193"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "assign"
          },
          {
            "$type": "Assignment",
            "feature": "targetMember",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@445"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ":="
          },
          {
            "$type": "Assignment",
            "feature": "assignedValue",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@208"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminateNode",
      "returnType": {
        "$ref": "#/interfaces@183"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@194"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "terminate"
          },
          {
            "$type": "Assignment",
            "feature": "terminatedOccurrence",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@208"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@181"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExpressionParameterMember",
      "returnType": {
        "$ref": "#/interfaces@65"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@337"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "IfNode",
      "returnType": {
        "$ref": "#/interfaces@106"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@194"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "if"
          },
          {
            "$type": "Assignment",
            "feature": "condition",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@214"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "then",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@216"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "else"
              },
              {
                "$type": "Assignment",
                "feature": "else",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@216"
                      },
                      "arguments": []
                    },
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@218"
                      },
                      "arguments": []
                    }
                  ]
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionBodyParameterMember",
      "returnType": {
        "$ref": "#/interfaces@65"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@217"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionBodyParameter",
      "returnType": {
        "$ref": "#/interfaces@105"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "action"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@88"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "{"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@182"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "}"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "IfNodeParameterMember",
      "returnType": {
        "$ref": "#/interfaces@65"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@215"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "WhileLoopNode",
      "returnType": {
        "$ref": "#/interfaces@155"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@194"
            },
            "arguments": []
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "while"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "condition",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@214"
                      },
                      "arguments": []
                    }
                  }
                ]
              },
              {
                "$type": "Keyword",
                "value": "loop"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "body",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@216"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "until"
              },
              {
                "$type": "Assignment",
                "feature": "until",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@214"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ";"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ForLoopNode",
      "returnType": {
        "$ref": "#/interfaces@156"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@194"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "for"
          },
          {
            "$type": "Assignment",
            "feature": "variable",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@221"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "in"
          },
          {
            "$type": "Assignment",
            "feature": "sequence",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@208"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "body",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@216"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ForVariableDeclarationMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@222"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ForVariableDeclaration",
      "returnType": {
        "$ref": "#/interfaces@93"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@88"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ControlNode",
      "returnType": {
        "$ref": "#/interfaces@158"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@225"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@226"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@227"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@228"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ControlNodePrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@78"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@4"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@5"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@16"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MergeNode",
      "returnType": {
        "$ref": "#/interfaces@160"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@224"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "merge"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@88"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@229"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DecisionNode",
      "returnType": {
        "$ref": "#/interfaces@162"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@224"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "decide"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@88"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@229"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "JoinNode",
      "returnType": {
        "$ref": "#/interfaces@161"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@224"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "join"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@88"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@229"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ForkNode",
      "returnType": {
        "$ref": "#/interfaces@159"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@224"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "fork"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@88"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@229"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionNodeBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@230"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionNodeItems",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "children",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@9"
          },
          "arguments": []
        },
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActionTargetSuccession",
      "returnType": {
        "$ref": "#/interfaces@90"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@232"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@233"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@234"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@90"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TargetSuccession",
      "returnType": {
        "$ref": "#/interfaces@163"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@122"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "then"
          },
          {
            "$type": "Assignment",
            "feature": "ends",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@132"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "GuardedTargetSuccession",
      "returnType": {
        "$ref": "#/interfaces@113"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "guard",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@259"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "then"
          },
          {
            "$type": "Assignment",
            "feature": "then",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@268"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefaultTargetSuccession",
      "returnType": {
        "$ref": "#/interfaces@113"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "else"
          },
          {
            "$type": "Assignment",
            "feature": "else",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@268"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "GuardedSuccession",
      "returnType": {
        "$ref": "#/interfaces@113"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "succession"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@88"
                },
                "arguments": []
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "first"
          },
          {
            "$type": "Assignment",
            "feature": "source",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@256"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "guard",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@259"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "then"
          },
          {
            "$type": "Assignment",
            "feature": "then",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@268"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@90"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StateDefinition",
      "returnType": {
        "$ref": "#/interfaces@107"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "state"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@237"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StateBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "isParallel",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "parallel"
                },
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@238"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StateBodyPart",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@239"
        },
        "arguments": [],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StateBodyItem",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@36"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@33"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@71"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@31"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@72"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@73"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@74"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@120"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@76"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@77"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@251"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@250"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@240"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@243"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@241"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@242"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EntryActionMember",
      "returnType": {
        "$ref": "#/interfaces@171"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "kind",
            "operator": "=",
            "terminal": {
              "$type": "Keyword",
              "value": "entry"
            }
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@249"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DoActionMember",
      "returnType": {
        "$ref": "#/interfaces@171"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "kind",
            "operator": "=",
            "terminal": {
              "$type": "Keyword",
              "value": "do"
            }
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@249"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExitActionMember",
      "returnType": {
        "$ref": "#/interfaces@171"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "kind",
            "operator": "=",
            "terminal": {
              "$type": "Keyword",
              "value": "exit"
            }
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@249"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EntryTransitionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "target",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@233"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "then"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "target",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@269"
                      },
                      "arguments": []
                    }
                  }
                ]
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StateActionUsage_1",
      "returnType": {
        "$ref": "#/interfaces@105"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "type": {
              "$ref": "#/interfaces@105"
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StateActionUsage_2",
      "returnType": {
        "$ref": "#/interfaces@152"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@190"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@181"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StateActionUsage_3",
      "returnType": {
        "$ref": "#/interfaces@114"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@196"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@181"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StateActionUsage_4",
      "returnType": {
        "$ref": "#/interfaces@157"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@207"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@181"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StateActionUsage_5",
      "returnType": {
        "$ref": "#/interfaces@150"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@212"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@181"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StateActionUsage",
      "returnType": {
        "$ref": "#/interfaces@105"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@244"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@245"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@246"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@247"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@248"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TransitionUsageMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@254"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TargetTransitionUsageMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@255"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StateUsage",
      "returnType": {
        "$ref": "#/interfaces@108"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "state"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@191"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@237"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExhibitStateUsage",
      "returnType": {
        "$ref": "#/interfaces@109"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "exhibit"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "heritage",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@57"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@44"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "state"
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@88"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  }
                ]
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@91"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@237"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TransitionUsage",
      "returnType": {
        "$ref": "#/interfaces@113"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "transition"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@88"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": "first"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "source",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@256"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "accepter",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@257"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "guard",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@259"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "effect",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@260"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "then"
          },
          {
            "$type": "Assignment",
            "feature": "then",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@268"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@181"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TargetTransitionUsage",
      "returnType": {
        "$ref": "#/interfaces@113"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "transition"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "accepter",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@257"
                      },
                      "arguments": []
                    },
                    "cardinality": "?"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "guard",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@259"
                      },
                      "arguments": []
                    },
                    "cardinality": "?"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "effect",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@260"
                      },
                      "arguments": []
                    },
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "accepter",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@257"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "guard",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@259"
                      },
                      "arguments": []
                    },
                    "cardinality": "?"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "effect",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@260"
                      },
                      "arguments": []
                    },
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "guard",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@259"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "effect",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@260"
                      },
                      "arguments": []
                    },
                    "cardinality": "?"
                  }
                ]
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "then"
          },
          {
            "$type": "Assignment",
            "feature": "then",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@268"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@181"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TransitionSourceMember",
      "returnType": {
        "$ref": "#/interfaces@58"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@427"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@59"
                }
              },
              {
                "$type": "Assignment",
                "feature": "target",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@446"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TriggerActionMember",
      "returnType": {
        "$ref": "#/interfaces@172"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "kind",
            "operator": "=",
            "terminal": {
              "$type": "Keyword",
              "value": "accept"
            }
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@258"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TriggerAction",
      "returnType": {
        "$ref": "#/interfaces@114"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@197"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "GuardExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@172"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "kind",
            "operator": "=",
            "terminal": {
              "$type": "Keyword",
              "value": "if"
            }
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@337"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EffectBehaviorMember",
      "returnType": {
        "$ref": "#/interfaces@172"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "kind",
            "operator": "=",
            "terminal": {
              "$type": "Keyword",
              "value": "do"
            }
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@267"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EffectBehaviorUsageBody",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "{"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@182"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "}"
          }
        ],
        "cardinality": "?"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EffectBehaviorUsage_1",
      "returnType": {
        "$ref": "#/interfaces@105"
      },
      "definition": {
        "$type": "Action",
        "type": {
          "$ref": "#/interfaces@105"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EffectBehaviorUsage_2",
      "returnType": {
        "$ref": "#/interfaces@152"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@190"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@261"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EffectBehaviorUsage_3",
      "returnType": {
        "$ref": "#/interfaces@114"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@196"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@261"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EffectBehaviorUsage_4",
      "returnType": {
        "$ref": "#/interfaces@157"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@207"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@261"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EffectBehaviorUsage_5",
      "returnType": {
        "$ref": "#/interfaces@150"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@212"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@261"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EffectBehaviorUsage",
      "returnType": {
        "$ref": "#/interfaces@105"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@262"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@263"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@264"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@265"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@266"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TransitionSuccessionMember",
      "returnType": {
        "$ref": "#/interfaces@59"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@269"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TransitionSuccession",
      "returnType": {
        "$ref": "#/interfaces@163"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "ends",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@132"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CalculationDefinition",
      "returnType": {
        "$ref": "#/interfaces@120"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "calc"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@271"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CalculationBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@272"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CalculationBodyPart",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@273"
            },
            "arguments": [],
            "cardinality": "*"
          },
          {
            "$type": "Assignment",
            "feature": "result",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CalculationBodyItem",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@183"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@274"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReturnParameterMember",
      "returnType": {
        "$ref": "#/interfaces@67"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "return"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@40"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ResultExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@66"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@337"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CalculationUsage",
      "returnType": {
        "$ref": "#/interfaces@121"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "calc"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@191"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@271"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConstraintDefinition",
      "returnType": {
        "$ref": "#/interfaces@110"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "constraint"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@271"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConstraintUsage",
      "returnType": {
        "$ref": "#/interfaces@111"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "constraint"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@280"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@271"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AssertConstraintUsage",
      "returnType": {
        "$ref": "#/interfaces@112"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "assert"
          },
          {
            "$type": "Assignment",
            "feature": "isNegated",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "not"
            },
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "heritage",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@57"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@44"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "constraint"
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@280"
                    },
                    "arguments": []
                  }
                ]
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@271"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConstraintUsageDeclaration",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@88"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@91"
            },
            "arguments": [],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RequirementDefinition",
      "returnType": {
        "$ref": "#/interfaces@115"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "requirement"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@282"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RequirementBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@283"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RequirementBodyItems",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@284"
        },
        "arguments": [],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RequirementBodyItem",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@70"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@285"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@287"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@289"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@314"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@291"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@293"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SubjectMember",
      "returnType": {
        "$ref": "#/interfaces@173"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "subject"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@286"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SubjectUsage",
      "returnType": {
        "$ref": "#/interfaces@93"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@82"
            },
            "arguments": [],
            "cardinality": "*"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RequirementConstraintMember",
      "returnType": {
        "$ref": "#/interfaces@176"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "kind",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@2"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@288"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RequirementConstraintUsage",
      "returnType": {
        "$ref": "#/interfaces@111"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@57"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@46"
                },
                "arguments": [],
                "cardinality": "*"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@271"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@82"
                        },
                        "arguments": [],
                        "cardinality": "*"
                      },
                      {
                        "$type": "Keyword",
                        "value": "constraint"
                      }
                    ]
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@82"
                    },
                    "arguments": [],
                    "cardinality": "+"
                  }
                ]
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@280"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@271"
                },
                "arguments": []
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FramedConcernMember",
      "returnType": {
        "$ref": "#/interfaces@177"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "frame"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@290"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FramedConcernUsage",
      "returnType": {
        "$ref": "#/interfaces@119"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@57"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@46"
                },
                "arguments": [],
                "cardinality": "*"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@282"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@82"
                        },
                        "arguments": [],
                        "cardinality": "*"
                      },
                      {
                        "$type": "Keyword",
                        "value": "concern"
                      }
                    ]
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@82"
                    },
                    "arguments": [],
                    "cardinality": "+"
                  }
                ]
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@280"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@271"
                },
                "arguments": []
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActorMember",
      "returnType": {
        "$ref": "#/interfaces@174"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "actor"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@292"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ActorUsage",
      "returnType": {
        "$ref": "#/interfaces@101"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@82"
            },
            "arguments": [],
            "cardinality": "*"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StakeholderMember",
      "returnType": {
        "$ref": "#/interfaces@175"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "stakeholder"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@294"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StakeholderUsage",
      "returnType": {
        "$ref": "#/interfaces@101"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@82"
            },
            "arguments": [],
            "cardinality": "*"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RequirementUsage",
      "returnType": {
        "$ref": "#/interfaces@116"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "requirement"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@280"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@282"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SatisfyRequirementUsage",
      "returnType": {
        "$ref": "#/interfaces@117"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "assert",
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "isNegated",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "not"
            },
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "satisfy"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "heritage",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@57"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@44"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "requirement"
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@88"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  }
                ]
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@91"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "by"
              },
              {
                "$type": "Assignment",
                "feature": "satisfactionSubject",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@297"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@282"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SatisfactionSubjectMember",
      "returnType": {
        "$ref": "#/interfaces@173"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@298"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SatisfactionParameter",
      "returnType": {
        "$ref": "#/interfaces@93"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@299"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SatisfactionFeatureValue",
      "returnType": {
        "$ref": "#/interfaces@60"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@300"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SatisfactionReferenceExpression",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@445"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConcernDefinition",
      "returnType": {
        "$ref": "#/interfaces@118"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "concern"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@282"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConcernUsage",
      "returnType": {
        "$ref": "#/interfaces@119"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "concern"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@280"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@282"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CaseDefinition",
      "returnType": {
        "$ref": "#/interfaces@122"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "case"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@304"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CaseBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@305"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CaseBodyItems",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@306"
            },
            "arguments": [],
            "cardinality": "*"
          },
          {
            "$type": "Assignment",
            "feature": "result",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@275"
              },
              "arguments": []
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CaseBodyItem",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@273"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@285"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@291"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@307"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ObjectiveMember",
      "returnType": {
        "$ref": "#/interfaces@179"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "objective"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@308"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ObjectiveRequirementUsage",
      "returnType": {
        "$ref": "#/interfaces@116"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@82"
            },
            "arguments": [],
            "cardinality": "*"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@280"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@282"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CaseUsage",
      "returnType": {
        "$ref": "#/interfaces@123"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "case"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@191"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@304"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AnalysisCaseDefinition",
      "returnType": {
        "$ref": "#/interfaces@124"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "analysis"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@304"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AnalysisCaseUsage",
      "returnType": {
        "$ref": "#/interfaces@125"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "analysis"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@191"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@304"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "VerificationCaseDefinition",
      "returnType": {
        "$ref": "#/interfaces@138"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "verification"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@304"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "VerificationCaseUsage",
      "returnType": {
        "$ref": "#/interfaces@139"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "verification"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@191"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@304"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RequirementVerificationMember",
      "returnType": {
        "$ref": "#/interfaces@178"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "verify"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@315"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RequirementVerificationUsage",
      "returnType": {
        "$ref": "#/interfaces@116"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@57"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@46"
                },
                "arguments": [],
                "cardinality": "*"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@282"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@82"
                        },
                        "arguments": [],
                        "cardinality": "*"
                      },
                      {
                        "$type": "Keyword",
                        "value": "requirement"
                      }
                    ]
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@82"
                    },
                    "arguments": [],
                    "cardinality": "+"
                  }
                ]
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@280"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@282"
                },
                "arguments": []
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UseCaseDefinition",
      "returnType": {
        "$ref": "#/interfaces@144"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "use"
          },
          {
            "$type": "Keyword",
            "value": "case"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@304"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UseCaseUsage",
      "returnType": {
        "$ref": "#/interfaces@145"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "use"
          },
          {
            "$type": "Keyword",
            "value": "case"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@191"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@304"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "IncludeUseCaseUsage",
      "returnType": {
        "$ref": "#/interfaces@146"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "include"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "heritage",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@57"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@44"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "use"
                  },
                  {
                    "$type": "Keyword",
                    "value": "case"
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@88"
                    },
                    "arguments": [],
                    "cardinality": "?"
                  }
                ]
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@91"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@304"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ViewDefinition",
      "returnType": {
        "$ref": "#/interfaces@132"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "view"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@320"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ViewDefinitionBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@321"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ViewDefinitionBodyItems",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@322"
        },
        "arguments": [],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ViewDefinitionBodyItem",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@70"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@32"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@323"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ViewRenderingMember",
      "returnType": {
        "$ref": "#/interfaces@180"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "render"
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@324"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ViewRenderingUsage",
      "returnType": {
        "$ref": "#/interfaces@137"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "heritage",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@57"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@46"
                },
                "arguments": [],
                "cardinality": "*"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@90"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@16"
                        },
                        "arguments": [],
                        "cardinality": "?"
                      },
                      {
                        "$type": "Keyword",
                        "value": "rendering"
                      }
                    ]
                  },
                  {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@16"
                    },
                    "arguments": []
                  }
                ]
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@87"
                },
                "arguments": []
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ViewUsage",
      "returnType": {
        "$ref": "#/interfaces@133"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "view"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@88"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@91"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@326"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ViewBody",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "{"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@327"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": "}"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ViewBodyItems",
      "fragment": true,
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@328"
        },
        "arguments": [],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ViewBodyItem",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@70"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@32"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@330"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@323"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExposePrefix",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@409"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "expose"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Expose",
      "returnType": {
        "$ref": "#/interfaces@164"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@329"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@35"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "target",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@37"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@11"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ViewpointDefinition",
      "returnType": {
        "$ref": "#/interfaces@134"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "viewpoint"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@282"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ViewpointUsage",
      "returnType": {
        "$ref": "#/interfaces@135"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "viewpoint"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@280"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@282"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RenderingDefinition",
      "returnType": {
        "$ref": "#/interfaces@136"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "rendering"
          },
          {
            "$type": "Keyword",
            "value": "def"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@66"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RenderingUsage",
      "returnType": {
        "$ref": "#/interfaces@137"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "rendering"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExpressionBody",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@271"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@337"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@340"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedExpressionReference",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@336"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConcreteConditionalExpression",
      "returnType": {
        "$ref": "#/interfaces@83"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "operator",
            "operator": "=",
            "terminal": {
              "$type": "Keyword",
              "value": "if"
            }
          },
          {
            "$type": "Assignment",
            "feature": "operands",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@341"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "?"
          },
          {
            "$type": "Assignment",
            "feature": "operands",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@338"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "else"
          },
          {
            "$type": "Assignment",
            "feature": "operands",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@338"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConditionalExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@341"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@339"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NullCoalescingExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@344"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "??"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@342"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImpliesExpressionReference",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@343"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImpliesExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@344"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImpliesExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@347"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "implies"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@345"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OrExpressionReference",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@346"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OrExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@347"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OrExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@350"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "operator",
                        "operator": "=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "|"
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operands",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@350"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "operator",
                        "operator": "=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "or"
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operands",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@348"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  }
                ]
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "XorExpressionReference",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@349"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "XorExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@350"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "XorExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@351"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "xor"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@351"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AndExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@354"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "operator",
                        "operator": "=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "&"
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operands",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@354"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "operator",
                        "operator": "=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "and"
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operands",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@352"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  }
                ]
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EqualityExpressionReference",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@353"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EqualityExpressionMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@354"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EqualityExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@355"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@433"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@355"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ClassificationExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@356"
                },
                "arguments": []
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Action",
                    "type": {
                      "$ref": "#/interfaces@83"
                    },
                    "feature": "operands",
                    "operator": "+="
                  },
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Assignment",
                            "feature": "operator",
                            "operator": "=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@431"
                              },
                              "arguments": []
                            }
                          },
                          {
                            "$type": "Assignment",
                            "feature": "children",
                            "operator": "+=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@438"
                              },
                              "arguments": []
                            }
                          }
                        ]
                      },
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Assignment",
                            "feature": "operator",
                            "operator": "=",
                            "terminal": {
                              "$type": "Keyword",
                              "value": "as"
                            }
                          },
                          {
                            "$type": "Assignment",
                            "feature": "children",
                            "operator": "+=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@439"
                              },
                              "arguments": []
                            }
                          }
                        ]
                      }
                    ]
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@431"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@438"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@437"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "@@"
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@438"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "as"
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@439"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@437"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "meta"
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@439"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RelationalExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@357"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@432"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@357"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RangeExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@358"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": ".."
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@358"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AdditiveExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@359"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "+"
                    },
                    {
                      "$type": "Keyword",
                      "value": "-"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@359"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicativeExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@360"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "*"
                    },
                    {
                      "$type": "Keyword",
                      "value": "/"
                    },
                    {
                      "$type": "Keyword",
                      "value": "%"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@360"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExponentiationExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@361"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "**"
                    },
                    {
                      "$type": "Keyword",
                      "value": "^"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@360"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnaryExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@430"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "operands",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@362"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@362"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExtentExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@83"
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "all"
                }
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@439"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@363"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrimaryExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@364"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@84"
                },
                "feature": "operands",
                "operator": "+="
              },
              {
                "$type": "Keyword",
                "value": "."
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@445"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Action",
                        "type": {
                          "$ref": "#/interfaces@81"
                        },
                        "feature": "operands",
                        "operator": "+="
                      },
                      {
                        "$type": "Keyword",
                        "value": "#"
                      },
                      {
                        "$type": "Keyword",
                        "value": "("
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operands",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@367"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Keyword",
                        "value": ")"
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Action",
                        "type": {
                          "$ref": "#/interfaces@83"
                        },
                        "feature": "operands",
                        "operator": "+="
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operator",
                        "operator": "=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "["
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operands",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@367"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Keyword",
                        "value": "]"
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Action",
                        "type": {
                          "$ref": "#/interfaces@82"
                        },
                        "feature": "operands",
                        "operator": "+="
                      },
                      {
                        "$type": "Keyword",
                        "value": "->"
                      },
                      {
                        "$type": "Assignment",
                        "feature": "heritage",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@441"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Alternatives",
                        "elements": [
                          {
                            "$type": "Assignment",
                            "feature": "children",
                            "operator": "+=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@366"
                              },
                              "arguments": []
                            }
                          },
                          {
                            "$type": "Assignment",
                            "feature": "children",
                            "operator": "+=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@443"
                              },
                              "arguments": []
                            }
                          },
                          {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@369"
                            },
                            "arguments": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Action",
                        "type": {
                          "$ref": "#/interfaces@85"
                        },
                        "feature": "operands",
                        "operator": "+="
                      },
                      {
                        "$type": "Keyword",
                        "value": "."
                      },
                      {
                        "$type": "Assignment",
                        "feature": "children",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@366"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Action",
                        "type": {
                          "$ref": "#/interfaces@86"
                        },
                        "feature": "operands",
                        "operator": "+="
                      },
                      {
                        "$type": "Keyword",
                        "value": ".?"
                      },
                      {
                        "$type": "Assignment",
                        "feature": "children",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@366"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Action",
                    "type": {
                      "$ref": "#/interfaces@84"
                    },
                    "feature": "operands",
                    "operator": "+="
                  },
                  {
                    "$type": "Keyword",
                    "value": "."
                  },
                  {
                    "$type": "Assignment",
                    "feature": "children",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@445"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BaseExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@396"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@395"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@450"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@452"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@368"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@365"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@367"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BodyExpression",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@366"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExpressionBodyMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@335"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SequenceExpression",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@337"
            },
            "arguments": []
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Action",
                    "type": {
                      "$ref": "#/interfaces@83"
                    },
                    "feature": "operands",
                    "operator": "+="
                  },
                  {
                    "$type": "Assignment",
                    "feature": "operator",
                    "operator": "=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": ","
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "operands",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@367"
                      },
                      "arguments": []
                    }
                  }
                ]
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InvocationExpression",
      "returnType": {
        "$ref": "#/interfaces@82"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@435"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@369"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ArgumentList",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@370"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@373"
                },
                "arguments": []
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PositionalArgumentList",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@371"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@371"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ArgumentMember",
      "returnType": {
        "$ref": "#/interfaces@65"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@372"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Argument",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@377"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamedArgumentList",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "children",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@374"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "children",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@374"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamedArgumentMember",
      "returnType": {
        "$ref": "#/interfaces@65"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@375"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamedArgument",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "heritage",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@376"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "="
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@377"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParameterRedefinition",
      "returnType": {
        "$ref": "#/interfaces@51"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@427"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ArgumentValue",
      "returnType": {
        "$ref": "#/interfaces@60"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@337"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "TerminalRule",
      "fragment": true,
      "name": "DECIMAL",
      "definition": {
        "$type": "RegexToken",
        "regex": "[0-9]+"
      },
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "fragment": true,
      "name": "FRACTION",
      "definition": {
        "$type": "TerminalGroup",
        "elements": [
          {
            "$type": "CharacterRange",
            "left": {
              "$type": "Keyword",
              "value": "."
            }
          },
          {
            "$type": "TerminalRuleCall",
            "rule": {
              "$ref": "#/rules@378"
            }
          }
        ]
      },
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "fragment": true,
      "name": "FLOAT",
      "definition": {
        "$type": "TerminalAlternatives",
        "elements": [
          {
            "$type": "TerminalGroup",
            "elements": [
              {
                "$type": "TerminalRuleCall",
                "rule": {
                  "$ref": "#/rules@378"
                }
              },
              {
                "$type": "TerminalRuleCall",
                "rule": {
                  "$ref": "#/rules@379"
                },
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "TerminalRuleCall",
            "rule": {
              "$ref": "#/rules@379"
            }
          }
        ]
      },
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "fragment": true,
      "name": "EXPONENT",
      "definition": {
        "$type": "TerminalGroup",
        "elements": [
          {
            "$type": "RegexToken",
            "regex": "[eE][\\\\-\\\\+]*"
          },
          {
            "$type": "TerminalRuleCall",
            "rule": {
              "$ref": "#/rules@378"
            }
          }
        ]
      },
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "NUMBER",
      "type": {
        "$type": "ReturnType",
        "name": "number"
      },
      "definition": {
        "$type": "TerminalGroup",
        "elements": [
          {
            "$type": "TerminalRuleCall",
            "rule": {
              "$ref": "#/rules@380"
            }
          },
          {
            "$type": "TerminalRuleCall",
            "rule": {
              "$ref": "#/rules@381"
            },
            "cardinality": "?"
          }
        ]
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "ID",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "[_a-zA-Z][\\\\w_\\\\d]*"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "UNRESTRICTED_NAME",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "'(\\\\\\\\['\\"bftnr\\\\\\\\]|[^'\\\\\\\\])*'"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "STRING_VALUE",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "\\"[^\\"]*\\""
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "REGULAR_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "ML_NOTE",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "SL_NOTE",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\/[^\\\\n\\\\r]*"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "WS",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\s+"
      },
      "fragment": false
    },
    {
      "$type": "ParserRule",
      "name": "Name",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@383"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@384"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LiteralBoolean",
      "returnType": {
        "$ref": "#/interfaces@76"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "false"
          },
          {
            "$type": "Assignment",
            "feature": "literal",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "true"
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LiteralString",
      "returnType": {
        "$ref": "#/interfaces@77"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "literal",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@385"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LiteralNumber",
      "returnType": {
        "$ref": "#/interfaces@78"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "literal",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@382"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LiteralInfinity",
      "returnType": {
        "$ref": "#/interfaces@79"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "type": {
              "$ref": "#/interfaces@79"
            }
          },
          {
            "$type": "Keyword",
            "value": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LiteralExpression",
      "returnType": {
        "$ref": "#/interfaces@75"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@391"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@392"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@393"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@394"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NullExpression",
      "returnType": {
        "$ref": "#/interfaces@80"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "type": {
              "$ref": "#/interfaces@80"
            }
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "null"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ShortName",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "<"
          },
          {
            "$type": "Assignment",
            "feature": "declaredShortName",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@390"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ">"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RegularName",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "declaredName",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@390"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Identification",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@397"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@398"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@398"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SpecializesToken",
      "fragment": true,
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ":>"
          },
          {
            "$type": "Keyword",
            "value": "specializes"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SubsetsToken",
      "fragment": true,
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ":>"
          },
          {
            "$type": "Keyword",
            "value": "subsets"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReferencesToken",
      "fragment": true,
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "::>"
          },
          {
            "$type": "Keyword",
            "value": "references"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CrossesToken",
      "fragment": true,
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "=>"
          },
          {
            "$type": "Keyword",
            "value": "crosses"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RedefinesToken",
      "fragment": true,
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": ":>>"
          },
          {
            "$type": "Keyword",
            "value": "redefines"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureDirectionKind",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "in"
          },
          {
            "$type": "Keyword",
            "value": "inout"
          },
          {
            "$type": "Keyword",
            "value": "out"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "VisibilityKind",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "private"
          },
          {
            "$type": "Keyword",
            "value": "protected"
          },
          {
            "$type": "Keyword",
            "value": "public"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImportKind",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "::*"
          },
          {
            "$type": "Keyword",
            "value": "::**"
          },
          {
            "$type": "Keyword",
            "value": "::*::**"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Abstract",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isAbstract",
        "operator": "=",
        "terminal": {
          "$type": "Keyword",
          "value": "abstract"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Visibility",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "visibility",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@406"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Readonly",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isReadOnly",
        "operator": "=",
        "terminal": {
          "$type": "Keyword",
          "value": "readonly"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Derived",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isDerived",
        "operator": "=",
        "terminal": {
          "$type": "Keyword",
          "value": "derived"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "End",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isEnd",
        "operator": "=",
        "terminal": {
          "$type": "Keyword",
          "value": "end"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Sufficient",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isSufficient",
        "operator": "?=",
        "terminal": {
          "$type": "Keyword",
          "value": "all"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Standard",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "isStandard",
        "operator": "?=",
        "terminal": {
          "$type": "Keyword",
          "value": "standard"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ImportAll",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "importsAll",
        "operator": "?=",
        "terminal": {
          "$type": "Keyword",
          "value": "all"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultiplicityProperties",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "isOrdered",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "ordered"
                }
              },
              {
                "$type": "Assignment",
                "feature": "isNonunique",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "nonunique"
                },
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "isNonunique",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "nonunique"
                }
              },
              {
                "$type": "Assignment",
                "feature": "isOrdered",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "ordered"
                },
                "cardinality": "?"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Annotation",
      "returnType": {
        "$ref": "#/interfaces@0"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@423"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TextualAnnotatingElementBody",
      "fragment": true,
      "definition": {
        "$type": "Assignment",
        "feature": "body",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@386"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Comment",
      "returnType": {
        "$ref": "#/interfaces@3"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "comment"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@399"
                },
                "arguments": [],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "about"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "about",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@417"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "about",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@417"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "locale"
              },
              {
                "$type": "Assignment",
                "feature": "locale",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@385"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@418"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Documentation",
      "returnType": {
        "$ref": "#/interfaces@4"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "doc"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@399"
            },
            "arguments": [],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "locale"
              },
              {
                "$type": "Assignment",
                "feature": "locale",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@385"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@418"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TextualRepresentation",
      "returnType": {
        "$ref": "#/interfaces@5"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "rep"
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@399"
                },
                "arguments": [],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "language"
          },
          {
            "$type": "Assignment",
            "feature": "language",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@385"
              },
              "arguments": []
            }
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@418"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "QualifiedReferenceChain",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "parts",
            "operator": "+=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/interfaces@6"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@390"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "::"
              },
              {
                "$type": "Assignment",
                "feature": "parts",
                "operator": "+=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/interfaces@6"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@390"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ElementReference",
      "returnType": {
        "$ref": "#/interfaces@68"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@422"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamespaceReference",
      "returnType": {
        "$ref": "#/interfaces@69"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@422"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeReference",
      "returnType": {
        "$ref": "#/interfaces@70"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@422"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ClassifierReference",
      "returnType": {
        "$ref": "#/interfaces@71"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@422"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureReference",
      "returnType": {
        "$ref": "#/interfaces@72"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@422"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetaclassReference",
      "returnType": {
        "$ref": "#/interfaces@73"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@422"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MembershipReference",
      "returnType": {
        "$ref": "#/interfaces@74"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@422"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnaryOperator",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "+"
          },
          {
            "$type": "Keyword",
            "value": "-"
          },
          {
            "$type": "Keyword",
            "value": "~"
          },
          {
            "$type": "Keyword",
            "value": "not"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ClassificationTestOperator",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "istype"
          },
          {
            "$type": "Keyword",
            "value": "hastype"
          },
          {
            "$type": "Keyword",
            "value": "@"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RelationalOperator",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "<"
          },
          {
            "$type": "Keyword",
            "value": ">"
          },
          {
            "$type": "Keyword",
            "value": "<="
          },
          {
            "$type": "Keyword",
            "value": ">="
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EqualityOperator",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "=="
          },
          {
            "$type": "Keyword",
            "value": "!="
          },
          {
            "$type": "Keyword",
            "value": "==="
          },
          {
            "$type": "Keyword",
            "value": "!=="
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataTyping",
      "returnType": {
        "$ref": "#/interfaces@47"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@428"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedFeatureTyping",
      "returnType": {
        "$ref": "#/interfaces@47"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@436"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureType",
      "fragment": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@425"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "targetChain",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@446"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataReference",
      "returnType": {
        "$ref": "#/interfaces@88"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "reference",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@423"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeReferenceMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@440"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeResultMember",
      "returnType": {
        "$ref": "#/interfaces@67"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@440"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeReferenceFeature",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "heritage",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@441"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReferenceTyping",
      "returnType": {
        "$ref": "#/interfaces@47"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@425"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FunctionReferenceExpression",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@443"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FunctionReferenceMember",
      "returnType": {
        "$ref": "#/interfaces@63"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "target",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@444"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FunctionReference",
      "returnType": {
        "$ref": "#/interfaces@30"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "heritage",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@441"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureChainMember",
      "returnType": {
        "$ref": "#/interfaces@58"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "targetRef",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@427"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "type": {
                  "$ref": "#/interfaces@59"
                }
              },
              {
                "$type": "Assignment",
                "feature": "target",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@446"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedFeatureChain",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@447"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureChain",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "typeRelationships",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@449"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "."
              },
              {
                "$type": "Assignment",
                "feature": "typeRelationships",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@449"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "+"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureChainPrefix",
      "returnType": {
        "$ref": "#/interfaces@20"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "typeRelationships",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@449"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": "."
              }
            ],
            "cardinality": "+"
          },
          {
            "$type": "Assignment",
            "feature": "typeRelationships",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@449"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "."
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OwnedFeatureChaining",
      "returnType": {
        "$ref": "#/interfaces@42"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@427"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureReferenceExpression",
      "returnType": {
        "$ref": "#/interfaces@87"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@451"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureReferenceMember",
      "returnType": {
        "$ref": "#/interfaces@58"
      },
      "definition": {
        "$type": "Assignment",
        "feature": "targetRef",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@427"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MetadataAccessExpression",
      "returnType": {
        "$ref": "#/interfaces@88"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "reference",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@423"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "."
          },
          {
            "$type": "Keyword",
            "value": "metadata"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    }
  ],
  "definesHiddenTokens": false,
  "hiddenTokens": [],
  "interfaces": [
    {
      "$type": "Interface",
      "name": "Annotation",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "about",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@0"
              }
            }
          },
          "isOptional": false
        }
      ],
      "name": "AnnotatingElement",
      "superTypes": [
        {
          "$ref": "#/interfaces@6"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "body",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          },
          "isOptional": false
        }
      ],
      "name": "TextualAnnotatingElement",
      "superTypes": [
        {
          "$ref": "#/interfaces@1"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "locale",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          }
        }
      ],
      "name": "Comment",
      "superTypes": [
        {
          "$ref": "#/interfaces@2"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "Documentation",
      "superTypes": [
        {
          "$ref": "#/interfaces@3"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "language",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          },
          "isOptional": false
        }
      ],
      "name": "TextualRepresentation",
      "superTypes": [
        {
          "$ref": "#/interfaces@2"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "declaredName",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "declaredShortName",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          }
        }
      ],
      "name": "Element",
      "superTypes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "prefixes",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@59"
              }
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "children",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "UnionType",
              "types": [
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/interfaces@55"
                  }
                },
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/interfaces@58"
                  }
                }
              ]
            }
          },
          "isOptional": false
        }
      ],
      "name": "Namespace",
      "superTypes": [
        {
          "$ref": "#/interfaces@6"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isSufficient",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "isAbstract",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "abstract"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "heritage",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@38"
              }
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "typeRelationships",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "UnionType",
              "types": [
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/types@9"
                  }
                },
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/types@10"
                  }
                }
              ]
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "multiplicity",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@59"
            }
          }
        }
      ],
      "name": "Type",
      "superTypes": [
        {
          "$ref": "#/interfaces@7"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "Classifier",
      "superTypes": [
        {
          "$ref": "#/interfaces@8"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "DataType",
      "superTypes": [
        {
          "$ref": "#/interfaces@9"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Class",
      "superTypes": [
        {
          "$ref": "#/interfaces@9"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Structure",
      "superTypes": [
        {
          "$ref": "#/interfaces@11"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Behavior",
      "superTypes": [
        {
          "$ref": "#/interfaces@11"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Association",
      "superTypes": [
        {
          "$ref": "#/interfaces@9"
        },
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "AssociationStructure",
      "superTypes": [
        {
          "$ref": "#/interfaces@14"
        },
        {
          "$ref": "#/interfaces@12"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Metaclass",
      "superTypes": [
        {
          "$ref": "#/interfaces@12"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "result",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@66"
            }
          }
        }
      ],
      "name": "SysMLFunction",
      "superTypes": [
        {
          "$ref": "#/interfaces@13"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "Predicate",
      "superTypes": [
        {
          "$ref": "#/interfaces@17"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Interaction",
      "superTypes": [
        {
          "$ref": "#/interfaces@14"
        },
        {
          "$ref": "#/interfaces@13"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isNonunique",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "isOrdered",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "direction",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/types@1"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "isComposite",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "composite"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "isDerived",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "derived"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "isEnd",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "end"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "isPortion",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "portion"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "isReadOnly",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "readonly"
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "value",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@60"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "write",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@58"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "crossingFeature",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@59"
            }
          }
        }
      ],
      "name": "Feature",
      "superTypes": [
        {
          "$ref": "#/interfaces@8"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "MetadataFeature",
      "superTypes": [
        {
          "$ref": "#/interfaces@20"
        },
        {
          "$ref": "#/interfaces@1"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Multiplicity",
      "superTypes": [
        {
          "$ref": "#/interfaces@20"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "range",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@59"
            }
          }
        }
      ],
      "name": "MultiplicityRange",
      "superTypes": [
        {
          "$ref": "#/interfaces@22"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "ItemFeature",
      "superTypes": [
        {
          "$ref": "#/interfaces@20"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Step",
      "superTypes": [
        {
          "$ref": "#/interfaces@20"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "ends",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@64"
              }
            }
          },
          "isOptional": false
        }
      ],
      "name": "Connector",
      "superTypes": [
        {
          "$ref": "#/interfaces@20"
        },
        {
          "$ref": "#/interfaces@37"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "ItemFlowEnd",
      "superTypes": [
        {
          "$ref": "#/interfaces@20"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Succession",
      "superTypes": [
        {
          "$ref": "#/interfaces@26"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "BindingConnector",
      "superTypes": [
        {
          "$ref": "#/interfaces@26"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "result",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@66"
            }
          }
        }
      ],
      "name": "Expression",
      "superTypes": [
        {
          "$ref": "#/interfaces@25"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "item",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@63"
            }
          }
        }
      ],
      "name": "ItemFlow",
      "superTypes": [
        {
          "$ref": "#/interfaces@26"
        },
        {
          "$ref": "#/interfaces@25"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "SuccessionItemFlow",
      "superTypes": [
        {
          "$ref": "#/interfaces@31"
        },
        {
          "$ref": "#/interfaces@28"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "BooleanExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@30"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isNegated",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "Invariant",
      "superTypes": [
        {
          "$ref": "#/interfaces@33"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "Package",
      "superTypes": [
        {
          "$ref": "#/interfaces@7"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isStandard",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "LibraryPackage",
      "superTypes": [
        {
          "$ref": "#/interfaces@35"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "visibility",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/types@0"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "elements",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "UnionType",
              "types": [
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/interfaces@7"
                  }
                },
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/interfaces@37"
                  }
                },
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/interfaces@20"
                  }
                },
                {
                  "$type": "SimpleType",
                  "typeRef": {
                    "$ref": "#/interfaces@0"
                  }
                }
              ]
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "source",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@6"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "sourceRef",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@68"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "sourceChain",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@20"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "target",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@6"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "targetRef",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@68"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "targetChain",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@20"
            }
          }
        }
      ],
      "name": "Relationship",
      "superTypes": [
        {
          "$ref": "#/interfaces@6"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "Inheritance",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Unioning",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Differencing",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Intersecting",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "FeatureChaining",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Specialization",
      "superTypes": [
        {
          "$ref": "#/interfaces@38"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Disjoining",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "FeatureInverting",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "TypeFeaturing",
      "superTypes": [
        {
          "$ref": "#/interfaces@62"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "FeatureTyping",
      "superTypes": [
        {
          "$ref": "#/interfaces@43"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Subclassification",
      "superTypes": [
        {
          "$ref": "#/interfaces@43"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Subsetting",
      "superTypes": [
        {
          "$ref": "#/interfaces@43"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Conjugation",
      "superTypes": [
        {
          "$ref": "#/interfaces@38"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Redefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@49"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ReferenceSubsetting",
      "superTypes": [
        {
          "$ref": "#/interfaces@49"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "CrossSubsetting",
      "superTypes": [
        {
          "$ref": "#/interfaces@49"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "prefixes",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@0"
              }
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "client",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@68"
              }
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "supplier",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@68"
              }
            }
          },
          "isOptional": false
        }
      ],
      "name": "Dependency",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "importsAll",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "isRecursive",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "isNamespace",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "stringType": "::*"
          }
        }
      ],
      "name": "Import",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "MembershipImport",
      "superTypes": [
        {
          "$ref": "#/interfaces@55"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "NamespaceImport",
      "superTypes": [
        {
          "$ref": "#/interfaces@55"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isAlias",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "Membership",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "OwningMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@58"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isDefault",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "isInitial",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "FeatureValue",
      "superTypes": [
        {
          "$ref": "#/interfaces@59"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "ElementFilterMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@59"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Featuring",
      "superTypes": [
        {
          "$ref": "#/interfaces@37"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "FeatureMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@62"
        },
        {
          "$ref": "#/interfaces@59"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "EndFeatureMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@63"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ParameterMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@63"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ResultExpressionMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@63"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ReturnParameterMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@65"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "parts",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "ReferenceType",
              "referenceType": {
                "$type": "SimpleType",
                "typeRef": {
                  "$ref": "#/interfaces@6"
                }
              }
            }
          },
          "isOptional": false
        }
      ],
      "name": "ElementReference",
      "superTypes": []
    },
    {
      "$type": "Interface",
      "name": "NamespaceReference",
      "superTypes": [
        {
          "$ref": "#/interfaces@68"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "TypeReference",
      "superTypes": [
        {
          "$ref": "#/interfaces@69"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ClassifierReference",
      "superTypes": [
        {
          "$ref": "#/interfaces@70"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "FeatureReference",
      "superTypes": [
        {
          "$ref": "#/interfaces@70"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "MetaclassReference",
      "superTypes": [
        {
          "$ref": "#/interfaces@71"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "MembershipReference",
      "superTypes": [
        {
          "$ref": "#/interfaces@68"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "LiteralExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@30"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "literal",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "LiteralBoolean",
      "superTypes": [
        {
          "$ref": "#/interfaces@75"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "literal",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          },
          "isOptional": false
        }
      ],
      "name": "LiteralString",
      "superTypes": [
        {
          "$ref": "#/interfaces@75"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "literal",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "number"
          },
          "isOptional": false
        }
      ],
      "name": "LiteralNumber",
      "superTypes": [
        {
          "$ref": "#/interfaces@75"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "LiteralInfinity",
      "superTypes": [
        {
          "$ref": "#/interfaces@75"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "NullExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@30"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "IndexExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@83"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "operands",
          "isOptional": true,
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@30"
              }
            }
          }
        }
      ],
      "name": "InvocationExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@30"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "operator",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "primitiveType": "string"
          }
        }
      ],
      "name": "OperatorExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@82"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "FeatureChainExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@83"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "CollectExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@83"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "SelectExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@83"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "expression",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@58"
            }
          },
          "isOptional": false
        }
      ],
      "name": "FeatureReferenceExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@30"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "reference",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@68"
            }
          },
          "isOptional": false
        }
      ],
      "name": "MetadataAccessExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@30"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isVariation",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "isIndividual",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "Definition",
      "superTypes": [
        {
          "$ref": "#/interfaces@9"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isVariation",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "isReference",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "portionKind",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/types@15"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "isIndividual",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "Usage",
      "superTypes": [
        {
          "$ref": "#/interfaces@20"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "MetadataDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@16"
        },
        {
          "$ref": "#/interfaces@98"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "MetadataUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@21"
        },
        {
          "$ref": "#/interfaces@99"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ReferenceUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@90"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "OccurrenceDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@89"
        },
        {
          "$ref": "#/interfaces@11"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "OccurrenceUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@90"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "AttributeDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@89"
        },
        {
          "$ref": "#/interfaces@10"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "AttributeUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@90"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ItemDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@94"
        },
        {
          "$ref": "#/interfaces@12"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ItemUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@95"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "PartDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@98"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "PartUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@99"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "PortDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@94"
        },
        {
          "$ref": "#/interfaces@12"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "PortUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@95"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ActionDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@94"
        },
        {
          "$ref": "#/interfaces@13"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ActionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@95"
        },
        {
          "$ref": "#/interfaces@25"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "condition",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "then",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "else",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          }
        }
      ],
      "name": "IfActionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@105"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isParallel",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "StateDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@104"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "isParallel",
          "type": {
            "$type": "SimpleType",
            "primitiveType": "boolean"
          },
          "isOptional": false
        }
      ],
      "name": "StateUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@105"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "ExhibitStateUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@108"
        },
        {
          "$ref": "#/interfaces@152"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ConstraintDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@94"
        },
        {
          "$ref": "#/interfaces@18"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ConstraintUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@95"
        },
        {
          "$ref": "#/interfaces@33"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "AssertConstraintUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@111"
        },
        {
          "$ref": "#/interfaces@34"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "source",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@58"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "transitionLinkSource",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "payload",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "accepter",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@172"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "guard",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@172"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "effect",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@172"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "then",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@59"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "else",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@59"
            }
          }
        }
      ],
      "name": "TransitionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@105"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "payload",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "receiver",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          }
        }
      ],
      "name": "AcceptActionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@105"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "RequirementDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@110"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "RequirementUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@111"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "satisfactionSubject",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@173"
            }
          }
        }
      ],
      "name": "SatisfyRequirementUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@116"
        },
        {
          "$ref": "#/interfaces@112"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "ConcernDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@115"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ConcernUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@116"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "CalculationDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@104"
        },
        {
          "$ref": "#/interfaces@17"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "CalculationUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@105"
        },
        {
          "$ref": "#/interfaces@30"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "CaseDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@120"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "CaseUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@121"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "AnalysisCaseDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@122"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "AnalysisCaseUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@123"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ConnectorAsUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@90"
        },
        {
          "$ref": "#/interfaces@26"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "BindingConnectorAsUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@126"
        },
        {
          "$ref": "#/interfaces@29"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ConnectionDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@100"
        },
        {
          "$ref": "#/interfaces@15"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ConnectionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@101"
        },
        {
          "$ref": "#/interfaces@126"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "InterfaceDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@128"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "InterfaceUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@129"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ViewDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@100"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ViewUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@101"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ViewpointDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@115"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ViewpointUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@116"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "RenderingDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@100"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "RenderingUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@101"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "VerificationCaseDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@122"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "VerificationCaseUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@123"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "EnumerationDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@96"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "EnumerationUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@97"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "AllocationDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@128"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "AllocationUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@129"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "UseCaseDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@122"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "UseCaseUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@123"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "IncludeUseCaseUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@145"
        },
        {
          "$ref": "#/interfaces@152"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "FlowConnectionDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@104"
        },
        {
          "$ref": "#/interfaces@19"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "messages",
          "type": {
            "$type": "ArrayType",
            "elementType": {
              "$type": "SimpleType",
              "typeRef": {
                "$ref": "#/interfaces@65"
              }
            }
          },
          "isOptional": false
        }
      ],
      "name": "FlowConnectionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@126"
        },
        {
          "$ref": "#/interfaces@105"
        },
        {
          "$ref": "#/interfaces@31"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "SuccessionFlowConnectionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@148"
        },
        {
          "$ref": "#/interfaces@32"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "targetMember",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@58"
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "assignedValue",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          },
          "isOptional": false
        }
      ],
      "name": "AssignmentActionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@105"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "kind",
          "type": {
            "$type": "UnionType",
            "types": [
              {
                "$type": "SimpleType",
                "stringType": "at"
              },
              {
                "$type": "SimpleType",
                "stringType": "after"
              },
              {
                "$type": "SimpleType",
                "stringType": "when"
              }
            ]
          },
          "isOptional": false
        }
      ],
      "name": "TriggerInvocationExpression",
      "superTypes": [
        {
          "$ref": "#/interfaces@82"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "PerformActionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@105"
        },
        {
          "$ref": "#/interfaces@153"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "EventOccurrenceUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@95"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "LoopActionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@105"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "condition",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "body",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "until",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          }
        }
      ],
      "name": "WhileLoopActionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@154"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "variable",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@63"
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "sequence",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "body",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          },
          "isOptional": false
        }
      ],
      "name": "ForLoopActionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@154"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "payload",
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          },
          "isOptional": false
        },
        {
          "$type": "TypeAttribute",
          "name": "sender",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          }
        },
        {
          "$type": "TypeAttribute",
          "name": "receiver",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          }
        }
      ],
      "name": "SendActionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@105"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "ControlNode",
      "superTypes": [
        {
          "$ref": "#/interfaces@105"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ForkNode",
      "superTypes": [
        {
          "$ref": "#/interfaces@158"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "MergeNode",
      "superTypes": [
        {
          "$ref": "#/interfaces@158"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "JoinNode",
      "superTypes": [
        {
          "$ref": "#/interfaces@158"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "DecisionNode",
      "superTypes": [
        {
          "$ref": "#/interfaces@158"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "SuccessionAsUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@126"
        },
        {
          "$ref": "#/interfaces@28"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "Expose",
      "superTypes": [
        {
          "$ref": "#/interfaces@55"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ConjugatedPortReference",
      "superTypes": [
        {
          "$ref": "#/interfaces@71"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "VariantMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@59"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "LifeClass",
      "superTypes": [
        {
          "$ref": "#/interfaces@11"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ConjugatedPortDefinition",
      "superTypes": [
        {
          "$ref": "#/interfaces@102"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ConjugatedPortTyping",
      "superTypes": [
        {
          "$ref": "#/interfaces@47"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "PortConjugation",
      "superTypes": [
        {
          "$ref": "#/interfaces@50"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "kind",
          "type": {
            "$type": "UnionType",
            "types": [
              {
                "$type": "SimpleType",
                "stringType": "entry"
              },
              {
                "$type": "SimpleType",
                "stringType": "exit"
              },
              {
                "$type": "SimpleType",
                "stringType": "do"
              }
            ]
          },
          "isOptional": false
        }
      ],
      "name": "StateSubactionMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@63"
        }
      ]
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "kind",
          "type": {
            "$type": "UnionType",
            "types": [
              {
                "$type": "SimpleType",
                "stringType": "accept"
              },
              {
                "$type": "SimpleType",
                "stringType": "if"
              },
              {
                "$type": "SimpleType",
                "stringType": "do"
              }
            ]
          },
          "isOptional": false
        }
      ],
      "name": "TransitionFeatureMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@63"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "SubjectMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@65"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ActorMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@65"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "StakeholderMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@65"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "kind",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/types@14"
            }
          }
        }
      ],
      "name": "RequirementConstraintMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@63"
        }
      ]
    },
    {
      "$type": "Interface",
      "name": "FramedConcernMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@176"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "RequirementVerificationMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@176"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ObjectiveMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@63"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "ViewRenderingMembership",
      "superTypes": [
        {
          "$ref": "#/interfaces@63"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "MembershipExpose",
      "superTypes": [
        {
          "$ref": "#/interfaces@164"
        },
        {
          "$ref": "#/interfaces@56"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "name": "NamespaceExpose",
      "superTypes": [
        {
          "$ref": "#/interfaces@164"
        },
        {
          "$ref": "#/interfaces@57"
        }
      ],
      "attributes": []
    },
    {
      "$type": "Interface",
      "attributes": [
        {
          "$type": "TypeAttribute",
          "name": "terminatedOccurrence",
          "isOptional": true,
          "type": {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@65"
            }
          }
        }
      ],
      "name": "TerminateActionUsage",
      "superTypes": [
        {
          "$ref": "#/interfaces@105"
        }
      ]
    }
  ],
  "types": [
    {
      "$type": "Type",
      "name": "VisibilityKind",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "private"
          },
          {
            "$type": "SimpleType",
            "stringType": "protected"
          },
          {
            "$type": "SimpleType",
            "stringType": "public"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "FeatureDirectionKind",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "in"
          },
          {
            "$type": "SimpleType",
            "stringType": "inout"
          },
          {
            "$type": "SimpleType",
            "stringType": "out"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "UnaryOperator",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "+"
          },
          {
            "$type": "SimpleType",
            "stringType": "-"
          },
          {
            "$type": "SimpleType",
            "stringType": "not"
          },
          {
            "$type": "SimpleType",
            "stringType": "~"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "ClassificationTestOperator",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "@"
          },
          {
            "$type": "SimpleType",
            "stringType": "hastype"
          },
          {
            "$type": "SimpleType",
            "stringType": "istype"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "EqualityOperator",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "!="
          },
          {
            "$type": "SimpleType",
            "stringType": "!=="
          },
          {
            "$type": "SimpleType",
            "stringType": "=="
          },
          {
            "$type": "SimpleType",
            "stringType": "==="
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "ImportKind",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "::*"
          },
          {
            "$type": "SimpleType",
            "stringType": "::**"
          },
          {
            "$type": "SimpleType",
            "stringType": "::*::**"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "RelationalOperator",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "<"
          },
          {
            "$type": "SimpleType",
            "stringType": "<="
          },
          {
            "$type": "SimpleType",
            "stringType": ">"
          },
          {
            "$type": "SimpleType",
            "stringType": ">="
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "InlineExpression",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@84"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@81"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@82"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@75"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@88"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@80"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@83"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@85"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@86"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@87"
            }
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "NonOwnerType",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@58"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@0"
            }
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "TypeRelationship",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@39"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@40"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@44"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@41"
            }
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "FeatureRelationship",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/types@9"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@42"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@45"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@46"
            }
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "TransparentElement",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/interfaces@154"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/types@8"
            }
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "RequirementKind",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "objective"
          },
          {
            "$type": "SimpleType",
            "stringType": "verify"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "ParameterKind",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "actor"
          },
          {
            "$type": "SimpleType",
            "stringType": "stakeholder"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "RequirementConstraintKind",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "assume"
          },
          {
            "$type": "SimpleType",
            "stringType": "require"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "PortionKind",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "timeslice"
          },
          {
            "$type": "SimpleType",
            "stringType": "snapshot"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "TriggerKind",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "when"
          },
          {
            "$type": "SimpleType",
            "stringType": "at"
          },
          {
            "$type": "SimpleType",
            "stringType": "after"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "StateSubactionKind",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "entry"
          },
          {
            "$type": "SimpleType",
            "stringType": "do"
          },
          {
            "$type": "SimpleType",
            "stringType": "exit"
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "TransitionFeatureKind",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "stringType": "trigger"
          },
          {
            "$type": "SimpleType",
            "stringType": "guard"
          },
          {
            "$type": "SimpleType",
            "stringType": "effect"
          }
        ]
      }
    }
  ],
  "usedGrammars": []
}`);
    exports2.SysMLGrammar = SysMLGrammar;
  }
});

// ../syside-languageserver/lib/generated/module.js
var require_module2 = __commonJS({
  "../syside-languageserver/lib/generated/module.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLGeneratedModule = exports2.KerMLGeneratedModule = exports2.SysMlGeneratedSharedModule = exports2.parserConfig = exports2.SysMLLanguageMetaData = exports2.KerMLLanguageMetaData = void 0;
    var ast_1 = require_ast2();
    var grammar_1 = require_grammar3();
    exports2.KerMLLanguageMetaData = {
      languageId: "kerml",
      fileExtensions: [".kerml"],
      caseInsensitive: false
    };
    exports2.SysMLLanguageMetaData = {
      languageId: "sysml",
      fileExtensions: [".sysml"],
      caseInsensitive: false
    };
    exports2.parserConfig = {
      recoveryEnabled: true,
      nodeLocationTracking: "none"
    };
    exports2.SysMlGeneratedSharedModule = {
      AstReflection: () => new ast_1.SysMlAstReflection()
    };
    exports2.KerMLGeneratedModule = {
      Grammar: () => (0, grammar_1.KerMLGrammar)(),
      LanguageMetaData: () => exports2.KerMLLanguageMetaData,
      parser: {
        ParserConfig: () => exports2.parserConfig
      }
    };
    exports2.SysMLGeneratedModule = {
      Grammar: () => (0, grammar_1.SysMLGrammar)(),
      LanguageMetaData: () => exports2.SysMLLanguageMetaData,
      parser: {
        ParserConfig: () => exports2.parserConfig
      }
    };
  }
});

// ../syside-languageserver/lib/utils/ast-util.js
var require_ast_util2 = __commonJS({
  "../syside-languageserver/lib/utils/ast-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.followAlias = exports2.followAstAlias = exports2.resolveAlias = exports2.linesDiff = exports2.compareRanges = exports2.streamModel = exports2.streamAllModelContents = exports2.streamAst = exports2.streamAllContents = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    function streamAllContents(root) {
      return new langium_1.TreeStreamImpl(root, (node) => node.$children);
    }
    exports2.streamAllContents = streamAllContents;
    function streamAst(root) {
      return new langium_1.TreeStreamImpl(root, (node) => node.$children, { includeRoot: true });
    }
    exports2.streamAst = streamAst;
    function streamAllModelContents(root) {
      return new langium_1.TreeStreamImpl(root, (node) => node.ownedElements());
    }
    exports2.streamAllModelContents = streamAllModelContents;
    function streamModel(root) {
      return new langium_1.TreeStreamImpl(root, (node) => node.ownedElements(), { includeRoot: true });
    }
    exports2.streamModel = streamModel;
    var EMPTY_POS = { line: 0, character: 0 };
    function compareRanges(lhs, rhs) {
      var _a, _b;
      const left = (_a = lhs === null || lhs === void 0 ? void 0 : lhs.start) !== null && _a !== void 0 ? _a : EMPTY_POS;
      const right = (_b = rhs === null || rhs === void 0 ? void 0 : rhs.start) !== null && _b !== void 0 ? _b : EMPTY_POS;
      const lineDiff = left.line - right.line;
      if (lineDiff !== 0)
        return lineDiff;
      return left.character - right.character;
    }
    exports2.compareRanges = compareRanges;
    function linesDiff(a, b) {
      return b.range.start.line - a.range.end.line;
    }
    exports2.linesDiff = linesDiff;
    function resolveAlias(node, fn) {
      const target = followAstAlias(node);
      return fn(target) ? target : void 0;
    }
    exports2.resolveAlias = resolveAlias;
    function followAstAlias(node) {
      var _a;
      if ((0, ast_1.isMembership)(node)) {
        return (_a = node.$meta.element()) === null || _a === void 0 ? void 0 : _a.ast();
      }
      return node;
    }
    exports2.followAstAlias = followAstAlias;
    function followAlias(node) {
      if (node === null || node === void 0 ? void 0 : node.is(ast_1.Membership)) {
        return node.element();
      }
      return node;
    }
    exports2.followAlias = followAlias;
  }
});

// ../syside-languageserver/lib/utils/ast-to-model.js
var require_ast_to_model = __commonJS({
  "../syside-languageserver/lib/utils/ast-to-model.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.clearTreeArtifacts = exports2.clearArtifacts = exports2.astToModel = void 0;
    var ast2 = __importStar(require_ast2());
    var model_1 = require_model3();
    var ast_util_1 = require_ast_util2();
    var AstToModel = {
      default(model, node) {
        var _a;
        model["_ast"] = node;
        model["setParent"]((_a = node.$container) === null || _a === void 0 ? void 0 : _a.$meta);
      },
      [ast2.Comment](model, node) {
        if (node.locale)
          model.locale = node.locale.substring(1, node.locale.length - 1);
      },
      [ast2.FeatureReferenceExpression](model, node) {
        model["_expression"] = node.expression.$meta;
      },
      [ast2.LiteralBoolean](model, node) {
        model.literal = node.literal;
      },
      [ast2.LiteralNumber](model, node) {
        var _a, _b;
        model["_isInteger"] = !/[eE.]/.test((_b = (_a = node.$cstNode) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "");
        model["_literal"] = node.literal;
      },
      [ast2.LiteralString](model, node) {
        model.literal = node.literal.slice(1, node.literal.length - 1);
      },
      [ast2.OperatorExpression](model, node) {
        if (node.operator)
          model.operator = `'${node.operator}'`;
      },
      [ast2.InvocationExpression](model, node) {
        model["_operands"] = node.operands.map((e) => e.$meta);
      },
      [ast2.ElementReference](model, node) {
        var _a, _b, _c;
        model.text = (_c = (_a = node.text) !== null && _a !== void 0 ? _a : (_b = node.$cstNode) === null || _b === void 0 ? void 0 : _b.text) !== null && _c !== void 0 ? _c : "";
        model.found.length = node.parts.length;
      },
      [ast2.FeatureValue](model, node) {
        model.isDefault = node.isDefault;
        model.isInitial = node.isInitial;
      },
      [ast2.Import](model, node) {
        var _a, _b, _c;
        model.isRecursive = !!node.isRecursive;
        model["_importsAll"] = node.importsAll;
        if (((_a = model.parent()) === null || _a === void 0 ? void 0 : _a.is(ast2.Package)) && ((_c = (_b = model.parent()) === null || _b === void 0 ? void 0 : _b.parent()) === null || _c === void 0 ? void 0 : _c.is(ast2.Import))) {
          model.visibility = 0;
        }
      },
      [ast2.AnnotatingElement](model, node) {
        model["_annotations"] = node.about.map((a) => a.$meta);
      },
      [ast2.Connector](model, node) {
        model["_ends"] = node.ends.map((e) => e.$meta);
      },
      [ast2.Element](model, node) {
        model.declaredName = (0, model_1.sanitizeName)(node.declaredName);
        model.declaredShortName = (0, model_1.sanitizeName)(node.declaredShortName);
      },
      [ast2.Expression](model, node) {
        var _a;
        model["_result"] = (_a = node.result) === null || _a === void 0 ? void 0 : _a.$meta;
      },
      [ast2.SysMLFunction](model, node) {
        var _a;
        model["_result"] = (_a = node.result) === null || _a === void 0 ? void 0 : _a.$meta;
      },
      [ast2.Feature](model, node) {
        var _a, _b;
        model["_value"] = (_a = node.value) === null || _a === void 0 ? void 0 : _a.$meta;
        model.isOrdered = node.isOrdered;
        model.direction = (0, model_1.getFeatureDirectionKind)(node.direction);
        model.isPortion = !!node.isPortion;
        model.isComposite = !!node.isComposite || model.isPortion;
        model.isReadonly = !!node.isReadOnly;
        model.isDerived = !!node.isDerived;
        model.isEnd = !!node.isEnd;
        model.isOrdered = node.isOrdered;
        model.isNonUnique = node.isNonunique;
        model["_crossingFeature"] = (_b = node.crossingFeature) === null || _b === void 0 ? void 0 : _b.$meta;
      },
      [ast2.Invariant](model, node) {
        model.isNegated = node.isNegated;
      },
      [ast2.LibraryPackage](model, node) {
        model.isStandard = node.isStandard;
      },
      [ast2.MultiplicityRange](model, node) {
        var _a;
        model["_range"] = (_a = node.range) === null || _a === void 0 ? void 0 : _a.$meta;
      },
      [ast2.Namespace](model, node) {
        model["_prefixes"].length = 0;
        model["_children"].clear();
        model["_prefixes"].push(...node.prefixes.map((m) => m.$meta));
        model["_children"].push(...node.children.map((child) => child.$meta));
      },
      [ast2.Dependency](model, node) {
        model["_prefixes"].length = 0;
        model["_children"].clear();
        model["_prefixes"].push(...node.prefixes.map((m) => m.$meta));
        model["_children"].push(...node.elements.map((child) => child.$meta));
      },
      [ast2.Relationship](model, node) {
        model["_visibility"] = (0, model_1.getVisibility)(node.visibility);
        if (node.target)
          model["_element"] = node.target.$meta;
        else if (node.targetChain)
          model["_element"] = node.targetChain.$meta;
        if (node.source)
          model["_source"] = node.source.$meta;
        else if (node.sourceChain)
          model["_source"] = node.sourceChain.$meta;
        else if (node.sourceRef)
          model["_source"] = void 0;
        model["_children"].push(...node.elements.map((e) => e.$meta));
      },
      [ast2.TextualAnnotatingElement](model, node) {
        if (node.body)
          model.body = (0, model_1.prettyAnnotationBody)(node.body);
      },
      [ast2.TextualRepresentation](model, node) {
        model.language = node.language.substring(1, node.language.length - 1);
      },
      [ast2.Type](model, node) {
        var _a;
        model["_isAbstract"] = Boolean(node.isAbstract);
        model.isSufficient = node.isSufficient;
        model["_multiplicity"] = (_a = node.multiplicity) === null || _a === void 0 ? void 0 : _a.$meta;
        model["_heritage"].clear();
        model["_heritage"].push(...node.heritage.map((e) => e.$meta));
        model["_typeRelationships"].clear();
        model["_typeRelationships"].push(...node.typeRelationships.map((e) => e.$meta));
      },
      [ast2.RequirementConstraintMembership](model, node) {
        model.kind = node.kind === "assume" ? "assumption" : "requirement";
      },
      [ast2.StateSubactionMembership](model, node) {
        model.kind = node.kind;
      },
      [ast2.TransitionFeatureMembership](model, node) {
        model["_kind"] = (0, model_1.getTransitionFeatureKind)(node);
      },
      [ast2.AcceptActionUsage](model, node) {
        var _a;
        model["_payload"] = node.payload.$meta;
        model["_receiver"] = (_a = node.receiver) === null || _a === void 0 ? void 0 : _a.$meta;
      },
      [ast2.StateUsage](model, node) {
        model.isParallel = node.isParallel;
      },
      [ast2.AssignmentActionUsage](model, node) {
        model["_targetMember"] = node.targetMember.$meta;
        model["_assignedValue"] = node.assignedValue.$meta;
      },
      [ast2.Definition](model, node) {
        model.isIndividual = node.isIndividual;
        model["_isVariation"] = node.isVariation;
      },
      [ast2.ForLoopActionUsage](model, node) {
        model["_variable"] = node.variable.$meta;
        model["_sequence"] = node.sequence.$meta;
        model["_body"] = node.body.$meta;
      },
      [ast2.IfActionUsage](model, node) {
        var _a;
        model["_condition"] = node.condition.$meta;
        model["_then"] = node.then.$meta;
        model["_else"] = (_a = node.else) === null || _a === void 0 ? void 0 : _a.$meta;
      },
      [ast2.SatisfyRequirementUsage](model, node) {
        var _a;
        model["_satisfactionSubject"] = (_a = node.satisfactionSubject) === null || _a === void 0 ? void 0 : _a.$meta;
      },
      [ast2.SendActionUsage](model, node) {
        var _a, _b;
        model["_payload"] = node.payload.$meta;
        model["_sender"] = (_a = node.sender) === null || _a === void 0 ? void 0 : _a.$meta;
        model["_receiver"] = (_b = node.receiver) === null || _b === void 0 ? void 0 : _b.$meta;
      },
      [ast2.StateDefinition](model, node) {
        model.isParallel = node.isParallel;
      },
      [ast2.TerminateActionUsage](model, node) {
        var _a;
        model["_terminatedOccurrence"] = (_a = node.terminatedOccurrence) === null || _a === void 0 ? void 0 : _a.$meta;
      },
      [ast2.TransitionUsage](model, node) {
        var _a, _b, _c, _d, _e, _f;
        model["_source"] = (_a = node.source) === null || _a === void 0 ? void 0 : _a.$meta;
        model["_accepter"] = (_b = node.accepter) === null || _b === void 0 ? void 0 : _b.$meta;
        model["_guard"] = (_c = node.guard) === null || _c === void 0 ? void 0 : _c.$meta;
        model["_effect"] = (_d = node.effect) === null || _d === void 0 ? void 0 : _d.$meta;
        model["_then"] = (_e = node.then) === null || _e === void 0 ? void 0 : _e.$meta;
        model["_else"] = (_f = node.else) === null || _f === void 0 ? void 0 : _f.$meta;
        if (node.payload) {
          node.payload.$meta = model["_payload"];
          if (node.payload.target)
            node.payload.target.$meta = model["_payload"].element();
        }
        if (node.transitionLinkSource) {
          node.transitionLinkSource.$meta = model["_transitionLinkSource"];
          if (node.transitionLinkSource.target)
            node.transitionLinkSource.target.$meta = model["_transitionLinkSource"].element();
        }
      },
      [ast2.Usage](model, node) {
        model.isVariation = node.isVariation;
        model.isIndividual = node.isIndividual;
        model.isReference = node.isReference;
        model.portionKind = node.portionKind;
      },
      [ast2.WhileLoopActionUsage](model, node) {
        var _a, _b;
        model["_condition"] = (_a = node.condition) === null || _a === void 0 ? void 0 : _a.$meta;
        model["_body"] = node.body.$meta;
        model["_until"] = (_b = node.until) === null || _b === void 0 ? void 0 : _b.$meta;
      },
      [ast2.Membership](model, node) {
        model.isAlias = node.isAlias;
      },
      [ast2.ItemFlow](model, node) {
        var _a;
        model["_item"] = (_a = node.item) === null || _a === void 0 ? void 0 : _a.$meta;
      },
      [ast2.TriggerInvocationExpression](model, node) {
        model.kind = node.kind;
      },
      [ast2.FlowConnectionUsage](model, node) {
        model["_messages"] = node.messages.map((m) => m.$meta);
      }
    };
    var ClearArtifacts = {
      default(model) {
        model.setupState = "none";
      },
      [ast2.Element](model) {
        model["_comments"] = model["_comments"].filter((e) => e.owner() === model);
        model["_docs"] = model["_docs"].filter((e) => e.owner() === model);
        model["_reps"] = model["_reps"].filter((e) => e.owner() === model);
        model["_metadata"] = model["_metadata"].filter((e) => e.owner() === model);
        model["_metaclass"] = "unset";
        const garbage = [];
        for (const [key, value] of model.namedMembers) {
          if (typeof value === "string") {
            garbage.push(key);
          }
        }
        garbage.forEach((key) => model["_memberLookup"].delete(key));
      },
      [ast2.Feature](model) {
        model["setName"](model.declaredName);
        model["setShortName"](model.declaredShortName);
        model["_impliedIsOrdered"] = false;
        model["typings"] = void 0;
      },
      [ast2.ElementReference](model) {
        model.to.reset();
        model.found.fill(void 0);
      },
      [ast2.Namespace](model) {
        model["_importResolutionState"] = "none";
      },
      [ast2.Dependency](model) {
        model.client.length = 0;
        model.supplier.length = 0;
      },
      [ast2.Relationship](model) {
        var _a, _b;
        if (((_a = model.element()) === null || _a === void 0 ? void 0 : _a.parent()) !== model)
          model["_element"] = void 0;
        if (model.source() === model.parent() || ((_b = model.source()) === null || _b === void 0 ? void 0 : _b.parent()) === model)
          return;
        model["_source"] = void 0;
      },
      [ast2.Type](model) {
        const heritage = model.heritage.filter((e) => !e.isImplied && e.parent() === model);
        model["_heritage"].clear();
        model["_heritage"].push(...heritage);
        const typeRelationships = model.typeRelationships.filter((e) => !e.isImplied && e.parent() === model);
        model["_typeRelationships"].clear();
        model["_typeRelationships"].push(...typeRelationships);
        model["resetInputParameters"]();
      },
      [ast2.Association](model) {
        model["resetEnds"]();
      },
      [ast2.Connector](model) {
        model["resetEnds"]();
      },
      [ast2.MultiplicityRange](model) {
        model["_bounds"] = "unset";
      }
    };
    var Ast2ModelChains;
    function astToModel(model, node) {
      var _a;
      if (!Ast2ModelChains) {
        Ast2ModelChains = model_1.typeIndex.chain(AstToModel, "supertype-first");
      }
      (_a = Ast2ModelChains.get(node.$type)) === null || _a === void 0 ? void 0 : _a.forEach((fn) => fn(model, node));
    }
    exports2.astToModel = astToModel;
    var ClearArtifactsChains;
    function clearArtifacts(model) {
      var _a;
      if (!ClearArtifactsChains) {
        ClearArtifactsChains = model_1.typeIndex.chain(
          ClearArtifacts,
          // reverse order of the initialization
          "subtype-first"
        );
      }
      (_a = ClearArtifactsChains.get(model.nodeType())) === null || _a === void 0 ? void 0 : _a.forEach((fn) => fn(model));
    }
    exports2.clearArtifacts = clearArtifacts;
    function clearTreeArtifacts(model) {
      (0, ast_util_1.streamModel)(model).forEach(clearArtifacts);
    }
    exports2.clearTreeArtifacts = clearTreeArtifacts;
  }
});

// ../syside-languageserver/lib/utils/cst-util.js
var require_cst_util2 = __commonJS({
  "../syside-languageserver/lib/utils/cst-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.distance = exports2.newLineCount = exports2.findChildren = exports2.getNextNode = exports2.getPreviousNode = void 0;
    var langium_1 = require_lib2();
    function getPreviousNode(node, hidden = true) {
      while (node.parent) {
        const parent = node.parent;
        let index = parent.children.indexOf(node);
        while (index > 0) {
          index--;
          const previous = parent.children[index];
          if (hidden || !previous.hidden) {
            return previous;
          }
        }
        node = parent;
      }
      return void 0;
    }
    exports2.getPreviousNode = getPreviousNode;
    function getNextNode(node, hidden = true) {
      while (node.parent) {
        const parent = node.parent;
        let index = parent.children.indexOf(node);
        const last = parent.children.length - 1;
        while (index < last) {
          index++;
          const next = parent.children[index];
          if (hidden || !next.hidden) {
            return next;
          }
        }
        node = parent;
      }
      return void 0;
    }
    exports2.getNextNode = getNextNode;
    function isOverlapping(a, b) {
      if (a.end.line < b.start.line || a.start.line > b.end.line)
        return false;
      if (a.end.line === b.start.line && a.end.character < b.start.character)
        return false;
      if (a.start.line === b.end.line && a.start.character > b.end.character)
        return false;
      return true;
    }
    function findChildren(node, range = node.range) {
      const children = [];
      const it = (0, langium_1.streamCst)(node).iterator();
      let next = it.next();
      const owner = node.element;
      while (!next.done) {
        if (next.value.element !== owner || next.value.hidden) {
          it.prune();
          if (isOverlapping(range, next.value.range))
            children.push(next.value);
        }
        next = it.next();
      }
      return children;
    }
    exports2.findChildren = findChildren;
    function newLineCount(left, right) {
      if (!left || !right)
        return 0;
      return right.range.start.line - left.range.end.line;
    }
    exports2.newLineCount = newLineCount;
    function distance(left, right) {
      if (!left || !right)
        return 0;
      return right.offset - left.end;
    }
    exports2.distance = distance;
  }
});

// ../../node_modules/.pnpm/ansi-regex@6.0.1/node_modules/ansi-regex/index.js
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}
var init_ansi_regex = __esm({
  "../../node_modules/.pnpm/ansi-regex@6.0.1/node_modules/ansi-regex/index.js"() {
  }
});

// ../../node_modules/.pnpm/strip-ansi@7.1.0/node_modules/strip-ansi/index.js
function stripAnsi(string) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  }
  return string.replace(regex, "");
}
var regex;
var init_strip_ansi = __esm({
  "../../node_modules/.pnpm/strip-ansi@7.1.0/node_modules/strip-ansi/index.js"() {
    init_ansi_regex();
    regex = ansiRegex();
  }
});

// ../../node_modules/.pnpm/eastasianwidth@0.2.0/node_modules/eastasianwidth/eastasianwidth.js
var require_eastasianwidth = __commonJS({
  "../../node_modules/.pnpm/eastasianwidth@0.2.0/node_modules/eastasianwidth/eastasianwidth.js"(exports2, module2) {
    var eaw = {};
    if ("undefined" == typeof module2) {
      window.eastasianwidth = eaw;
    } else {
      module2.exports = eaw;
    }
    eaw.eastAsianWidth = function(character) {
      var x = character.charCodeAt(0);
      var y = character.length == 2 ? character.charCodeAt(1) : 0;
      var codePoint = x;
      if (55296 <= x && x <= 56319 && (56320 <= y && y <= 57343)) {
        x &= 1023;
        y &= 1023;
        codePoint = x << 10 | y;
        codePoint += 65536;
      }
      if (12288 == codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510) {
        return "F";
      }
      if (8361 == codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518) {
        return "H";
      }
      if (4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141) {
        return "W";
      }
      if (32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 == codePoint || 175 == codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630) {
        return "Na";
      }
      if (161 == codePoint || 164 == codePoint || 167 <= codePoint && codePoint <= 168 || 170 == codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 == codePoint || 208 == codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 == codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 == codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 == codePoint || 254 == codePoint || 257 == codePoint || 273 == codePoint || 275 == codePoint || 283 == codePoint || 294 <= codePoint && codePoint <= 295 || 299 == codePoint || 305 <= codePoint && codePoint <= 307 || 312 == codePoint || 319 <= codePoint && codePoint <= 322 || 324 == codePoint || 328 <= codePoint && codePoint <= 331 || 333 == codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 == codePoint || 462 == codePoint || 464 == codePoint || 466 == codePoint || 468 == codePoint || 470 == codePoint || 472 == codePoint || 474 == codePoint || 476 == codePoint || 593 == codePoint || 609 == codePoint || 708 == codePoint || 711 == codePoint || 713 <= codePoint && codePoint <= 715 || 717 == codePoint || 720 == codePoint || 728 <= codePoint && codePoint <= 731 || 733 == codePoint || 735 == codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 == codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 == codePoint || 8208 == codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 == codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 == codePoint || 8251 == codePoint || 8254 == codePoint || 8308 == codePoint || 8319 == codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 == codePoint || 8451 == codePoint || 8453 == codePoint || 8457 == codePoint || 8467 == codePoint || 8470 == codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 == codePoint || 8491 == codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 == codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 == codePoint || 8660 == codePoint || 8679 == codePoint || 8704 == codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 == codePoint || 8719 == codePoint || 8721 == codePoint || 8725 == codePoint || 8730 == codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 == codePoint || 8741 == codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 == codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 == codePoint || 8780 == codePoint || 8786 == codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 == codePoint || 8857 == codePoint || 8869 == codePoint || 8895 == codePoint || 8978 == codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 == codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 == codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 == codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 == codePoint || 9758 == codePoint || 9792 == codePoint || 9794 == codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 == codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 == codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 == codePoint || 10071 == codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 == codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109) {
        return "A";
      }
      return "N";
    };
    eaw.characterLength = function(character) {
      var code = this.eastAsianWidth(character);
      if (code == "F" || code == "W" || code == "A") {
        return 2;
      } else {
        return 1;
      }
    };
    function stringToArray(string) {
      return string.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
    }
    eaw.length = function(string) {
      var characters = stringToArray(string);
      var len = 0;
      for (var i = 0; i < characters.length; i++) {
        len = len + this.characterLength(characters[i]);
      }
      return len;
    };
    eaw.slice = function(text, start, end) {
      textLen = eaw.length(text);
      start = start ? start : 0;
      end = end ? end : 1;
      if (start < 0) {
        start = textLen + start;
      }
      if (end < 0) {
        end = textLen + end;
      }
      var result = "";
      var eawLen = 0;
      var chars = stringToArray(text);
      for (var i = 0; i < chars.length; i++) {
        var char = chars[i];
        var charLen = eaw.length(char);
        if (eawLen >= start - (charLen == 2 ? 1 : 0)) {
          if (eawLen + charLen <= end) {
            result += char;
          } else {
            break;
          }
        }
        eawLen += charLen;
      }
      return result;
    };
  }
});

// ../../node_modules/.pnpm/emoji-regex@10.3.0/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "../../node_modules/.pnpm/emoji-regex@10.3.0/node_modules/emoji-regex/index.js"(exports2, module2) {
    module2.exports = () => {
      return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    };
  }
});

// ../../node_modules/.pnpm/string-width@6.1.0/node_modules/string-width/index.js
var string_width_exports = {};
__export(string_width_exports, {
  default: () => stringWidth
});
function stringWidth(string, options) {
  if (typeof string !== "string" || string.length === 0) {
    return 0;
  }
  options = {
    ambiguousIsNarrow: true,
    countAnsiEscapeCodes: false,
    ...options
  };
  if (!options.countAnsiEscapeCodes) {
    string = stripAnsi(string);
  }
  if (string.length === 0) {
    return 0;
  }
  const ambiguousCharacterWidth = options.ambiguousIsNarrow ? 1 : 2;
  let width = 0;
  for (const { segment: character } of new Intl.Segmenter().segment(string)) {
    const codePoint = character.codePointAt(0);
    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
      continue;
    }
    if (codePoint >= 768 && codePoint <= 879) {
      continue;
    }
    if ((0, import_emoji_regex.default)().test(character)) {
      width += 2;
      continue;
    }
    const code = import_eastasianwidth.default.eastAsianWidth(character);
    switch (code) {
      case "F":
      case "W": {
        width += 2;
        break;
      }
      case "A": {
        width += ambiguousCharacterWidth;
        break;
      }
      default: {
        width += 1;
      }
    }
  }
  return width;
}
var import_eastasianwidth, import_emoji_regex;
var init_string_width = __esm({
  "../../node_modules/.pnpm/string-width@6.1.0/node_modules/string-width/index.js"() {
    init_strip_ansi();
    import_eastasianwidth = __toESM(require_eastasianwidth(), 1);
    import_emoji_regex = __toESM(require_emoji_regex(), 1);
  }
});

// ../syside-languageserver/lib/utils/printer/doc.js
var require_doc = __commonJS({
  "../syside-languageserver/lib/utils/printer/doc.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unwrapIndent = exports2.appendFill = exports2.getLabel = exports2.inheritLabel = exports2.visitDoc = exports2.getDocKind = exports2.DefaultPrinterConfig = exports2.addAlignment = exports2.join = exports2.literals = exports2.brackets = exports2.keyword = exports2.text = exports2.label = exports2.cursor = exports2.literalline = exports2.hardline = exports2.softline = exports2.line = exports2.literallineWithoutBreakParent = exports2.hardlineWithoutBreakParent = exports2.trim = exports2.breakParent = exports2.lineSuffixBoundary = exports2.lineSuffix = exports2.indentIfBreak = exports2.ifBreak = exports2.fill = exports2.dedentToRoot = exports2.markAsRoot = exports2.conditionalGroup = exports2.group = exports2.align = exports2.dedent = exports2.indent = void 0;
    var string_width_1 = __importDefault((init_string_width(), __toCommonJS(string_width_exports)));
    var vscode_languageserver_1 = require_main4();
    var ansiRegex2 = new RegExp([
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
    ].join("|"));
    function stripAnsi2(text2) {
      return text2.replace(ansiRegex2, "");
    }
    function stringWidth2(str) {
      if (!Intl.Segmenter) {
        return stripAnsi2(str).length;
      }
      return (0, string_width_1.default)(str);
    }
    function indent(contents) {
      return { kind: "indent", contents };
    }
    exports2.indent = indent;
    function dedent(contents) {
      return align(-1, contents);
    }
    exports2.dedent = dedent;
    function align(prefix, contents) {
      return { kind: "align", prefix, contents };
    }
    exports2.align = align;
    function groupInternal(contents, options = {}) {
      return {
        kind: "group",
        id: options.id,
        contents,
        break: Boolean(options.shouldBreak),
        expandedStates: options.expandedStates
      };
    }
    function group(contents, options = {}) {
      return groupInternal(contents, options);
    }
    exports2.group = group;
    function conditionalGroup(states, options = {}) {
      return groupInternal(states[0], Object.assign(Object.assign({}, options), { expandedStates: states }));
    }
    exports2.conditionalGroup = conditionalGroup;
    function markAsRoot(contents) {
      return { kind: "root", contents };
    }
    exports2.markAsRoot = markAsRoot;
    function dedentToRoot(contents) {
      return align(Number.NEGATIVE_INFINITY, contents);
    }
    exports2.dedentToRoot = dedentToRoot;
    function fill(parts) {
      return { kind: "fill", parts };
    }
    exports2.fill = fill;
    function ifBreak(onBreak, onFlat, groupId) {
      return { kind: "if-break", onBreak, onFlat, groupId };
    }
    exports2.ifBreak = ifBreak;
    function indentIfBreak(contents, options) {
      return Object.assign({ kind: "indent-if-break", contents }, options);
    }
    exports2.indentIfBreak = indentIfBreak;
    function lineSuffix(contents) {
      return { kind: "line-suffix", contents };
    }
    exports2.lineSuffix = lineSuffix;
    exports2.lineSuffixBoundary = { kind: "line-suffix-boundary" };
    exports2.breakParent = { kind: "break-parent" };
    exports2.trim = { kind: "trim" };
    exports2.hardlineWithoutBreakParent = { kind: "line", mode: "hard" };
    exports2.literallineWithoutBreakParent = { kind: "line", mode: "hard-literal" };
    exports2.line = { kind: "line", mode: "auto" };
    exports2.softline = { kind: "line", mode: "soft" };
    exports2.hardline = [exports2.hardlineWithoutBreakParent, exports2.breakParent];
    exports2.literalline = [
      exports2.literallineWithoutBreakParent,
      exports2.breakParent
    ];
    exports2.cursor = { kind: "cursor" };
    function label(label2, contents) {
      return label2 ? { kind: "label", label: label2, contents } : contents;
    }
    exports2.label = label;
    function text(contents, semantic = {}) {
      let width;
      return Object.assign(Object.assign({ kind: "text", contents }, semantic), { get width() {
        if (width !== void 0)
          return width;
        return width = stringWidth2(contents);
      } });
    }
    exports2.text = text;
    function keyword(contents) {
      return text(contents, { type: vscode_languageserver_1.SemanticTokenTypes.keyword });
    }
    exports2.keyword = keyword;
    exports2.brackets = {
      round: {
        open: text("("),
        close: text(")")
      },
      square: {
        open: text("["),
        close: text("]")
      },
      curly: {
        open: text("{"),
        close: text("}")
      },
      angle: {
        open: text("<"),
        close: text(">")
      }
    };
    exports2.literals = {
      true: text("true", { type: vscode_languageserver_1.SemanticTokenTypes.keyword }),
      false: text("false", { type: vscode_languageserver_1.SemanticTokenTypes.keyword }),
      null: text("null", { type: vscode_languageserver_1.SemanticTokenTypes.keyword }),
      dot: text("."),
      comma: text(","),
      colon: text(":"),
      semicolon: text(";"),
      tilde: text("~"),
      doublecolon: text("::"),
      emptytext: text(""),
      space: text(" "),
      tab: text("	"),
      lf: text("\n"),
      crlf: text("\r\n")
    };
    function join(separator, docs, trailing = false) {
      const joined = docs.flatMap((doc) => [doc, separator]);
      if (!trailing)
        joined.pop();
      return joined;
    }
    exports2.join = join;
    function addAlignment(doc, size, tabWidth) {
      if (size <= 0)
        return doc;
      const level = Math.floor(size / tabWidth);
      let aligned = doc;
      const spaces = size % tabWidth;
      if (spaces > 0) {
        aligned = align(spaces, aligned);
      }
      for (let i = 0; i < level; i++)
        aligned = indent(aligned);
      return align(Number.NEGATIVE_INFINITY, aligned);
    }
    exports2.addAlignment = addAlignment;
    exports2.DefaultPrinterConfig = {
      lineWidth: 100,
      tabWidth: 4,
      useSpaces: true,
      lineEnd: "\n",
      addFinalNewline: true,
      highlighting: false
    };
    function getDocKind(doc) {
      return "kind" in doc ? doc.kind : "array";
    }
    exports2.getDocKind = getDocKind;
    var Visitor = {
      "break-parent"() {
      },
      "if-break"(doc, stack) {
        stack.push(doc.onFlat, doc.onBreak);
      },
      "indent-if-break"(doc, stack) {
        stack.push(doc.contents);
      },
      "line-suffix"(doc, stack) {
        stack.push(doc.contents);
      },
      "line-suffix-boundary"() {
      },
      align(doc, stack) {
        stack.push(doc.contents);
      },
      array(doc, stack) {
        stack.push(...doc.slice().reverse());
      },
      cursor() {
      },
      fill(doc, stack) {
        stack.push(...doc.parts.slice().reverse());
      },
      group(doc, stack, traverseOptional) {
        if (traverseOptional && doc.expandedStates && doc.expandedStates.length > 0) {
          stack.push(...doc.expandedStates.slice().reverse());
        } else {
          stack.push(doc.contents);
        }
      },
      indent(doc, stack) {
        stack.push(doc.contents);
      },
      label(doc, stack) {
        stack.push(doc.contents);
      },
      line() {
      },
      root(doc, stack) {
        stack.push(doc.contents);
      },
      text() {
      },
      trim() {
      }
    };
    var ExitMarker = Symbol("DocVisitorExitMarker");
    function visitDoc(doc, visitor) {
      var _a;
      const stack = [doc];
      const traverseOptionalGroups = visitor.traverseOptionalGroups === true;
      while (stack.length > 0) {
        const item = stack.pop();
        if (item === ExitMarker) {
          (_a = visitor.exit) === null || _a === void 0 ? void 0 : _a.call(visitor, stack.pop());
          continue;
        }
        if (visitor.exit) {
          stack.push(item, ExitMarker);
        }
        if (visitor.enter(item) === false) {
          continue;
        }
        const kind = getDocKind(item);
        Visitor[kind](item, stack, traverseOptionalGroups);
      }
    }
    exports2.visitDoc = visitDoc;
    function inheritLabel(doc, contents) {
      const command = doc;
      return command.kind === "label" ? label(command.label, contents(command.contents)) : contents(doc);
    }
    exports2.inheritLabel = inheritLabel;
    function getLabel(doc) {
      const command = doc;
      return command.kind === "label" ? command.label : void 0;
    }
    exports2.getLabel = getLabel;
    function appendFill(left, ...items) {
      const lhs = left;
      if (lhs.kind === "fill") {
        lhs.parts.push(...items);
        return lhs;
      }
      return fill([left, ...items]);
    }
    exports2.appendFill = appendFill;
    function unwrapIndent(doc) {
      const d = doc;
      if (d.kind === "indent")
        return d.contents;
      if (d.kind === "align")
        return d.contents;
      return d;
    }
    exports2.unwrapIndent = unwrapIndent;
  }
});

// ../syside-languageserver/lib/utils/comments/comments.js
var require_comments = __commonJS({
  "../syside-languageserver/lib/utils/comments/comments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printInnerComments = exports2.surroundWithComments = exports2.printOuterComments = exports2.printTrailingComment = exports2.printLeadingComment = exports2.printComment = exports2.printKerMLNote = exports2.AbstractKerMLCommentVisitor = exports2.trimComment = exports2.trimBlockComment = exports2.trimLineComment = exports2.visitComments = void 0;
    var langium_1 = require_lib2();
    var cst_util_1 = require_cst_util2();
    var doc_1 = require_doc();
    var vscode_languageserver_1 = require_main4();
    var cst_util_2 = require_cst_util2();
    function visitComments(root, visitor) {
      const iterator = (0, langium_1.streamCst)(root).iterator();
      let previous;
      let stack = [];
      const path2 = [];
      let preceding = void 0;
      let following = void 0;
      const onNext = (node) => {
        var _a, _b;
        const isLeaf = node && (0, langium_1.isLeafCstNode)(node);
        const ast2 = node === null || node === void 0 ? void 0 : node.element;
        const last = path2.at(-1);
        if (last !== ast2) {
          const astChanged = !(node === null || node === void 0 ? void 0 : node.hidden) && (!ast2 || !path2.includes(ast2));
          if (ast2) {
            following = ast2;
            const ancestorIdx = path2.findLastIndex((node2) => node2 === ast2.$container || node2 === ast2);
            if (ancestorIdx === -1) {
              preceding = void 0;
            } else {
              preceding = path2.at(ancestorIdx + 1);
            }
            path2.length = ancestorIdx + 1;
            path2.push(ast2);
          } else {
            path2.length = 0;
            preceding = following;
            following = void 0;
          }
          if (astChanged) {
            stack.forEach((item) => {
              var _a2;
              const { comment } = item;
              if (!item.following) {
                if ((0, cst_util_1.distance)((_a2 = comment.$enclosingNode) === null || _a2 === void 0 ? void 0 : _a2.$cstNode, following === null || following === void 0 ? void 0 : following.$cstNode) <= 0)
                  comment.$followingNode = following;
                item.following = true;
              }
            });
          }
        }
        if (isLeaf && node.hidden) {
          const kind = visitor.getKind(node);
          if (kind) {
            stack.push({
              comment: {
                $previous: previous,
                $cstNode: node,
                $precedingNode: (
                  // only add the preceding node if it is contained by the
                  // enclosing node, or the enclosing nodes ends after the
                  // preceding node starts
                  (0, cst_util_1.distance)(preceding === null || preceding === void 0 ? void 0 : preceding.$cstNode, node.element.$cstNode) <= 0 ? preceding : void 0
                ),
                $enclosingNode: node === null || node === void 0 ? void 0 : node.element,
                segment: {
                  offset: node.offset,
                  end: node.end,
                  length: node.length,
                  range: node.range
                },
                placement: "ownLine",
                kind,
                text: (_b = (_a = visitor.trim) === null || _a === void 0 ? void 0 : _a.call(visitor, node.text, kind)) !== null && _b !== void 0 ? _b : node.text
              },
              following: false,
              next: false,
              ready: false
            });
          }
          return;
        }
        if (!node || isLeaf) {
          stack.forEach((item) => {
            const { comment } = item;
            item.ready = true;
            if (item.next)
              return;
            comment.$next = node;
            if (node && node.range.start.line === comment.segment.range.end.line) {
              comment.placement = "remaining";
            } else if (comment.$previous && comment.$previous.range.end.line === comment.segment.range.start.line) {
              comment.placement = "endOfLine";
            }
            item.next = true;
          });
          previous = node;
        }
        stack = stack.filter((item) => {
          if (!item.ready || !item.following)
            return true;
          visitor.visit(item.comment);
          return false;
        });
      };
      let value = iterator.next();
      while (!value.done) {
        const node = value.value;
        onNext(node);
        value = iterator.next();
      }
      onNext(void 0);
    }
    exports2.visitComments = visitComments;
    function trimLineComment(text) {
      return text.substring(2);
    }
    exports2.trimLineComment = trimLineComment;
    function trimBlockComment(text) {
      return text.substring(3, text.length - 2);
    }
    exports2.trimBlockComment = trimBlockComment;
    function trimComment(text, kind) {
      switch (kind) {
        case "line":
          return trimLineComment(text);
        case "block":
          return trimBlockComment(text);
        default:
          (0, langium_1.assertUnreachable)(kind);
      }
    }
    exports2.trimComment = trimComment;
    var AbstractKerMLCommentVisitor = class {
      getKind(node) {
        switch (node.tokenType.name) {
          case "SL_NOTE":
            return "line";
          case "ML_NOTE":
            return "block";
          default:
            return;
        }
      }
      trim(text, kind) {
        return trimComment(text, kind);
      }
    };
    exports2.AbstractKerMLCommentVisitor = AbstractKerMLCommentVisitor;
    var HighlightComment = { type: vscode_languageserver_1.SemanticTokenTypes.comment };
    var SL_NOTE = {
      start: (0, doc_1.text)("//", HighlightComment)
    };
    var ML_NOTE = {
      start: (0, doc_1.text)("//*", HighlightComment),
      end: (0, doc_1.text)("*/", HighlightComment)
    };
    function printKerMLNote(comment) {
      var _a;
      if (comment.kind === "line")
        return [SL_NOTE.start, (0, doc_1.text)(comment.text, HighlightComment)];
      const lines = comment.text.split("\n");
      const lastLine = (_a = lines.at(-1)) === null || _a === void 0 ? void 0 : _a.trim();
      const indentable = lines.length > 1 && lines.slice(1, lines.length - 1).every((line) => line.trimStart()[0] === "*") && ((lastLine === null || lastLine === void 0 ? void 0 : lastLine[0]) === "*" || lastLine === "");
      if (indentable) {
        return [
          ML_NOTE.start,
          (0, doc_1.join)([doc_1.hardline, (0, doc_1.text)("  ")], lines.map((line, index) => {
            if (index === 0)
              return (0, doc_1.text)(line.trimEnd(), HighlightComment);
            if (index < lines.length - 1)
              return (0, doc_1.text)(line.trim(), HighlightComment);
            return (0, doc_1.text)(line.trimStart(), HighlightComment);
          }), lastLine !== ""),
          ML_NOTE.end
        ];
      }
      return [
        ML_NOTE.start,
        (0, doc_1.join)(doc_1.literalline, lines.map((line) => (0, doc_1.text)(line, HighlightComment))),
        ML_NOTE.end
      ];
    }
    exports2.printKerMLNote = printKerMLNote;
    function printComment(comment, context = { printComment: printKerMLNote }) {
      var _a;
      (_a = context.printed) === null || _a === void 0 ? void 0 : _a.add(comment);
      return context.printComment(comment);
    }
    exports2.printComment = printComment;
    function printLeadingComment(comment, context = { printComment: printKerMLNote }) {
      const parts = [printComment(comment, context)];
      let newLinebreaks = 0;
      if (comment.$cstNode) {
        newLinebreaks = (0, cst_util_1.newLineCount)(comment.segment, (0, cst_util_2.getNextNode)(comment.$cstNode, true));
      }
      if (comment.kind === "block") {
        if (newLinebreaks <= 0)
          parts.push(doc_1.literals.space);
        else {
          let prevLinebreaks = 0;
          if (comment.$cstNode) {
            prevLinebreaks = (0, cst_util_1.newLineCount)((0, cst_util_2.getPreviousNode)(comment.$cstNode, true), comment.segment);
          }
          parts.push(prevLinebreaks > 0 ? doc_1.hardline : doc_1.line);
        }
      } else {
        parts.push(doc_1.hardline);
      }
      if (newLinebreaks > 1)
        parts.push(doc_1.hardline);
      return parts;
    }
    exports2.printLeadingComment = printLeadingComment;
    function printTrailingComment(comment, context = { printComment: printKerMLNote }, previousComment) {
      const doc = printComment(comment, context);
      let prevLinebreaks = 0;
      if (comment.$cstNode) {
        prevLinebreaks = (0, cst_util_1.newLineCount)((0, cst_util_2.getPreviousNode)(comment.$cstNode, true), comment.segment);
      }
      if ((previousComment === null || previousComment === void 0 ? void 0 : previousComment.hasLineSuffix) && previousComment.comment.kind === "line" || prevLinebreaks > 0) {
        return {
          doc: (0, doc_1.lineSuffix)([doc_1.hardline, prevLinebreaks > 1 ? doc_1.hardline : doc_1.literals.emptytext, doc]),
          comment,
          hasLineSuffix: true
        };
      }
      if (comment.kind === "line" || (previousComment === null || previousComment === void 0 ? void 0 : previousComment.hasLineSuffix)) {
        return {
          doc: [(0, doc_1.lineSuffix)([doc_1.literals.space, doc]), doc_1.breakParent],
          comment,
          hasLineSuffix: true
        };
      }
      return { doc: [doc_1.literals.space, doc], comment, hasLineSuffix: false };
    }
    exports2.printTrailingComment = printTrailingComment;
    function printOuterComments(comments, context = { printComment: printKerMLNote }) {
      if (comments.length === 0)
        return;
      const leading = [];
      const trailing = [];
      let trailingComment = void 0;
      comments.filter((comment) => {
        var _a;
        return !((_a = context.printed) === null || _a === void 0 ? void 0 : _a.has(comment));
      }).forEach((comment) => {
        if (comment.localPlacement === "leading") {
          leading.push(printLeadingComment(comment, context));
        } else if (comment.localPlacement === "trailing") {
          trailingComment = printTrailingComment(comment, context, trailingComment);
          trailing.push(trailingComment.doc);
        } else {
          throw new Error(`Unprinted inner ${comment.kind} comment '${comment.text}' at ${comment.segment}`);
        }
      });
      if (leading.length === 0 && trailing.length === 0)
        return;
      return { leading, trailing };
    }
    exports2.printOuterComments = printOuterComments;
    function surroundWithComments(doc, comments, context = { printComment: printKerMLNote }) {
      const printed = printOuterComments(comments, context);
      if (!printed)
        return doc;
      return (0, doc_1.inheritLabel)(doc, (contents) => [printed.leading, contents, printed.trailing]);
    }
    exports2.surroundWithComments = surroundWithComments;
    var alwaysTrue = () => true;
    function printInnerComments(comments, context = { printComment: printKerMLNote }, suffix) {
      if (comments.length === 0)
        return doc_1.literals.emptytext;
      const { label, filter = alwaysTrue } = context;
      const inner = comments.filter((comment) => comment.localPlacement === "inner" && comment.label === label && filter(comment));
      const parts = inner.map((comment) => printComment(comment, context));
      if (parts.length === 0)
        return doc_1.literals.emptytext;
      let printed = (0, doc_1.join)(doc_1.hardline, parts);
      if (context.indent)
        printed = (0, doc_1.indent)(printed);
      if (suffix) {
        const ending = suffix(inner[inner.length - 1]);
        if (ending)
          return [printed, ending];
      }
      return printed;
    }
    exports2.printInnerComments = printInnerComments;
  }
});

// ../syside-languageserver/lib/utils/comments/index.js
var require_comments2 = __commonJS({
  "../syside-languageserver/lib/utils/comments/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_comments(), exports2);
  }
});

// ../../node_modules/.pnpm/performance-now@2.1.0/node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
  "../../node_modules/.pnpm/performance-now@2.1.0/node_modules/performance-now/lib/performance-now.js"(exports2, module2) {
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        module2.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module2.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module2.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module2.exports = function() {
          return (/* @__PURE__ */ new Date()).getTime() - loadTime;
        };
        loadTime = (/* @__PURE__ */ new Date()).getTime();
      }
    }).call(exports2);
  }
});

// ../syside-languageserver/lib/utils/common.js
var require_common = __commonJS({
  "../syside-languageserver/lib/utils/common.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NonNullable = exports2.enumerable = exports2.waitAllPromises = exports2.backtrackToDirname = exports2.asyncWaitWhile = exports2.erase = exports2.stringifyFlags = exports2.flagNames = exports2.isPowerOf2 = exports2.mergeWithPartial = exports2.Statistics = exports2.Timer = exports2.isJSONConvertible = exports2.stringify = exports2.toJSON = exports2.JSONreplacer = exports2.simplifyCstNode = exports2.cstNodeRuleName = exports2.JSONMetaReplacer = exports2.sanitizeRange = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast();
    var vscode_languageserver_1 = require_main4();
    var ast_2 = require_ast2();
    var performance_now_1 = __importDefault(require_performance_now());
    var model_1 = require_model3();
    var path_1 = __importDefault(require("path"));
    function sanitizeRange(range) {
      var _a, _b;
      const start = { line: (_a = range.start.line) !== null && _a !== void 0 ? _a : 0, character: (_b = range.start.character) !== null && _b !== void 0 ? _b : 0 };
      const r = { start, end: range.end };
      if (!vscode_languageserver_1.Range.is(r)) {
        return { start, end: start };
      }
      return r;
    }
    exports2.sanitizeRange = sanitizeRange;
    function JSONMetaReplacer(key, value) {
      if (isJSONConvertible(value)) {
        return JSONMetaReplacer(key, value.toJSON());
      }
      if (key.startsWith("$") || key.startsWith("_"))
        return;
      if (key.length > 0 && (0, model_1.isMetamodel)(value)) {
        if (value.is(ast_2.Element))
          return value.qualifiedName;
        return `[Node ${value.nodeType()}]`;
      }
      return value;
    }
    exports2.JSONMetaReplacer = JSONMetaReplacer;
    function cstNodeRuleName(node) {
      var _a;
      if (!node)
        return;
      let element = node.feature;
      while (element) {
        if ((0, ast_1.isAbstractRule)(element))
          return element.name;
        if ((0, ast_1.isRuleCall)(element))
          return (_a = element.rule.ref) === null || _a === void 0 ? void 0 : _a.name;
        element = element.$container;
      }
      return;
    }
    exports2.cstNodeRuleName = cstNodeRuleName;
    function simplifyCstNode(node, depth = 2) {
      const tree = [];
      let cst = node;
      while (cst) {
        const rule = cstNodeRuleName(cst);
        if (rule) {
          tree.push(rule);
          if (tree.length === depth)
            break;
        }
        cst = cst.parent;
      }
      return {
        text: node.text,
        stack: tree
      };
    }
    exports2.simplifyCstNode = simplifyCstNode;
    function JSONreplacer(key, value) {
      var _a, _b, _c;
      if (isJSONConvertible(value)) {
        return JSONreplacer(key, value.toJSON());
      }
      if (key === "$meta") {
        if (!(0, model_1.isMetamodel)(value) || !value.is(ast_2.Element))
          return value;
        return {
          elementId: value.elementId,
          qualifiedName: value.qualifiedName
        };
      }
      if (key === "$type")
        return value;
      if (key === "$cstNode") {
        if (!value)
          return;
        const cst = value;
        return simplifyCstNode(cst);
      }
      if (key.startsWith("$") || key.startsWith("_"))
        return;
      if ((0, ast_2.isElementReference)(value)) {
        const target = (_b = (_a = value.$meta.to.target) === null || _a === void 0 ? void 0 : _a.qualifiedName) !== null && _b !== void 0 ? _b : null;
        return {
          $type: value.$type,
          $cstNode: value.$cstNode,
          text: (_c = value.$cstNode) === null || _c === void 0 ? void 0 : _c.text,
          reference: target,
          parts: value.parts.map((ref) => {
            var _a2;
            return (_a2 = ref.ref) === null || _a2 === void 0 ? void 0 : _a2.$meta.qualifiedName;
          })
        };
      }
      return value;
    }
    exports2.JSONreplacer = JSONreplacer;
    function toJSONImpl(item, key, value, replacer) {
      if (typeof item !== "object" || !item)
        return item;
      if ("toJSON" in item && item.toJSON instanceof Function)
        item = item.toJSON(key);
      item = replacer.call(item, key, value);
      if (typeof item !== "object" || !item || item instanceof Function || item instanceof Symbol)
        return item;
      if (Array.isArray(item)) {
        return item.map((value2, index) => toJSONImpl(item, index.toString(), value2, replacer)).filter(exports2.NonNullable);
      }
      const out = {};
      for (const key2 in item) {
        if (typeof key2 !== "string")
          continue;
        const value2 = item[key2];
        const replaced = toJSONImpl(item, key2, value2, replacer);
        if (replaced === void 0)
          continue;
        out[key2] = replaced;
      }
      return out;
    }
    function toJSON(item, replacer) {
      return toJSONImpl(item, "", item, replacer);
    }
    exports2.toJSON = toJSON;
    function stringify2(node, indent = 2) {
      if (typeof node !== "object")
        return JSON.stringify(node);
      return JSON.stringify(node, JSONreplacer, indent);
    }
    exports2.stringify = stringify2;
    function isJSONConvertible(item) {
      return typeof item === "object" && item !== null && item.toJSON instanceof Function;
    }
    exports2.isJSONConvertible = isJSONConvertible;
    var Timer = class {
      constructor() {
        this.start = (0, performance_now_1.default)();
      }
      /**
       * @returns Time elapsed in ms since construction or last {@link reset}
       */
      elapsed() {
        return (0, performance_now_1.default)() - this.start;
      }
      /**
       * Reset timer start point
       */
      reset() {
        this.start = (0, performance_now_1.default)();
      }
    };
    exports2.Timer = Timer;
    var StatisticsCounter = class {
      constructor() {
        this.timer = new Timer();
        this.elapsed = 0;
        this.hits = 0;
      }
      enter() {
        this.timer.reset();
      }
      exit(suspend = false) {
        this.elapsed += this.timer.elapsed();
        if (!suspend)
          this.hits++;
      }
      reset() {
        this.elapsed = 0;
        this.hits = 0;
      }
      timeSpent() {
        return this.elapsed;
      }
      timesEntered() {
        return this.hits;
      }
    };
    var Statistics = class {
      constructor() {
        this.stats = {};
        this.stack = [];
      }
      /**
       * Start timing {@link name}, suspends an active timer if one exists
       * @param name Individual statistic name
       */
      enter(name) {
        let counter = this.stats[name];
        if (!counter) {
          counter = new StatisticsCounter();
          this.stats[name] = counter;
        }
        if (this.stack.length > 0) {
          this.stack[this.stack.length - 1].exit(true);
        }
        this.stack.push(counter);
        counter.enter();
      }
      /**
       * Stop timing {@link name}, continues the last timer if one exists
       * @param name Individual statistic name
       */
      exit(name) {
        var _a;
        (_a = this.stats[name]) === null || _a === void 0 ? void 0 : _a.exit();
        this.stack.pop();
        if (this.stack.length > 0) {
          this.stack[this.stack.length - 1].enter();
        }
      }
      /**
       * Collect all statistics
       * @returns A record of statistic names to a tuple of [time elapsed, times
       * entered]
       */
      dump() {
        const out = {};
        for (const [name, counter] of Object.entries(this.stats)) {
          out[name] = [counter.timeSpent(), counter.timesEntered()];
        }
        return out;
      }
      /**
       * Clear statistics
       */
      reset() {
        this.stats = {};
      }
      /**
       *
       * @returns true if there are any statistics collected, false otherwise
       */
      isEmpty() {
        return Object.keys(this.stats).length === 0;
      }
      /**
       * Current depth of {@link enter}/{@link exit} statistics, only the last one
       * is timed while the rest are suspended
       */
      get currentDepth() {
        return this.stack.length;
      }
    };
    exports2.Statistics = Statistics;
    function mergeWithPartial(left, right) {
      if (typeof left !== "object" || left === null)
        return right !== null && right !== void 0 ? right : left;
      if (right === void 0)
        return left;
      if (Array.isArray(left)) {
        return right;
      }
      const rhs = right;
      const out = Object.assign({}, rhs);
      for (const [key, value] of Object.entries(left)) {
        if (key in rhs) {
          out[key] = mergeWithPartial(value, rhs[key]);
        } else {
          out[key] = value;
        }
      }
      return out;
    }
    exports2.mergeWithPartial = mergeWithPartial;
    function isPowerOf2(v) {
      return v !== 0 && !(v & v - 1);
    }
    exports2.isPowerOf2 = isPowerOf2;
    function flagNames(v, names) {
      if (v == 0)
        return [];
      const name = names.get(v);
      if (name)
        return [name];
      const flags = [];
      for (const [flag, name2] of names.entries()) {
        if (!isPowerOf2(flag))
          continue;
        if ((v & flag) === v) {
          flags.push(name2);
        }
      }
      return flags;
    }
    exports2.flagNames = flagNames;
    function stringifyFlags(v, names) {
      return flagNames(v, names).join(" | ");
    }
    exports2.stringifyFlags = stringifyFlags;
    function erase(array, value) {
      const index = array.indexOf(value);
      if (index < 0)
        return array;
      return array.splice(index, 1);
    }
    exports2.erase = erase;
    function asyncWaitWhile(condition, { timeout = void 0, period = 1 } = {}, cancelToken = vscode_languageserver_1.CancellationToken.None) {
      return __awaiter(this, void 0, void 0, function* () {
        let end;
        if (timeout) {
          const start = (0, performance_now_1.default)();
          end = start + timeout;
        }
        return new Promise((resolve, reject) => {
          const check = () => {
            if (!condition())
              resolve();
            else if (end && (0, performance_now_1.default)() > end)
              reject(langium_1.OperationCancelled);
            else if (cancelToken.isCancellationRequested)
              reject(langium_1.OperationCancelled);
            else
              setTimeout(check, period);
          };
          check();
        });
      });
    }
    exports2.asyncWaitWhile = asyncWaitWhile;
    function backtrackToDirname(p, dirname) {
      for (; ; ) {
        const name = path_1.default.basename(p);
        if (typeof dirname === "string") {
          if (name === dirname)
            return p;
        } else if (dirname.test(name))
          return p;
        const prev = path_1.default.join(p, "..");
        if (prev === p) {
          return;
        }
        p = prev;
      }
    }
    exports2.backtrackToDirname = backtrackToDirname;
    function waitAllPromises(value, onRejected) {
      return __awaiter(this, void 0, void 0, function* () {
        const resolved = [];
        yield Promise.allSettled(value).then((results) => {
          results.forEach((result, index) => {
            var _a;
            if (result.status === "rejected") {
              let message = (_a = onRejected === null || onRejected === void 0 ? void 0 : onRejected.call(void 0, result, index)) !== null && _a !== void 0 ? _a : `Promise failed: ${result.reason}`;
              if (result.reason instanceof Error)
                message += "\n" + result.reason.stack;
              console.error(message);
            } else {
              resolved.push(result.value);
            }
          });
        });
        return resolved;
      });
    }
    exports2.waitAllPromises = waitAllPromises;
    function enumerable(targetOrValue, name, descriptor) {
      const decorator = function(target, name2, descriptor2) {
        const enumerable2 = targetOrValue;
        if (descriptor2) {
          descriptor2.enumerable = enumerable2;
          return;
        }
        if (enumerable2)
          return;
        let value = void 0;
        Object.defineProperty(target, name2, {
          configurable: true,
          enumerable: enumerable2,
          get() {
            return value;
          },
          set(v) {
            value = v;
          }
        });
      };
      if (name) {
        decorator(targetOrValue, name, descriptor);
        return;
      }
      return decorator;
    }
    exports2.enumerable = enumerable;
    var NonNullable = (item) => Boolean(item);
    exports2.NonNullable = NonNullable;
  }
});

// ../syside-languageserver/lib/utils/containers.js
var require_containers = __commonJS({
  "../syside-languageserver/lib/utils/containers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Target = void 0;
    var Target = class {
      constructor(value) {
        this.ref = value;
      }
      get target() {
        var _a;
        return (_a = this.ref) !== null && _a !== void 0 ? _a : void 0;
      }
      get cached() {
        return this.ref !== void 0;
      }
      set(value) {
        this.ref = value !== null && value !== void 0 ? value : null;
      }
      toJSON() {
        if (this.target)
          return { reference_: this.target.qualifiedName };
        return this.target;
      }
      reset() {
        this.ref = void 0;
      }
    };
    exports2.Target = Target;
  }
});

// ../syside-languageserver/lib/utils/scope-util.js
var require_scope_util = __commonJS({
  "../syside-languageserver/lib/utils/scope-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.streamParents = exports2.collectRedefinitions = exports2.resolveContentInputs = exports2.fillContentOptions = exports2.decrementVisibility = exports2.resolveVisibility = exports2.CHILD_CONTENTS_OPTIONS = exports2.PARENT_CONTENTS_OPTIONS = exports2.DEFAULT_ALIAS_RESOLVER = exports2.isVisibleWith = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    function isVisibleWith(visibility, constraint) {
      return visibility <= constraint;
    }
    exports2.isVisibleWith = isVisibleWith;
    var DEFAULT_ALIAS_RESOLVER = (node) => node.element();
    exports2.DEFAULT_ALIAS_RESOLVER = DEFAULT_ALIAS_RESOLVER;
    exports2.PARENT_CONTENTS_OPTIONS = {
      // private visibility by default for parent scopes
      imported: {
        visibility: 2,
        depth: 1
      },
      inherited: {
        visibility: 2,
        depth: 1
      },
      aliasResolver: exports2.DEFAULT_ALIAS_RESOLVER
    };
    exports2.CHILD_CONTENTS_OPTIONS = {
      // only publicly visible contents by default
      imported: {
        visibility: 0,
        depth: 0
      },
      inherited: {
        visibility: 0,
        depth: 0
      },
      aliasResolver: void 0
    };
    function resolveVisibility(opts) {
      var _a, _b;
      return {
        visibility: (_a = opts.visibility) !== null && _a !== void 0 ? _a : 0,
        depth: (_b = opts.depth) !== null && _b !== void 0 ? _b : 1e7,
        next: opts.next
      };
    }
    exports2.resolveVisibility = resolveVisibility;
    var DEFAULT_VISIBILITY = {
      visibility: 0,
      depth: 0,
      next: void 0
    };
    function decrementVisibility(options) {
      const depth = options.depth - 1;
      if (depth < 0) {
        if (options.next)
          return resolveVisibility(options.next);
        return DEFAULT_VISIBILITY;
      }
      return { visibility: options.visibility, depth, next: options.next };
    }
    exports2.decrementVisibility = decrementVisibility;
    function fillContentOptions({ imported = DEFAULT_VISIBILITY, inherited = DEFAULT_VISIBILITY, aliasResolver = exports2.DEFAULT_ALIAS_RESOLVER, visited = void 0, specializations = void 0 } = {}) {
      const cache = visited !== null && visited !== void 0 ? visited : /* @__PURE__ */ new Set();
      const specs = specializations !== null && specializations !== void 0 ? specializations : /* @__PURE__ */ new Set();
      return {
        imported: resolveVisibility(imported),
        inherited: resolveVisibility(inherited),
        aliasResolver,
        visited: cache,
        specializations: specs
      };
    }
    exports2.fillContentOptions = fillContentOptions;
    function resolveContentInputs(node, opts) {
      const options = fillContentOptions(opts);
      let resolved = void 0;
      if (node && options.aliasResolver && node.is(ast_1.Membership))
        resolved = options.aliasResolver(node);
      else if (node.is(ast_1.Element))
        resolved = node;
      return {
        element: resolved,
        options
      };
    }
    exports2.resolveContentInputs = resolveContentInputs;
    function collectRedefinitions(feature, redefinitions) {
      const visitRedefinitions = (node) => {
        node.types(ast_1.Redefinition).forEach((t) => {
          const f = t;
          if (redefinitions.has(f))
            return;
          redefinitions.add(f);
          visitRedefinitions(f);
        });
      };
      visitRedefinitions(feature);
    }
    exports2.collectRedefinitions = collectRedefinitions;
    function streamParents(root) {
      return new langium_1.TreeStreamImpl(root, (node) => {
        const parent = node.owner();
        return parent ? [parent] : langium_1.EMPTY_STREAM;
      }, { includeRoot: true });
    }
    exports2.streamParents = streamParents;
  }
});

// ../syside-languageserver/lib/utils/scopes.js
var require_scopes = __commonJS({
  "../syside-languageserver/lib/utils/scopes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeLinkingScope = exports2.makeScope = exports2.FilteredScope = exports2.ScopeStream = exports2.TypeScope = exports2.NamespaceScope = exports2.NamespaceImportScope = exports2.MembershipImportScope = exports2.ImportScope = exports2.ElementScope = exports2.EMPTY_SYSML_SCOPE = exports2.SysMLScope = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    var model_1 = require_model3();
    var scope_util_1 = require_scope_util();
    var common_1 = require_common();
    var SysMLScope = class {
      getAllExportedElements() {
        const ignored = /* @__PURE__ */ new Set();
        const tree = new langium_1.TreeStreamImpl(
          [ignored, this],
          // need to create a copy of the set on every new child scope so that
          // the changes don't propagate back up, only down to children
          ([ignored2, scope]) => scope.getChildScopes().map((s) => [new Set(ignored2), s]),
          {
            includeRoot: true
          }
        );
        return tree.flatMap(([ignored2, scope]) => scope.getAllLocalElements(ignored2).filter(([name]) => !ignored2.has(name))).distinct(([name]) => name);
      }
      getAllElements() {
        return this.getAllExportedElements().distinct(([_, m]) => m).map(([_, e]) => e.description).nonNullable();
      }
      getExportedElement(name) {
        const iterator = this.getAllScopes(true).iterator();
        let current = iterator.next();
        while (!current.done) {
          const candidate = current.value.getLocalElement(name);
          if (candidate === "prune") {
            iterator.prune();
          } else if (candidate && this.isValidCandidate(candidate)) {
            return candidate;
          }
          current = iterator.next();
        }
        return;
      }
      getElement(name) {
        var _a;
        return (_a = this.getExportedElement(name)) === null || _a === void 0 ? void 0 : _a.description;
      }
      /**
       *
       * @param includeSelf if true, include this scope in the stream
       * @returns Stream of all owned, inherited and imported scopes
       */
      getAllScopes(includeSelf = true) {
        const scopes = new langium_1.TreeStreamImpl(this, (scope) => scope.getChildScopes(), {
          includeRoot: includeSelf
        });
        return scopes;
      }
      /**
       * Check if an AST node can be returned by {@link getElement} (e.g. it is not hidden by redefinitions)
       * @param candidate AST node description to check
       * @returns true if {@link candidate} is visible to {@link getElement}, false otherwise
       */
      // eslint-disable-next-line unused-imports/no-unused-vars
      isValidCandidate(candidate) {
        return true;
      }
    };
    exports2.SysMLScope = SysMLScope;
    var EmptySysMLScope = class extends SysMLScope {
      getLocalElement(_) {
        return;
      }
      getAllLocalElements() {
        return langium_1.EMPTY_STREAM;
      }
      getChildScopes() {
        return langium_1.EMPTY_STREAM;
      }
    };
    exports2.EMPTY_SYSML_SCOPE = new EmptySysMLScope();
    var ElementScope = class extends SysMLScope {
      constructor(element, options) {
        super();
        this.element = element;
        this.options = options;
      }
      getChildScopes() {
        return langium_1.EMPTY_STREAM;
      }
      getLocalElement(name) {
        const candidate = this.element.findMember(name);
        if (typeof candidate === "string") {
          if (candidate === "unresolved reference")
            throw candidate;
          return "prune";
        }
        if (candidate && this.isVisible(candidate))
          return (0, model_1.namedMembership)(candidate);
        return;
      }
      getAllLocalElements(ignored) {
        return (0, langium_1.stream)(this.element.namedMembers).map(([name, child]) => {
          if (child === "shadow") {
            ignored.add(name);
            return;
          }
          if (child === "unresolved reference") {
            return;
          }
          const element = (0, model_1.namedMembership)(child);
          if (!element || !this.isVisible(child))
            return;
          return [name, element];
        }).filter(common_1.NonNullable);
      }
      /**
       * Check if {@link exported} is visible outside this scope
       * @param exported element description
       * @returns true if {@link exported} is visible outside of this scope, false otherwise
       */
      isVisible(exported) {
        var _a;
        return (0, scope_util_1.isVisibleWith)(exported.visibility, this.options.inherited.visibility) && !this.options.visited.has((_a = (0, model_1.namedMembership)(exported)) === null || _a === void 0 ? void 0 : _a.element());
      }
      isValidCandidate(candidate) {
        return !this.options.visited.has(candidate.element());
      }
    };
    exports2.ElementScope = ElementScope;
    var ImportScope = class extends ElementScope {
      constructor(element, options) {
        super(element, Object.assign({}, options));
        this.element = element;
        if (this.element.importsAll) {
          this.options.inherited = {
            depth: 1e6,
            visibility: 2
            /* Visibility.private */
          };
          this.options.imported = {
            depth: 1e6,
            visibility: 2
            /* Visibility.private */
          };
        }
      }
      getLocalElement(_name) {
        return;
      }
      getAllLocalElements() {
        return langium_1.EMPTY_STREAM;
      }
      /**
       * Construct a stream of scopes for recursive imports
       * @param target
       * @returns Recursive stream of scopes starting at {@link target}
       */
      makeRecursiveScope(target) {
        if (!target.is(ast_1.Namespace))
          return langium_1.EMPTY_STREAM;
        const node = target.ast();
        let namespaces;
        if (node) {
          namespaces = new langium_1.TreeStreamImpl(node, (child) => child.$children.filter(ast_1.isOwningMembership).map((m) => m.target).filter(ast_1.isNamespace), {
            includeRoot: true
          }).map((ns) => ns.$meta);
        } else {
          namespaces = new langium_1.TreeStreamImpl(target, (ns) => (0, langium_1.stream)(ns.children).filter(model_1.BasicMetamodel.is(ast_1.OwningMembership)).map((m) => m.element()).filter(model_1.BasicMetamodel.is(ast_1.Namespace)), { includeRoot: true });
        }
        return namespaces.map((ns) => makeScope(ns, this.options));
      }
    };
    exports2.ImportScope = ImportScope;
    var MembershipImportScope = class extends ImportScope {
      constructor(element, options) {
        super(element, Object.assign({}, options));
        this.element = element;
      }
      getChildScopes() {
        var _a;
        const target = (_a = this.element.element()) === null || _a === void 0 ? void 0 : _a.element();
        if (!target || !this.element.isRecursive)
          return langium_1.EMPTY_STREAM;
        return this.makeRecursiveScope(target);
      }
    };
    exports2.MembershipImportScope = MembershipImportScope;
    var NamespaceImportScope = class extends ImportScope {
      constructor(element, options) {
        super(element, Object.assign({}, options));
        this.element = element;
      }
      getChildScopes() {
        const element = this.element.element();
        if (!element)
          return langium_1.EMPTY_STREAM;
        if (this.element.isRecursive)
          return this.makeRecursiveScope(element);
        return (0, langium_1.stream)([makeScope(element, this.options)]);
      }
    };
    exports2.NamespaceImportScope = NamespaceImportScope;
    var NamespaceScope = class extends ElementScope {
      constructor(element, options) {
        super(element, Object.assign(Object.assign({}, options), { inherited: (0, scope_util_1.decrementVisibility)(options.inherited), imported: (0, scope_util_1.decrementVisibility)(options.imported) }));
        this.element = element;
      }
      getChildScopes() {
        return this.getInheritedScopes().concat((0, langium_1.stream)(this.element.imports).map((imp) => {
          if (!imp.importsAll && imp.visibility > this.options.imported.visibility || imp.importsNameOnly() || this.options.visited.has(imp))
            return exports2.EMPTY_SYSML_SCOPE;
          this.options.visited.add(imp);
          return imp.is(ast_1.MembershipImport) ? new MembershipImportScope(imp, this.options) : new NamespaceImportScope(imp, this.options);
        }));
      }
      /**
       * @returns stream of all directly inherited scopes
       */
      getInheritedScopes() {
        return langium_1.EMPTY_STREAM;
      }
    };
    exports2.NamespaceScope = NamespaceScope;
    var TypeScope = class extends NamespaceScope {
      constructor(element, options) {
        super(element, options);
        this.element = element;
      }
      getInheritedScopes() {
        const scopes = [];
        const visited = this.options.visited;
        const specializations = this.options.specializations;
        specializations.add(this.element);
        const inherited = (0, scope_util_1.decrementVisibility)(this.options.inherited);
        for (const specialization of this.element.specializations()) {
          const specialized = specialization.finalElement();
          if (!specialized || specializations.has(specialized))
            continue;
          specializations.add(specialized);
          scopes.push(new TypeScope(specialized, Object.assign(Object.assign({}, this.options), {
            // use the same visibility for imported members from inherited scopes as
            // they are essentially the same in this case
            inherited,
            imported: inherited,
            visited: new Set(visited),
            specializations: new Set(specializations)
          })));
        }
        return (0, langium_1.stream)(scopes);
      }
    };
    exports2.TypeScope = TypeScope;
    var ScopeStream = class extends SysMLScope {
      constructor(scopes) {
        super();
        this.scopes = scopes;
      }
      getChildScopes() {
        if (this.scopes instanceof langium_1.StreamImpl)
          return this.scopes;
        return (0, langium_1.stream)(this.scopes);
      }
      getLocalElement(_name) {
        return;
      }
      getAllLocalElements() {
        return langium_1.EMPTY_STREAM;
      }
    };
    exports2.ScopeStream = ScopeStream;
    var FilteredScope = class extends SysMLScope {
      constructor(scope, predicate) {
        super();
        this.scope = scope;
        this.predicate = predicate;
      }
      getAllScopes(includeSelf) {
        return this.scope.getAllScopes(includeSelf);
      }
      getAllExportedElements() {
        return this.scope.getAllExportedElements().filter(([_, m]) => this.predicate(m));
      }
      getChildScopes() {
        return this.scope["getChildScopes"]();
      }
      getLocalElement(name) {
        const candidate = this.scope["getLocalElement"](name);
        if (typeof candidate === "object")
          return this.predicate(candidate) ? candidate : void 0;
        return candidate;
      }
      getAllLocalElements(ignored) {
        return this.scope["getAllLocalElements"](ignored).filter(([_, m]) => this.predicate(m));
      }
      isValidCandidate(candidate) {
        return this.predicate(candidate);
      }
    };
    exports2.FilteredScope = FilteredScope;
    var SCOPE_MAP = void 0;
    var SCOPE_CONSTRUCTORS = {
      Element: ElementScope,
      Namespace: NamespaceScope,
      NamespaceImport: NamespaceImportScope,
      MembershipImport: MembershipImportScope,
      Type: TypeScope
    };
    function makeScope(node, opts = {}) {
      if (!node)
        return exports2.EMPTY_SYSML_SCOPE;
      const { element, options } = (0, scope_util_1.resolveContentInputs)(node, opts);
      if (!element)
        return exports2.EMPTY_SYSML_SCOPE;
      if (!SCOPE_MAP) {
        SCOPE_MAP = model_1.typeIndex.expandToDerivedTypes(SCOPE_CONSTRUCTORS);
      }
      let target = element.is(ast_1.Membership) ? element.element() : element;
      target !== null && target !== void 0 ? target : target = element;
      const ctor = SCOPE_MAP.get(target.nodeType());
      if (ctor)
        return new ctor(target, options);
      return exports2.EMPTY_SYSML_SCOPE;
    }
    exports2.makeScope = makeScope;
    var EMPTY_SCOPE_STREAM = new ScopeStream(langium_1.EMPTY_STREAM);
    function makeLinkingScope(root, options = {}, global2) {
      var _a;
      if (!root)
        return EMPTY_SCOPE_STREAM;
      (_a = options.visited) !== null && _a !== void 0 ? _a : options.visited = /* @__PURE__ */ new Set();
      let parentScopes = langium_1.EMPTY_STREAM;
      const parent = root.owner();
      if (parent && !options.skipParents) {
        const parents = (0, scope_util_1.streamParents)(parent);
        const scopeOptions = (0, scope_util_1.fillContentOptions)(Object.assign(Object.assign({}, scope_util_1.PARENT_CONTENTS_OPTIONS), {
          aliasResolver: options.aliasResolver,
          // all direct children are visible
          imported: { visibility: 2, depth: 1 },
          inherited: { visibility: 2, depth: 1 }
        }));
        parentScopes = parents.filter(model_1.BasicMetamodel.is(ast_1.Element)).map((parent2) => makeScope(parent2, Object.assign(Object.assign({}, scopeOptions), {
          // redefinitions are only valid in the owning scope
          visited: /* @__PURE__ */ new Set(),
          specializations: /* @__PURE__ */ new Set()
        })));
      }
      if (global2 && !options.skipParents) {
        if (root.parent() || !options.skip)
          parentScopes = parentScopes.concat([global2]);
        else
          parentScopes = parentScopes.concat([
            new FilteredScope(global2, (d) => d.element() !== options.skip)
          ]);
      }
      const rootScope = makeScope(root, {
        aliasResolver: options.aliasResolver,
        visited: options.visited,
        imported: {
          // root scope has private members visible but not transitively
          visibility: 2,
          depth: 1
        },
        inherited: {
          // private members visible in root scope
          visibility: 2,
          depth: 1,
          // private members hidden in base scopes
          next: { visibility: 1, depth: 1e6 }
        }
      });
      if (!options.skip) {
        return new ScopeStream((0, langium_1.stream)([rootScope]).concat(parentScopes));
      }
      return new ScopeStream((0, langium_1.stream)([new FilteredScope(rootScope, (d) => d.element() !== options.skip)]).concat(parentScopes));
    }
    exports2.makeLinkingScope = makeLinkingScope;
  }
});

// ../syside-languageserver/lib/utils/global-scope.js
var require_global_scope = __commonJS({
  "../syside-languageserver/lib/utils/global-scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GlobalScope = exports2.getLanguageId = void 0;
    var langium_1 = require_lib2();
    var vscode_uri_1 = require_umd();
    var scopes_1 = require_scopes();
    var model_1 = require_model3();
    var common_1 = require_common();
    function getLanguageId(uri) {
      return vscode_uri_1.Utils.extname(uri).toLowerCase();
    }
    exports2.getLanguageId = getLanguageId;
    function getFromEntries(entries, langId) {
      var _a, _b;
      if (langId) {
        const candidate = (_a = entries.filter((entry) => entry.langId === langId).at(-1)) === null || _a === void 0 ? void 0 : _a.member;
        if (candidate)
          return candidate;
      }
      return (_b = entries.at(-1)) === null || _b === void 0 ? void 0 : _b.member;
    }
    var GlobalScope = class extends scopes_1.SysMLScope {
      constructor() {
        super(...arguments);
        this.staticExports = /* @__PURE__ */ new Map();
        this.documentStaticExports = /* @__PURE__ */ new Map();
        this.allExports = {};
      }
      /**
       *
       * @param name member name
       * @param langId language id, i.e. `.kerml` or `.sysml`, used to resolve shadows
       * @returns
       */
      getExportedElement(name, langId) {
        const value = this.getLocalElement(name, langId);
        if (typeof value === "object")
          return value;
        return;
      }
      getStaticExportedElement(name, langId) {
        const entries = this.staticExports.get(name);
        if (entries) {
          const candidate = getFromEntries(entries, langId);
          if (candidate)
            return candidate;
        }
        return;
      }
      getAllExportedElements(langId) {
        return this.getAllLocalElements(/* @__PURE__ */ new Set(), langId);
      }
      getChildScopes() {
        return langium_1.EMPTY_STREAM;
      }
      getLocalElement(name, langId) {
        return this.getStaticExportedElement(name, langId);
      }
      getAllLocalElements(ignored, langId) {
        return (0, langium_1.stream)(this.staticExports).map(([name, entries]) => [name, getFromEntries(entries, langId)]).filter((t) => Boolean(t[1])).distinct(([name]) => name);
      }
      invalidateDocuments(uris) {
        uris.forEach((uri) => {
          var _a, _b;
          const id = getLanguageId(uri);
          const uriStr = uri.toString();
          (_a = this.allExports[id]) === null || _a === void 0 ? void 0 : _a.delete(uriStr);
          (_b = this.documentStaticExports.get(uriStr)) === null || _b === void 0 ? void 0 : _b.forEach(([name, entry]) => {
            const entries = this.staticExports.get(name);
            if (entries)
              (0, common_1.erase)(entries, entry);
          });
          this.documentStaticExports.delete(uriStr);
        });
      }
      collectDocument(document) {
        const root = document.parseResult.value.$meta;
        const langId = getLanguageId(document.uri);
        const exports3 = [];
        for (const [name, child] of root.namedMembers) {
          if (typeof child !== "object" || child.visibility !== 0)
            continue;
          const member = (0, model_1.namedMembership)(child);
          if (!member)
            continue;
          exports3.push([name, { langId, member }]);
        }
        this.documentStaticExports.set(document.uriString, exports3);
        exports3.forEach(([name, entry]) => {
          let entries = this.staticExports.get(name);
          if (!entries) {
            entries = [];
            this.staticExports.set(name, entries);
          }
          entries.push(entry);
        });
        const addExports = (exports4) => {
          var _a;
          ((_a = exports4[langId]) !== null && _a !== void 0 ? _a : exports4[langId] = /* @__PURE__ */ new Map()).set(document.uriString, root);
        };
        addExports(this.allExports);
      }
      wrapForLang(langId) {
        class GlobalLangScope extends scopes_1.SysMLScope {
          constructor(scope, langId2) {
            super();
            this.scope = scope;
            this.langId = langId2;
          }
          getChildScopes() {
            return this.scope.getChildScopes();
          }
          getLocalElement(name) {
            return this.scope.getLocalElement(name, this.langId);
          }
          getAllLocalElements(ignored) {
            return this.scope.getAllLocalElements(ignored, this.langId);
          }
          getExportedElement(name) {
            return this.scope.getExportedElement(name, this.langId);
          }
          getAllExportedElements() {
            return this.scope.getAllExportedElements(this.langId);
          }
        }
        return new GlobalLangScope(this, langId);
      }
    };
    exports2.GlobalScope = GlobalScope;
  }
});

// ../syside-languageserver/lib/utils/printer/print.js
var require_print2 = __commonJS({
  "../syside-languageserver/lib/utils/printer/print.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printIgnored = exports2.print = exports2.printDoc = exports2.formatDoc = exports2.collect = void 0;
    var assert_1 = __importDefault(require("assert"));
    var doc_1 = require_doc();
    var Cursor = Symbol("cursor");
    function generateInitialQueue(indent, newIndent) {
      if (newIndent.kind === "dedent") {
        return indent.queue.slice(0, -1);
      }
      return [...indent.queue, newIndent];
    }
    function generateIndent(indent, newIndent, config) {
      const queue = generateInitialQueue(indent, newIndent);
      let length = 0;
      const value = [];
      queue.forEach((indent2) => {
        const kind = indent2.kind;
        if (kind === "indent") {
          length += config.tabWidth;
          value.push(config.useSpaces ? " ".repeat(config.tabWidth) : "	");
          return;
        } else if (typeof kind === "number") {
          (0, assert_1.default)(kind >= 0);
          length += kind;
          if (config.useSpaces)
            value.push(" ".repeat(kind));
          else {
            value.push("	".repeat(Math.floor(kind / config.tabWidth)) + " ".repeat(kind % config.tabWidth));
          }
          return;
        } else if (typeof kind === "object") {
          length += kind.width;
          value.push(kind.contents);
        }
      });
      return {
        length,
        value: (0, doc_1.text)(value.join("")),
        queue,
        kind: newIndent.kind,
        root: indent.root
      };
    }
    function makeIndent(indent, config) {
      return generateIndent(indent, { kind: "indent", length: 0, queue: [], value: doc_1.literals.emptytext }, config);
    }
    function trim(out) {
      if (out.length === 0)
        return 0;
      let trimmed = 0;
      let cursors = 0;
      let index = out.length;
      const loop = () => {
        while (index--) {
          const last = out[index];
          if (last === Cursor) {
            cursors++;
            continue;
          }
          for (let charIdx = last.contents.length - 1; charIdx >= 0; charIdx--) {
            const char = last.contents[charIdx];
            if (char === " " || char === "	") {
              trimmed++;
              continue;
            }
            out[index] = (0, doc_1.text)(last.contents.slice(0, charIdx + 1), {
              type: last.type,
              modifiers: last.modifiers
            });
            return;
          }
        }
      };
      loop();
      if (trimmed > 0 || cursors > 0) {
        out.length = index + 1;
        out.push(...Array(cursors).fill(Cursor));
      }
      return trimmed;
    }
    function makeAlign(indent, amount, config) {
      var _a;
      if (typeof amount === "number") {
        if (amount === Number.NEGATIVE_INFINITY) {
          return (_a = indent.root) !== null && _a !== void 0 ? _a : rootIndent();
        }
        if (amount === 0)
          return indent;
        if (amount < 0)
          return generateIndent(indent, { kind: "dedent", length: 0, queue: [], value: doc_1.literals.emptytext }, config);
      }
      return generateIndent(indent, {
        kind: amount,
        length: 0,
        queue: [],
        value: doc_1.literals.emptytext
      }, config);
    }
    function rootIndent() {
      return { kind: 0, value: doc_1.literals.emptytext, length: 0, queue: [] };
    }
    var Fits = {
      text([_, __, text], stack, out, context) {
        context.width -= text.width;
        out.push(text);
        return;
      },
      array([indent, mode, items], stack) {
        stack.push(...items.slice().reverse().map((doc) => [indent, mode, doc]));
      },
      fill([indent, mode, doc], stack) {
        stack.push(...doc.parts.slice().reverse().map((doc2) => [indent, mode, doc2]));
      },
      label([indent, mode, doc], stack) {
        stack.push([indent, mode, doc.contents]);
      },
      indent([indent, mode, doc], stack, out, context) {
        stack.push([makeIndent(indent, context.config), mode, doc.contents]);
      },
      ["indent-if-break"]([indent, mode, doc], stack) {
        stack.push([indent, mode, doc.contents]);
      },
      align([indent, mode, doc], stack, out, context) {
        stack.push([makeAlign(indent, doc.prefix, context.config), mode, doc.contents]);
      },
      group([indent, mode, doc], stack, out, context) {
        if (context.mustBeFlat && doc.break)
          return false;
        const groupMode = doc.break ? "break" : mode;
        const contents = doc.expandedStates && doc.expandedStates.length > 0 && groupMode === "break" ? doc.expandedStates[doc.expandedStates.length - 1] : doc.contents;
        stack.push([indent, groupMode, contents]);
        return;
      },
      cursor() {
        return;
      },
      root([indent, mode, doc], stack) {
        stack.push([
          Object.assign(Object.assign({}, indent), { root: indent }),
          mode,
          doc.contents
        ]);
      },
      ["if-break"]([indent, mode, doc], stack, out, context) {
        const groupMode = doc.groupId ? context.groupModeMap.get(doc.groupId) || "flat" : mode;
        const contents = groupMode === "break" ? doc.onBreak : doc.onFlat;
        if (contents)
          stack.push([indent, mode, contents]);
      },
      ["line-suffix"](_, stack, out, context) {
        context.hasLineSuffix = true;
      },
      ["line-suffix-boundary"](_, stack, out, context) {
        if (context.hasLineSuffix)
          return false;
        return;
      },
      trim(_, stack, out, context) {
        context.width += trim(out);
      },
      line([_, mode, doc], stack, out, context) {
        if (mode === "break" || doc.mode === "hard" || doc.mode === "hard-literal")
          return true;
        if (doc.mode !== "soft") {
          out.push(doc_1.literals.space);
          context.width--;
        }
        return;
      },
      ["break-parent"]() {
      }
    };
    function fits(next, restCommands, context) {
      if (context.width === Number.POSITIVE_INFINITY) {
        return true;
      }
      let restIdx = restCommands.length;
      const commands = [next];
      const out = [];
      while (context.width >= 0) {
        if (commands.length === 0) {
          if (restIdx === 0)
            return true;
          commands.push(restCommands[--restIdx]);
          continue;
        }
        const command = commands.pop();
        const kind = (0, doc_1.getDocKind)(command[2]);
        const fits2 = Fits[kind](command, commands, out, context);
        if (typeof fits2 === "boolean")
          return fits2;
      }
      return false;
    }
    function collect(out, semantic) {
      const text = [];
      const highlighting = [];
      const cursors = [];
      let position = 0;
      out.forEach((part) => {
        if (part === Cursor) {
          cursors.push(position);
        } else {
          text.push(part.contents);
          if (semantic && part.type) {
            highlighting.push({
              start: position,
              end: position + part.contents.length,
              type: part.type,
              modifiers: part.modifiers
            });
          }
          position += part.contents.length;
        }
      });
      const result = {
        text: text.join(""),
        cursors
      };
      if (semantic)
        result.highlighting = highlighting;
      return result;
    }
    exports2.collect = collect;
    var Formatter = {
      text(indent, mode, doc, context) {
        context.out.push(doc);
        context.position += doc.width;
      },
      array(indent, mode, doc, context) {
        context.stack.push(...doc.slice().reverse().map((command) => [indent, mode, command]));
      },
      indent(ind, mode, doc, context) {
        const indent = makeIndent(ind, context.config);
        context.stack.push([indent, mode, doc.contents]);
      },
      align(ind, mode, doc, context) {
        const indent = makeAlign(ind, doc.prefix, context.config);
        context.stack.push([indent, mode, doc.contents]);
      },
      trim(indent, mode, doc, context) {
        context.position -= trim(context.out);
      },
      cursor(indent, mode, doc, context) {
        context.out.push(Cursor);
      },
      group(indent, mode, doc, context) {
        var _a;
        const inner = () => {
          if (mode === "flat") {
            if (!context.shouldRemeasure) {
              context.stack.push([indent, doc.break ? "break" : "flat", doc.contents]);
              return;
            }
          }
          context.shouldRemeasure = false;
          const next = [indent, "flat", doc.contents];
          const remainder = context.config.lineWidth - context.position;
          const hasLineSuffix = context.lineSuffixes.length > 0;
          if (!doc.break && fits(next, context.stack, {
            config: context.config,
            groupModeMap: context.groupModeMap,
            hasLineSuffix,
            width: remainder
          })) {
            context.stack.push(next);
          } else {
            if (doc.expandedStates && doc.expandedStates.length > 0) {
              const mostExpanded = doc.expandedStates.at(-1);
              if (doc.break) {
                context.stack.push([indent, "break", mostExpanded]);
                return;
              }
              for (let i = 1; i < doc.expandedStates.length + 1; i++) {
                if (i >= doc.expandedStates.length) {
                  context.stack.push([indent, "break", mostExpanded]);
                  return;
                }
                const state = doc.expandedStates[i];
                const command = [indent, "flat", state];
                if (fits(command, context.stack, {
                  width: remainder,
                  hasLineSuffix,
                  groupModeMap: context.groupModeMap,
                  config: context.config
                })) {
                  context.stack.push(command);
                  return;
                }
              }
            } else {
              context.stack.push([indent, "break", doc.contents]);
            }
          }
        };
        inner();
        if (doc.id) {
          context.groupModeMap.set(doc.id, (_a = context.stack.at(-1)) === null || _a === void 0 ? void 0 : _a[1]);
        }
      },
      fill(indent, mode, doc, context) {
        let parts = doc.parts;
        if (parts.length === 0)
          return;
        const remainder = context.config.lineWidth - context.position;
        const content = parts[0];
        const flatContent = [indent, "flat", content];
        const breakContent = [indent, "break", content];
        const flatContentFits = fits(flatContent, [], {
          width: remainder,
          config: context.config,
          groupModeMap: context.groupModeMap,
          hasLineSuffix: context.lineSuffixes.length > 0,
          mustBeFlat: true
        });
        if (parts.length === 1) {
          context.stack.push(flatContentFits ? flatContent : breakContent);
          return;
        }
        const whitespace = parts[1];
        const flatWs = [indent, "flat", whitespace];
        const breakWs = [indent, "break", whitespace];
        if (parts.length === 2) {
          if (flatContentFits) {
            context.stack.push(flatWs, flatContent);
          } else {
            context.stack.push(breakWs, breakContent);
          }
          return;
        }
        parts = parts.slice(2);
        const remaining = [indent, mode, (0, doc_1.fill)(parts)];
        const secondContent = parts[0];
        const combinedFlatContent = [indent, "flat", [content, whitespace, secondContent]];
        const combinedFits = fits(combinedFlatContent, [], {
          width: remainder,
          config: context.config,
          groupModeMap: context.groupModeMap,
          hasLineSuffix: context.lineSuffixes.length > 0,
          mustBeFlat: true
        });
        if (combinedFits) {
          context.stack.push(remaining, flatWs, flatContent);
        } else {
          context.stack.push(remaining, breakWs, flatContentFits ? flatContent : breakContent);
        }
      },
      "line-suffix"(indent, mode, doc, context) {
        context.lineSuffixes.push([indent, mode, doc.contents]);
      },
      "line-suffix-boundary"(indent, mode, doc, context) {
        if (context.lineSuffixes.length > 0) {
          context.stack.push([indent, mode, doc_1.hardlineWithoutBreakParent]);
        }
      },
      line(indent, mode, doc, context) {
        if (mode === "flat") {
          if (doc.mode === "auto") {
            context.out.push((0, doc_1.text)(" "));
            context.position++;
            return;
          }
          if (doc.mode === "soft")
            return;
          context.shouldRemeasure = true;
        }
        if (context.lineSuffixes.length > 0) {
          context.stack.push([indent, mode, doc], ...context.lineSuffixes.reverse());
          context.lineSuffixes.length = 0;
          return;
        }
        if (doc.mode === "hard-literal") {
          if (indent.root) {
            context.out.push(context.lineEnd, indent.root.value);
            context.position = indent.root.length;
          } else {
            context.out.push(context.lineEnd);
            context.position = 0;
          }
          return;
        }
        context.position -= trim(context.out);
        context.out.push(context.lineEnd);
        context.position = 0;
        if (indent.length > 0) {
          context.out.push(indent.value);
          context.position = indent.length;
        }
      },
      label(indent, mode, doc, context) {
        context.stack.push([indent, mode, doc.contents]);
      },
      "break-parent"() {
      },
      "if-break"(ind, mode, doc, context) {
        var _a;
        const groupMode = (_a = doc.groupId ? context.groupModeMap.get(doc.groupId) : mode) !== null && _a !== void 0 ? _a : mode;
        context.stack.push([ind, mode, groupMode === "flat" ? doc.onFlat : doc.onBreak]);
      },
      "indent-if-break"(ind, mode, doc, context) {
        var _a;
        const groupMode = (_a = doc.groupId ? context.groupModeMap.get(doc.groupId) : mode) !== null && _a !== void 0 ? _a : mode;
        context.stack.push([
          ind,
          mode,
          groupMode === "flat" ? doc.negate ? (0, doc_1.indent)(doc.contents) : doc.contents : doc.negate ? doc.contents : (0, doc_1.indent)(doc.contents)
        ]);
      },
      root(indent, mode, doc, context) {
        context.stack.push([
          Object.assign(Object.assign({}, indent), { root: indent }),
          mode,
          doc.contents
        ]);
      }
    };
    function propagateBreaks(doc) {
      const visited = /* @__PURE__ */ new Set();
      const stack = [];
      const breakParent = () => {
        const group = stack.at(-1);
        if (group && !group.expandedStates && !group.break) {
          group.break = "propagated";
        }
      };
      (0, doc_1.visitDoc)(doc, {
        traverseOptionalGroups: true,
        enter(doc2) {
          const item = doc2;
          if (item.kind === "break-parent") {
            breakParent();
          } else if (item.kind === "group") {
            stack.push(item);
            if (visited.has(item))
              return false;
            visited.add(item);
          }
          return true;
        },
        exit(doc2) {
          var _a;
          const item = doc2;
          if (item.kind === "group" && ((_a = stack.pop()) === null || _a === void 0 ? void 0 : _a.break)) {
            breakParent();
          }
        }
      });
    }
    function formatDoc(doc, config) {
      const context = {
        position: 0,
        shouldRemeasure: false,
        out: [],
        lineSuffixes: [],
        groupModeMap: /* @__PURE__ */ new Map(),
        stack: [[rootIndent(), "break", doc]],
        lineEnd: (0, doc_1.text)(config.lineEnd),
        config
      };
      propagateBreaks(doc);
      while (context.stack.length > 0) {
        const [indent, mode, doc2] = context.stack.pop();
        const kind = (0, doc_1.getDocKind)(doc2);
        Formatter[kind](indent, mode, doc2, context);
        if (context.stack.length === 0 && context.lineSuffixes.length > 0) {
          context.stack.push(...context.lineSuffixes.reverse());
          context.lineSuffixes.length = 0;
        }
      }
      const finalText = context.out.findLast((item) => item !== Cursor);
      if (context.config.addFinalNewline && (!finalText || !finalText.contents.endsWith(config.lineEnd))) {
        context.out.push((0, doc_1.text)(context.config.lineEnd));
      }
      return context.out;
    }
    exports2.formatDoc = formatDoc;
    function printDoc(doc, config = doc_1.DefaultPrinterConfig) {
      const out = formatDoc(doc, config);
      return collect(out, config.highlighting === true);
    }
    exports2.printDoc = printDoc;
    function print(doc, options) {
      const text = printDoc(doc, Object.assign(Object.assign({}, doc_1.DefaultPrinterConfig), options)).text;
      return text;
    }
    exports2.print = print;
    function printIgnored(document, segment, comments, printed) {
      const { offset, end } = segment;
      comments.forEach((comment) => {
        if (!comment.segment)
          return;
        const { offset: left, end: right } = comment.segment;
        if (left >= offset && right <= end)
          printed.add(comment);
      });
      return (0, doc_1.join)(doc_1.literalline, document.slice(offset, end).split(/\r?\n/).map((line) => (0, doc_1.text)(line)));
    }
    exports2.printIgnored = printIgnored;
  }
});

// ../syside-languageserver/lib/utils/printer/index.js
var require_printer = __commonJS({
  "../syside-languageserver/lib/utils/printer/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_doc(), exports2);
    __exportStar(require_print2(), exports2);
  }
});

// ../syside-languageserver/lib/utils/index.js
var require_utils2 = __commonJS({
  "../syside-languageserver/lib/utils/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_ast_to_model(), exports2);
    __exportStar(require_ast_util2(), exports2);
    __exportStar(require_comments2(), exports2);
    __exportStar(require_common(), exports2);
    __exportStar(require_containers(), exports2);
    __exportStar(require_cst_util2(), exports2);
    __exportStar(require_global_scope(), exports2);
    __exportStar(require_printer(), exports2);
    __exportStar(require_scope_util(), exports2);
    __exportStar(require_scopes(), exports2);
  }
});

// ../syside-languageserver/lib/model/types.js
var require_types2 = __commonJS({
  "../syside-languageserver/lib/model/types.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.typeIndex = void 0;
    var ast2 = __importStar(require_ast2());
    var NON_TYPES = /* @__PURE__ */ new Set([
      ast2.TransparentElement,
      ast2.FeatureRelationship,
      ast2.InlineExpression,
      ast2.NonOwnerType,
      ast2.TypeRelationship
    ]);
    var TypesIndex = class {
      constructor() {
        this.supertypes = /* @__PURE__ */ new Map();
        this.subtypes = /* @__PURE__ */ new Map();
        this.base = new ast2.SysMlAstReflection();
        for (const type of this.base.getAllTypes()) {
          const unions = [];
          const types = [];
          const relationships = [];
          for (const subtype of this.base.getAllTypes()) {
            if (subtype === type)
              continue;
            if (this.base.isSubtype(type, subtype)) {
              (NON_TYPES.has(subtype) ? unions : this.base.isSubtype(subtype, ast2.Namespace) ? types : relationships).push(subtype);
            }
          }
          this.sortTypes(types);
          this.mergeTypes(types, this.sortTypes(relationships));
          this.mergeTypes(types, this.sortTypes(unions));
          const supertypes = new Set(types);
          this.supertypes.set(type, supertypes);
          supertypes.forEach((supertype) => {
            this.getSubtypes(supertype).add(type);
          });
        }
        this.types = this.base.getAllTypes().filter((s) => !NON_TYPES.has(s));
      }
      sortTypes(types) {
        return types.sort((a, b) => this.base.isSubtype(a, b) ? -1 : this.base.isSubtype(b, a) ? 1 : 0);
      }
      mergeTypes(types, other) {
        const pos = other.map((u) => {
          let index = types.findIndex((i) => !this.base.isSubtype(i, u));
          if (index === -1)
            index = types.length;
          return [index, u];
        }).sort(([a, _], [b, __]) => a - b);
        pos.forEach(([pos2, union], i) => types.splice(pos2 + i, 0, union));
        return types;
      }
      /**
       * @returns names of all registered types in the grammar
       */
      getAllTypes() {
        return this.types;
      }
      /**
       * @returns true if {@link subtype} extends {@link supertype} interface
       */
      isSubtype(subtype, supertype) {
        var _a, _b;
        return subtype === supertype || ((_b = (_a = this.supertypes.get(subtype)) === null || _a === void 0 ? void 0 : _a.has(supertype)) !== null && _b !== void 0 ? _b : false);
      }
      /**
       * Get supertypes of {@link type} in the order of inheritance
       * @param type Type name
       * @returns set of supertypes ordered from the most specialized supertype to
       * the most general
       */
      getInheritanceChain(type) {
        var _a;
        return (_a = this.supertypes.get(type)) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Set();
      }
      getSubtypes(type) {
        let subtypes = this.subtypes.get(type);
        if (!subtypes) {
          subtypes = /* @__PURE__ */ new Set();
          this.subtypes.set(type, subtypes);
        }
        return subtypes;
      }
      /**
       * Expand {@link registry} mapping `typeName => value` to all AST types
       * using the most derived type values, i.e. `registry.Element` would map to
       * all types extending `Element` unless {@link registry} contained other
       * entries for types extending `Element`. For example `registry = {Element:
       * ..., Type: ...}` would expand `registry.Type` value to all types
       * extending element while `registry.Element` only to those types that
       * extend `Element` but not `Type`. If {@link registry} has `default`
       * member, it is used in cases where there were no other valid alternatives.
       * @param registry type specific values.
       * @returns map of type names to expanded {@link registry} values
       */
      expandToDerivedTypes(registry) {
        const result = /* @__PURE__ */ new Map();
        const def = registry.default;
        for (const type of this.base.getAllTypes()) {
          let value = registry[type];
          if (!value) {
            const chain = this.getInheritanceChain(type);
            for (const subtype of chain) {
              value = registry[subtype];
              if (value)
                break;
            }
          }
          if (!value)
            value = def;
          if (value)
            result.set(type, value);
        }
        return result;
      }
      /**
       * Expand {@link registry} mapping `typeName => [...value]` and merge with
       * values from the inherited types
       * @see {@link expandToDerivedTypes}
       * @param registry type specific values
       * @returns map of type names to expanded and merged {@link registry} values
       */
      expandAndMerge(registry, reverse = false) {
        const result = new Map(this.base.getAllTypes().map((t) => [t, []]));
        const push = reverse ? (array, values) => {
          array.unshift(...values);
        } : (array, values) => {
          array.push(...values);
        };
        for (const type of this.base.getAllTypes()) {
          const array = result.get(type);
          let value = registry[type];
          if (value)
            push(array, value);
          const chain = this.getInheritanceChain(type);
          for (const subtype of chain) {
            value = registry[subtype];
            if (value)
              push(array, value);
          }
        }
        return result;
      }
      chain(registry, order) {
        const result = /* @__PURE__ */ new Map();
        const reversed = order === "supertype-first";
        for (const type of this.base.getAllTypes()) {
          const chain = [];
          const value = registry[type];
          if (value)
            chain.push(value);
          this.getInheritanceChain(type).forEach((supertype) => {
            const value2 = registry[supertype];
            if (value2)
              chain.push(value2);
          });
          if (registry.default)
            chain.push(registry.default);
          result.set(type, reversed ? chain.reverse() : chain);
        }
        return result;
      }
      isUnion(type) {
        return type.startsWith("Named") || type.indexOf("Or") !== -1;
      }
    };
    exports2.typeIndex = new TypesIndex();
    ast2.reflection.isSubtype = function(subtype, supertype) {
      return exports2.typeIndex.isSubtype(subtype, supertype);
    };
  }
});

// ../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flatten = exports2.unique = exports2.hardMixProtos = exports2.nearestCommonProto = exports2.protoChain = exports2.copyProps = void 0;
    var copyProps = (dest, src, exclude = []) => {
      const props = Object.getOwnPropertyDescriptors(src);
      for (let prop of exclude)
        delete props[prop];
      Object.defineProperties(dest, props);
    };
    exports2.copyProps = copyProps;
    var protoChain = (obj, currentChain = [obj]) => {
      const proto2 = Object.getPrototypeOf(obj);
      if (proto2 === null)
        return currentChain;
      return (0, exports2.protoChain)(proto2, [...currentChain, proto2]);
    };
    exports2.protoChain = protoChain;
    var nearestCommonProto = (...objs) => {
      if (objs.length === 0)
        return void 0;
      let commonProto = void 0;
      const protoChains = objs.map((obj) => (0, exports2.protoChain)(obj));
      while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
        const protos = protoChains.map((protoChain2) => protoChain2.pop());
        const potentialCommonProto = protos[0];
        if (protos.every((proto2) => proto2 === potentialCommonProto))
          commonProto = potentialCommonProto;
        else
          break;
      }
      return commonProto;
    };
    exports2.nearestCommonProto = nearestCommonProto;
    var hardMixProtos = (ingredients, constructor, exclude = []) => {
      var _a;
      const base = (_a = (0, exports2.nearestCommonProto)(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;
      const mixedProto = Object.create(base);
      const visitedProtos = (0, exports2.protoChain)(base);
      for (let prototype of ingredients) {
        let protos = (0, exports2.protoChain)(prototype);
        for (let i = protos.length - 1; i >= 0; i--) {
          let newProto = protos[i];
          if (visitedProtos.indexOf(newProto) === -1) {
            (0, exports2.copyProps)(mixedProto, newProto, ["constructor", ...exclude]);
            visitedProtos.push(newProto);
          }
        }
      }
      mixedProto.constructor = constructor;
      return mixedProto;
    };
    exports2.hardMixProtos = hardMixProtos;
    var unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
    exports2.unique = unique;
    var flatten = (arr) => arr.length === 0 ? [] : arr.length === 1 ? arr[0] : arr.reduce((a1, a2) => [...a1, ...a2]);
    exports2.flatten = flatten;
  }
});

// ../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/proxy.js
var require_proxy = __commonJS({
  "../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/proxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.softMixProtos = exports2.proxyMix = exports2.getIngredientWithProp = void 0;
    var util_1 = require_util();
    var getIngredientWithProp = (prop, ingredients) => {
      const protoChains = ingredients.map((ingredient) => (0, util_1.protoChain)(ingredient));
      let protoDepth = 0;
      let protosAreLeftToSearch = true;
      while (protosAreLeftToSearch) {
        protosAreLeftToSearch = false;
        for (let i = ingredients.length - 1; i >= 0; i--) {
          const searchTarget = protoChains[i][protoDepth];
          if (searchTarget !== void 0 && searchTarget !== null) {
            protosAreLeftToSearch = true;
            if (Object.getOwnPropertyDescriptor(searchTarget, prop) != void 0) {
              return protoChains[i][0];
            }
          }
        }
        protoDepth++;
      }
      return void 0;
    };
    exports2.getIngredientWithProp = getIngredientWithProp;
    var proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
      getPrototypeOf() {
        return prototype;
      },
      setPrototypeOf() {
        throw Error("Cannot set prototype of Proxies created by ts-mixer");
      },
      getOwnPropertyDescriptor(_, prop) {
        return Object.getOwnPropertyDescriptor((0, exports2.getIngredientWithProp)(prop, ingredients) || {}, prop);
      },
      defineProperty() {
        throw new Error("Cannot define new properties on Proxies created by ts-mixer");
      },
      has(_, prop) {
        return (0, exports2.getIngredientWithProp)(prop, ingredients) !== void 0 || prototype[prop] !== void 0;
      },
      get(_, prop) {
        return ((0, exports2.getIngredientWithProp)(prop, ingredients) || prototype)[prop];
      },
      set(_, prop, val) {
        const ingredientWithProp = (0, exports2.getIngredientWithProp)(prop, ingredients);
        if (ingredientWithProp === void 0)
          throw new Error("Cannot set new properties on Proxies created by ts-mixer");
        ingredientWithProp[prop] = val;
        return true;
      },
      deleteProperty() {
        throw new Error("Cannot delete properties on Proxies created by ts-mixer");
      },
      ownKeys() {
        return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
      }
    });
    exports2.proxyMix = proxyMix;
    var softMixProtos = (ingredients, constructor) => (0, exports2.proxyMix)([...ingredients, { constructor }]);
    exports2.softMixProtos = softMixProtos;
  }
});

// ../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/settings.js
var require_settings = __commonJS({
  "../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.settings = void 0;
    exports2.settings = {
      initFunction: null,
      staticsStrategy: "copy",
      prototypeStrategy: "copy",
      decoratorInheritance: "deep"
    };
  }
});

// ../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/mixin-tracking.js
var require_mixin_tracking = __commonJS({
  "../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/mixin-tracking.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasMixin = exports2.registerMixins = exports2.getMixinsForClass = void 0;
    var util_1 = require_util();
    var mixins = /* @__PURE__ */ new WeakMap();
    var getMixinsForClass = (clazz) => mixins.get(clazz);
    exports2.getMixinsForClass = getMixinsForClass;
    var registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
    exports2.registerMixins = registerMixins;
    var hasMixin = (instance, mixin) => {
      if (instance instanceof mixin)
        return true;
      const constructor = instance.constructor;
      const visited = /* @__PURE__ */ new Set();
      let frontier = /* @__PURE__ */ new Set();
      frontier.add(constructor);
      while (frontier.size > 0) {
        if (frontier.has(mixin))
          return true;
        frontier.forEach((item) => visited.add(item));
        const newFrontier = /* @__PURE__ */ new Set();
        frontier.forEach((item) => {
          var _a;
          const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : (0, util_1.protoChain)(item.prototype).map((proto2) => proto2.constructor).filter((item2) => item2 !== null);
          if (itemConstituents)
            itemConstituents.forEach((constituent) => {
              if (!visited.has(constituent) && !frontier.has(constituent))
                newFrontier.add(constituent);
            });
        });
        frontier = newFrontier;
      }
      return false;
    };
    exports2.hasMixin = hasMixin;
  }
});

// ../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/decorator.js
var require_decorator = __commonJS({
  "../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decorate = exports2.getDecoratorsForClass = exports2.directDecoratorSearch = exports2.deepDecoratorSearch = void 0;
    var util_1 = require_util();
    var mixin_tracking_1 = require_mixin_tracking();
    var mergeObjectsOfDecorators = (o1, o2) => {
      var _a, _b;
      const allKeys = (0, util_1.unique)([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
      const mergedObject = {};
      for (let key of allKeys)
        mergedObject[key] = (0, util_1.unique)([...(_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : [], ...(_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : []]);
      return mergedObject;
    };
    var mergePropertyAndMethodDecorators = (d1, d2) => {
      var _a, _b, _c, _d;
      return {
        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})
      };
    };
    var mergeDecorators = (d1, d2) => {
      var _a, _b, _c, _d, _e, _f;
      return {
        class: (0, util_1.unique)([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),
        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})
      };
    };
    var decorators = /* @__PURE__ */ new Map();
    var findAllConstituentClasses = (...classes) => {
      var _a;
      const allClasses = /* @__PURE__ */ new Set();
      const frontier = /* @__PURE__ */ new Set([...classes]);
      while (frontier.size > 0) {
        for (let clazz of frontier) {
          const protoChainClasses = (0, util_1.protoChain)(clazz.prototype).map((proto2) => proto2.constructor);
          const mixinClasses = (_a = (0, mixin_tracking_1.getMixinsForClass)(clazz)) !== null && _a !== void 0 ? _a : [];
          const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
          const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
          for (let newClass of newClasses)
            frontier.add(newClass);
          allClasses.add(clazz);
          frontier.delete(clazz);
        }
      }
      return [...allClasses];
    };
    var deepDecoratorSearch = (...classes) => {
      const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
      if (decoratorsForClassChain.length == 0)
        return {};
      if (decoratorsForClassChain.length == 1)
        return decoratorsForClassChain[0];
      return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    exports2.deepDecoratorSearch = deepDecoratorSearch;
    var directDecoratorSearch = (...classes) => {
      const classDecorators = classes.map((clazz) => (0, exports2.getDecoratorsForClass)(clazz));
      if (classDecorators.length === 0)
        return {};
      if (classDecorators.length === 1)
        return classDecorators[0];
      return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    exports2.directDecoratorSearch = directDecoratorSearch;
    var getDecoratorsForClass = (clazz) => {
      let decoratorsForClass = decorators.get(clazz);
      if (!decoratorsForClass) {
        decoratorsForClass = {};
        decorators.set(clazz, decoratorsForClass);
      }
      return decoratorsForClass;
    };
    exports2.getDecoratorsForClass = getDecoratorsForClass;
    var decorateClass = (decorator) => (clazz) => {
      const decoratorsForClass = (0, exports2.getDecoratorsForClass)(clazz);
      let classDecorators = decoratorsForClass.class;
      if (!classDecorators) {
        classDecorators = [];
        decoratorsForClass.class = classDecorators;
      }
      classDecorators.push(decorator);
      return decorator(clazz);
    };
    var decorateMember = (decorator) => (object, key, ...otherArgs) => {
      var _a, _b, _c;
      const decoratorTargetType = typeof object === "function" ? "static" : "instance";
      const decoratorType = typeof object[key] === "function" ? "method" : "property";
      const clazz = decoratorTargetType === "static" ? object : object.constructor;
      const decoratorsForClass = (0, exports2.getDecoratorsForClass)(clazz);
      const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};
      decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
      let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};
      decoratorsForTargetType[decoratorType] = decoratorsForType;
      let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];
      decoratorsForType[key] = decoratorsForKey;
      decoratorsForKey.push(decorator);
      return decorator(object, key, ...otherArgs);
    };
    var decorate = (decorator) => (...args) => {
      if (args.length === 1)
        return decorateClass(decorator)(args[0]);
      return decorateMember(decorator)(...args);
    };
    exports2.decorate = decorate;
  }
});

// ../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/mixins.js
var require_mixins = __commonJS({
  "../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/mixins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mix = exports2.Mixin = void 0;
    var proxy_1 = require_proxy();
    var settings_1 = require_settings();
    var util_1 = require_util();
    var decorator_1 = require_decorator();
    var mixin_tracking_1 = require_mixin_tracking();
    function Mixin(...constructors) {
      var _a, _b, _c;
      const prototypes = constructors.map((constructor) => constructor.prototype);
      const initFunctionName = settings_1.settings.initFunction;
      if (initFunctionName !== null) {
        const initFunctions = prototypes.map((proto2) => proto2[initFunctionName]).filter((func) => typeof func === "function");
        const combinedInitFunction = function(...args) {
          for (let initFunction of initFunctions)
            initFunction.apply(this, args);
        };
        const extraProto = { [initFunctionName]: combinedInitFunction };
        prototypes.push(extraProto);
      }
      function MixedClass(...args) {
        for (const constructor of constructors)
          (0, util_1.copyProps)(this, new constructor(...args));
        if (initFunctionName !== null && typeof this[initFunctionName] === "function")
          this[initFunctionName].apply(this, args);
      }
      MixedClass.prototype = settings_1.settings.prototypeStrategy === "copy" ? (0, util_1.hardMixProtos)(prototypes, MixedClass) : (0, proxy_1.softMixProtos)(prototypes, MixedClass);
      Object.setPrototypeOf(MixedClass, settings_1.settings.staticsStrategy === "copy" ? (0, util_1.hardMixProtos)(constructors, null, ["prototype"]) : (0, proxy_1.proxyMix)(constructors, Function.prototype));
      let DecoratedMixedClass = MixedClass;
      if (settings_1.settings.decoratorInheritance !== "none") {
        const classDecorators = settings_1.settings.decoratorInheritance === "deep" ? (0, decorator_1.deepDecoratorSearch)(...constructors) : (0, decorator_1.directDecoratorSearch)(...constructors);
        for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {
          const result = decorator(DecoratedMixedClass);
          if (result) {
            DecoratedMixedClass = result;
          }
        }
        applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
        applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
      }
      (0, mixin_tracking_1.registerMixins)(DecoratedMixedClass, constructors);
      return DecoratedMixedClass;
    }
    exports2.Mixin = Mixin;
    var applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
      const propDecorators = propAndMethodDecorators.property;
      const methodDecorators = propAndMethodDecorators.method;
      if (propDecorators)
        for (let key in propDecorators)
          for (let decorator of propDecorators[key])
            decorator(target, key);
      if (methodDecorators)
        for (let key in methodDecorators)
          for (let decorator of methodDecorators[key])
            decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
    };
    var mix = (...ingredients) => (decoratedClass) => {
      const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
      Object.defineProperty(mixedClass, "name", {
        value: decoratedClass.name,
        writable: false
      });
      return mixedClass;
    };
    exports2.mix = mix;
  }
});

// ../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/index.js
var require_cjs = __commonJS({
  "../../node_modules/.pnpm/ts-mixer@6.0.4/node_modules/ts-mixer/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasMixin = exports2.decorate = exports2.settings = exports2.mix = exports2.Mixin = void 0;
    var mixins_1 = require_mixins();
    Object.defineProperty(exports2, "Mixin", { enumerable: true, get: function() {
      return mixins_1.Mixin;
    } });
    Object.defineProperty(exports2, "mix", { enumerable: true, get: function() {
      return mixins_1.mix;
    } });
    var settings_1 = require_settings();
    Object.defineProperty(exports2, "settings", { enumerable: true, get: function() {
      return settings_1.settings;
    } });
    var decorator_1 = require_decorator();
    Object.defineProperty(exports2, "decorate", { enumerable: true, get: function() {
      return decorator_1.decorate;
    } });
    var mixin_tracking_1 = require_mixin_tracking();
    Object.defineProperty(exports2, "hasMixin", { enumerable: true, get: function() {
      return mixin_tracking_1.hasMixin;
    } });
  }
});

// ../syside-languageserver/lib/model/metamodel.js
var require_metamodel = __commonJS({
  "../syside-languageserver/lib/model/metamodel.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.basicIdProvider = exports2.BasicMetamodel = exports2.isMetamodel = exports2.metamodelOf = exports2.IMPLICIT_MAP = exports2.META_FACTORY = exports2.mix = void 0;
    var types_1 = require_types2();
    var ast_1 = require_ast2();
    var mixer = __importStar(require_cjs());
    function mix(...types) {
      return mixer.mix(...types);
    }
    exports2.mix = mix;
    exports2.META_FACTORY = {};
    exports2.IMPLICIT_MAP = {};
    function metamodelOf(type, generalizations = {}) {
      const collect = (target) => {
        target.prototype.nodeType = function() {
          return type;
        };
        const supertypes = new Set(types_1.typeIndex.getInheritanceChain(type));
        supertypes.add(type);
        target.prototype.is = supertypes.size > 1 ? function(t) {
          return supertypes.has(t);
        } : function(t) {
          return type === t;
        };
      };
      if (generalizations === "abstract") {
        return collect;
      }
      exports2.IMPLICIT_MAP[type] = Object.entries(generalizations);
      return function(target) {
        collect(target);
        exports2.META_FACTORY[type] = //
        (provider, document) => target.create(provider, document);
        target.prototype.implicitGeneralizations = function() {
          return generalizations;
        };
      };
    }
    exports2.metamodelOf = metamodelOf;
    function isMetamodel(o) {
      return typeof o === "object" && o !== null && typeof o["elementId"] === "number" && typeof o["document"] === "object" && typeof o["isStandardElement"] === "boolean";
    }
    exports2.isMetamodel = isMetamodel;
    var BasicMetamodel = class {
      constructor(id, document) {
        this.setupState = "none";
        this.isStandardElement = false;
        this.notes = [];
        this.elementId = id;
        this._document = document;
      }
      get document() {
        return this._document;
      }
      set document(value) {
        this._document = value;
      }
      swapOwnership(current, value) {
        if (current)
          current.setParent(void 0);
        if (value)
          this.takeOwnership(value);
        return value;
      }
      takeOwnership(element) {
        element.setParent(this);
      }
      unsetOwnership(element) {
        element.setParent(void 0);
      }
      /**
       * @param previous if set, a tuple of previous `[parent, owner]`
       * @param current if set, a tuple of current `[parent, owner]`
       */
      onOwnerSet(previous, current) {
      }
      setParent(parent) {
        const previous = this._parent;
        this._parent = parent;
        if (previous !== parent)
          this.onParentSet(previous, parent);
        this.setOwner((parent === null || parent === void 0 ? void 0 : parent.is(ast_1.NonOwnerType)) ? parent.parent() : parent, previous);
      }
      setOwner(owner, previousParent) {
        const previousOwner = this._owner;
        this._owner = owner;
        if (previousOwner !== owner)
          this.onOwnerSet(previousOwner ? [
            previousParent !== null && previousParent !== void 0 ? previousParent : this._parent,
            previousOwner
          ] : void 0, owner ? [this._parent, owner] : void 0);
      }
      onParentSet(previous, current) {
      }
      cst() {
        var _a;
        return (_a = this._ast) === null || _a === void 0 ? void 0 : _a.$cstNode;
      }
      ast() {
        return this._ast;
      }
      parent() {
        return this._parent;
      }
      owner() {
        return this._owner;
      }
      nodeType() {
        var _a, _b;
        return (_b = (_a = this._ast) === null || _a === void 0 ? void 0 : _a.$type) !== null && _b !== void 0 ? _b : "Unknown";
      }
      implicitGeneralizations() {
        return {};
      }
      defaultGeneralTypes() {
        return [this.defaultSupertype()];
      }
      defaultSupertype() {
        return "base";
      }
      specializationKind() {
        return ast_1.Specialization;
      }
      is(type) {
        return types_1.typeIndex.isSubtype(this.nodeType(), type);
      }
      isAny(...type) {
        return type.some((t) => this.is(t));
      }
      static is(type) {
        return (value) => Boolean(value === null || value === void 0 ? void 0 : value.is(type));
      }
      static isAny(...type) {
        return (value) => Boolean(value === null || value === void 0 ? void 0 : value.isAny(...type));
      }
      /**
       * Construct a new model element
       * @param id
       * @returns
       */
      static create(provider, document, options) {
        const model = new this(provider(), document);
        if (options === null || options === void 0 ? void 0 : options.parent)
          model.setParent(options.parent);
        return model;
      }
    };
    exports2.BasicMetamodel = BasicMetamodel;
    function basicIdProvider() {
      let count = 0;
      return () => count++;
    }
    exports2.basicIdProvider = basicIdProvider;
  }
});

// ../syside-languageserver/lib/model/naming.js
var require_naming = __commonJS({
  "../syside-languageserver/lib/model/naming.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Name = exports2.computeQualifiedName = exports2.getName = exports2.concatNames = exports2.unsanitizeName = exports2.sanitizeName = void 0;
    var ast_1 = require_ast2();
    function sanitizeName(name) {
      if (!name || name.length === 0)
        return;
      if (!name.startsWith("'"))
        return name;
      return name.slice(1, name.length - 1).replaceAll(/\\([btnfr"'\\])/g, (substr, match) => {
        switch (match) {
          case "b":
            return "\b";
          case "t":
            return "	";
          case "n":
            return "\n";
          case "f":
            return "\f";
          case "r":
            return "\r";
          case "'":
            return "'";
          case '"':
            return '"';
          case "\\":
            return "\\";
        }
        return match;
      });
    }
    exports2.sanitizeName = sanitizeName;
    var SimpleNameRegex = /^[_a-zA-Z][\w_\d]*$/;
    function unsanitizeName(name) {
      return SimpleNameRegex.test(name) ? name : `'${name.replaceAll(/([\b\t\n\f\r'\\])/g, (_, match) => {
        switch (match) {
          case "\b":
            return "\\b";
          case "	":
            return "\\t";
          case "\n":
            return "\\n";
          case "\f":
            return "\\f";
          case "\r":
            return "\\r";
          case "'":
            return "\\'";
          case "\\":
            return "\\\\";
        }
        return match;
      })}'`;
    }
    exports2.unsanitizeName = unsanitizeName;
    function concatNames(left, right) {
      return left + "::" + right;
    }
    exports2.concatNames = concatNames;
    function getName(meta) {
      var _a, _b;
      return (_b = (_a = meta.rawName) !== null && _a !== void 0 ? _a : meta.rawShortName) !== null && _b !== void 0 ? _b : meta.elementId.toString();
    }
    exports2.getName = getName;
    function computeQualifiedName(meta, parent) {
      var _a;
      let name = getName(meta);
      let parentName = "";
      while (parent === null || parent === void 0 ? void 0 : parent.owner()) {
        if (!parent.is(ast_1.TransparentElement)) {
          if (parent.is(ast_1.Element)) {
            return concatNames(parent.qualifiedName, name);
          } else {
            parentName = (_a = parent.elementId.toString()) !== null && _a !== void 0 ? _a : "<unnamed>";
          }
          name = concatNames(parentName, name);
        }
        parent = parent.owner();
      }
      return name;
    }
    exports2.computeQualifiedName = computeQualifiedName;
    var Name = class {
      constructor(name) {
        this.set(name);
      }
      /**
       * Name as was parsed/provided
       */
      get declared() {
        return this._declared;
      }
      /**
       * Name to be used in reference resolution
       */
      get sanitized() {
        return this._name;
      }
      /**
       * Set new name
       */
      set(name) {
        this._declared = name;
        this._name = sanitizeName(name);
      }
    };
    exports2.Name = Name;
  }
});

// ../syside-languageserver/lib/model/containers.js
var require_containers2 = __commonJS({
  "../syside-languageserver/lib/model/containers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeIfObserved = exports2.removeObserved = exports2.ElementContainer = void 0;
    var metamodel_1 = require_metamodel();
    var ElementContainer = class {
      constructor(...items) {
        this.elements = [];
        this.caches = /* @__PURE__ */ new Map();
        this.elements = items;
      }
      toJSON() {
        return this.all;
      }
      [Symbol.iterator]() {
        return this.elements.values()[Symbol.iterator]();
      }
      invalidateCaches() {
        this.caches.clear();
      }
      /**
       * Clear all elements and caches
       */
      clear() {
        this.elements.length = 0;
        this.invalidateCaches();
      }
      /**
       * Add a new element
       * @param element
       */
      push(...element) {
        this.invalidateCaches();
        return this.elements.push(...element);
      }
      remove(value) {
        return removeObserved(this.elements, () => this.invalidateCaches(), value);
      }
      removeIf(predicate) {
        if (this.elements.length !== this.elements.removeIf(predicate))
          this.invalidateCaches();
        return this.elements.length;
      }
      get length() {
        return this.elements.length;
      }
      get(kindOrFilter) {
        const all = this.all;
        if (!kindOrFilter) {
          return all;
        }
        let filtered = this.caches.get(kindOrFilter);
        if (filtered)
          return filtered;
        filtered = all.filter(typeof kindOrFilter === "string" ? metamodel_1.BasicMetamodel.is(kindOrFilter) : kindOrFilter);
        this.caches.set(kindOrFilter, filtered);
        return filtered;
      }
      get all() {
        return this.elements;
      }
    };
    exports2.ElementContainer = ElementContainer;
    Array.prototype.removeIf = function(predicate) {
      const total = this.length;
      let from = 0, to = 0;
      while (from < total) {
        const value = this[from];
        if (!predicate(value, from)) {
          this[to] = value;
          to++;
        }
        from++;
      }
      this.length = to;
      return this.length;
    };
    Array.prototype.remove = function(value) {
      const index = this.indexOf(value);
      if (index !== -1) {
        this.splice(index, 1);
        return true;
      }
      return false;
    };
    function removeObserved(array, observer, value) {
      if (array.remove(value)) {
        observer(value);
        return true;
      }
      return false;
    }
    exports2.removeObserved = removeObserved;
    function removeIfObserved(array, observer, predicate) {
      return array.removeIf((value, index) => {
        if (predicate(value, index)) {
          observer(value, index);
          return true;
        }
        return false;
      });
    }
    exports2.removeIfObserved = removeIfObserved;
  }
});

// ../syside-languageserver/lib/model/KerML/element.js
var require_element = __commonJS({
  "../syside-languageserver/lib/model/KerML/element.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var ElementMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ElementMeta = exports2.namedMembership = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var naming_1 = require_naming();
    var common_1 = require_common();
    var containers_1 = require_containers2();
    function namedMembership(member) {
      return member.is(ast_1.MembershipImport) ? member.element() : member;
    }
    exports2.namedMembership = namedMembership;
    var ElementMeta = exports2.ElementMeta = ElementMeta_1 = class ElementMeta extends metamodel_1.BasicMetamodel {
      constructor() {
        super(...arguments);
        this._comments = [];
        this._metadata = [];
        this._docs = [];
        this._reps = [];
        this._name = new naming_1.Name();
        this._shortName = new naming_1.Name();
        this._qualifiedName = "";
        this._memberLookup = /* @__PURE__ */ new Map();
        this._metaclass = "unset";
      }
      get isImpliedIncluded() {
        return this.setupState === "completed";
      }
      /**
       * Adds annotating element that annotates this element. An implementation
       * detail used for tracking explicit annotations. All elements added through
       * this should call {@link removeExplicitAnnotatingElement} to remove them.
       */
      addExplicitAnnotatingElement(element) {
        const registerCleanup = () => {
          if (element.document === this.document)
            return;
          const cleanup = () => this.removeExplicitAnnotatingElement(element, ElementMeta_1.CleanupToken);
          cleanup.owner = this;
          element.document.onInvalidated.add(element, cleanup);
        };
        switch (element.nodeType()) {
          case "Comment":
            this._comments.push(element);
            registerCleanup();
            break;
          case "Documentation":
            this._docs.push(element);
            registerCleanup();
            break;
          case "TextualRepresentation":
            this._reps.push(element);
            registerCleanup();
            break;
          case "MetadataFeature":
          case "MetadataUsage":
            this._metadata.push(element);
            registerCleanup();
            break;
        }
      }
      /**
       * Reverse of {@link addExplicitAnnotatingElement} that stops tracking the
       * annotating element. An implementation detail.
       * @param element
       * @param token a token to signal this called from cleanup function to avoid
       * unnecessary work
       */
      removeExplicitAnnotatingElement(element, token) {
        const unregister = () => {
          if (token === ElementMeta_1.CleanupToken)
            return;
          const registry = element.document.onInvalidated;
          const value = registry.get(element).find((cb) => cb.owner === this);
          if (value)
            registry.delete(element, value);
        };
        switch (element.nodeType()) {
          case "Comment":
            this._comments.remove(element);
            unregister();
            break;
          case "Documentation":
            this._docs.remove(element);
            unregister();
            break;
          case "TextualRepresentation":
            this._reps.remove(element);
            unregister();
            break;
          case "MetadataFeature":
          case "MetadataUsage":
            this._metadata.remove(element);
            unregister();
            break;
        }
      }
      /**
       * Comments about this element
       */
      get comments() {
        return this._comments;
      }
      /**
       * Documentation about this element
       */
      get documentation() {
        return this._docs;
      }
      /**
       * Metadata about this element
       */
      get metadata() {
        return (0, langium_1.stream)(this._metadata);
      }
      /**
       * Textual representations about this element
       */
      get textualRepresentation() {
        return this._reps;
      }
      /**
       * Name to be used in reference resolution
       */
      get name() {
        return this._name.sanitized;
      }
      /**
       * Name as parsed
       */
      get rawName() {
        return this._name.declared;
      }
      /**
       * Name as it appeared in the source file
       */
      get declaredName() {
        return this._declaredName;
      }
      set declaredName(value) {
        if (value === this._declaredName)
          return;
        this._declaredName = value;
        this.setName(value);
      }
      /**
       * @param name new name
       */
      setName(name) {
        const old = this.name;
        this.updateName(this._name, name);
        const parent = this.parent();
        if ((parent === null || parent === void 0 ? void 0 : parent.is(ast_1.Membership)) && parent.name === old && parent.shortName === this.shortName)
          parent.updateName(parent._name, name);
      }
      /**
       * Alternative name to be used in reference resolution
       * @see {@link name}
       */
      get shortName() {
        return this._shortName.sanitized;
      }
      /**
       * Short name as parsed
       */
      get rawShortName() {
        return this._shortName.declared;
      }
      /**
       * Name as it appeared in the source file
       */
      get declaredShortName() {
        return this._declaredShortName;
      }
      set declaredShortName(value) {
        if (value === this._declaredShortName)
          return;
        this._declaredShortName = value;
        this.setShortName(value);
      }
      /**
       * @param name new short name
       */
      setShortName(name) {
        const old = this.shortName;
        this.updateName(this._shortName, name);
        const parent = this.parent();
        if ((parent === null || parent === void 0 ? void 0 : parent.is(ast_1.Membership)) && parent.shortName === old && parent.name === this.name)
          parent.updateName(parent._shortName, name);
      }
      /**
       * Fully qualified name based on preferably name
       */
      get qualifiedName() {
        return this._qualifiedName;
      }
      /**
       * Cached descriptions for this element based on names only
       */
      get description() {
        return this._description;
      }
      findMember(name) {
        return this._memberLookup.get(name);
      }
      hasMember(name) {
        return this._memberLookup.has(name);
      }
      get namedMembers() {
        return this._memberLookup.entries();
      }
      get reservedNames() {
        return this._memberLookup.keys();
      }
      /**
       * Library metaclass of this element
       */
      get metaclass() {
        if (!this._metaclass || this._metaclass === "unset")
          return;
        if (typeof this._metaclass === "function")
          return this._metaclass = this._metaclass();
        return this._metaclass;
      }
      setMetaclass(meta) {
        this._metaclass = meta;
        return this;
      }
      /**
       * @returns Implicit generalization identifier
       */
      defaultSupertype() {
        return "base";
      }
      ast() {
        return this._ast;
      }
      parent() {
        return this._parent;
      }
      owner() {
        return this._owner;
      }
      /**
       * @returns stream of all owned and inherited metadata features
       */
      allMetadata() {
        return this.metadata;
      }
      onOwnerSet(previous, current) {
        const oldParent = previous === null || previous === void 0 ? void 0 : previous[0];
        if (oldParent === null || oldParent === void 0 ? void 0 : oldParent.is(ast_1.Membership)) {
          const oldOwner = previous === null || previous === void 0 ? void 0 : previous[1];
          if (oldParent.name)
            oldOwner.removeLookupMemberByName(oldParent, oldParent.name);
          if (oldParent.shortName)
            oldOwner.removeLookupMemberByName(oldParent, oldParent.shortName);
        }
        const currentParent = current === null || current === void 0 ? void 0 : current[0];
        const currentOwner = current === null || current === void 0 ? void 0 : current[1];
        if (currentParent === null || currentParent === void 0 ? void 0 : currentParent.is(ast_1.Membership))
          currentOwner === null || currentOwner === void 0 ? void 0 : currentOwner.addLookupMember(currentParent);
      }
      /**
       * Add a {@link child} to this element scope
       */
      addLookupMember(child) {
        if (child.name)
          this._memberLookup.set(child.name, child);
        if (child.shortName)
          this._memberLookup.set(child.shortName, child);
      }
      removeLookupMemberByName(member, name) {
        if (!member)
          return;
        const cached = this._memberLookup.get(name);
        const isCached = cached === member || cached === "shadow";
        if (cached && isCached)
          this._memberLookup.delete(name);
      }
      /**
       * @param name name to update
       * @param exported description corresponding to {@link name} (either full or short name)
       * @param value new name
       */
      updateName(name, value) {
        const owner = this.owner();
        const previousName = name.sanitized;
        name.set(value);
        if (previousName === name.sanitized)
          return;
        if (previousName && owner) {
          owner.removeLookupMemberByName(this.parent(), previousName);
        }
        this._qualifiedName = (0, naming_1.computeQualifiedName)(this, owner);
        if (name.sanitized && name.sanitized.length > 0) {
          const membership = this.parent();
          if (owner && !owner._memberLookup.has(name.sanitized) && (membership === null || membership === void 0 ? void 0 : membership.is(ast_1.Membership))) {
            owner._memberLookup.set(name.sanitized, membership);
          }
        }
      }
      /**
       * Parts of this elements in the order they appear in textual notation
       */
      parts() {
        return Object.fromEntries(this.collectParts());
      }
      ownedElements() {
        return (0, langium_1.stream)(this.collectParts()).map(([_, elements]) => elements).flat();
      }
      /**
       * Invalidate cached members to make sure they are up-to date
       */
      invalidateMemberCaches() {
      }
      swapEdgeOwnership(current, edge) {
        if (edge) {
          edge[0]["setElement"](void 0);
          this.swapOwnership(current, edge[0]);
          edge[0]["setElement"](edge[1]);
          return edge[0];
        }
        return this.swapOwnership(current, void 0);
      }
      addOwnedEdges(container, edges, callback) {
        return container.push(...edges.map(([edge, target]) => {
          this.takeOwnership(edge);
          edge["setElement"](target);
          callback === null || callback === void 0 ? void 0 : callback([edge, target]);
          return edge;
        }));
      }
      addOwnedElements(container, children, callback) {
        children.forEach((c) => {
          this.takeOwnership(c);
          callback === null || callback === void 0 ? void 0 : callback(c);
        });
        return container.push(...children);
      }
      removeOwnedElements(container, children, callback) {
        children.forEach((c) => {
          if (container.remove(c)) {
            callback === null || callback === void 0 ? void 0 : callback(c);
            this.unsetOwnership(c);
          }
        });
        return container.length;
      }
      removeOwnedElementsIf(container, predicate, callback) {
        (0, containers_1.removeIfObserved)(container, (v) => {
          callback === null || callback === void 0 ? void 0 : callback(v);
          this.unsetOwnership(v);
        }, predicate);
        return container.length;
      }
      static applyElementOptions(model, options) {
        if (options === null || options === void 0 ? void 0 : options.declaredName)
          model.declaredName = options.declaredName;
        if (options === null || options === void 0 ? void 0 : options.declaredShortName)
          model.declaredShortName = options.declaredShortName;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          ElementMeta_1.applyElementOptions(model, options);
        return model;
      }
    };
    ElementMeta.CleanupToken = {};
    __decorate([
      common_1.enumerable
    ], ElementMeta.prototype, "name", null);
    __decorate([
      common_1.enumerable
    ], ElementMeta.prototype, "declaredName", null);
    __decorate([
      common_1.enumerable
    ], ElementMeta.prototype, "shortName", null);
    __decorate([
      common_1.enumerable
    ], ElementMeta.prototype, "declaredShortName", null);
    __decorate([
      common_1.enumerable
    ], ElementMeta.prototype, "qualifiedName", null);
    exports2.ElementMeta = ElementMeta = ElementMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Element, "abstract")
    ], ElementMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/annotating-element.js
var require_annotating_element = __commonJS({
  "../syside-languageserver/lib/model/KerML/annotating-element.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var AnnotatingElementMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnnotatingElementMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var element_1 = require_element();
    var AnnotatingElementMeta = exports2.AnnotatingElementMeta = AnnotatingElementMeta_1 = class AnnotatingElementMeta extends element_1.ElementMeta {
      constructor() {
        super(...arguments);
        this._annotations = [];
      }
      get unlinkAnnotation() {
        return (a) => {
          const target = a.element();
          if (!a.isImplied && target)
            target["removeExplicitAnnotatingElement"](this);
        };
      }
      /**
       * Adds owned annotations and returns the new number of annotations.
       * Annotations don't own of their targets.
       */
      addAnnotation(...annotation) {
        return this.addOwnedEdges(this._annotations, annotation, ([a, target]) => {
          if (!a.isImplied)
            target["addExplicitAnnotatingElement"](this);
        });
      }
      /**
       * Removes and unlinks annotations by value and returns the new number of annotations.
       */
      removeAnnotation(...annotation) {
        return this.removeOwnedElements(this._annotations, annotation, this.unlinkAnnotation);
      }
      /**
       * Removes and unlinks annotations by predicate and returns the new number of annotations.
       */
      removeAnnotationIf(predicate) {
        return this.removeOwnedElementsIf(this._annotations, predicate, this.unlinkAnnotation);
      }
      annotations() {
        return this._annotations;
      }
      annotatedElements() {
        const annotations = this.annotations();
        const owner = this.owner();
        if (annotations.length === 0 && owner)
          return [owner];
        return annotations.map((a) => a.element()).filter(utils_1.NonNullable);
      }
      ast() {
        return this._ast;
      }
      collectParts() {
        return [["about", this._annotations]];
      }
      static applyAnnotatingElementOptions(model, options) {
        if (options.annotations)
          model.addAnnotation(...options.annotations);
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          AnnotatingElementMeta_1.applyAnnotatingElementOptions(model, options);
        return model;
      }
    };
    exports2.AnnotatingElementMeta = AnnotatingElementMeta = AnnotatingElementMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.AnnotatingElement, "abstract")
    ], AnnotatingElementMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/references/element-reference.js
var require_element_reference = __commonJS({
  "../syside-languageserver/lib/model/KerML/references/element-reference.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ElementReferenceMeta = void 0;
    var ast_1 = require_ast2();
    var containers_1 = require_containers();
    var metamodel_1 = require_metamodel();
    var ElementReferenceMeta = exports2.ElementReferenceMeta = class ElementReferenceMeta extends metamodel_1.BasicMetamodel {
      constructor() {
        super(...arguments);
        this.to = new containers_1.Target();
        this.found = [];
        this.text = "";
      }
      owner() {
        return this._owner;
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.ElementReferenceMeta = ElementReferenceMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ElementReference)
    ], ElementReferenceMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationship.js
var require_relationship = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationship.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RelationshipMeta = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var containers_1 = require_containers2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var RelationshipMeta = exports2.RelationshipMeta = class RelationshipMeta extends _internal_1.ElementMeta {
      constructor() {
        super(...arguments);
        this._children = new containers_1.ElementContainer();
        this._isImplied = false;
      }
      get comments() {
        return this._children.get(ast_1.Comment).concat(this._comments);
      }
      get documentation() {
        return this._children.get(ast_1.Documentation).concat(this._docs);
      }
      get metadata() {
        return (0, langium_1.stream)(this._children.get(ast_1.MetadataFeature)).concat(this._metadata);
      }
      get textualRepresentation() {
        return this._children.get(ast_1.TextualRepresentation).concat(this._reps);
      }
      onParentSet(previous, current) {
        if (!this._source || this._source === previous)
          this._source = current;
        super.onParentSet(previous, current);
      }
      get isImplied() {
        return this._isImplied;
      }
      get children() {
        return this._children.all;
      }
      source() {
        return this._source;
      }
      setSource(s) {
        this._source = s;
      }
      /**
       * Visibility of the element at the end of this relationship
       * @see {@link element}
       */
      get visibility() {
        var _a;
        return (_a = this._visibility) !== null && _a !== void 0 ? _a : 0;
      }
      set visibility(value) {
        this._visibility = value;
      }
      clearVisibility() {
        this._visibility = void 0;
        return this;
      }
      get hasExplicitVisibility() {
        return this._visibility !== void 0;
      }
      /**
       * The element at the end of this relationship, check for ownership by `element().owner()`
       * @see {@link setElement}
       */
      element() {
        return this._element;
      }
      /**
       * @see {@link element}
       */
      setElement(e) {
        if (this._element === e)
          return;
        const previous = this._element;
        this._element = e;
        this.onTargetSet(previous, e);
      }
      // eslint-disable-next-line unused-imports/no-unused-vars
      onTargetSet(previous, current) {
      }
      ast() {
        return this._ast;
      }
      /**
       * @returns final target of this relationship after following any existing
       * chaining features
       */
      finalElement() {
        var _a;
        const target = this.element();
        return (target === null || target === void 0 ? void 0 : target.is(ast_1.Feature)) && target.chainings.length > 0 ? (_a = target.chainings.at(-1)) === null || _a === void 0 ? void 0 : _a.element() : target;
      }
      collectParts() {
        var _a;
        const parts = [];
        if (((_a = this.source()) === null || _a === void 0 ? void 0 : _a.parent()) === this) {
          parts.push(["source", [this.source()]]);
        }
        const target = this.element();
        if ((target === null || target === void 0 ? void 0 : target.parent()) === this) {
          parts.push(["target", [target]]);
        }
        parts.push(["children", this.children]);
        return parts;
      }
      static create(provider, document, options) {
        const self2 = super.create(provider, document, options);
        if (options) {
          self2._visibility = options.visibility;
          self2._isImplied = Boolean(options.isImplied);
          if (options.source)
            self2._source = options.source;
          self2.setElement(options.target);
        }
        return self2;
      }
    };
    __decorate([
      utils_1.enumerable
    ], RelationshipMeta.prototype, "isImplied", null);
    __decorate([
      utils_1.enumerable
    ], RelationshipMeta.prototype, "children", null);
    __decorate([
      utils_1.enumerable
    ], RelationshipMeta.prototype, "visibility", null);
    __decorate([
      utils_1.enumerable
    ], RelationshipMeta.prototype, "hasExplicitVisibility", null);
    exports2.RelationshipMeta = RelationshipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Relationship, "abstract")
    ], RelationshipMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/membership.js
var require_membership = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MembershipMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var MembershipMeta = exports2.MembershipMeta = class MembershipMeta extends _internal_1.RelationshipMeta {
      constructor() {
        super(...arguments);
        this.isAlias = false;
      }
      ast() {
        return this._ast;
      }
      get name() {
        var _a;
        return this.isAlias ? super.name : (_a = this.element()) === null || _a === void 0 ? void 0 : _a.name;
      }
      get shortName() {
        var _a;
        return this.isAlias ? super.shortName : (_a = this.element()) === null || _a === void 0 ? void 0 : _a.shortName;
      }
      /**
       * Adds new owned body elements and returns the new number of body elements.
       */
      addChild(...element) {
        return this.addOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements and returns the new number of body elements.
       */
      removeChild(...element) {
        return this.removeOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements by predicate and returns the new number of
       * body elements.
       */
      removeChildIf(predicate) {
        return this.removeOwnedElementsIf(this._children, predicate);
      }
      static create(provider, document, options) {
        const member = super.create(provider, document, options);
        if (options) {
          member.isAlias = Boolean(options.isAlias);
          _internal_1.ElementMeta.applyElementOptions(member, options);
        }
        return member;
      }
    };
    exports2.MembershipMeta = MembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Membership)
      // @ts-expect-error ignoring static inheritance error
    ], MembershipMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/annotation.js
var require_annotation = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/annotation.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnnotationMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var AnnotationMeta = exports2.AnnotationMeta = class AnnotationMeta extends _internal_1.RelationshipMeta {
      ast() {
        return this._ast;
      }
      onParentSet(previous, current) {
        if (previous) {
          if (previous === this._source)
            this._source = void 0;
          else
            this._element = void 0;
        }
        if (current === null || current === void 0 ? void 0 : current.is(ast_1.AnnotatingElement))
          this._source = current;
        else
          this._element = current;
      }
      static create(provider, document, options) {
        const self2 = _internal_1.ElementMeta.create.call(this, provider, document, options);
        if (options) {
          self2._visibility = options.visibility;
          self2._isImplied = Boolean(options.isImplied);
          if (options.source)
            self2._source = options.source;
          if (options.target)
            self2.setElement(options.target);
        }
        return self2;
      }
    };
    exports2.AnnotationMeta = AnnotationMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Annotation)
    ], AnnotationMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/textual-annotating-element.js
var require_textual_annotating_element = __commonJS({
  "../syside-languageserver/lib/model/KerML/textual-annotating-element.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextualAnnotatingMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var TextualAnnotatingMeta = exports2.TextualAnnotatingMeta = class TextualAnnotatingMeta extends _internal_1.AnnotatingElementMeta {
      constructor() {
        super(...arguments);
        this.body = "";
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          model.body = options.body;
        return model;
      }
    };
    exports2.TextualAnnotatingMeta = TextualAnnotatingMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.TextualAnnotatingElement, "abstract")
    ], TextualAnnotatingMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/comment.js
var require_comment = __commonJS({
  "../syside-languageserver/lib/model/KerML/comment.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommentMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var CommentMeta = exports2.CommentMeta = class CommentMeta extends _internal_1.TextualAnnotatingMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          model.locale = options.locale;
        return model;
      }
    };
    exports2.CommentMeta = CommentMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Comment)
    ], CommentMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/documentation.js
var require_documentation2 = __commonJS({
  "../syside-languageserver/lib/model/KerML/documentation.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentationMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var DocumentationMeta = exports2.DocumentationMeta = class DocumentationMeta extends _internal_1.CommentMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.DocumentationMeta = DocumentationMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Documentation)
    ], DocumentationMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/textual-representation.js
var require_textual_representation = __commonJS({
  "../syside-languageserver/lib/model/KerML/textual-representation.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextualRepresentationMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var TextualRepresentationMeta = exports2.TextualRepresentationMeta = class TextualRepresentationMeta extends _internal_1.TextualAnnotatingMeta {
      constructor() {
        super(...arguments);
        this.language = "plaintext";
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options === null || options === void 0 ? void 0 : options.language)
          model.language = options.language;
        return model;
      }
    };
    exports2.TextualRepresentationMeta = TextualRepresentationMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.TextualRepresentation)
    ], TextualRepresentationMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/namespace.js
var require_namespace = __commonJS({
  "../syside-languageserver/lib/model/KerML/namespace.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var NamespaceMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NamespaceMeta = exports2.namespaceChildren = exports2.EdgeContainer = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var containers_1 = require_containers2();
    var FeatureMembers = (e) => {
      var _a;
      return Boolean(
        // filters are feature members but not what we want, they serve a different purpose
        e.nodeType() !== ast_1.ElementFilterMembership && e.is(ast_1.Membership) && ((_a = e.element()) === null || _a === void 0 ? void 0 : _a.is(ast_1.Feature))
      );
    };
    var Filters = ast_1.ElementFilterMembership;
    var Imports = ast_1.Import;
    var makeMemberFilter = (type) => (e) => {
      var _a;
      return Boolean(e.is(ast_1.Membership) && ((_a = e.element()) === null || _a === void 0 ? void 0 : _a.is(type)));
    };
    var DocMembers = makeMemberFilter(ast_1.Documentation);
    var CommentMembers = makeMemberFilter(ast_1.Comment);
    var MetaMembers = makeMemberFilter(ast_1.MetadataFeature);
    var RepMembers = makeMemberFilter(ast_1.TextualRepresentation);
    var EdgeContainer = class {
      constructor(edges) {
        this.values = edges;
      }
      static make(...edges) {
        return new EdgeContainer(edges);
      }
    };
    exports2.EdgeContainer = EdgeContainer;
    function namespaceChildren(...children) {
      return EdgeContainer.make(...children);
    }
    exports2.namespaceChildren = namespaceChildren;
    var NamespaceMeta = exports2.NamespaceMeta = NamespaceMeta_1 = class NamespaceMeta extends _internal_1.ElementMeta {
      constructor() {
        super(...arguments);
        this._prefixes = [];
        this._children = new containers_1.ElementContainer();
        this._importResolutionState = "none";
      }
      get comments() {
        return this._children.get(CommentMembers).map((m) => m.element()).filter(utils_1.NonNullable).concat(this._comments);
      }
      get documentation() {
        return this._children.get(DocMembers).map((m) => m.element()).filter(utils_1.NonNullable).concat(this._docs);
      }
      get metadata() {
        return (0, langium_1.stream)(this._prefixes, this._children.get(MetaMembers)).map((m) => m.element()).filter(utils_1.NonNullable).concat(this._metadata);
      }
      get textualRepresentation() {
        return this._children.get(RepMembers).map((m) => m.element()).filter(utils_1.NonNullable).concat(this._reps);
      }
      get children() {
        return this._children.all;
      }
      /**
       * Adds owned members or imports and returns the new number of children.
       */
      addChild(...children) {
        return this.addOwnedEdges(this._children, children);
      }
      /**
       * Removes owned members or imports by value and returns the new number of
       * children.
       */
      removeChild(...children) {
        return this.removeOwnedElements(this._children, children);
      }
      /**
       * Removes owned members or imports by predicate and returns the new number of
       * children.
       */
      removeChildIf(predicate) {
        return this.removeOwnedElementsIf(this._children, predicate);
      }
      /**
       * Metadata prefixes of this elements
       */
      get prefixes() {
        return this._prefixes;
      }
      /**
       * Adds owned metadata prefixes and returns the new number of prefixes.
       */
      addPrefix(...children) {
        return this.addOwnedEdges(this._prefixes, children);
      }
      /**
       * Removes owned metadata prefixes by value and returns the new number of
       * prefixes.
       */
      removePrefix(...children) {
        return this.removeOwnedElements(this._prefixes, children);
      }
      /**
       * Removes owned metadata prefixes by predicate and returns the new number of
       * prefixes.
       */
      removePrefixIf(predicate) {
        return this.removeOwnedElementsIf(this._prefixes, predicate);
      }
      /**
       * Import statements
       */
      get imports() {
        return this._children.get(Imports);
      }
      get filters() {
        return this._children.get(Filters);
      }
      featureMembers() {
        return this._children.get(FeatureMembers);
      }
      /**
       * Imports resolution state
       */
      get importResolutionState() {
        return this._importResolutionState;
      }
      set importResolutionState(value) {
        this._importResolutionState = value;
      }
      ast() {
        return this._ast;
      }
      /**
       * @returns stream of all owned and inherited features
       */
      allFeatures() {
        return (0, langium_1.stream)(this.featureMembers());
      }
      featuresByMembership(kind) {
        return (0, langium_1.stream)(this.featureMembers()).filter(metamodel_1.BasicMetamodel.is(kind)).map((m) => m.element()).nonNullable();
      }
      featuresMatching(kind) {
        return (0, langium_1.stream)(this.featureMembers()).map((m) => m.element()).nonNullable().filter(metamodel_1.BasicMetamodel.is(kind));
      }
      collectParts() {
        return [
          ["prefixes", this.prefixes],
          ["children", this.children]
        ];
      }
      invalidateMemberCaches() {
        this._children.invalidateCaches();
      }
      static applyNamespaceOptions(model, options) {
        if (options.prefixes)
          model.addPrefix(...options.prefixes);
        if (options.children)
          model.addChild(...options.children["values"]);
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          NamespaceMeta_1.applyNamespaceOptions(model, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], NamespaceMeta.prototype, "children", null);
    __decorate([
      utils_1.enumerable
    ], NamespaceMeta.prototype, "prefixes", null);
    exports2.NamespaceMeta = NamespaceMeta = NamespaceMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Namespace)
    ], NamespaceMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/references/namespace-reference.js
var require_namespace_reference = __commonJS({
  "../syside-languageserver/lib/model/KerML/references/namespace-reference.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NamespaceReferenceMeta = void 0;
    var ast_1 = require_ast2();
    var containers_1 = require_containers();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var NamespaceReferenceMeta = exports2.NamespaceReferenceMeta = class NamespaceReferenceMeta extends _internal_1.ElementReferenceMeta {
      constructor() {
        super(...arguments);
        this.to = new containers_1.Target();
      }
      ast() {
        return this._ast;
      }
    };
    exports2.NamespaceReferenceMeta = NamespaceReferenceMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.NamespaceReference)
    ], NamespaceReferenceMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/package.js
var require_package = __commonJS({
  "../syside-languageserver/lib/model/KerML/package.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PackageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var PackageMeta = exports2.PackageMeta = class PackageMeta extends _internal_1.NamespaceMeta {
      ast() {
        return this._ast;
      }
      owner() {
        return this._owner;
      }
    };
    exports2.PackageMeta = PackageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Package)
    ], PackageMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/library-package.js
var require_library_package = __commonJS({
  "../syside-languageserver/lib/model/KerML/library-package.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LibraryPackageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var LibraryPackageMeta = exports2.LibraryPackageMeta = class LibraryPackageMeta extends _internal_1.PackageMeta {
      constructor() {
        super(...arguments);
        this.isStandard = false;
      }
      ast() {
        return this._ast;
      }
    };
    exports2.LibraryPackageMeta = LibraryPackageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.LibraryPackage)
    ], LibraryPackageMeta);
  }
});

// ../syside-languageserver/lib/model/enums.js
var require_enums = __commonJS({
  "../syside-languageserver/lib/model/enums.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTransitionFeatureKindText = exports2.getTransitionFeatureKind = exports2.getRequirementConstraintKind = exports2.getTypeClassifierString = exports2.conjugateDirectionKind = exports2.getFeatureDirectionKind = exports2.getVisibility = void 0;
    var langium_1 = require_lib2();
    var common_1 = require_common();
    function getVisibility(visibility) {
      switch (visibility) {
        case "protected":
          return 1;
        case "private":
          return 2;
        case "public":
          return 0;
        case void 0:
          return;
      }
    }
    exports2.getVisibility = getVisibility;
    function getFeatureDirectionKind(kind) {
      return kind !== null && kind !== void 0 ? kind : "none";
    }
    exports2.getFeatureDirectionKind = getFeatureDirectionKind;
    function conjugateDirectionKind(kind) {
      switch (kind) {
        case "in":
          return "out";
        case "out":
          return "in";
        case "inout":
          return "inout";
        case "none":
          return "none";
      }
    }
    exports2.conjugateDirectionKind = conjugateDirectionKind;
    var TypeClassifierNames = /* @__PURE__ */ new Map([
      [0, "None"],
      [1, "DataType"],
      [2, "Class"],
      [4, "Structure"],
      [8, "Association"],
      [12, "AssociationStruct"]
    ]);
    function getTypeClassifierString(v) {
      return (0, common_1.stringifyFlags)(v, TypeClassifierNames);
    }
    exports2.getTypeClassifierString = getTypeClassifierString;
    function getRequirementConstraintKind(node) {
      switch (node.kind) {
        case "assume":
          return "assumption";
        case "require":
        case void 0:
          return "requirement";
      }
    }
    exports2.getRequirementConstraintKind = getRequirementConstraintKind;
    function getTransitionFeatureKind(node) {
      switch (node.kind) {
        case "accept":
          return "trigger";
        case "do":
          return "effect";
        case "if":
          return "guard";
        default:
          (0, langium_1.assertUnreachable)(node.kind);
      }
    }
    exports2.getTransitionFeatureKind = getTransitionFeatureKind;
    function getTransitionFeatureKindText(kind) {
      switch (kind) {
        case "trigger":
          return "accept";
        case "effect":
          return "do";
        case "guard":
          return "if";
        default:
          (0, langium_1.assertUnreachable)(kind);
      }
    }
    exports2.getTransitionFeatureKindText = getTransitionFeatureKindText;
  }
});

// ../syside-languageserver/lib/model/mixins/positional-features.js
var require_positional_features = __commonJS({
  "../syside-languageserver/lib/model/mixins/positional-features.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PositionalFeaturesBase = void 0;
    var langium_1 = require_lib2();
    var PositionalFeaturesBase = class {
      constructor() {
        this._owned = void 0;
        this._all = void 0;
      }
      /**
       * @returns directly owned features
       */
      owned(self2, filter) {
        if (this._owned === void 0) {
          this._owned = (0, langium_1.stream)(self2.featureMembers()).filter(filter).map((m) => m.element()).nonNullable().toArray();
        }
        return this._owned;
      }
      /**
       * @returns directly owned and inherited features
       */
      all(self2, filter, typeFilter) {
        if (this._all === void 0) {
          this._all = self2.basePositionalFeatures(filter, typeFilter, true).map((m) => m.element()).nonNullable().toArray();
        }
        return this._all;
      }
      clearCaches() {
        this._owned = void 0;
        this._all = void 0;
      }
    };
    exports2.PositionalFeaturesBase = PositionalFeaturesBase;
  }
});

// ../syside-languageserver/lib/model/mixins/connector.js
var require_connector = __commonJS({
  "../syside-languageserver/lib/model/mixins/connector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectorMixin = void 0;
    var ast_1 = require_ast2();
    var positional_features_1 = require_positional_features();
    var Filter = (f) => {
      var _a;
      return Boolean(((_a = f.element()) === null || _a === void 0 ? void 0 : _a.isEnd) || f.is(ast_1.EndFeatureMembership));
    };
    var Types = (t) => t.is(ast_1.Association);
    var ConnectorMixin = class {
      constructor() {
        this.endsCache = new positional_features_1.PositionalFeaturesBase();
      }
      /**
       * @returns directly owned end features
       */
      ownedEnds() {
        return this.endsCache.owned(this, Filter);
      }
      /**
       * @returns directly owned and inherited end features
       */
      allEnds() {
        return this.endsCache.all(this, Filter, Types);
      }
      resetEnds() {
        this.endsCache.clearCaches();
      }
      /**
       * @returns Total number of ends including inherited ones
       */
      totalEnds() {
        return this.allEnds().length;
      }
      /**
       * Whether this Association/Connector is binary
       */
      isBinary() {
        return this.totalEnds() === 2;
      }
    };
    exports2.ConnectorMixin = ConnectorMixin;
  }
});

// ../syside-languageserver/lib/model/mixins/function.js
var require_function = __commonJS({
  "../syside-languageserver/lib/model/mixins/function.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FunctionMixin = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var FunctionMixin = class {
      /**
       * @returns owned or inherited result parameter if one exists, otherwise undefined
       */
      resultParameter() {
        if (!this._result) {
          return this.allTypes().filter(metamodel_1.BasicMetamodel.isAny(ast_1.SysMLFunction, ast_1.Expression)).map((e) => e._result).nonNullable().head();
        }
        return this._result;
      }
      returnParameter() {
        return this._children.get(ast_1.ReturnParameterMembership).at(0);
      }
      /**
       * Get the expected return type of a function or expression
       * @param self AST node that owns this metamodel
       * @returns the return type or its qualified name if one was inferred, undefined otherwise
       */
      getReturnType(self2) {
        var _a, _b;
        if (!self2)
          return;
        const result = self2.resultParameter();
        if (result) {
          return (_a = result.element()) === null || _a === void 0 ? void 0 : _a.returnType();
        }
        return (_b = self2.returnParameter()) === null || _b === void 0 ? void 0 : _b.element();
      }
    };
    exports2.FunctionMixin = FunctionMixin;
  }
});

// ../syside-languageserver/lib/model/mixins/input-parameters.js
var require_input_parameters = __commonJS({
  "../syside-languageserver/lib/model/mixins/input-parameters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InputParametersMixin = void 0;
    var ast_1 = require_ast2();
    var positional_features_1 = require_positional_features();
    var Filter = (f) => {
      var _a;
      if (!f.is(ast_1.OwningMembership))
        return false;
      const dir = (_a = f.element()) === null || _a === void 0 ? void 0 : _a.direction;
      return dir === "in" || dir === "inout";
    };
    var InputParametersMixin = class {
      constructor() {
        this.params = new positional_features_1.PositionalFeaturesBase();
      }
      /**
       * @returns directly owned input parameter features
       */
      ownedInputParameters() {
        return this.params.owned(this, Filter);
      }
      /**
       * @returns directly owned and inherited input parameter features
       */
      inputParameters() {
        return this.params.all(this, Filter);
      }
      resetInputParameters() {
        this.params.clearCaches();
      }
    };
    exports2.InputParametersMixin = InputParametersMixin;
  }
});

// ../syside-languageserver/lib/model/mixins/index.js
var require_mixins2 = __commonJS({
  "../syside-languageserver/lib/model/mixins/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_connector(), exports2);
    __exportStar(require_function(), exports2);
    __exportStar(require_input_parameters(), exports2);
    __exportStar(require_positional_features(), exports2);
  }
});

// ../syside-languageserver/lib/model/KerML/type.js
var require_type = __commonJS({
  "../syside-languageserver/lib/model/KerML/type.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var TypeMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeMeta = exports2.typeRelationships = exports2.typeHeritage = exports2.ImplicitTypes = void 0;
    var langium_1 = require_lib2();
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var common_1 = require_common();
    var scope_util_1 = require_scope_util();
    var containers_1 = require_containers2();
    var enums_1 = require_enums();
    var metamodel_1 = require_metamodel();
    var mixins_1 = require_mixins2();
    var _internal_1 = require_internal();
    exports2.ImplicitTypes = {
      base: "Base::Anything"
    };
    function typeHeritage(...children) {
      return _internal_1.EdgeContainer.make(...children);
    }
    exports2.typeHeritage = typeHeritage;
    function typeRelationships(...children) {
      return _internal_1.EdgeContainer.make(...children);
    }
    exports2.typeRelationships = typeRelationships;
    var TypeMeta = exports2.TypeMeta = TypeMeta_1 = class TypeMeta extends (0, ts_mixer_1.Mixin)(mixins_1.InputParametersMixin, _internal_1.NamespaceMeta) {
      constructor() {
        super(...arguments);
        this._heritage = new containers_1.ElementContainer();
        this._typeRelationships = new containers_1.ElementContainer();
        this._isAbstract = false;
        this._classifier = 0;
        this._isSufficient = false;
      }
      get isSufficient() {
        return this._isSufficient;
      }
      set isSufficient(value) {
        this._isSufficient = value;
      }
      /**
       * Whether this type is abstract
       */
      get isAbstract() {
        return this._isAbstract;
      }
      set isAbstract(value) {
        this._isAbstract = value;
      }
      get multiplicity() {
        return this._multiplicity;
      }
      set multiplicity(value) {
        this._multiplicity = this.swapEdgeOwnership(this._multiplicity, value);
      }
      get heritage() {
        return this._heritage.all;
      }
      /**
       * Adds potentially owned heritage and returns the new number of heritage
       * relationships. Heritage with owned sources or non-type parents are not
       * taken ownership of.
       */
      addHeritage(...value) {
        return this.addDeclaredRelationship(this._heritage, value.filter(([_, target]) => !target.is(ast_1.Feature) || target.basicFeature() !== this), this.onHeritageAdded, this);
      }
      /**
       * Removes heritage by value and returns the new number of heritage
       * relationships.
       */
      removeHeritage(...value) {
        const removed = [];
        const count = this.removeDeclaredRelationship(this._heritage, value, (v) => removed.push(v));
        if (removed.length > 0)
          this.onHeritageRemoved(removed);
        return count;
      }
      /**
       * Removes heritage by predicate and returns the new number of heritage
       * relationships.
       */
      removeHeritageIf(predicate) {
        const removed = [];
        const count = this.removeDeclaredRelationshipIf(this._heritage, predicate, (v) => removed.push(v));
        if (removed.length > 0)
          this.onHeritageRemoved(removed);
        return count;
      }
      get typeRelationships() {
        return this._typeRelationships.all;
      }
      typeRelationshipsOf(kind) {
        return this._typeRelationships.get(kind);
      }
      /**
       * Adds potentially owned type relationships and returns the new number of
       * type relationships. Relationships with owned sources or non-type parents
       * are not taken ownership of.
       */
      addTypeRelationship(...element) {
        return this.addDeclaredRelationship(this._typeRelationships, element);
      }
      /**
       * Removes type relationships by value and returns the new number of type
       * relationships.
       */
      removeTypeRelationship(...element) {
        return this.removeDeclaredRelationship(this._typeRelationships, element);
      }
      /**
       * Removes type relationships by predicate and returns the new number of type
       * relationships.
       */
      removeTypeRelationshipIf(predicate) {
        return this.removeDeclaredRelationshipIf(this._typeRelationships, predicate);
      }
      /**
       * Cached type classifiers
       */
      get classifier() {
        return this._classifier;
      }
      /**
       * Human readable string of classifier flags
       */
      get classifierString() {
        return (0, enums_1.getTypeClassifierString)(this.classifier);
      }
      ast() {
        return this._ast;
      }
      specializations(kind) {
        return this._heritage.get(kind);
      }
      types(kind) {
        return (0, langium_1.stream)(this.specializations(kind)).map((s) => s.finalElement()).nonNullable();
      }
      supertypes(kind) {
        return (0, langium_1.stream)(this.specializations(kind)).map((s) => s.element()).nonNullable();
      }
      allSpecializations(kind) {
        const visited = /* @__PURE__ */ new Set();
        const self2 = _internal_1.SpecializationMeta.create(() => -1, this.document);
        self2["setElement"](this);
        const tree = new langium_1.TreeStreamImpl(
          self2,
          // avoid circular specializations, there probably should be a
          // warning
          (s) => {
            var _a, _b;
            return (_b = (_a = s.finalElement()) === null || _a === void 0 ? void 0 : _a.specializations().filter((s2) => {
              const target = s2.finalElement();
              if (visited.has(target))
                return false;
              visited.add(target);
              return true;
            })) !== null && _b !== void 0 ? _b : [];
          },
          {
            includeRoot: false
          }
        );
        if (!kind)
          return tree;
        return tree.filter(metamodel_1.BasicMetamodel.is(kind));
      }
      allSupertypeSpecializations(kind) {
        const visited = /* @__PURE__ */ new Set();
        const self2 = _internal_1.SpecializationMeta.create(() => -1, this.document);
        self2["setElement"](this);
        const tree = new langium_1.TreeStreamImpl(
          self2,
          // avoid circular specializations, there probably should be a
          // warning
          (s) => {
            var _a, _b;
            return (_b = (_a = s.element()) === null || _a === void 0 ? void 0 : _a.specializations().filter((s2) => {
              const target = s2.element();
              if (visited.has(target))
                return false;
              visited.add(target);
              return true;
            })) !== null && _b !== void 0 ? _b : [];
          },
          {
            includeRoot: false
          }
        );
        if (!kind)
          return tree;
        return tree.filter(metamodel_1.BasicMetamodel.is(kind));
      }
      allTypes(kind, includeSelf = false) {
        const tree = this.allSpecializations(kind).map((s) => s.finalElement()).nonNullable();
        if (includeSelf)
          return (0, langium_1.stream)([this]).concat(tree);
        return tree;
      }
      allSupertypes(kind, includeSelf = false) {
        const tree = this.allSupertypeSpecializations(kind).map((s) => s.element()).nonNullable();
        if (includeSelf)
          return (0, langium_1.stream)([this]).concat(tree);
        return tree;
      }
      /**
       * @param type qualified name or type AST node to check
       * @returns true if this type conforms directly or indirectly to
       * {@link type}, false otherwise
       */
      conforms(type) {
        if (typeof type === "string")
          return this.allTypes(void 0, true).some((t) => (t === null || t === void 0 ? void 0 : t.qualifiedName) === type);
        return this.allTypes(void 0, true).some((t) => t === type);
      }
      /**
       * @param type qualified name or type AST node to check
       * @returns true if this type specializes directly or indirectly
       * {@link type}, false otherwise
       */
      specializes(type) {
        var _a;
        const conjugator = this._heritage.get(ast_1.Conjugation).at(0);
        if (conjugator) {
          return Boolean((_a = conjugator.element()) === null || _a === void 0 ? void 0 : _a.specializes(type));
        }
        if (typeof type === "string")
          return this.allSupertypes(void 0, true).some((t) => (t === null || t === void 0 ? void 0 : t.qualifiedName) === type);
        return this.allSupertypes(void 0, true).some((t) => t === type);
      }
      /**
       * @param types types or their fully qualified names to check for
       * conformance
       * @returns the first value in `types` that `this` conforms to and the
       * corresponding type or `undefined` if `this` does not conform to any
       * `types`
       */
      firstConforming(types) {
        for (const type of this.allTypes(void 0, true)) {
          const result = types.find((t) => typeof t === "string" ? type.qualifiedName === t : type === t);
          if (result)
            return [result, type];
        }
        return;
      }
      /**
       * @param is type assertion predicate
       * @param kind specialization kind filter
       * @returns Stream of direct specializations that satisfy {@link is}
       */
      specializationsMatching(is, kind) {
        return Array.isArray(is) ? (0, langium_1.stream)(this.specializations(kind)).filter((s) => {
          var _a;
          return (_a = s.finalElement()) === null || _a === void 0 ? void 0 : _a.isAny(...is);
        }) : (0, langium_1.stream)(this.specializations(kind)).filter((s) => {
          var _a;
          return (_a = s.finalElement()) === null || _a === void 0 ? void 0 : _a.is(is);
        });
      }
      /**
       * @param is type assertion predicate
       * @param kind specialization kind filter
       * @returns Stream of direct specialized types that satisfy {@link is}
       */
      typesMatching(is, kind) {
        return (0, langium_1.stream)(this.specializationsMatching(is, kind)).map((s) => s.finalElement()).nonNullable();
      }
      /**
       * @param is type assertion predicate
       * @param kind specialization kind filter
       * @param includeSelf if true, also include self
       * @returns Stream of all direct and indirect specializations that satisfy {@link is}
       */
      allSpecializationsMatching(is, kind) {
        return Array.isArray(is) ? (0, langium_1.stream)(this.allSpecializations(kind)).filter((s) => {
          var _a;
          return (_a = s.finalElement()) === null || _a === void 0 ? void 0 : _a.isAny(...is);
        }) : (0, langium_1.stream)(this.allSpecializations(kind)).filter((s) => {
          var _a;
          return (_a = s.finalElement()) === null || _a === void 0 ? void 0 : _a.is(is);
        });
      }
      /**
       * @param is type assertion predicate
       * @param kind specialization kind filter
       * @param includeSelf if true, also include self
       * @returns Stream of all direct and indirect specialized types that satisfy {@link conforms}
       */
      allTypesMatching(is, kind, includeSelf = false) {
        return Array.isArray(is) ? (0, langium_1.stream)(this.allTypes(kind, includeSelf)).filter((s) => s.isAny(...is)) : (0, langium_1.stream)(this.allTypes(kind, includeSelf)).filter((s) => s.is(is));
      }
      /**
       * Get a stream of inherited positional features
       * @param predicate feature filter predicate
       * @param typePredicate type constraint
       * @param includeSelf if true, include owned features
       * @returns stream of features from direct and indirect specializations that
       * satisfy both {@link predicate} and {@link typePredicate}
       */
      basePositionalFeatures(predicate, typePredicate, includeSelf = false) {
        let count = 0;
        const counted = (f) => {
          ++count;
          return f;
        };
        let allTypes = typePredicate ? this.allTypes().filter((s) => typePredicate(s)) : this.allTypes();
        if (includeSelf)
          allTypes = (0, langium_1.stream)([this]).concat(allTypes);
        return allTypes.flatMap((s) => (0, langium_1.stream)(s.featureMembers()).filter(predicate).tail(count).map(counted));
      }
      // eslint-disable-next-line unused-imports/no-unused-vars
      onHeritageAdded(heritage, target) {
      }
      // eslint-disable-next-line unused-imports/no-unused-vars
      onHeritageRemoved(heritage) {
      }
      isDeclaredRelationship(element) {
        const source = element.source();
        if (source && source.parent() === element)
          return false;
        const parent = element.parent();
        return Boolean(!parent || parent.is(ast_1.Type));
      }
      maybeTakeOwnership(element) {
        if (this.isDeclaredRelationship(element))
          this.takeOwnership(element);
      }
      maybeUnsetOwnership(element) {
        if (this.isDeclaredRelationship(element))
          this.unsetOwnership(element);
      }
      allMetadata() {
        return this.allTypes(void 0, true).flatMap((t) => t.metadata);
      }
      allFeatures() {
        const visited = /* @__PURE__ */ new Set();
        return this.allTypes(void 0, true).flatMap((t) => t.featureMembers()).filter((member) => {
          const f = member.element();
          if (!f || visited.has(f))
            return false;
          visited.add(f);
          (0, scope_util_1.collectRedefinitions)(f, visited);
          return true;
        });
      }
      directionOf(feature, visited = /* @__PURE__ */ new Set()) {
        if (feature.owningType == this) {
          return feature.direction;
        }
        visited.add(this);
        const conjugator = this._heritage.get(ast_1.Conjugation).at(0);
        if (conjugator) {
          const original = conjugator.element();
          if (!original || visited.has(original)) {
            return "none";
          }
          const direction = original.directionOf(feature, visited);
          return direction == "in" ? "out" : direction == "out" ? "in" : direction;
        }
        for (const spec of this.specializations()) {
          const general = spec.element();
          if (general && !visited.has(general)) {
            const direction = general.directionOf(feature, visited);
            if (direction != "none") {
              return direction;
            }
          }
        }
        return "none";
      }
      ownedFeatureMemberships() {
        return (0, langium_1.stream)(this.featureMembers()).filter(metamodel_1.BasicMetamodel.is(ast_1.FeatureMembership));
      }
      ownedFeatures() {
        return this.featuresByMembership(ast_1.FeatureMembership);
      }
      ownedParameters() {
        return this.ownedFeatures().filter((f) => f.isParameter);
      }
      addDeclaredRelationship(container, value, callback, thisObj) {
        value.forEach(([relationship, target]) => {
          this.maybeTakeOwnership(relationship);
          relationship["setElement"](target);
          container.push(relationship);
          callback === null || callback === void 0 ? void 0 : callback.call(thisObj, relationship, target);
        });
        return container.length;
      }
      removeDeclaredRelationship(container, value, callback) {
        value.forEach((item) => {
          if (container.remove(item)) {
            this.maybeUnsetOwnership(item);
            callback === null || callback === void 0 ? void 0 : callback(item);
          }
        });
        return container.length;
      }
      removeDeclaredRelationshipIf(container, predicate, callback) {
        return container.removeIf((value) => {
          if (predicate(value)) {
            this.maybeUnsetOwnership(value);
            callback === null || callback === void 0 ? void 0 : callback(value);
            return true;
          }
          return false;
        });
      }
      collectDeclaration(parts) {
        if (this._multiplicity) {
          parts.push(["multiplicity", [this._multiplicity]]);
        }
        parts.push(["heritage", this.heritage]);
        parts.push(["typeRelationships", this.typeRelationships]);
      }
      collectParts() {
        const parts = [["prefixes", this.prefixes]];
        this.collectDeclaration(parts);
        parts.push(["children", this.children]);
        return parts;
      }
      static applyTypeOptions(model, options) {
        model._isAbstract = Boolean(options.isAbstract);
        if (options.multiplicity)
          model.multiplicity = options.multiplicity;
        if (options.heritage)
          model.addHeritage(...options.heritage["values"]);
        if (options.typeRelationships)
          model.addTypeRelationship(...options.typeRelationships["values"]);
        model.isSufficient = Boolean(options.isSufficient);
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          TypeMeta_1.applyTypeOptions(model, options);
        return model;
      }
    };
    __decorate([
      common_1.enumerable
    ], TypeMeta.prototype, "isAbstract", null);
    __decorate([
      common_1.enumerable
    ], TypeMeta.prototype, "multiplicity", null);
    __decorate([
      common_1.enumerable
    ], TypeMeta.prototype, "heritage", null);
    __decorate([
      common_1.enumerable
    ], TypeMeta.prototype, "typeRelationships", null);
    exports2.TypeMeta = TypeMeta = TypeMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Type, exports2.ImplicitTypes)
    ], TypeMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/references/type-reference.js
var require_type_reference = __commonJS({
  "../syside-languageserver/lib/model/KerML/references/type-reference.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeReferenceMeta = void 0;
    var ast_1 = require_ast2();
    var containers_1 = require_containers();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var TypeReferenceMeta = exports2.TypeReferenceMeta = class TypeReferenceMeta extends _internal_1.NamespaceReferenceMeta {
      constructor() {
        super(...arguments);
        this.to = new containers_1.Target();
      }
      ast() {
        return this._ast;
      }
    };
    exports2.TypeReferenceMeta = TypeReferenceMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.TypeReference)
    ], TypeReferenceMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/classifier.js
var require_classifier = __commonJS({
  "../syside-languageserver/lib/model/KerML/classifier.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClassifierMeta = exports2.ImplicitClassifiers = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitClassifiers = {
      base: "Base::Anything"
    };
    var ClassifierMeta = exports2.ClassifierMeta = class ClassifierMeta extends _internal_1.TypeMeta {
      ast() {
        return this._ast;
      }
      specializationKind() {
        return ast_1.Subclassification;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.ClassifierMeta = ClassifierMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Classifier, exports2.ImplicitClassifiers)
    ], ClassifierMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/references/classifier-reference.js
var require_classifier_reference = __commonJS({
  "../syside-languageserver/lib/model/KerML/references/classifier-reference.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClassifierReferenceMeta = void 0;
    var ast_1 = require_ast2();
    var containers_1 = require_containers();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var ClassifierReferenceMeta = exports2.ClassifierReferenceMeta = class ClassifierReferenceMeta extends _internal_1.TypeReferenceMeta {
      constructor() {
        super(...arguments);
        this.to = new containers_1.Target();
      }
      ast() {
        return this._ast;
      }
    };
    exports2.ClassifierReferenceMeta = ClassifierReferenceMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ClassifierReference)
    ], ClassifierReferenceMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/class.js
var require_class = __commonJS({
  "../syside-languageserver/lib/model/KerML/class.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClassMeta = exports2.ImplicitClasses = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitClasses = {
      base: "Occurrences::Occurrence"
    };
    var ClassMeta = exports2.ClassMeta = class ClassMeta extends _internal_1.ClassifierMeta {
      constructor() {
        super(...arguments);
        this._classifier = 2;
      }
      ast() {
        return this._ast;
      }
    };
    exports2.ClassMeta = ClassMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Class, exports2.ImplicitClasses)
    ], ClassMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/data-type.js
var require_data_type = __commonJS({
  "../syside-languageserver/lib/model/KerML/data-type.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataTypeMeta = exports2.ImplicitDataTypes = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitDataTypes = {
      base: "Base::DataValue"
    };
    var DataTypeMeta = exports2.DataTypeMeta = class DataTypeMeta extends _internal_1.ClassifierMeta {
      constructor() {
        super(...arguments);
        this._classifier = 1;
      }
      ast() {
        return this._ast;
      }
    };
    exports2.DataTypeMeta = DataTypeMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.DataType, exports2.ImplicitDataTypes)
    ], DataTypeMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/association.js
var require_association = __commonJS({
  "../syside-languageserver/lib/model/KerML/association.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AssociationMeta = exports2.ImplicitAssociations = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var connector_1 = require_connector();
    var _internal_1 = require_internal();
    exports2.ImplicitAssociations = {
      base: "Links::Link",
      binary: "Links::BinaryLink"
    };
    var AssociationMeta = exports2.AssociationMeta = class AssociationMeta extends (0, ts_mixer_1.Mixin)(connector_1.ConnectorMixin, _internal_1.RelationshipMeta, _internal_1.ClassifierMeta) {
      constructor() {
        super(...arguments);
        this._classifier = 8;
      }
      defaultSupertype() {
        return this.isBinary() ? "binary" : "base";
      }
      ast() {
        return this._ast;
      }
      onHeritageAdded(heritage, target) {
        this.resetEnds();
        _internal_1.ClassifierMeta.prototype["onHeritageAdded"].call(this, heritage, target);
      }
      onHeritageRemoved(heritage) {
        this.resetEnds();
        _internal_1.ClassifierMeta.prototype["onHeritageRemoved"].call(this, heritage);
      }
    };
    exports2.AssociationMeta = AssociationMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Association, exports2.ImplicitAssociations)
      // Note: inherited methods are override by the last class inside `Mixin`
    ], AssociationMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/behavior.js
var require_behavior = __commonJS({
  "../syside-languageserver/lib/model/KerML/behavior.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BehaviorMeta = exports2.ImplicitBehaviors = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitBehaviors = {
      base: "Performances::Performance"
    };
    var BehaviorMeta = exports2.BehaviorMeta = class BehaviorMeta extends _internal_1.ClassMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.BehaviorMeta = BehaviorMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Behavior, exports2.ImplicitBehaviors)
    ], BehaviorMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/interaction.js
var require_interaction = __commonJS({
  "../syside-languageserver/lib/model/KerML/interaction.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InteractionMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var InteractionMeta = exports2.InteractionMeta = class InteractionMeta extends (0, ts_mixer_1.Mixin)(_internal_1.AssociationMeta, _internal_1.BehaviorMeta) {
      ast() {
        return this._ast;
      }
    };
    exports2.InteractionMeta = InteractionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Interaction)
    ], InteractionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/structure.js
var require_structure = __commonJS({
  "../syside-languageserver/lib/model/KerML/structure.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StructureMeta = exports2.ImplicitStructures = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitStructures = {
      base: "Objects::Object"
    };
    var StructureMeta = exports2.StructureMeta = class StructureMeta extends _internal_1.ClassMeta {
      constructor() {
        super(...arguments);
        this._classifier = 4;
      }
      ast() {
        return this._ast;
      }
    };
    exports2.StructureMeta = StructureMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Structure, exports2.ImplicitStructures)
    ], StructureMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/metaclass.js
var require_metaclass = __commonJS({
  "../syside-languageserver/lib/model/KerML/metaclass.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetaclassMeta = exports2.ImplicitMetaclasses = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitMetaclasses = {
      base: "Metaobjects::Metaobject"
    };
    var MetaclassMeta = exports2.MetaclassMeta = class MetaclassMeta extends _internal_1.StructureMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.MetaclassMeta = MetaclassMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Metaclass, exports2.ImplicitMetaclasses)
    ], MetaclassMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/references/metaclass-reference.js
var require_metaclass_reference = __commonJS({
  "../syside-languageserver/lib/model/KerML/references/metaclass-reference.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetaclassReferenceMeta = void 0;
    var ast_1 = require_ast2();
    var containers_1 = require_containers();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var MetaclassReferenceMeta = exports2.MetaclassReferenceMeta = class MetaclassReferenceMeta extends _internal_1.TypeReferenceMeta {
      constructor() {
        super(...arguments);
        this.to = new containers_1.Target();
      }
      ast() {
        return this._ast;
      }
    };
    exports2.MetaclassReferenceMeta = MetaclassReferenceMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.MetaclassReference)
    ], MetaclassReferenceMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/feature.js
var require_feature = __commonJS({
  "../syside-languageserver/lib/model/KerML/feature.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var FeatureMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FeatureMeta = exports2.featureRelationships = exports2.ImplicitFeatures = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var langium_1 = require_lib2();
    var utils_1 = require_utils2();
    exports2.ImplicitFeatures = {
      base: "Base::things",
      dataValue: "Base::dataValues",
      occurrence: "Occurrences::occurrences",
      suboccurrence: "Occurrences::Occurrence::suboccurrences",
      portion: "Occurrences::Occurrence::portions",
      object: "Objects::objects",
      subobject: "Objects::Object::subobjects",
      participant: "Links::Link::participant",
      // TODO
      startingAt: "FeatureReferencingPerformances::FeatureAccessPerformance::onOccurrence::startingAt",
      // TODO
      accessedFeature: "FeatureReferencingPerformances::FeatureAccessPerformance::onOccurrence::startingAt::accessedFeature"
    };
    function featureRelationships(...children) {
      return _internal_1.EdgeContainer.make(...children);
    }
    exports2.featureRelationships = featureRelationships;
    var FeatureMeta = exports2.FeatureMeta = FeatureMeta_1 = class FeatureMeta extends _internal_1.TypeMeta {
      constructor() {
        super(...arguments);
        this._direction = "none";
        this._isComposite = false;
        this.isPortion = false;
        this.isReadonly = false;
        this.isDerived = false;
        this._isEnd = false;
        this._isImpliedEnd = false;
        this._isOrdered = false;
        this._impliedIsOrdered = false;
        this._isNonUnique = false;
        this.typings = void 0;
      }
      /**
       * Feature direction
       */
      get direction() {
        var _a;
        return (_a = this._impliedDirection) !== null && _a !== void 0 ? _a : this._direction;
      }
      set direction(value) {
        this._direction = value;
        this.computedImpliedDirection();
      }
      get explicitDirection() {
        return this._direction;
      }
      computedImpliedDirection() {
        const parent = this.parent();
        if (this._direction === "none" && (parent === null || parent === void 0 ? void 0 : parent.is(ast_1.ParameterMembership))) {
          this._impliedDirection = parent.is(ast_1.ReturnParameterMembership) ? "out" : "in";
        } else {
          this._impliedDirection = void 0;
        }
      }
      /**
       * Whether this feature is composite
       */
      get isComposite() {
        return this._isComposite;
      }
      set isComposite(value) {
        this._isComposite = value;
      }
      /**
       * Whether this feature is end
       */
      get isEnd() {
        return this._isImpliedEnd || this._isEnd;
      }
      set isEnd(value) {
        this._isEnd = value;
      }
      get isEndExplicitly() {
        return this._isEnd;
      }
      get isOrdered() {
        return this._isOrdered || this._impliedIsOrdered;
      }
      set isOrdered(value) {
        this._isOrdered = value;
      }
      get isOrderedExplicitly() {
        return this._isOrdered;
      }
      get isNonUnique() {
        return this._isNonUnique;
      }
      set isNonUnique(value) {
        this._isNonUnique = value;
      }
      /**
       * Adds potentially owned feature relationships and returns the new number of
       * feature relationships. Relationships with owned sources or non-type parents
       * are not taken ownership of.
       */
      addFeatureRelationship(...element) {
        return this.addDeclaredRelationship(this._typeRelationships, element);
      }
      /**
       * Removes feature relationships by value and returns the new number of feature
       * relationships.
       */
      removeFeatureRelationship(...element) {
        return this.removeDeclaredRelationship(this._typeRelationships, element);
      }
      /**
       * Removes feature relationships by predicate and returns the new number of feature
       * relationships.
       */
      removeFeatureRelationshipIf(predicate) {
        return this.removeDeclaredRelationshipIf(this._typeRelationships, predicate);
      }
      get typeFeaturings() {
        return this._typeRelationships.get(ast_1.TypeFeaturing);
      }
      get featuredBy() {
        var _a;
        const featurings = this.typeFeaturings.map((f) => f.element()).filter(utils_1.NonNullable);
        const chaining = (_a = this.chainings.at(0)) === null || _a === void 0 ? void 0 : _a.element();
        if (chaining)
          featurings.push(...chaining.featuredBy);
        if (featurings.length === 0 && this._owningType)
          return [this._owningType];
        return featurings;
      }
      get chainings() {
        return this._typeRelationships.get(ast_1.FeatureChaining);
      }
      get chainingFeatures() {
        return this.chainings.map((chaining) => chaining.element()).filter(utils_1.NonNullable);
      }
      get featureTarget() {
        return this.basicFeature();
      }
      get value() {
        return this._value;
      }
      set value(value) {
        this._value = this.swapEdgeOwnership(this._value, value);
      }
      get featureWrite() {
        return this._value && !this._value.isDefault && this._value.isInitial ? this._write : void 0;
      }
      onParentSet(previous, current) {
        super.onParentSet(previous, current);
        this._isImpliedEnd = Boolean(current === null || current === void 0 ? void 0 : current.is(ast_1.EndFeatureMembership));
        this.computedImpliedDirection();
      }
      onOwnerSet(previous, current) {
        if ((current === null || current === void 0 ? void 0 : current[0].is(ast_1.FeatureMembership)) && (current === null || current === void 0 ? void 0 : current[1].is(ast_1.Type))) {
          this._owningType = current[1];
        } else {
          this._owningType = void 0;
        }
        super.onOwnerSet(previous, current);
      }
      get owningType() {
        return this._owningType;
      }
      defaultGeneralTypes() {
        const supertypes = super.defaultGeneralTypes();
        if (this.isAssociationEnd())
          supertypes.push("participant");
        return supertypes;
      }
      defaultSupertype() {
        if (this.hasStructureType())
          return this.isSubobject() ? "subobject" : "object";
        if (this.hasClassType())
          return this.isSuboccurrence() ? "suboccurrence" : this.isPortion ? "portion" : "occurrence";
        if (this.hasDataType())
          return "dataValue";
        return "base";
      }
      isPortionImpl() {
        const owningType = this.owningType;
        if (!owningType) {
          return false;
        }
        return this.isPortion && (owningType.is(ast_1.Class) || owningType.is(ast_1.Feature) && owningType.hasClassType());
      }
      get ownedCrossSubsetting() {
        return this.specializations(ast_1.CrossSubsetting).at(0);
      }
      get crossFeature() {
        var _a, _b;
        const target = (_a = this.ownedCrossSubsetting) === null || _a === void 0 ? void 0 : _a.element();
        return (_b = target === null || target === void 0 ? void 0 : target.chainings.at(1)) === null || _b === void 0 ? void 0 : _b.element();
      }
      get ownedCrossFeatureMember() {
        return this._crossingFeature;
      }
      get ownedCrossFeature() {
        var _a;
        return (_a = this._crossingFeature) === null || _a === void 0 ? void 0 : _a.element();
      }
      findOwnedCrossFeature() {
        if (this.ownedCrossFeature)
          return this.ownedCrossFeature;
        for (const child of this.children) {
          if (child.nodeType() !== ast_1.OwningMembership)
            continue;
          const f = child.element();
          if (f && f.is(ast_1.Feature) && !f.is(ast_1.MetadataFeature) && !f.is(ast_1.Multiplicity))
            return f;
        }
        return void 0;
      }
      ast() {
        return this._ast;
      }
      /**
       * @returns true if this feature specializes any structure type, false
       * otherwise
       */
      hasStructureType() {
        return (this.classifier & 4) === 4;
      }
      /**
       * @returns true if this feature specializes any class type, false otherwise
       */
      hasClassType() {
        return (this.classifier & 2) === 2;
      }
      /**
       * @returns true if this feature specializes any data type, false otherwise
       */
      hasDataType() {
        return (this.classifier & 1) === 1;
      }
      /**
       * @returns true if this feature specializes any association type, false
       * otherwise
       */
      hasAssociation() {
        return (this.classifier & 8) === 8;
      }
      /**
       * @returns true if this feature is owned by a behavior or step, false
       * otherwise
       */
      isBehaviorOwned() {
        const owner = this.owner();
        return Boolean(owner === null || owner === void 0 ? void 0 : owner.isAny(ast_1.Behavior, ast_1.Step));
      }
      /**
       * @returns true if this feature is composite and is enclosed performance,
       * false otherwise
       */
      isBehaviorOwnedComposite() {
        return this.isComposite && this.isBehaviorOwned();
      }
      /**
       * @returns true if this feature is composite and is owned by a structure
       * type or a feature specializing a structure type, false otherwise
       */
      isSubobject() {
        if (!this.isComposite)
          return false;
        const owner = this.owner();
        return Boolean((owner === null || owner === void 0 ? void 0 : owner.is(ast_1.Structure)) || (owner === null || owner === void 0 ? void 0 : owner.is(ast_1.Feature)) && owner.hasStructureType());
      }
      /**
       * @returns same as {@link FeatureMeta.isSubobject isSubobject}
       */
      isStructureOwnedComposite() {
        return this.isSubobject();
      }
      /**
       * @returns true if this feature is composite and is owned by a class type
       * or a feature specializing a class type, false otherwise
       */
      isSuboccurrence() {
        if (!this.isComposite)
          return false;
        const owner = this.owner();
        return Boolean((owner === null || owner === void 0 ? void 0 : owner.is(ast_1.Class)) || (owner === null || owner === void 0 ? void 0 : owner.is(ast_1.Feature)) && owner.hasClassType());
      }
      /**
       * @returns true if this feature is end feature and is owned by an
       * association of a connector
       */
      isAssociationEnd() {
        if (!this.isEnd)
          return false;
        const owner = this.owner();
        return Boolean(owner === null || owner === void 0 ? void 0 : owner.isAny(ast_1.Association, ast_1.Connector));
      }
      /**
       * Feature that provides the name for this feature. Itself if it was named,
       * otherwise the naming feature of the first redefinition
       */
      namingFeature() {
        return this.types(ast_1.Redefinition).head();
      }
      isFeaturedWithin(type) {
        if (type === void 0) {
          return this.featuredBy.length == 0 || this.featuredBy.length == 1 && this.featuredBy[0].qualifiedName == "Base::Anything";
        }
        if (this.featuredBy.length == 0) {
          return true;
        }
        return this.featuredBy.every((f) => type.specializes(f));
      }
      allRedefinitions() {
        const visited = /* @__PURE__ */ new Set();
        const self2 = _internal_1.RedefinitionMeta.create(() => -1, this.document);
        self2["setElement"](this);
        return new langium_1.TreeStreamImpl(self2, (s) => {
          var _a, _b;
          return (_b = (_a = s.element()) === null || _a === void 0 ? void 0 : _a._heritage.get(ast_1.Redefinition).filter((s2) => {
            const target = s2.element();
            if (visited.has(target))
              return false;
            visited.add(target);
            return true;
          })) !== null && _b !== void 0 ? _b : [];
        }, {
          includeRoot: false
        });
      }
      allRedefinedFeatures() {
        return this.allRedefinitions().map((r) => r.element()).filter(utils_1.NonNullable);
      }
      referencedFeature(kind) {
        const feature = this.types(ast_1.ReferenceSubsetting).head();
        if (kind)
          return (feature === null || feature === void 0 ? void 0 : feature.is(kind)) ? feature : this;
        return feature;
      }
      basicFeature() {
        var _a, _b;
        return (_b = (_a = this.chainings.at(-1)) === null || _a === void 0 ? void 0 : _a.element()) !== null && _b !== void 0 ? _b : this;
      }
      isIgnoredParameter() {
        return this.isResultParameter;
      }
      get isParameter() {
        var _a;
        return Boolean(this.direction !== "none" && ((_a = this.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast_1.Behavior, ast_1.Step)));
      }
      get isResultParameter() {
        var _a;
        return Boolean((_a = this.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.ReturnParameterMembership));
      }
      recomputeEffectiveNames() {
        if (this.declaredName || this.declaredShortName)
          return;
        this.updateEffectiveNames();
      }
      updateEffectiveNames() {
        const namingFeature = this.namingFeature();
        if (namingFeature) {
          if (namingFeature.name)
            this.setName(namingFeature.name);
          if (namingFeature.shortName)
            this.setShortName(namingFeature.shortName);
        } else {
          if (this.name)
            this.setName(void 0);
          if (this.shortName)
            this.setShortName(void 0);
        }
      }
      onHeritageAdded(heritage, target) {
        var _a;
        super.onHeritageAdded(heritage, target);
        this.typings = void 0;
        if (!this._impliedIsOrdered && heritage.is(ast_1.Subsetting)) {
          if ((_a = heritage.finalElement()) === null || _a === void 0 ? void 0 : _a.isOrdered)
            this._impliedIsOrdered = true;
        }
        if (!this.name && !this.shortName) {
          this.updateEffectiveNames();
        }
        if (heritage.is(ast_1.Redefinition)) {
          const feature = heritage.finalElement();
          const owner = this.owningType;
          if (owner && feature) {
            const addShadow = (name) => {
              const existing = owner.findMember(name);
              if (!existing)
                owner["_memberLookup"].set(name, "shadow");
            };
            if (feature.name)
              addShadow(feature.name);
            if (feature.shortName)
              addShadow(feature.shortName);
          }
        }
      }
      onHeritageRemoved(heritage) {
        var _a;
        super.onHeritageRemoved(heritage);
        this.typings = void 0;
        if (this._impliedIsOrdered && heritage.some((h) => {
          var _a2;
          return h.is(ast_1.Subsetting) && ((_a2 = h.finalElement()) === null || _a2 === void 0 ? void 0 : _a2.isOrdered);
        })) {
          this._impliedIsOrdered = this.heritage.some((h) => {
            var _a2;
            return h.is(ast_1.Subsetting) && ((_a2 = h.finalElement()) === null || _a2 === void 0 ? void 0 : _a2.isOrdered);
          });
        }
        this.recomputeEffectiveNames();
        const lookup = (_a = this.owningType) === null || _a === void 0 ? void 0 : _a["_memberLookup"];
        if (!lookup)
          return;
        heritage.filter(metamodel_1.BasicMetamodel.is(ast_1.Redefinition)).map((r) => r.finalElement()).filter(utils_1.NonNullable).forEach((feature) => {
          const removeShadow = (name) => {
            const existing = lookup.get(name);
            if (existing === "shadow")
              lookup.delete(name);
          };
          if (feature.name)
            removeShadow(feature.name);
          if (feature.shortName)
            removeShadow(feature.shortName);
        });
      }
      specializationKind() {
        return ast_1.Subsetting;
      }
      allTypings(recompute = false) {
        if (!this.typings || recompute)
          return this.collectTypings();
        return this.typings;
      }
      collectTypings() {
        const types = this.collectInheritedTypes(/* @__PURE__ */ new Set()).distinct().toArray();
        this.typings = types.filter((t) => types.every((type) => type === t || !type.conforms(t)));
        return this.typings;
      }
      collectDirectTypes(visited) {
        const types = (0, langium_1.stream)(this.specializations(ast_1.FeatureTyping)).map((s) => s.finalElement()).nonNullable();
        const lastChaining = this.chainingFeatures.at(-1);
        if (lastChaining) {
          return types.concat(lastChaining.collectInheritedTypes(visited));
        }
        return types;
      }
      collectInheritedTypes(visited) {
        if (visited.has(this))
          return langium_1.EMPTY_STREAM;
        visited.add(this);
        return (0, langium_1.stream)(this.collectDirectTypes(visited), ...[ast_1.Conjugation, ast_1.Subsetting].map((kind) => this.types(kind).filter(metamodel_1.BasicMetamodel.is(ast_1.Feature)).flatMap((f) => f.collectInheritedTypes(visited))));
      }
      allFeaturingTypes() {
        let queue = [this];
        const types = /* @__PURE__ */ new Set();
        while (queue.length > 0) {
          const next = [];
          for (const feature of queue) {
            for (const type of feature.featuredBy) {
              if (types.has(type))
                continue;
              types.add(type);
              if (type.is(ast_1.Feature))
                next.push(type);
            }
          }
          queue = next;
        }
        return Array.from(types);
      }
      ownedParameters() {
        return _internal_1.TypeMeta.prototype.ownedParameters.call(this.basicFeature());
      }
      collectDeclaration(parts) {
        var _a;
        if (this.ownedCrossFeatureMember) {
          parts.push(["ownedCrossFeatureMember", [this.ownedCrossFeatureMember]]);
        }
        if ((_a = this.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.EndFeatureMembership)) {
          parts.push(["heritage", this.heritage]);
          if (this._multiplicity) {
            parts.push(["multiplicity", [this._multiplicity]]);
          }
        } else {
          if (this._multiplicity) {
            parts.push(["multiplicity", [this._multiplicity]]);
          }
          parts.push(["heritage", this.heritage]);
        }
        parts.push(["typeRelationships", this.typeRelationships]);
        if (this.value) {
          parts.push(["value", [this.value]]);
          if (this.featureWrite)
            parts.push(["featureWrite", [this.featureWrite]]);
        }
      }
      static applyFeatureOptions(model, options) {
        var _a;
        model._direction = (_a = options.direction) !== null && _a !== void 0 ? _a : "none";
        model._isComposite = Boolean(options.isComposite);
        model.isPortion = Boolean(options.isPortion);
        model.isReadonly = Boolean(options.isReadonly);
        model.isDerived = Boolean(options.isDerived);
        model._isEnd = Boolean(options.isEnd);
        model.isOrdered = Boolean(options.isOrdered);
        model.isNonUnique = Boolean(options.isNonUnique);
        if (options.value)
          model.value = options.value;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          FeatureMeta_1.applyFeatureOptions(model, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], FeatureMeta.prototype, "direction", null);
    __decorate([
      utils_1.enumerable
    ], FeatureMeta.prototype, "isComposite", null);
    __decorate([
      utils_1.enumerable
    ], FeatureMeta.prototype, "isEnd", null);
    __decorate([
      utils_1.enumerable
    ], FeatureMeta.prototype, "isOrdered", null);
    __decorate([
      utils_1.enumerable
    ], FeatureMeta.prototype, "isNonUnique", null);
    exports2.FeatureMeta = FeatureMeta = FeatureMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Feature, exports2.ImplicitFeatures)
    ], FeatureMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/references/feature-reference.js
var require_feature_reference = __commonJS({
  "../syside-languageserver/lib/model/KerML/references/feature-reference.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FeatureReferenceMeta = void 0;
    var ast_1 = require_ast2();
    var containers_1 = require_containers();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var FeatureReferenceMeta = exports2.FeatureReferenceMeta = class FeatureReferenceMeta extends _internal_1.TypeReferenceMeta {
      constructor() {
        super(...arguments);
        this.to = new containers_1.Target();
      }
      ast() {
        return this._ast;
      }
    };
    exports2.FeatureReferenceMeta = FeatureReferenceMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.FeatureReference)
    ], FeatureReferenceMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/multiplicity.js
var require_multiplicity = __commonJS({
  "../syside-languageserver/lib/model/KerML/multiplicity.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiplicityMeta = exports2.ImplicitMultiplicities = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitMultiplicities = {
      base: "Base::naturals",
      feature: "Base::exactlyOne",
      classifier: "Base::zeroOrOne"
    };
    var MultiplicityMeta = exports2.MultiplicityMeta = class MultiplicityMeta extends _internal_1.FeatureMeta {
      get typeFeaturings() {
        var _a;
        const explicit = super.typeFeaturings;
        if (explicit.length > 0)
          return explicit;
        if ((_a = this.owningType) === null || _a === void 0 ? void 0 : _a.is(ast_1.Feature))
          return this.owningType.typeFeaturings;
        return explicit;
      }
      ast() {
        return this._ast;
      }
      defaultSupertype() {
        const owner = this.owner();
        if (owner === null || owner === void 0 ? void 0 : owner.is(ast_1.Classifier))
          return "classifier";
        if (owner === null || owner === void 0 ? void 0 : owner.is(ast_1.Feature))
          return "feature";
        return "base";
      }
    };
    exports2.MultiplicityMeta = MultiplicityMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Multiplicity, exports2.ImplicitMultiplicities)
    ], MultiplicityMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/multiplicity-range.js
var require_multiplicity_range = __commonJS({
  "../syside-languageserver/lib/model/KerML/multiplicity-range.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiplicityRangeMeta = exports2.ImplicitMultiplicityRanges = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitMultiplicityRanges = {
      feature: "Base::naturals",
      classifier: "Base::naturals"
    };
    var MultiplicityRangeMeta = exports2.MultiplicityRangeMeta = class MultiplicityRangeMeta extends _internal_1.MultiplicityMeta {
      constructor() {
        super(...arguments);
        this._bounds = "unset";
      }
      get range() {
        return this._range;
      }
      set range(value) {
        this._range = this.swapEdgeOwnership(this._range, value);
      }
      get bounds() {
        if (typeof this._bounds === "function")
          return this._bounds = this._bounds();
        return this._bounds === "unset" ? void 0 : this._bounds;
      }
      setBounds(value) {
        this._bounds = value;
        return this;
      }
      ast() {
        return this._ast;
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        if (this.range)
          parts.push(["range", [this.range]]);
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          model.range = options.range;
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], MultiplicityRangeMeta.prototype, "bounds", null);
    exports2.MultiplicityRangeMeta = MultiplicityRangeMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.MultiplicityRange, exports2.ImplicitMultiplicityRanges)
    ], MultiplicityRangeMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/step.js
var require_step = __commonJS({
  "../syside-languageserver/lib/model/KerML/step.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StepMeta = exports2.ImplicitSteps = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitSteps = {
      base: "Performances::performances",
      enclosedPerformance: "Performances::Performance::enclosedPerformances",
      subperformance: "Performances::Performance::subperformances",
      ownedPerformance: "Objects::Object::ownedPerformances",
      incomingTransfer: "Occurrences::Occurrence::incomingTransfers",
      featureWrite: "FeatureReferencingPerformances::FeatureWritePerformance"
      // TODO
    };
    var StepMeta = exports2.StepMeta = class StepMeta extends _internal_1.FeatureMeta {
      ast() {
        return this._ast;
      }
      defaultSupertype() {
        if (this.isStructureOwnedComposite())
          return "ownedPerformance";
        if (this.isBehaviorOwnedComposite())
          return "subperformance";
        if (this.isBehaviorOwned())
          return "enclosedPerformance";
        if (this.isIncomingTransfer())
          return "incomingTransfer";
        return "base";
      }
      isIncomingTransfer() {
        const parent = this.owner();
        if (!(parent === null || parent === void 0 ? void 0 : parent.is(ast_1.ItemFlow)))
          return false;
        return Boolean(parent.item);
      }
    };
    exports2.StepMeta = StepMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Step, exports2.ImplicitSteps)
    ], StepMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/connector.js
var require_connector2 = __commonJS({
  "../syside-languageserver/lib/model/KerML/connector.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var ConnectorMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectorMeta = exports2.ImplicitConnectors = void 0;
    var langium_1 = require_lib2();
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var connector_1 = require_connector();
    var _internal_1 = require_internal();
    var utils_1 = require_utils2();
    exports2.ImplicitConnectors = {
      base: "Links::links",
      binary: "Links::binaryLinks",
      object: "Objects::linkObjects",
      binaryObject: "Objects::binaryLinkObjects"
    };
    var ConnectorMeta = exports2.ConnectorMeta = ConnectorMeta_1 = class ConnectorMeta extends (0, ts_mixer_1.Mixin)(connector_1.ConnectorMixin, _internal_1.RelationshipMeta, _internal_1.FeatureMeta) {
      constructor() {
        super(...arguments);
        this._ends = [];
      }
      get ends() {
        return this._ends;
      }
      /**
       * Adds owned end members and returns the new number of end members.
       */
      addEnd(...value) {
        this.resetEnds();
        return this.addOwnedEdges(this._ends, value);
      }
      /**
       * Removes ends by value and returns the new number of end members.
       */
      removeEnd(...value) {
        this.resetEnds();
        return this.removeOwnedElements(this._ends, value);
      }
      /**
       * Removes ends by predicate and returns the new number of end members.
       */
      removeEndIf(predicate) {
        this.resetEnds();
        return this.removeOwnedElementsIf(this._ends, predicate);
      }
      defaultSupertype() {
        if (this.hasStructureType()) {
          if (this._ends.length > 2)
            return "object";
          return this.isBinary() ? "binaryObject" : "object";
        }
        if (this._ends.length > 2)
          return "base";
        return this.isBinary() ? "binary" : "base";
      }
      ast() {
        return this._ast;
      }
      onHeritageAdded(heritage, target) {
        this.resetEnds();
        _internal_1.FeatureMeta.prototype["onHeritageAdded"].call(this, heritage, target);
      }
      onHeritageRemoved(heritage) {
        this.resetEnds();
        _internal_1.FeatureMeta.prototype["onHeritageRemoved"].call(this, heritage);
      }
      featureMembers() {
        return this._ends.concat(_internal_1.FeatureMeta.prototype.featureMembers.call(this));
      }
      contextType() {
        let commonFeaturingTypes;
        const relatedFeatures = this.relatedFeatures();
        const relatedFeatureContext = relatedFeatures.find((f1) => relatedFeatures.some((f2) => f2 !== f1 && (f2 === null || f2 === void 0 ? void 0 : f2.featuredBy.includes(f1))));
        if (relatedFeatureContext)
          return relatedFeatureContext;
        for (const related of this.relatedFeatures()) {
          const featurings = related === null || related === void 0 ? void 0 : related.allFeaturingTypes();
          if (!featurings)
            continue;
          if (!commonFeaturingTypes) {
            commonFeaturingTypes = featurings;
            continue;
          }
          commonFeaturingTypes = commonFeaturingTypes.map((type) => {
            const subtype = featurings.find((t) => t.conforms(type));
            if (subtype)
              return subtype;
            if (featurings.every((t) => !type.conforms(t)))
              return void 0;
            return type;
          }).filter(utils_1.NonNullable);
        }
        return commonFeaturingTypes === null || commonFeaturingTypes === void 0 ? void 0 : commonFeaturingTypes.at(0);
      }
      /**
       * @returns end features of this connector
       */
      connectorEnds() {
        return this.ownedEnds();
      }
      /**
       * @returns features related by this connector
       */
      relatedFeatures() {
        return (0, langium_1.stream)(this.allEnds()).map((end) => end.specializations(ast_1.ReferenceSubsetting).at(0)).nonNullable().map((sub) => sub.element()).toArray();
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        parts.push(["ends", this.ends]);
      }
      static applyConnectorOptions(model, options) {
        if (options.ends)
          model.addEnd(...options.ends);
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          ConnectorMeta_1.applyConnectorOptions(model, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], ConnectorMeta.prototype, "ends", null);
    exports2.ConnectorMeta = ConnectorMeta = ConnectorMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Connector, exports2.ImplicitConnectors)
      // @ts-expect-error stop it with static inheritance errors
    ], ConnectorMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/binding-connector.js
var require_binding_connector = __commonJS({
  "../syside-languageserver/lib/model/KerML/binding-connector.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BindingConnectorMeta = exports2.ImplicitBindingConnectors = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitBindingConnectors = {
      binary: "Links::selfLinks"
    };
    var BindingConnectorMeta = exports2.BindingConnectorMeta = class BindingConnectorMeta extends _internal_1.ConnectorMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.BindingConnectorMeta = BindingConnectorMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.BindingConnector, exports2.ImplicitBindingConnectors)
    ], BindingConnectorMeta);
  }
});

// ../syside-languageserver/lib/model/expressions/range.js
var require_range = __commonJS({
  "../syside-languageserver/lib/model/expressions/range.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RangeGenerator = void 0;
    var RangeGenerator = class {
      constructor(r) {
        var _a;
        this.start = r.start;
        this.stop = r.stop + 1;
        this.step = (_a = r.step) !== null && _a !== void 0 ? _a : 1;
      }
      [Symbol.iterator]() {
        let current = this.start;
        const stop = this.stop;
        const step = this.step;
        return {
          next() {
            if (current >= stop) {
              return {
                done: true,
                value: void 0
              };
            }
            const value = current;
            current += step;
            return {
              done: false,
              value
            };
          }
        };
      }
      toArray() {
        return Array.from(this);
      }
      get length() {
        return Math.max(0, Math.floor((this.stop - this.start + this.step - 1) / this.step));
      }
      at(index) {
        if (index < 0) {
          index += this.length;
          if (index < 0)
            return void 0;
        }
        const value = this.start + index * this.step;
        return value >= this.stop ? void 0 : value;
      }
      some(predicate) {
        for (const v of this)
          if (predicate(v))
            return true;
        return false;
      }
      every(predicate) {
        for (const v of this)
          if (!predicate(v))
            return false;
        return true;
      }
    };
    exports2.RangeGenerator = RangeGenerator;
  }
});

// ../syside-languageserver/lib/model/expressions/util.js
var require_util2 = __commonJS({
  "../syside-languageserver/lib/model/expressions/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalize = exports2.typeOf = exports2.typeFor = exports2.resultType = exports2.isMetaclassFeature = exports2.metaclassReferenceOf = exports2.hasType = exports2.isType = exports2.typeArgument = exports2.isModelLevelEvaluable = exports2.builtinFunction = exports2.functionFor = exports2.OPERATOR_FUNCTIONS = exports2.BUILTIN_FUNCTIONS = exports2.BuiltinFunction = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var naming_1 = require_naming();
    var range_1 = require_range();
    var BuiltinFunction = class {
      get isModelLevelEvaluable() {
        return true;
      }
    };
    exports2.BuiltinFunction = BuiltinFunction;
    exports2.BUILTIN_FUNCTIONS = {};
    exports2.OPERATOR_FUNCTIONS = {};
    function functionFor(pack, operators) {
      const functions = [];
      const add = (op) => {
        const name = (0, naming_1.concatNames)(pack, op);
        if (op.startsWith("'"))
          exports2.OPERATOR_FUNCTIONS[op] = name;
        functions.push(name);
      };
      if (typeof operators === "string")
        add(operators);
      else
        operators.forEach((op) => add(op));
      return function(target) {
        for (const f of functions) {
          exports2.BUILTIN_FUNCTIONS[f] = new target();
        }
      };
    }
    exports2.functionFor = functionFor;
    function builtinFunction(fn) {
      if (typeof fn === "string")
        return exports2.BUILTIN_FUNCTIONS[fn];
      return exports2.BUILTIN_FUNCTIONS[fn.qualifiedName];
    }
    exports2.builtinFunction = builtinFunction;
    function isModelLevelEvaluable(fn) {
      var _a;
      return ((_a = builtinFunction(fn)) === null || _a === void 0 ? void 0 : _a.isModelLevelEvaluable) === true;
    }
    exports2.isModelLevelEvaluable = isModelLevelEvaluable;
    function typeArgument(expr) {
      const arg = expr.ownedFeatures().tail(Math.max(0, 1 - expr.operands.length)).head();
      if (arg === null || arg === void 0 ? void 0 : arg.is(ast_1.Type)) {
        return arg.types().head();
      }
      return;
    }
    exports2.typeArgument = typeArgument;
    function isType(node, type) {
      if (!(0, metamodel_1.isMetamodel)(node))
        return false;
      if (node.is(ast_1.Type))
        return node === type || node.allTypes().includes(type);
      if (node.is(ast_1.LiteralExpression)) {
        return node.returnType() === type.qualifiedName;
      }
      return false;
    }
    exports2.isType = isType;
    function hasType(node, type) {
      if (!(0, metamodel_1.isMetamodel)(node))
        return false;
      if (node.is(ast_1.Type))
        return node === type || node.types().includes(type);
      if (node.is(ast_1.LiteralExpression)) {
        return node.returnType() === type.qualifiedName;
      }
      return false;
    }
    exports2.hasType = hasType;
    function metaclassReferenceOf(element) {
      if (!element.is(ast_1.MetadataFeature))
        return;
      return element.annotatedElements().find((node) => node.metaclass === element);
    }
    exports2.metaclassReferenceOf = metaclassReferenceOf;
    function isMetaclassFeature(element) {
      return metaclassReferenceOf(element) !== void 0;
    }
    exports2.isMetaclassFeature = isMetaclassFeature;
    function resultType(value) {
      if (typeof value === "boolean")
        return "ScalarValues::Boolean";
      if (typeof value === "string")
        return "ScalarValues::String";
      if (typeof value === "number")
        return Number.isInteger(value) ? "ScalarValues::Integer" : "ScalarValues::Rational";
      if (value === null || value === void 0 ? void 0 : value.isAny(ast_1.InlineExpression, ast_1.Expression))
        return value.returnType();
      if (value === null || value === void 0 ? void 0 : value.is(ast_1.Type))
        return value;
      return;
    }
    exports2.resultType = resultType;
    function typeFor(result) {
      if (!result || result.length === 0)
        return;
      const types = [];
      for (const value of result) {
        const type = resultType(value);
        if (type)
          types.push(type);
      }
      return types;
    }
    exports2.typeFor = typeFor;
    function typeOf(arg) {
      var _a;
      if (!arg)
        return;
      if (arg.value)
        return (_a = arg.value.element()) === null || _a === void 0 ? void 0 : _a.returnType();
      if (arg.isAny(ast_1.Expression, ast_1.SysMLFunction))
        return arg.returnType();
      return arg;
    }
    exports2.typeOf = typeOf;
    function normalize(values) {
      if (values instanceof range_1.RangeGenerator) {
        if (values.length > 1e9)
          throw new Error(`Range too large: ${values.length}`);
        return values.toArray();
      }
      return values;
    }
    exports2.normalize = normalize;
  }
});

// ../syside-languageserver/lib/model/KerML/function.js
var require_function2 = __commonJS({
  "../syside-languageserver/lib/model/KerML/function.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var FunctionMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FunctionMeta = exports2.ImplicitFunctions = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var util_1 = require_util2();
    var metamodel_1 = require_metamodel();
    var function_1 = require_function();
    var _internal_1 = require_internal();
    var utils_1 = require_utils2();
    exports2.ImplicitFunctions = {
      base: "Performances::Evaluation"
    };
    var FunctionMeta = exports2.FunctionMeta = FunctionMeta_1 = class FunctionMeta extends (0, ts_mixer_1.Mixin)(_internal_1.BehaviorMeta, function_1.FunctionMixin) {
      get result() {
        return this._result;
      }
      set result(value) {
        this._result = this.swapEdgeOwnership(this._result, value);
      }
      ast() {
        return this._ast;
      }
      /**
       * @returns fully qualified name or AST node of the return type of this
       * expression if one can be inferred, undefined otherwise
       */
      returnType() {
        return this.getReturnType(this);
      }
      isModelLevelEvaluable() {
        return (0, util_1.isModelLevelEvaluable)(this.qualifiedName);
      }
      collectParts() {
        const parts = _internal_1.BehaviorMeta.prototype["collectParts"].call(this);
        if (this._result)
          parts.push(["result", [this._result]]);
        return parts;
      }
      static applyFunctionOptions(model, options) {
        model.result = options.result;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          FunctionMeta_1.applyFunctionOptions(model, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], FunctionMeta.prototype, "result", null);
    exports2.FunctionMeta = FunctionMeta = FunctionMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.SysMLFunction, exports2.ImplicitFunctions)
    ], FunctionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/item-feature.js
var require_item_feature = __commonJS({
  "../syside-languageserver/lib/model/KerML/item-feature.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ItemFeatureMeta = exports2.ItemFeatureImplicits = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ItemFeatureImplicits = {
      payload: "Transfers::Transfer::item"
    };
    var ItemFeatureMeta = exports2.ItemFeatureMeta = class ItemFeatureMeta extends _internal_1.FeatureMeta {
      ast() {
        return this._ast;
      }
      defaultSupertype() {
        return "payload";
      }
      specializationKind() {
        return ast_1.Redefinition;
      }
    };
    exports2.ItemFeatureMeta = ItemFeatureMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ItemFeature, exports2.ItemFeatureImplicits)
    ], ItemFeatureMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/item-flow.js
var require_item_flow = __commonJS({
  "../syside-languageserver/lib/model/KerML/item-flow.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var ItemFlowMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ItemFlowMeta = exports2.ImplicitItemFlows = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var utils_1 = require_utils2();
    exports2.ImplicitItemFlows = {
      base: "Transfers::flowTransfers",
      enclosedPerformance: "Performances::Performance::enclosedPerformances",
      subperformance: "Performances::Performance::subperformances",
      ownedPerformance: "Objects::Object::ownedPerformances"
    };
    var ItemFlowMeta = exports2.ItemFlowMeta = ItemFlowMeta_1 = class ItemFlowMeta extends (0, ts_mixer_1.Mixin)(_internal_1.StepMeta, _internal_1.ConnectorMeta) {
      get item() {
        return this._item;
      }
      set item(value) {
        this._item = this.swapEdgeOwnership(this._item, value);
      }
      ast() {
        return this._ast;
      }
      defaultGeneralTypes() {
        const supertypes = super.defaultGeneralTypes();
        if (this.isStructureOwnedComposite())
          supertypes.push("ownedPerformance");
        if (this.isBehaviorOwnedComposite())
          supertypes.push("subperformance");
        if (this.isBehaviorOwned())
          supertypes.push("enclosedPerformance");
        return supertypes;
      }
      defaultSupertype() {
        return "base";
      }
      /**
       * @returns owned item flow ends of this item flow
       */
      itemFlowEnds() {
        return this.ownedEnds().filter(metamodel_1.BasicMetamodel.is(ast_1.ItemFlowEnd));
      }
      featureMembers() {
        const baseFeatures = _internal_1.ConnectorMeta.prototype.featureMembers.call(this);
        if (!this._item)
          return baseFeatures;
        return [this._item].concat(baseFeatures);
      }
      collectDeclaration(parts) {
        _internal_1.StepMeta.prototype["collectDeclaration"].call(this, parts);
        if (this._item) {
          parts.push(["item", [this._item]]);
        }
        parts.push(["ends", this.ends]);
      }
      static applyItemFlowOptions(model, options) {
        model.item = options.item;
      }
      static create(provider, document, options) {
        const model = _internal_1.ConnectorMeta.create.call(this, provider, document, options);
        if (options)
          ItemFlowMeta_1.applyItemFlowOptions(model, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], ItemFlowMeta.prototype, "item", null);
    exports2.ItemFlowMeta = ItemFlowMeta = ItemFlowMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ItemFlow, exports2.ImplicitItemFlows)
    ], ItemFlowMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/item-flow-end.js
var require_item_flow_end = __commonJS({
  "../syside-languageserver/lib/model/KerML/item-flow-end.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ItemFlowEndMeta = exports2.ImplicitItemFlowEnds = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitItemFlowEnds = {
      sourceOutput: "Transfers::Transfer::source::sourceOutput",
      targetInput: "Transfers::Transfer::target::targetInput"
    };
    var ItemFlowEndMeta = exports2.ItemFlowEndMeta = class ItemFlowEndMeta extends _internal_1.FeatureMeta {
      get isEnd() {
        return true;
      }
      set isEnd(value) {
      }
      get isEndExplicitly() {
        return false;
      }
      ast() {
        return this._ast;
      }
    };
    exports2.ItemFlowEndMeta = ItemFlowEndMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ItemFlowEnd, exports2.ImplicitItemFlowEnds)
    ], ItemFlowEndMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/metadata-feature.js
var require_metadata_feature = __commonJS({
  "../syside-languageserver/lib/model/KerML/metadata-feature.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetadataFeatureMeta = exports2.ImplicitMetadataFeatures = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitMetadataFeatures = {
      base: "Metaobjects::metaobjects",
      annotatedElement: "Metaobjects::Metaobject::annotatedElement",
      baseType: "Metaobjects::SemanticMetadata::baseType"
      // TODO
    };
    var MetadataFeatureMeta = exports2.MetadataFeatureMeta = class MetadataFeatureMeta extends (0, ts_mixer_1.Mixin)(_internal_1.AnnotatingElementMeta, _internal_1.FeatureMeta) {
      ast() {
        return this._ast;
      }
      defaultSupertype() {
        return "base";
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        parts.push(["about", this._annotations]);
      }
      static create(provider, document, options) {
        const model = _internal_1.FeatureMeta.create.call(this, provider, document, options);
        if (options) {
          _internal_1.AnnotatingElementMeta.applyAnnotatingElementOptions(model, options);
        }
        return model;
      }
    };
    exports2.MetadataFeatureMeta = MetadataFeatureMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.MetadataFeature, exports2.ImplicitMetadataFeatures)
    ], MetadataFeatureMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/succession.js
var require_succession = __commonJS({
  "../syside-languageserver/lib/model/KerML/succession.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SuccessionMeta = exports2.ImplicitSuccessions = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitSuccessions = {
      binary: "Occurrences::happensBeforeLinks"
    };
    var SuccessionMeta = exports2.SuccessionMeta = class SuccessionMeta extends _internal_1.ConnectorMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.SuccessionMeta = SuccessionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Succession, exports2.ImplicitSuccessions)
    ], SuccessionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/succession-item-flow.js
var require_succession_item_flow = __commonJS({
  "../syside-languageserver/lib/model/KerML/succession-item-flow.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SuccessionItemFlowMeta = exports2.ImplicitSuccessionItemFlows = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitSuccessionItemFlows = {
      base: "Transfers::flowTransfersBefore",
      enclosedperformance: "Performances::Performance::enclosedPerformances",
      subperformance: "Performances::Performance::subperformances",
      ownedPerformance: "Objects::Object::ownedPerformances"
    };
    var SuccessionItemFlowMeta = exports2.SuccessionItemFlowMeta = class SuccessionItemFlowMeta extends (0, ts_mixer_1.Mixin)(_internal_1.ItemFlowMeta, _internal_1.SuccessionMeta) {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        const model = _internal_1.SuccessionMeta.create.call(this, provider, document, options);
        if (options)
          _internal_1.ItemFlowMeta.applyItemFlowOptions(model, options);
        return model;
      }
    };
    exports2.SuccessionItemFlowMeta = SuccessionItemFlowMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.SuccessionItemFlow, exports2.ImplicitSuccessionItemFlows)
    ], SuccessionItemFlowMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expression.js
var require_expression = __commonJS({
  "../syside-languageserver/lib/model/KerML/expression.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var ExpressionMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExpressionMeta = exports2.ImplicitExpressions = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var util_1 = require_util2();
    var metamodel_1 = require_metamodel();
    var function_1 = require_function();
    var _internal_1 = require_internal();
    var common_1 = require_common();
    exports2.ImplicitExpressions = {
      base: "Performances::evaluations",
      enclosedPerformance: "Performances::Performance::enclosedPerformances"
    };
    var ExpressionMeta = exports2.ExpressionMeta = ExpressionMeta_1 = class ExpressionMeta extends (0, ts_mixer_1.Mixin)(_internal_1.StepMeta, function_1.FunctionMixin) {
      get result() {
        return this._result;
      }
      set result(value) {
        this._result = this.swapEdgeOwnership(this._result, value);
      }
      get featuredBy() {
        var _a;
        const featurings = super.typeFeaturings;
        if (featurings.length > 0)
          return featurings.map((f) => f.element()).filter(common_1.NonNullable);
        const owner = this.owner();
        if ((owner === null || owner === void 0 ? void 0 : owner.is(ast_1.Multiplicity)) || ((_a = this.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.FeatureValue))) {
          return owner.featuredBy;
        }
        return this._owningType ? [this._owningType] : [];
      }
      defaultGeneralTypes() {
        const supertypes = super.defaultGeneralTypes();
        if (this.isStructureOwnedComposite())
          supertypes.push("ownedPerformance");
        if (this.isBehaviorOwnedComposite())
          supertypes.push("subperformance");
        if (this.isBehaviorOwned())
          supertypes.push("enclosedPerformance");
        return supertypes;
      }
      defaultSupertype() {
        return "base";
      }
      ast() {
        return this._ast;
      }
      /**
       * @returns fully qualified name or AST node of the return type of this
       * expression if one can be inferred, undefined otherwise
       */
      returnType() {
        return this.getReturnType(this);
      }
      getFunction() {
        return this.qualifiedName;
      }
      isModelLevelEvaluable() {
        const fn = this.getFunction();
        return fn ? (0, util_1.isModelLevelEvaluable)(fn) : false;
      }
      collectParts() {
        const parts = _internal_1.StepMeta.prototype["collectParts"].call(this);
        if (this._result)
          parts.push(["result", [this._result]]);
        return parts;
      }
      static applyExpressionOptions(model, options) {
        model.result = options.result;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          ExpressionMeta_1.applyExpressionOptions(model, options);
        return model;
      }
    };
    __decorate([
      common_1.enumerable
    ], ExpressionMeta.prototype, "result", null);
    exports2.ExpressionMeta = ExpressionMeta = ExpressionMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Expression, exports2.ImplicitExpressions)
    ], ExpressionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/predicate.js
var require_predicate = __commonJS({
  "../syside-languageserver/lib/model/KerML/predicate.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PredicateMeta = exports2.ImplicitPredicates = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitPredicates = {
      base: "Performances::BooleanEvaluation"
    };
    var PredicateMeta = exports2.PredicateMeta = class PredicateMeta extends _internal_1.FunctionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.PredicateMeta = PredicateMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Predicate, exports2.ImplicitPredicates)
    ], PredicateMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/boolean-expression.js
var require_boolean_expression = __commonJS({
  "../syside-languageserver/lib/model/KerML/boolean-expression.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BooleanExpressionMeta = exports2.ImplicitBooleanExpressions = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitBooleanExpressions = {
      base: "Performances::booleanEvaluations"
    };
    var BooleanExpressionMeta = exports2.BooleanExpressionMeta = class BooleanExpressionMeta extends _internal_1.ExpressionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.BooleanExpressionMeta = BooleanExpressionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.BooleanExpression, exports2.ImplicitBooleanExpressions)
    ], BooleanExpressionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/invariant.js
var require_invariant = __commonJS({
  "../syside-languageserver/lib/model/KerML/invariant.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var InvariantMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvariantMeta = exports2.ImplicitInvariants = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitInvariants = {
      base: "Performances::trueEvaluations",
      negated: "Performances::falseEvaluations"
    };
    var InvariantMeta = exports2.InvariantMeta = InvariantMeta_1 = class InvariantMeta extends _internal_1.BooleanExpressionMeta {
      constructor() {
        super(...arguments);
        this.isNegated = false;
      }
      ast() {
        return this._ast;
      }
      defaultSupertype() {
        return this.isNegated ? "negated" : "base";
      }
      static applyInvariantOptions(model, options) {
        model.isNegated = Boolean(options.isNegated);
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          InvariantMeta_1.applyInvariantOptions(model, options);
        return model;
      }
    };
    exports2.InvariantMeta = InvariantMeta = InvariantMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Invariant, exports2.ImplicitInvariants)
    ], InvariantMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/inheritance.js
var require_inheritance = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/inheritance.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InheritanceMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var InheritanceMeta = exports2.InheritanceMeta = class InheritanceMeta extends _internal_1.RelationshipMeta {
      /**
       * Adds new owned body elements and returns the new number of body elements.
       */
      addChild(...element) {
        return this.addOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements and returns the new number of body elements.
       */
      removeChild(...element) {
        return this.removeOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements by predicate and returns the new number of
       * body elements.
       */
      removeChildIf(predicate) {
        return this.removeOwnedElementsIf(this._children, predicate);
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.InheritanceMeta = InheritanceMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Inheritance, "abstract")
    ], InheritanceMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/specialization.js
var require_specialization = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/specialization.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SpecializationMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var inheritance_1 = require_inheritance();
    var SpecializationMeta = exports2.SpecializationMeta = class SpecializationMeta extends inheritance_1.InheritanceMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.SpecializationMeta = SpecializationMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Specialization)
    ], SpecializationMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/subsetting.js
var require_subsetting = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/subsetting.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SubsettingMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var SubsettingMeta = exports2.SubsettingMeta = class SubsettingMeta extends _internal_1.SpecializationMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.SubsettingMeta = SubsettingMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Subsetting)
      // @ts-expect-error ignoring static inheritance error
    ], SubsettingMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/redefinition.js
var require_redefinition = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/redefinition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RedefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var RedefinitionMeta = exports2.RedefinitionMeta = class RedefinitionMeta extends _internal_1.SubsettingMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.RedefinitionMeta = RedefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Redefinition)
    ], RedefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/reference-subsetting.js
var require_reference_subsetting = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/reference-subsetting.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReferenceSubsettingMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var ReferenceSubsettingMeta = exports2.ReferenceSubsettingMeta = class ReferenceSubsettingMeta extends _internal_1.SubsettingMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.ReferenceSubsettingMeta = ReferenceSubsettingMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ReferenceSubsetting)
    ], ReferenceSubsettingMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/subclassification.js
var require_subclassification = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/subclassification.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SubclassificationMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var SubclassificationMeta = exports2.SubclassificationMeta = class SubclassificationMeta extends _internal_1.SpecializationMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.SubclassificationMeta = SubclassificationMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Subclassification)
      // @ts-expect-error ignoring static inheritance error
    ], SubclassificationMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/feature-typing.js
var require_feature_typing = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/feature-typing.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FeatureTypingMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var FeatureTypingMeta = exports2.FeatureTypingMeta = class FeatureTypingMeta extends _internal_1.SpecializationMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.FeatureTypingMeta = FeatureTypingMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.FeatureTyping)
      // @ts-expect-error ignoring static inheritance error
    ], FeatureTypingMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/conjugation.js
var require_conjugation = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/conjugation.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConjugationMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var inheritance_1 = require_inheritance();
    var ConjugationMeta = exports2.ConjugationMeta = class ConjugationMeta extends inheritance_1.InheritanceMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.ConjugationMeta = ConjugationMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Conjugation)
    ], ConjugationMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/invocation-expression.js
var require_invocation_expression = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/invocation-expression.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvocationExpressionMeta = void 0;
    var ast_1 = require_ast2();
    var common_1 = require_common();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var InvocationExpressionMeta = exports2.InvocationExpressionMeta = class InvocationExpressionMeta extends _internal_1.ExpressionMeta {
      constructor() {
        super(...arguments);
        this._args = [];
        this._operands = [];
      }
      /**
       * Cached version of {@link arguments} that is populated during model build
       * time
       */
      get args() {
        return this._args;
      }
      get operands() {
        return this._operands;
      }
      argumentMembers() {
        return this._children.get(ast_1.ParameterMembership).map((m) => m.element());
      }
      arguments() {
        return [
          ...this.operands,
          ...this.argumentMembers().map((f) => {
            var _a;
            return (_a = f.value) === null || _a === void 0 ? void 0 : _a.element();
          }).filter(common_1.NonNullable)
        ];
      }
      isModelLevelEvaluable() {
        var _a;
        if ((_a = this.invokes()) === null || _a === void 0 ? void 0 : _a.isAny(ast_1.Expression, ast_1.SysMLFunction))
          return super.isModelLevelEvaluable() && this.args.every((p) => p.isModelLevelEvaluable);
        return this.args.every((p) => p.isModelLevelEvaluable);
      }
      ast() {
        return this._ast;
      }
      invokes() {
        return this.types().head();
      }
      /**
       * @returns fully qualified name of the invoked function
       */
      getFunction() {
        var _a;
        return (_a = this.invokes()) === null || _a === void 0 ? void 0 : _a.qualifiedName;
      }
      returnType() {
        const type = this.invokes();
        if (type === null || type === void 0 ? void 0 : type.isAny(ast_1.Expression, ast_1.SysMLFunction))
          return type.returnType();
        return type;
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        parts.push(["operands", this.operands]);
      }
    };
    __decorate([
      common_1.enumerable
    ], InvocationExpressionMeta.prototype, "operands", null);
    exports2.InvocationExpressionMeta = InvocationExpressionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.InvocationExpression)
    ], InvocationExpressionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/operator-expression.js
var require_operator_expression = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/operator-expression.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OperatorExpressionMeta = exports2.IMPLICIT_OPERATORS = exports2.OPERATORS = void 0;
    var ast_1 = require_ast2();
    var util_1 = require_util2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.OPERATORS = {
      IF: "'if'",
      NULL_COALESCING: "'??'",
      IMPLIES: "'implies'",
      OR: "'or'",
      BITWISE_OR: "'|'",
      XOR: "'xor'",
      AND: "'and'",
      BITWISE_AND: "'&'",
      EQUALS: "'=='",
      SAME: "'==='",
      NOT_EQUALS: "'!='",
      NOT_SAME: "'!=='",
      IS_TYPE: "'istype'",
      HAS_TYPE: "'hastype'",
      AT: "'@'",
      AT_AT: "'@@'",
      AS: "'as'",
      META: "'meta'",
      LESS: "'<'",
      LESS_EQUAL: "'<='",
      GREATER: "'>'",
      GREATER_EQUAL: "'>='",
      RANGE: "'..'",
      PLUS: "'+'",
      MINUS: "'-'",
      MULTIPLY: "'*'",
      DIVIDE: "'/'",
      MODULO: "'%'",
      EXPONENT_1: "'**'",
      EXPONENT_2: "'^'",
      BITWISE_NOT: "'~'",
      NOT: "'not'",
      ALL: "'all'",
      QUANTITY: "'['",
      COMMA: "','",
      NONE: ""
    };
    exports2.IMPLICIT_OPERATORS = {
      INDEX: "'#'",
      DOT: "'.'",
      COLLECT: "collect",
      SELECT: "'.?'",
      METADATA: "'.metadata'"
    };
    var OperatorExpressionMeta = exports2.OperatorExpressionMeta = class OperatorExpressionMeta extends _internal_1.InvocationExpressionMeta {
      constructor() {
        super(...arguments);
        this._operator = exports2.OPERATORS.NONE;
      }
      get operator() {
        return this._operator;
      }
      set operator(value) {
        this._operator = value;
      }
      ast() {
        return this._ast;
      }
      getFunction() {
        return util_1.OPERATOR_FUNCTIONS[this.operator];
      }
      returnType() {
        var _a;
        if (this.operator === exports2.OPERATORS.AS || this.operator === exports2.OPERATORS.META) {
          return (0, util_1.typeArgument)(this);
        }
        if (this.operator === exports2.IMPLICIT_OPERATORS.INDEX) {
          return (0, util_1.typeOf)(this.args[0]);
        }
        if (this.operator === exports2.OPERATORS.QUANTITY) {
          return "Quantities::ScalarQuantityValue";
        }
        const result = this.resultParameter();
        if (result)
          return (_a = result.element()) === null || _a === void 0 ? void 0 : _a.returnType();
        const returns = this.returnParameter();
        if (returns)
          return returns.element();
        return super.returnType();
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options === null || options === void 0 ? void 0 : options.operator)
          model.operator = options.operator;
        return model;
      }
    };
    exports2.OperatorExpressionMeta = OperatorExpressionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.OperatorExpression)
    ], OperatorExpressionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/collect-expression.js
var require_collect_expression = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/collect-expression.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CollectExpressionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var CollectExpressionMeta = exports2.CollectExpressionMeta = class CollectExpressionMeta extends _internal_1.OperatorExpressionMeta {
      get operator() {
        return _internal_1.IMPLICIT_OPERATORS.COLLECT;
      }
      ast() {
        return this._ast;
      }
      getFunction() {
        return "ControlFunctions::collect";
      }
    };
    exports2.CollectExpressionMeta = CollectExpressionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.CollectExpression)
    ], CollectExpressionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/select-expression.js
var require_select_expression = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/select-expression.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectExpressionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var SelectExpressionMeta = exports2.SelectExpressionMeta = class SelectExpressionMeta extends _internal_1.OperatorExpressionMeta {
      ast() {
        return this._ast;
      }
      getFunction() {
        return "ControlFunctions::select";
      }
    };
    exports2.SelectExpressionMeta = SelectExpressionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.SelectExpression)
    ], SelectExpressionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/feature-chain-expression.js
var require_feature_chain_expression = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/feature-chain-expression.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FeatureChainExpressionMeta = exports2.ImplicitFeatureChainExpressions = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitFeatureChainExpressions = {
      target: "ControlFunctions::'.'::source::target"
      // TODO
    };
    var FeatureChainExpressionMeta = exports2.FeatureChainExpressionMeta = class FeatureChainExpressionMeta extends _internal_1.OperatorExpressionMeta {
      targetFeature() {
        var _a;
        const target = (_a = this._children.get(ast_1.Membership).at(Math.max(0, 1 - this.operands.length))) === null || _a === void 0 ? void 0 : _a.element();
        return (target === null || target === void 0 ? void 0 : target.is(ast_1.Feature)) ? target : void 0;
      }
      ast() {
        return this._ast;
      }
      getFunction() {
        return "ControlFunctions::'.'";
      }
      returnType() {
        var _a;
        return (_a = this.targetFeature()) === null || _a === void 0 ? void 0 : _a.basicFeature();
      }
    };
    exports2.FeatureChainExpressionMeta = FeatureChainExpressionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.FeatureChainExpression, exports2.ImplicitFeatureChainExpressions)
    ], FeatureChainExpressionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/feature-reference-expression.js
var require_feature_reference_expression = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/feature-reference-expression.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FeatureReferenceExpressionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var FeatureReferenceExpressionMeta = exports2.FeatureReferenceExpressionMeta = class FeatureReferenceExpressionMeta extends _internal_1.ExpressionMeta {
      /**
       * Membership to the feature this expression evaluates as
       */
      get expression() {
        return this._expression;
      }
      /**
       * Takes ownership of the membership and breaks its ownership to the
       * previous expression membership. Use `FeatureMembership` to return the
       * target directly, otherwise the target will be evaluated.
       */
      set expression(value) {
        this._expression = this.swapEdgeOwnership(this._expression, value);
      }
      ast() {
        return this._ast;
      }
      returnType() {
        var _a, _b;
        const expr = (_a = this.expression) === null || _a === void 0 ? void 0 : _a.element();
        if (!expr || !((_b = this.expression) === null || _b === void 0 ? void 0 : _b.is(ast_1.FeatureMembership)))
          return expr;
        if (expr.isAny(ast_1.Expression, ast_1.SysMLFunction))
          return expr.returnType();
        return expr;
      }
      isModelLevelEvaluable() {
        return true;
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        if (this.expression)
          parts.push(["expression", [this.expression]]);
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          model.expression = options.expression;
        return model;
      }
    };
    exports2.FeatureReferenceExpressionMeta = FeatureReferenceExpressionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.FeatureReferenceExpression)
    ], FeatureReferenceExpressionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/literal-expression.js
var require_literal_expression = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/literal-expression.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LiteralExpressionMeta = exports2.ImplicitLiteralExpressions = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitLiteralExpressions = {
      base: "Performances::literalIntegerEvaluations"
    };
    var LiteralExpressionMeta = exports2.LiteralExpressionMeta = class LiteralExpressionMeta extends _internal_1.ExpressionMeta {
      ast() {
        return this._ast;
      }
      isModelLevelEvaluable() {
        return true;
      }
      static create(provider, document, options) {
        return super.create(provider, document, Object.assign(Object.assign({}, options), { value: void 0 }));
      }
    };
    exports2.LiteralExpressionMeta = LiteralExpressionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.LiteralExpression, exports2.ImplicitLiteralExpressions)
    ], LiteralExpressionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/literal-boolean.js
var require_literal_boolean = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/literal-boolean.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LiteralBooleanMeta = exports2.ImplicitLiteralBooleans = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitLiteralBooleans = {
      base: "Performances::literalBooleanEvaluations"
    };
    var LiteralBooleanMeta = exports2.LiteralBooleanMeta = class LiteralBooleanMeta extends _internal_1.LiteralExpressionMeta {
      constructor() {
        super(...arguments);
        this.literal = false;
      }
      ast() {
        return this._ast;
      }
      returnType() {
        return "ScalarValues::Boolean";
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        model.literal = Boolean(options === null || options === void 0 ? void 0 : options.value);
        return model;
      }
    };
    exports2.LiteralBooleanMeta = LiteralBooleanMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.LiteralBoolean, exports2.ImplicitLiteralBooleans)
    ], LiteralBooleanMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/literal-infinity.js
var require_literal_infinity = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/literal-infinity.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LiteralInfinityMeta = exports2.ImplicitLiteralInfinities = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitLiteralInfinities = {
      base: "Performances::literalIntegerEvaluations"
    };
    var LiteralInfinityMeta = exports2.LiteralInfinityMeta = class LiteralInfinityMeta extends _internal_1.LiteralExpressionMeta {
      ast() {
        return this._ast;
      }
      returnType() {
        return "ScalarValues::Positive";
      }
    };
    exports2.LiteralInfinityMeta = LiteralInfinityMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.LiteralInfinity, exports2.ImplicitLiteralInfinities)
    ], LiteralInfinityMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/literal-number.js
var require_literal_number = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/literal-number.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LiteralNumberMeta = exports2.ImplicitLiteralNumbers = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitLiteralNumbers = {
      // can't parse ints and reals into separate node
      integer: "Performances::literalIntegerEvaluations",
      real: "Performances::literalRationalEvaluations"
    };
    var LiteralNumberMeta = exports2.LiteralNumberMeta = class LiteralNumberMeta extends _internal_1.LiteralExpressionMeta {
      constructor() {
        super(...arguments);
        this._isInteger = true;
        this._literal = 0;
      }
      get literal() {
        return this._literal;
      }
      set literal(value) {
        this._literal = value;
        this._isInteger = Number.isInteger(value);
      }
      get isInteger() {
        return this._isInteger;
      }
      defaultSupertype() {
        return this.isInteger ? "integer" : "real";
      }
      ast() {
        return this._ast;
      }
      returnType() {
        return this.isInteger ? "ScalarValues::Rational" : "ScalarValues::Integer";
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options === null || options === void 0 ? void 0 : options.value)
          model.literal = options.value;
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], LiteralNumberMeta.prototype, "literal", null);
    exports2.LiteralNumberMeta = LiteralNumberMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.LiteralNumber, exports2.ImplicitLiteralNumbers)
    ], LiteralNumberMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/literal-string.js
var require_literal_string = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/literal-string.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LiteralStringMeta = exports2.ImplicitLiteralStrings = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitLiteralStrings = {
      base: "Performances::literalStringEvaluations"
    };
    var LiteralStringMeta = exports2.LiteralStringMeta = class LiteralStringMeta extends _internal_1.LiteralExpressionMeta {
      constructor() {
        super(...arguments);
        this.literal = "";
      }
      ast() {
        return this._ast;
      }
      returnType() {
        return "ScalarValues::String";
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options === null || options === void 0 ? void 0 : options.value)
          model.literal = options.value;
        return model;
      }
    };
    exports2.LiteralStringMeta = LiteralStringMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.LiteralString, exports2.ImplicitLiteralStrings)
    ], LiteralStringMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/metadata-access-expression.js
var require_metadata_access_expression = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/metadata-access-expression.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetadataAccessExpressionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var utils_1 = require_utils2();
    var MetadataAccessExpressionMeta = exports2.MetadataAccessExpressionMeta = class MetadataAccessExpressionMeta extends _internal_1.ExpressionMeta {
      get reference() {
        return this._reference;
      }
      set reference(value) {
        this._reference = value;
      }
      ast() {
        return this._ast;
      }
      returnType() {
        return "Metaobjects::Metaobject";
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        model._reference = options === null || options === void 0 ? void 0 : options.reference;
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], MetadataAccessExpressionMeta.prototype, "reference", null);
    exports2.MetadataAccessExpressionMeta = MetadataAccessExpressionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.MetadataAccessExpression)
    ], MetadataAccessExpressionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/null-expression.js
var require_null_expression = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/null-expression.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NullExpressionMeta = exports2.ImplicitNullExpressions = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitNullExpressions = {
      base: "Performances::nullEvaluations"
    };
    var NullExpressionMeta = exports2.NullExpressionMeta = class NullExpressionMeta extends _internal_1.ExpressionMeta {
      ast() {
        return this._ast;
      }
      returnType() {
        return void 0;
      }
      isModelLevelEvaluable() {
        return true;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.NullExpressionMeta = NullExpressionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.NullExpression, exports2.ImplicitNullExpressions)
    ], NullExpressionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/dependency.js
var require_dependency = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/dependency.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DependencyMeta = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var DependencyMeta = exports2.DependencyMeta = class DependencyMeta extends _internal_1.RelationshipMeta {
      constructor() {
        super(...arguments);
        this._prefixes = [];
        this._client = [];
        this._supplier = [];
      }
      get metadata() {
        return (0, langium_1.stream)(this._prefixes).map((m) => m.element()).filter(utils_1.NonNullable).concat(super.metadata);
      }
      /**
       * Metadata prefixes of this elements
       */
      get prefixes() {
        return this._prefixes;
      }
      /**
       * Adds new owned metadata prefixes and return the new number of prefixes.
       * Note that the annotations take ownership of the metadata.
       */
      addPrefix(...prefix) {
        return this.addOwnedElements(this._prefixes, prefix.map(([edge, target]) => {
          edge["setSource"](target);
          edge["takeOwnership"](target);
          return edge;
        }));
      }
      /**
       * Removes metadata prefixes by their annotations and returns the new number
       * of prefixes.
       */
      removePrefix(...prefix) {
        return this.removeOwnedElements(this._prefixes, prefix, (annotation) => {
          const target = annotation.source();
          if (target)
            annotation["unsetOwnership"](target);
        });
      }
      /**
       * Removes metadata prefixes by a predicate and returns the new number of
       * prefixes.
       * @see {@link removePrefix}
       */
      removePrefixIf(predicate) {
        return this.removeOwnedElementsIf(this._prefixes, predicate);
      }
      /**
       * Adds new owned body elements and returns the new number of body elements.
       */
      addChild(...element) {
        return this.addOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements and returns the new number of body elements.
       */
      removeChild(...element) {
        return this.removeOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements by predicate and returns the new number of
       * body elements.
       */
      removeChildIf(predicate) {
        return this.removeOwnedElementsIf(this._children, predicate);
      }
      get client() {
        return this._client;
      }
      source() {
        return this._client.at(0);
      }
      get supplier() {
        return this._supplier;
      }
      element() {
        return this._supplier.at(0);
      }
      ast() {
        return this._ast;
      }
      collectParts() {
        return [
          ["prefixes", this.prefixes],
          ["children", this.children]
        ];
      }
      static create(provider, document, options) {
        const model = _internal_1.ElementMeta.create.call(this, provider, document, options);
        if (options) {
          model._client.push(...options.client);
          model._supplier.push(...options.supplier);
          if (options.prefixes)
            model.addPrefix(...options.prefixes);
        }
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], DependencyMeta.prototype, "prefixes", null);
    __decorate([
      utils_1.enumerable
    ], DependencyMeta.prototype, "client", null);
    __decorate([
      utils_1.enumerable
    ], DependencyMeta.prototype, "supplier", null);
    exports2.DependencyMeta = DependencyMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Dependency)
      // @ts-expect-error ignore static inheritance warning why is it even a thing???
    ], DependencyMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/featuring.js
var require_featuring = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/featuring.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FeaturingMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var FeaturingMeta = exports2.FeaturingMeta = class FeaturingMeta extends _internal_1.RelationshipMeta {
      /**
       * Adds new owned body elements and returns the new number of body elements.
       */
      addChild(...element) {
        return this.addOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements and returns the new number of body elements.
       */
      removeChild(...element) {
        return this.removeOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements by predicate and returns the new number of
       * body elements.
       */
      removeChildIf(predicate) {
        return this.removeOwnedElementsIf(this._children, predicate);
      }
      ast() {
        return this._ast;
      }
    };
    exports2.FeaturingMeta = FeaturingMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Featuring, "abstract")
    ], FeaturingMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/type-featuring.js
var require_type_featuring = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/type-featuring.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeFeaturingMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var TypeFeaturingMeta = exports2.TypeFeaturingMeta = class TypeFeaturingMeta extends _internal_1.FeaturingMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.TypeFeaturingMeta = TypeFeaturingMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.TypeFeaturing)
    ], TypeFeaturingMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/references/membership-reference.js
var require_membership_reference = __commonJS({
  "../syside-languageserver/lib/model/KerML/references/membership-reference.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MembershipReferenceMeta = void 0;
    var ast_1 = require_ast2();
    var containers_1 = require_containers();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var MembershipReferenceMeta = exports2.MembershipReferenceMeta = class MembershipReferenceMeta extends _internal_1.ElementReferenceMeta {
      constructor() {
        super(...arguments);
        this.to = new containers_1.Target();
      }
      ast() {
        return this._ast;
      }
    };
    exports2.MembershipReferenceMeta = MembershipReferenceMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.MembershipReference)
    ], MembershipReferenceMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/owning-membership.js
var require_owning_membership = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/owning-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OwningMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var OwningMembershipMeta = exports2.OwningMembershipMeta = class OwningMembershipMeta extends _internal_1.MembershipMeta {
      onTargetSet(previous, target) {
        if (previous)
          this.unsetOwnership(previous);
        if (target)
          this.takeOwnership(target);
      }
      onOwnerSet(previous, current) {
        if (this._element) {
          if (current)
            this._element["setOwner"](current[1]);
          else
            this.unsetOwnership(this._element);
        }
      }
      // Owning memberships will always be parsed with an owned target element so
      // it cannot be undefined
      element() {
        return this._element;
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.OwningMembershipMeta = OwningMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.OwningMembership)
    ], OwningMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/feature-value.js
var require_feature_value = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/feature-value.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FeatureValueMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var FeatureValueMeta = exports2.FeatureValueMeta = class FeatureValueMeta extends _internal_1.OwningMembershipMeta {
      constructor() {
        super(...arguments);
        this.isDefault = false;
        this.isInitial = false;
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.FeatureValueMeta = FeatureValueMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.FeatureValue)
    ], FeatureValueMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/element-filter-membership.js
var require_element_filter_membership = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/element-filter-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ElementFilterMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var ElementFilterMembershipMeta = exports2.ElementFilterMembershipMeta = class ElementFilterMembershipMeta extends _internal_1.OwningMembershipMeta {
      get visibility() {
        var _a;
        const parent = this.parent();
        if ((parent === null || parent === void 0 ? void 0 : parent.nodeType()) === ast_1.Package && ((_a = parent.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.NamespaceImport)))
          return 2;
        return super.visibility;
      }
      set visibility(value) {
        super.visibility = value;
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    __decorate([
      utils_1.enumerable
    ], ElementFilterMembershipMeta.prototype, "visibility", null);
    exports2.ElementFilterMembershipMeta = ElementFilterMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ElementFilterMembership)
    ], ElementFilterMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/feature-membership.js
var require_feature_membership = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/feature-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FeatureMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var featuring_1 = require_featuring();
    var owning_membership_1 = require_owning_membership();
    var FeatureMembershipMeta = exports2.FeatureMembershipMeta = class FeatureMembershipMeta {
      // eslint-disable-next-line unused-imports/no-unused-vars
      constructor(id) {
      }
      onTargetSet(previous, current) {
        owning_membership_1.OwningMembershipMeta.prototype["onTargetSet"].call(this, previous, current);
      }
      onOwnerSet(previous, current) {
        owning_membership_1.OwningMembershipMeta.prototype["onOwnerSet"].call(this, previous, current);
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return owning_membership_1.OwningMembershipMeta.create.call(this, provider, document, options);
      }
    };
    exports2.FeatureMembershipMeta = FeatureMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.FeatureMembership),
      (0, metamodel_1.mix)(featuring_1.FeaturingMeta, owning_membership_1.OwningMembershipMeta)
      // eslint-disable-next-line unused-imports/no-unused-vars
    ], FeatureMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/parameter-membership.js
var require_parameter_membership = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/parameter-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParameterMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var ParameterMembershipMeta = exports2.ParameterMembershipMeta = class ParameterMembershipMeta extends _internal_1.FeatureMembershipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.ParameterMembershipMeta = ParameterMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ParameterMembership)
    ], ParameterMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/result-expression-membership.js
var require_result_expression_membership = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/result-expression-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResultExpressionMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var ResultExpressionMembershipMeta = exports2.ResultExpressionMembershipMeta = class ResultExpressionMembershipMeta extends _internal_1.FeatureMembershipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.ResultExpressionMembershipMeta = ResultExpressionMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ResultExpressionMembership)
    ], ResultExpressionMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/end-feature-membership.js
var require_end_feature_membership = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/end-feature-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EndFeatureMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var EndFeatureMembershipMeta = exports2.EndFeatureMembershipMeta = class EndFeatureMembershipMeta extends _internal_1.FeatureMembershipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.EndFeatureMembershipMeta = EndFeatureMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.EndFeatureMembership)
    ], EndFeatureMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/return-parameter-membership.js
var require_return_parameter_membership = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/return-parameter-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReturnParameterMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var ReturnParameterMembershipMeta = exports2.ReturnParameterMembershipMeta = class ReturnParameterMembershipMeta extends _internal_1.ParameterMembershipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.ReturnParameterMembershipMeta = ReturnParameterMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ReturnParameterMembership)
    ], ReturnParameterMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/import.js
var require_import = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/import.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImportMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var ImportMeta = exports2.ImportMeta = class ImportMeta extends _internal_1.RelationshipMeta {
      constructor() {
        super(...arguments);
        this.isRecursive = false;
        this._importsAll = false;
      }
      /**
       * Visibility of the element at the end of this import
       * @see {@link element}
       */
      get visibility() {
        var _a;
        return (_a = this._visibility) !== null && _a !== void 0 ? _a : 2;
      }
      set visibility(value) {
        this._visibility = value;
      }
      get importsAll() {
        return this._importsAll;
      }
      set importsAll(value) {
        this._importsAll = value;
      }
      /**
       * Adds new owned body elements and returns the new number of body elements.
       */
      addChild(...element) {
        return this.addOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements and returns the new number of body elements.
       */
      removeChild(...element) {
        return this.removeOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements by predicate and returns the new number of
       * body elements.
       */
      removeChildIf(predicate) {
        return this.removeOwnedElementsIf(this._children, predicate);
      }
      ast() {
        return this._ast;
      }
      /**
       *
       * @returns true if this import only imports a single name into a scope,
       * false otherwise
       */
      importsNameOnly() {
        return false;
      }
      static create(provider, document, options) {
        const imp = super.create(provider, document, options);
        imp.isRecursive = Boolean(options === null || options === void 0 ? void 0 : options.isRecursive);
        imp._importsAll = Boolean(options === null || options === void 0 ? void 0 : options.importsAll);
        return imp;
      }
    };
    __decorate([
      utils_1.enumerable
    ], ImportMeta.prototype, "visibility", null);
    __decorate([
      utils_1.enumerable
    ], ImportMeta.prototype, "importsAll", null);
    exports2.ImportMeta = ImportMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Import, "abstract")
      // @ts-expect-error ignoring static inheritance error
    ], ImportMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/membership-import.js
var require_membership_import = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/membership-import.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MembershipImportMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var MembershipImportMeta = exports2.MembershipImportMeta = class MembershipImportMeta extends _internal_1.ImportMeta {
      ast() {
        return this._ast;
      }
      importsNameOnly() {
        return !this.isRecursive;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.MembershipImportMeta = MembershipImportMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.MembershipImport)
    ], MembershipImportMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/namespace-import.js
var require_namespace_import = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/namespace-import.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NamespaceImportMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var NamespaceImportMeta = exports2.NamespaceImportMeta = class NamespaceImportMeta extends _internal_1.ImportMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.NamespaceImportMeta = NamespaceImportMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.NamespaceImport)
    ], NamespaceImportMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/differencing.js
var require_differencing = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/differencing.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DifferencingMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var DifferencingMeta = exports2.DifferencingMeta = class DifferencingMeta extends _internal_1.RelationshipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.DifferencingMeta = DifferencingMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Differencing)
    ], DifferencingMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/disjoining.js
var require_disjoining = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/disjoining.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DisjoiningMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var DisjoiningMeta = exports2.DisjoiningMeta = class DisjoiningMeta extends _internal_1.RelationshipMeta {
      /**
       * Adds new owned body elements and returns the new number of body elements.
       */
      addChild(...element) {
        return this.addOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements and returns the new number of body elements.
       */
      removeChild(...element) {
        return this.removeOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements by predicate and returns the new number of
       * body elements.
       */
      removeChildIf(predicate) {
        return this.removeOwnedElementsIf(this._children, predicate);
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.DisjoiningMeta = DisjoiningMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Disjoining)
    ], DisjoiningMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/feature-chaining.js
var require_feature_chaining = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/feature-chaining.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FeatureChainingMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var FeatureChainingMeta = exports2.FeatureChainingMeta = class FeatureChainingMeta extends _internal_1.RelationshipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.FeatureChainingMeta = FeatureChainingMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.FeatureChaining)
      // @ts-expect-error ignoring static inheritance error
    ], FeatureChainingMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/feature-inverting.js
var require_feature_inverting = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/feature-inverting.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FeatureInvertingMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var FeatureInvertingMeta = exports2.FeatureInvertingMeta = class FeatureInvertingMeta extends _internal_1.RelationshipMeta {
      /**
       * Adds new owned body elements and returns the new number of body elements.
       */
      addChild(...element) {
        return this.addOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements and returns the new number of body elements.
       */
      removeChild(...element) {
        return this.removeOwnedElements(this._children, element);
      }
      /**
       * Removes owned body elements by predicate and returns the new number of
       * body elements.
       */
      removeChildIf(predicate) {
        return this.removeOwnedElementsIf(this._children, predicate);
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.FeatureInvertingMeta = FeatureInvertingMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.FeatureInverting)
    ], FeatureInvertingMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/intersecting.js
var require_intersecting = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/intersecting.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IntersectingMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var IntersectingMeta = exports2.IntersectingMeta = class IntersectingMeta extends _internal_1.RelationshipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.IntersectingMeta = IntersectingMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Intersecting)
    ], IntersectingMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/unioning.js
var require_unioning = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/unioning.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnioningMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var UnioningMeta = exports2.UnioningMeta = class UnioningMeta extends _internal_1.RelationshipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.UnioningMeta = UnioningMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Unioning)
    ], UnioningMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/_internal.js
var require_internal = __commonJS({
  "../syside-languageserver/lib/model/KerML/_internal.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_element(), exports2);
    __exportStar(require_element_reference(), exports2);
    __exportStar(require_relationship(), exports2);
    __exportStar(require_membership(), exports2);
    __exportStar(require_annotation(), exports2);
    __exportStar(require_annotating_element(), exports2);
    __exportStar(require_textual_annotating_element(), exports2);
    __exportStar(require_comment(), exports2);
    __exportStar(require_documentation2(), exports2);
    __exportStar(require_textual_representation(), exports2);
    __exportStar(require_namespace(), exports2);
    __exportStar(require_namespace_reference(), exports2);
    __exportStar(require_package(), exports2);
    __exportStar(require_library_package(), exports2);
    __exportStar(require_type(), exports2);
    __exportStar(require_type_reference(), exports2);
    __exportStar(require_classifier(), exports2);
    __exportStar(require_classifier_reference(), exports2);
    __exportStar(require_class(), exports2);
    __exportStar(require_data_type(), exports2);
    __exportStar(require_association(), exports2);
    __exportStar(require_behavior(), exports2);
    __exportStar(require_interaction(), exports2);
    __exportStar(require_structure(), exports2);
    __exportStar(require_association_structure(), exports2);
    __exportStar(require_metaclass(), exports2);
    __exportStar(require_metaclass_reference(), exports2);
    __exportStar(require_feature(), exports2);
    __exportStar(require_feature_reference(), exports2);
    __exportStar(require_multiplicity(), exports2);
    __exportStar(require_multiplicity_range(), exports2);
    __exportStar(require_step(), exports2);
    __exportStar(require_connector2(), exports2);
    __exportStar(require_binding_connector(), exports2);
    __exportStar(require_function2(), exports2);
    __exportStar(require_item_feature(), exports2);
    __exportStar(require_item_flow(), exports2);
    __exportStar(require_item_flow_end(), exports2);
    __exportStar(require_metadata_feature(), exports2);
    __exportStar(require_succession(), exports2);
    __exportStar(require_succession_item_flow(), exports2);
    __exportStar(require_expression(), exports2);
    __exportStar(require_predicate(), exports2);
    __exportStar(require_boolean_expression(), exports2);
    __exportStar(require_invariant(), exports2);
    __exportStar(require_inheritance(), exports2);
    __exportStar(require_specialization(), exports2);
    __exportStar(require_subsetting(), exports2);
    __exportStar(require_redefinition(), exports2);
    __exportStar(require_reference_subsetting(), exports2);
    __exportStar(require_subclassification(), exports2);
    __exportStar(require_feature_typing(), exports2);
    __exportStar(require_conjugation(), exports2);
    __exportStar(require_invocation_expression(), exports2);
    __exportStar(require_operator_expression(), exports2);
    __exportStar(require_collect_expression(), exports2);
    __exportStar(require_select_expression(), exports2);
    __exportStar(require_feature_chain_expression(), exports2);
    __exportStar(require_feature_reference_expression(), exports2);
    __exportStar(require_literal_expression(), exports2);
    __exportStar(require_literal_boolean(), exports2);
    __exportStar(require_literal_infinity(), exports2);
    __exportStar(require_literal_number(), exports2);
    __exportStar(require_literal_string(), exports2);
    __exportStar(require_metadata_access_expression(), exports2);
    __exportStar(require_null_expression(), exports2);
    __exportStar(require_dependency(), exports2);
    __exportStar(require_featuring(), exports2);
    __exportStar(require_type_featuring(), exports2);
    __exportStar(require_membership_reference(), exports2);
    __exportStar(require_owning_membership(), exports2);
    __exportStar(require_feature_value(), exports2);
    __exportStar(require_element_filter_membership(), exports2);
    __exportStar(require_feature_membership(), exports2);
    __exportStar(require_parameter_membership(), exports2);
    __exportStar(require_result_expression_membership(), exports2);
    __exportStar(require_end_feature_membership(), exports2);
    __exportStar(require_return_parameter_membership(), exports2);
    __exportStar(require_import(), exports2);
    __exportStar(require_membership_import(), exports2);
    __exportStar(require_namespace_import(), exports2);
    __exportStar(require_differencing(), exports2);
    __exportStar(require_disjoining(), exports2);
    __exportStar(require_feature_chaining(), exports2);
    __exportStar(require_feature_inverting(), exports2);
    __exportStar(require_intersecting(), exports2);
    __exportStar(require_unioning(), exports2);
  }
});

// ../syside-languageserver/lib/model/KerML/association-structure.js
var require_association_structure = __commonJS({
  "../syside-languageserver/lib/model/KerML/association-structure.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AssociationStructMeta = exports2.ImplicitAssociationStructures = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    exports2.ImplicitAssociationStructures = {
      base: "Objects::LinkObject",
      binary: "Objects::BinaryLinkObject"
    };
    var AssociationStructMeta = exports2.AssociationStructMeta = class AssociationStructMeta extends (0, ts_mixer_1.Mixin)(_internal_1.StructureMeta, _internal_1.AssociationMeta) {
      constructor() {
        super(...arguments);
        this._classifier = 12;
      }
      ast() {
        return this._ast;
      }
    };
    exports2.AssociationStructMeta = AssociationStructMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.AssociationStructure, exports2.ImplicitAssociationStructures)
    ], AssociationStructMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/index-expression.js
var require_index_expression = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/index-expression.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IndexExpressionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var IndexExpressionMeta = exports2.IndexExpressionMeta = class IndexExpressionMeta extends _internal_1.OperatorExpressionMeta {
      get operator() {
        return _internal_1.IMPLICIT_OPERATORS.INDEX;
      }
      ast() {
        return this._ast;
      }
    };
    exports2.IndexExpressionMeta = IndexExpressionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.IndexExpression)
    ], IndexExpressionMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/expressions/index.js
var require_expressions = __commonJS({
  "../syside-languageserver/lib/model/KerML/expressions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_collect_expression(), exports2);
    __exportStar(require_feature_chain_expression(), exports2);
    __exportStar(require_feature_reference_expression(), exports2);
    __exportStar(require_index_expression(), exports2);
    __exportStar(require_invocation_expression(), exports2);
    __exportStar(require_literal_boolean(), exports2);
    __exportStar(require_literal_expression(), exports2);
    __exportStar(require_literal_infinity(), exports2);
    __exportStar(require_literal_number(), exports2);
    __exportStar(require_literal_string(), exports2);
    __exportStar(require_metadata_access_expression(), exports2);
    __exportStar(require_null_expression(), exports2);
    __exportStar(require_operator_expression(), exports2);
    __exportStar(require_select_expression(), exports2);
  }
});

// ../syside-languageserver/lib/model/KerML/references/index.js
var require_references3 = __commonJS({
  "../syside-languageserver/lib/model/KerML/references/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_classifier_reference(), exports2);
    __exportStar(require_element_reference(), exports2);
    __exportStar(require_feature_reference(), exports2);
    __exportStar(require_membership_reference(), exports2);
    __exportStar(require_metaclass_reference(), exports2);
    __exportStar(require_namespace_reference(), exports2);
    __exportStar(require_type_reference(), exports2);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/cross-subsetting.js
var require_cross_subsetting = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/cross-subsetting.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CrossSubsettingMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var _internal_1 = require_internal();
    var CrossSubsettingMeta = exports2.CrossSubsettingMeta = class CrossSubsettingMeta extends _internal_1.SubsettingMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.CrossSubsettingMeta = CrossSubsettingMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.CrossSubsetting)
    ], CrossSubsettingMeta);
  }
});

// ../syside-languageserver/lib/model/KerML/relationships/index.js
var require_relationships = __commonJS({
  "../syside-languageserver/lib/model/KerML/relationships/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_annotation(), exports2);
    __exportStar(require_conjugation(), exports2);
    __exportStar(require_cross_subsetting(), exports2);
    __exportStar(require_dependency(), exports2);
    __exportStar(require_differencing(), exports2);
    __exportStar(require_disjoining(), exports2);
    __exportStar(require_element_filter_membership(), exports2);
    __exportStar(require_end_feature_membership(), exports2);
    __exportStar(require_feature_chaining(), exports2);
    __exportStar(require_feature_inverting(), exports2);
    __exportStar(require_feature_membership(), exports2);
    __exportStar(require_feature_typing(), exports2);
    __exportStar(require_feature_value(), exports2);
    __exportStar(require_featuring(), exports2);
    __exportStar(require_import(), exports2);
    __exportStar(require_inheritance(), exports2);
    __exportStar(require_intersecting(), exports2);
    __exportStar(require_membership_import(), exports2);
    __exportStar(require_membership(), exports2);
    __exportStar(require_namespace_import(), exports2);
    __exportStar(require_owning_membership(), exports2);
    __exportStar(require_parameter_membership(), exports2);
    __exportStar(require_redefinition(), exports2);
    __exportStar(require_reference_subsetting(), exports2);
    __exportStar(require_result_expression_membership(), exports2);
    __exportStar(require_return_parameter_membership(), exports2);
    __exportStar(require_specialization(), exports2);
    __exportStar(require_subclassification(), exports2);
    __exportStar(require_subsetting(), exports2);
    __exportStar(require_type_featuring(), exports2);
    __exportStar(require_unioning(), exports2);
  }
});

// ../syside-languageserver/lib/model/KerML/index.js
var require_KerML = __commonJS({
  "../syside-languageserver/lib/model/KerML/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_annotating_element(), exports2);
    __exportStar(require_association_structure(), exports2);
    __exportStar(require_association(), exports2);
    __exportStar(require_behavior(), exports2);
    __exportStar(require_binding_connector(), exports2);
    __exportStar(require_boolean_expression(), exports2);
    __exportStar(require_class(), exports2);
    __exportStar(require_classifier(), exports2);
    __exportStar(require_comment(), exports2);
    __exportStar(require_connector2(), exports2);
    __exportStar(require_data_type(), exports2);
    __exportStar(require_documentation2(), exports2);
    __exportStar(require_element(), exports2);
    __exportStar(require_expression(), exports2);
    __exportStar(require_expressions(), exports2);
    __exportStar(require_feature(), exports2);
    __exportStar(require_function2(), exports2);
    __exportStar(require_interaction(), exports2);
    __exportStar(require_invariant(), exports2);
    __exportStar(require_item_feature(), exports2);
    __exportStar(require_item_flow_end(), exports2);
    __exportStar(require_item_flow(), exports2);
    __exportStar(require_library_package(), exports2);
    __exportStar(require_metaclass(), exports2);
    __exportStar(require_metadata_feature(), exports2);
    __exportStar(require_multiplicity_range(), exports2);
    __exportStar(require_multiplicity(), exports2);
    __exportStar(require_namespace(), exports2);
    __exportStar(require_package(), exports2);
    __exportStar(require_predicate(), exports2);
    __exportStar(require_references3(), exports2);
    __exportStar(require_relationship(), exports2);
    __exportStar(require_relationships(), exports2);
    __exportStar(require_step(), exports2);
    __exportStar(require_structure(), exports2);
    __exportStar(require_succession_item_flow(), exports2);
    __exportStar(require_succession(), exports2);
    __exportStar(require_textual_annotating_element(), exports2);
    __exportStar(require_textual_representation(), exports2);
    __exportStar(require_type(), exports2);
  }
});

// ../syside-languageserver/lib/model/SysML/usage.js
var require_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var UsageMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UsageMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var feature_1 = require_feature();
    var metamodel_1 = require_metamodel();
    var UsageMeta = exports2.UsageMeta = UsageMeta_1 = class UsageMeta extends feature_1.FeatureMeta {
      constructor() {
        super(...arguments);
        this.isVariant = false;
        this.isVariation = false;
        this.isIndividual = false;
      }
      onParentSet(previous, current) {
        super.onParentSet(previous, current);
        this.isVariant = !!(current === null || current === void 0 ? void 0 : current.is(ast_1.VariantMembership));
      }
      get isReference() {
        return !this.isComposite;
      }
      set isReference(value) {
        this.isComposite = !value;
      }
      get isReferenceExplicitly() {
        return !super.isComposite;
      }
      get isComposite() {
        return super.isComposite && Boolean(this.direction === "none" && !this.isEnd && this.owningType);
      }
      set isComposite(value) {
        this._isComposite = value;
      }
      get isCompositeExplicitly() {
        return super.isComposite;
      }
      get isAbstract() {
        return this._isAbstract || this.isVariation;
      }
      set isAbstract(value) {
        this._isAbstract = value;
      }
      ast() {
        return this._ast;
      }
      isVariantNode() {
        var _a;
        return !!((_a = this.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.VariantMembership));
      }
      namingFeature() {
        const parent = this.parent();
        if (parent === null || parent === void 0 ? void 0 : parent.is(ast_1.VariantMembership)) {
          const referenced = this.referencedFeature();
          if (referenced)
            return referenced;
        }
        return super.namingFeature();
      }
      isNonEntryExitComposite() {
        return this.isComposite && !this.isEntryExitAction();
      }
      isActionOwnedComposite() {
        var _a;
        return Boolean(this.isComposite && !this.isEntryExitAction() && ((_a = this.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast_1.ActionDefinition, ast_1.ActionUsage)));
      }
      isPartOwnedComposite() {
        var _a;
        return Boolean(this.isComposite && ((_a = this.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast_1.PartDefinition, ast_1.PartUsage)));
      }
      isEntryExitAction() {
        const parent = this.parent();
        return !!(parent === null || parent === void 0 ? void 0 : parent.is(ast_1.StateSubactionMembership)) && parent.kind !== "do";
      }
      static applyUsageOptions(model, options) {
        model.isVariation = Boolean(options.isVariation);
        model.isIndividual = Boolean(options.isIndividual);
        model.isReference = Boolean(options.isReference);
        model.portionKind = options.portionKind;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          UsageMeta_1.applyUsageOptions(model, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], UsageMeta.prototype, "isReference", null);
    __decorate([
      utils_1.enumerable
    ], UsageMeta.prototype, "isComposite", null);
    __decorate([
      utils_1.enumerable
    ], UsageMeta.prototype, "isAbstract", null);
    exports2.UsageMeta = UsageMeta = UsageMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Usage)
    ], UsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/occurrence-usage.js
var require_occurrence_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/occurrence-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OccurrenceUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var usage_1 = require_usage();
    var OccurrenceUsageMeta = exports2.OccurrenceUsageMeta = class OccurrenceUsageMeta extends usage_1.UsageMeta {
      defaultGeneralTypes() {
        const supertypes = super.defaultGeneralTypes();
        if (this.isSuboccurrence())
          supertypes.push("suboccurrence");
        if (this.portionKind)
          supertypes.push(this.portionKind);
        return supertypes;
      }
      defaultSupertype() {
        return "base";
      }
      ast() {
        return this._ast;
      }
    };
    exports2.OccurrenceUsageMeta = OccurrenceUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.OccurrenceUsage, {
        base: "Occurrences::occurrences",
        timeslice: "Occurrences::Occurrence::timeSlices",
        snapshot: "Occurrences::Occurrence::snapshots"
      })
    ], OccurrenceUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/action-usage.js
var require_action_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/action-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActionUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var step_1 = require_step();
    var metamodel_1 = require_metamodel();
    var occurrence_usage_1 = require_occurrence_usage();
    var ActionUsageMeta = exports2.ActionUsageMeta = class ActionUsageMeta extends (0, ts_mixer_1.Mixin)(step_1.StepMeta, occurrence_usage_1.OccurrenceUsageMeta) {
      ast() {
        return this._ast;
      }
      defaultSupertype() {
        return "base";
      }
      defaultGeneralTypes() {
        const supertypes = super.defaultGeneralTypes();
        const subactionType = this.getSubactionType();
        if (subactionType)
          supertypes.push(subactionType);
        if (this.isStructureOwnedComposite())
          supertypes.push("ownedPerformance");
        else if (this.isBehaviorOwned())
          supertypes.push("enclosedPerformance");
        return supertypes;
      }
      getSubactionType() {
        return this.isActionOwnedComposite() ? "subaction" : this.isPartOwnedComposite() ? "ownedAction" : void 0;
      }
      isSuboccurrence() {
        return super.isSuboccurrence() && !this.isActionOwnedComposite();
      }
      isPerformedAction() {
        const parent = this.owner();
        return Boolean(parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.PartUsage, ast_1.PartDefinition));
      }
    };
    exports2.ActionUsageMeta = ActionUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ActionUsage, {
        base: "Actions::actions",
        subaction: "Actions::Action::subactions",
        ownedAction: "Parts::Part::ownedActions",
        subPerformance: "Performances::Performance::subPerformances",
        enclosedPerformance: "Performances::Performance::enclosedPerformances",
        entry: "States::StateAction::entryAction",
        do: "States::StateAction::doAction",
        exit: "States::StateAction::exitAction",
        trigger: "Actions::TransitionAction::accepter",
        guard: "Actions::TransitionAction::guard",
        effect: "Actions::TransitionAction::effect"
      })
    ], ActionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/reference-usage.js
var require_reference_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/reference-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createEmptyParameterMember = exports2.ReferenceUsageMeta = void 0;
    var ast_1 = require_ast2();
    var common_1 = require_common();
    var KerML_1 = require_KerML();
    var metamodel_1 = require_metamodel();
    var usage_1 = require_usage();
    var ReferenceUsageMeta = exports2.ReferenceUsageMeta = class ReferenceUsageMeta extends usage_1.UsageMeta {
      get isComposite() {
        return false;
      }
      set isComposite(value) {
      }
      defaultGeneralTypes() {
        const owner = this.owner();
        if ((owner === null || owner === void 0 ? void 0 : owner.is(ast_1.TransitionUsage)) && this === owner.payloadParameter())
          return [];
        const supertypes = super.defaultGeneralTypes();
        return supertypes;
      }
      ast() {
        return this._ast;
      }
    };
    __decorate([
      common_1.enumerable
    ], ReferenceUsageMeta.prototype, "isComposite", null);
    exports2.ReferenceUsageMeta = ReferenceUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ReferenceUsage)
    ], ReferenceUsageMeta);
    function createEmptyParameterMember(provider, document) {
      return [
        KerML_1.ParameterMembershipMeta.create(provider, document, { isImplied: true }),
        ReferenceUsageMeta.create(provider, document)
      ];
    }
    exports2.createEmptyParameterMember = createEmptyParameterMember;
  }
});

// ../syside-languageserver/lib/model/SysML/accept-action-usage.js
var require_accept_action_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/accept-action-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var AcceptActionUsageMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AcceptActionUsageMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var action_usage_1 = require_action_usage();
    var reference_usage_1 = require_reference_usage();
    var AcceptActionUsageMeta = exports2.AcceptActionUsageMeta = AcceptActionUsageMeta_1 = class AcceptActionUsageMeta extends action_usage_1.ActionUsageMeta {
      get payload() {
        var _a;
        return (_a = this._payload) !== null && _a !== void 0 ? _a : this._defaultPayload;
      }
      set payload(value) {
        this._payload = this.swapEdgeOwnership(this._payload, value);
      }
      get receiver() {
        var _a;
        return (_a = this._receiver) !== null && _a !== void 0 ? _a : this._defaultReceiver;
      }
      set receiver(value) {
        this._receiver = this.swapEdgeOwnership(this._receiver, value);
      }
      ast() {
        return this._ast;
      }
      defaultGeneralTypes() {
        if (!this.isTriggerAction())
          return super.defaultGeneralTypes();
        return [];
      }
      isTriggerAction() {
        const parent = this.parent();
        return Boolean((parent === null || parent === void 0 ? void 0 : parent.is(ast_1.TransitionFeatureMembership)) && parent.kind === "trigger");
      }
      featureMembers() {
        const baseFeatures = super.featureMembers();
        return [this.payload, this.receiver].filter(utils_1.NonNullable).concat(baseFeatures);
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        if (this.payload)
          parts.push(["payload", [this.payload]]);
        if (this.receiver)
          parts.push(["receiver", [this.receiver]]);
      }
      static applyAcceptOptions(model, provider, options) {
        model.payload = options === null || options === void 0 ? void 0 : options.payload;
        model.receiver = options === null || options === void 0 ? void 0 : options.receiver;
        model._defaultPayload = model.swapEdgeOwnership(model._defaultPayload, (0, reference_usage_1.createEmptyParameterMember)(provider, model.document));
        model._defaultReceiver = model.swapEdgeOwnership(model._defaultReceiver, (0, reference_usage_1.createEmptyParameterMember)(provider, model.document));
      }
      static create(provider, document, options) {
        const usage = super.create(provider, document, options);
        AcceptActionUsageMeta_1.applyAcceptOptions(usage, provider, options);
        return usage;
      }
    };
    __decorate([
      utils_1.enumerable
    ], AcceptActionUsageMeta.prototype, "payload", null);
    __decorate([
      utils_1.enumerable
    ], AcceptActionUsageMeta.prototype, "receiver", null);
    exports2.AcceptActionUsageMeta = AcceptActionUsageMeta = AcceptActionUsageMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.AcceptActionUsage, {
        base: "Actions::acceptActions",
        subactions: "Actions::Action::acceptSubactions"
      })
    ], AcceptActionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/definition.js
var require_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var DefinitionMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var classifier_1 = require_classifier();
    var metamodel_1 = require_metamodel();
    var DefinitionMeta = exports2.DefinitionMeta = DefinitionMeta_1 = class DefinitionMeta extends classifier_1.ClassifierMeta {
      constructor() {
        super(...arguments);
        this._isVariation = false;
        this.isIndividual = false;
      }
      get isAbstract() {
        return this._isAbstract || this.isVariation;
      }
      set isAbstract(value) {
        this._isAbstract = value;
      }
      get isVariation() {
        return this._isVariation;
      }
      set isVariation(value) {
        this._isVariation = value;
      }
      ast() {
        return this._ast;
      }
      getSubjectParameter() {
        return;
      }
      static applyDefinitionOptions(model, options) {
        model._isVariation = Boolean(options.isVariation);
        model.isIndividual = Boolean(options.isIndividual);
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          DefinitionMeta_1.applyDefinitionOptions(model, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], DefinitionMeta.prototype, "isAbstract", null);
    __decorate([
      utils_1.enumerable
    ], DefinitionMeta.prototype, "isVariation", null);
    exports2.DefinitionMeta = DefinitionMeta = DefinitionMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Definition)
    ], DefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/life-class.js
var require_life_class = __commonJS({
  "../syside-languageserver/lib/model/SysML/life-class.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LifeClassMeta = void 0;
    var ast_1 = require_ast2();
    var KerML_1 = require_KerML();
    var metamodel_1 = require_metamodel();
    var LifeClassMeta = exports2.LifeClassMeta = class LifeClassMeta extends KerML_1.ClassMeta {
      ast() {
        return this._ast;
      }
      get isSufficient() {
        return true;
      }
      set isSufficient(value) {
      }
    };
    exports2.LifeClassMeta = LifeClassMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.LifeClass)
    ], LifeClassMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/occurrence-definition.js
var require_occurrence_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/occurrence-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OccurrenceDefinitionMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var class_1 = require_class();
    var metamodel_1 = require_metamodel();
    var definition_1 = require_definition();
    var KerML_1 = require_KerML();
    var life_class_1 = require_life_class();
    var OccurrenceDefinitionMeta = exports2.OccurrenceDefinitionMeta = class OccurrenceDefinitionMeta extends (0, ts_mixer_1.Mixin)(class_1.ClassMeta, definition_1.DefinitionMeta) {
      get lifeClass() {
        return this.isIndividual ? this._lifeClass : void 0;
      }
      ast() {
        return this._ast;
      }
      createLifeClass(id) {
        this._lifeClass = this.swapEdgeOwnership(this._lifeClass, [
          KerML_1.OwningMembershipMeta.create(id, this.document, { isImplied: true }),
          life_class_1.LifeClassMeta.create(id, this.document, {
            heritage: KerML_1.EdgeContainer.make([
              KerML_1.SubclassificationMeta.create(id, this.document),
              this
            ])
          })
        ]);
      }
      static create(provider, document, options) {
        const model = definition_1.DefinitionMeta.create.call(this, provider, document, options);
        model.createLifeClass(provider);
        return model;
      }
    };
    exports2.OccurrenceDefinitionMeta = OccurrenceDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.OccurrenceDefinition, {
        base: "Occurrences::Occurrence"
      })
    ], OccurrenceDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/action-definition.js
var require_action_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/action-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActionDefinitionMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var behavior_1 = require_behavior();
    var metamodel_1 = require_metamodel();
    var occurrence_definition_1 = require_occurrence_definition();
    var ActionDefinitionMeta = exports2.ActionDefinitionMeta = class ActionDefinitionMeta extends (0, ts_mixer_1.Mixin)(behavior_1.BehaviorMeta, occurrence_definition_1.OccurrenceDefinitionMeta) {
      ast() {
        return this._ast;
      }
    };
    exports2.ActionDefinitionMeta = ActionDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ActionDefinition, {
        base: "Actions::Action"
      })
    ], ActionDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/item-definition.js
var require_item_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/item-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ItemDefinitionMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var structure_1 = require_structure();
    var metamodel_1 = require_metamodel();
    var occurrence_definition_1 = require_occurrence_definition();
    var ItemDefinitionMeta = exports2.ItemDefinitionMeta = class ItemDefinitionMeta extends (0, ts_mixer_1.Mixin)(structure_1.StructureMeta, occurrence_definition_1.OccurrenceDefinitionMeta) {
      ast() {
        return this._ast;
      }
    };
    exports2.ItemDefinitionMeta = ItemDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ItemDefinition, {
        base: "Items::Item"
      })
    ], ItemDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/part-definition.js
var require_part_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/part-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PartDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var item_definition_1 = require_item_definition();
    var PartDefinitionMeta = exports2.PartDefinitionMeta = class PartDefinitionMeta extends item_definition_1.ItemDefinitionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.PartDefinitionMeta = PartDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.PartDefinition, {
        base: "Parts::Part"
      })
    ], PartDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/connection-definition.js
var require_connection_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/connection-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionDefinitionMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var association_structure_1 = require_association_structure();
    var metamodel_1 = require_metamodel();
    var part_definition_1 = require_part_definition();
    var ConnectionDefinitionMeta = exports2.ConnectionDefinitionMeta = class ConnectionDefinitionMeta extends (0, ts_mixer_1.Mixin)(association_structure_1.AssociationStructMeta, part_definition_1.PartDefinitionMeta) {
      defaultSupertype() {
        return association_structure_1.AssociationStructMeta.prototype.defaultSupertype.call(this);
      }
      ast() {
        return this._ast;
      }
      onHeritageAdded(heritage, target) {
        this.resetEnds();
        part_definition_1.PartDefinitionMeta.prototype["onHeritageAdded"].call(this, heritage, target);
      }
      onHeritageRemoved(heritage) {
        this.resetEnds();
        part_definition_1.PartDefinitionMeta.prototype["onHeritageRemoved"].call(this, heritage);
      }
    };
    exports2.ConnectionDefinitionMeta = ConnectionDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ConnectionDefinition, {
        base: "Connections::Connection",
        binary: "Connections::BinaryConnection"
      })
    ], ConnectionDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/allocation-definition.js
var require_allocation_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/allocation-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AllocationDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var connection_definition_1 = require_connection_definition();
    var AllocationDefinitionMeta = exports2.AllocationDefinitionMeta = class AllocationDefinitionMeta extends connection_definition_1.ConnectionDefinitionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.AllocationDefinitionMeta = AllocationDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.AllocationDefinition, {
        base: "Allocations::Allocation",
        binary: "Allocations::Allocation"
      })
    ], AllocationDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/connector-as-usage.js
var require_connector_as_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/connector-as-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectorAsUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var connector_1 = require_connector2();
    var metamodel_1 = require_metamodel();
    var usage_1 = require_usage();
    var utils_1 = require_utils2();
    var ConnectorAsUsageMeta = exports2.ConnectorAsUsageMeta = class ConnectorAsUsageMeta extends (0, ts_mixer_1.Mixin)(connector_1.ConnectorMeta, usage_1.UsageMeta) {
      get isComposite() {
        return false;
      }
      set isComposite(value) {
      }
      ast() {
        return this._ast;
      }
      defaultSupertype() {
        return connector_1.ConnectorMeta.prototype.defaultSupertype.call(this);
      }
      onHeritageAdded(heritage, target) {
        this.resetEnds();
        usage_1.UsageMeta.prototype["onHeritageAdded"].call(this, heritage, target);
      }
      onHeritageRemoved(heritage) {
        this.resetEnds();
        usage_1.UsageMeta.prototype["onHeritageRemoved"].call(this, heritage);
      }
      featureMembers() {
        return connector_1.ConnectorMeta.prototype.featureMembers.call(this);
      }
      collectDeclaration(parts) {
        connector_1.ConnectorMeta.prototype["collectDeclaration"].call(this, parts);
      }
      static create(provider, document, options) {
        const model = connector_1.ConnectorMeta.create.call(this, provider, document, options);
        if (options)
          usage_1.UsageMeta.applyUsageOptions(model, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
      // @ts-expect-error issue with mixins
    ], ConnectorAsUsageMeta.prototype, "isComposite", null);
    exports2.ConnectorAsUsageMeta = ConnectorAsUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ConnectorAsUsage, "abstract")
    ], ConnectorAsUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/item-usage.js
var require_item_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/item-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ItemUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var occurrence_usage_1 = require_occurrence_usage();
    var ItemUsageMeta = exports2.ItemUsageMeta = class ItemUsageMeta extends occurrence_usage_1.OccurrenceUsageMeta {
      defaultSupertype() {
        return this.isSubitem() ? "subitem" : "base";
      }
      isSuboccurrence() {
        return super.isSuboccurrence() && !this.isSubitem();
      }
      isSubitem() {
        if (!this.isComposite)
          return false;
        const parent = this.owner();
        return Boolean(parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.ItemDefinition, ast_1.ItemUsage));
      }
      ast() {
        return this._ast;
      }
    };
    exports2.ItemUsageMeta = ItemUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ItemUsage, {
        base: "Items::items",
        subitem: "Items::Item::subitems"
      })
    ], ItemUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/part-usage.js
var require_part_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/part-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PartUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var item_usage_1 = require_item_usage();
    var PartUsageMeta = exports2.PartUsageMeta = class PartUsageMeta extends item_usage_1.ItemUsageMeta {
      defaultSupertype() {
        if (this.isRequirementActor())
          return "requirementActor";
        if (this.isRequirementStakeholder())
          return "requirementStakeholder";
        if (this.isCaseActor())
          return "caseActor";
        return super.defaultSupertype();
      }
      isRequirementActor() {
        var _a, _b;
        return Boolean(((_a = this.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.ActorMembership)) && ((_b = this.owner()) === null || _b === void 0 ? void 0 : _b.isAny(ast_1.RequirementDefinition, ast_1.RequirementUsage)));
      }
      isRequirementStakeholder() {
        var _a, _b;
        return Boolean(((_a = this.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.StakeholderMembership)) && ((_b = this.owner()) === null || _b === void 0 ? void 0 : _b.isAny(ast_1.RequirementDefinition, ast_1.RequirementUsage)));
      }
      isCaseActor() {
        var _a, _b;
        return Boolean(((_a = this.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.ActorMembership)) && ((_b = this.owner()) === null || _b === void 0 ? void 0 : _b.isAny(ast_1.CaseDefinition, ast_1.CaseUsage)));
      }
      isIgnoredParameter() {
        var _a;
        return Boolean(super.isIgnoredParameter() || ((_a = this.parent()) === null || _a === void 0 ? void 0 : _a.isAny(ast_1.ActorMembership, ast_1.StakeholderMembership)));
      }
      ast() {
        return this._ast;
      }
    };
    exports2.PartUsageMeta = PartUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.PartUsage, {
        base: "Parts::parts",
        subitem: "Items::Item::subparts",
        requirementActor: "Requirements::RequirementCheck::actors",
        requirementStakeholder: "Requirements::RequirementCheck::stakeholders",
        caseActor: "Cases::Case::actors"
      })
    ], PartUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/connection-usage.js
var require_connection_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/connection-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var connector_as_usage_1 = require_connector_as_usage();
    var part_usage_1 = require_part_usage();
    var utils_1 = require_utils2();
    var ConnectionUsageMeta = exports2.ConnectionUsageMeta = class ConnectionUsageMeta extends (0, ts_mixer_1.Mixin)(connector_as_usage_1.ConnectorAsUsageMeta, part_usage_1.PartUsageMeta) {
      get isComposite() {
        return false;
      }
      set isComposite(value) {
      }
      defaultSupertype() {
        return this.isBinary() ? "binary" : "base";
      }
      ast() {
        return this._ast;
      }
      onHeritageAdded(heritage, target) {
        this.resetEnds();
        part_usage_1.PartUsageMeta.prototype["onHeritageAdded"].call(this, heritage, target);
      }
      onHeritageRemoved(heritage) {
        this.resetEnds();
        part_usage_1.PartUsageMeta.prototype["onHeritageRemoved"].call(this, heritage);
      }
      featureMembers() {
        return connector_as_usage_1.ConnectorAsUsageMeta.prototype.featureMembers.call(this);
      }
      collectDeclaration(parts) {
        connector_as_usage_1.ConnectorAsUsageMeta.prototype["collectDeclaration"].call(this, parts);
      }
    };
    __decorate([
      utils_1.enumerable
      // @ts-expect-error issue with mixins
    ], ConnectionUsageMeta.prototype, "isComposite", null);
    exports2.ConnectionUsageMeta = ConnectionUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ConnectionUsage, {
        base: "Connections::connections",
        binary: "Connections::binaryConnections"
      })
    ], ConnectionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/allocation-usage.js
var require_allocation_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/allocation-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AllocationUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var connection_usage_1 = require_connection_usage();
    var AllocationUsageMeta = exports2.AllocationUsageMeta = class AllocationUsageMeta extends connection_usage_1.ConnectionUsageMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.AllocationUsageMeta = AllocationUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.AllocationUsage, {
        base: "Allocations::allocations",
        binary: "Allocations::allocations"
      })
    ], AllocationUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/calculation-definition.js
var require_calculation_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/calculation-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CalculationDefinitionMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var function_1 = require_function2();
    var metamodel_1 = require_metamodel();
    var action_definition_1 = require_action_definition();
    var CalculationDefinitionMeta = exports2.CalculationDefinitionMeta = class CalculationDefinitionMeta extends (0, ts_mixer_1.Mixin)(function_1.FunctionMeta, action_definition_1.ActionDefinitionMeta) {
      ast() {
        return this._ast;
      }
      collectDeclaration(parts) {
        action_definition_1.ActionDefinitionMeta.prototype["collectDeclaration"].call(this, parts);
        if (this._result)
          parts.push(["result", [this._result]]);
      }
    };
    exports2.CalculationDefinitionMeta = CalculationDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.CalculationDefinition, {
        base: "Calculations::Calculation"
      })
    ], CalculationDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/case-definition.js
var require_case_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/case-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CaseDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var calculation_definition_1 = require_calculation_definition();
    var CaseDefinitionMeta = exports2.CaseDefinitionMeta = class CaseDefinitionMeta extends calculation_definition_1.CalculationDefinitionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.CaseDefinitionMeta = CaseDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.CaseDefinition, {
        base: "Cases::Case"
      })
    ], CaseDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/analysis-case-definition.js
var require_analysis_case_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/analysis-case-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnalysisCaseDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var case_definition_1 = require_case_definition();
    var AnalysisCaseDefinitionMeta = exports2.AnalysisCaseDefinitionMeta = class AnalysisCaseDefinitionMeta extends case_definition_1.CaseDefinitionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.AnalysisCaseDefinitionMeta = AnalysisCaseDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.AnalysisCaseDefinition, {
        base: "AnalysisCases::AnalysisCase"
      })
    ], AnalysisCaseDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/calculation-usage.js
var require_calculation_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/calculation-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CalculationUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var expression_1 = require_expression();
    var metamodel_1 = require_metamodel();
    var action_usage_1 = require_action_usage();
    var CalculationUsageMeta = exports2.CalculationUsageMeta = class CalculationUsageMeta extends (0, ts_mixer_1.Mixin)(expression_1.ExpressionMeta, action_usage_1.ActionUsageMeta) {
      ast() {
        return this._ast;
      }
      getSubactionType() {
        return this.isSubcalculation() ? "subcalculation" : super.getSubactionType();
      }
      isSubcalculation() {
        const parent = this.owner();
        return Boolean(this.isNonEntryExitComposite() && (parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.CalculationUsage, ast_1.CalculationDefinition)));
      }
      collectDeclaration(parts) {
        action_usage_1.ActionUsageMeta.prototype["collectDeclaration"].call(this, parts);
        if (this._result)
          parts.push(["result", [this._result]]);
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          expression_1.ExpressionMeta.applyExpressionOptions(model, options);
        return model;
      }
    };
    exports2.CalculationUsageMeta = CalculationUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.CalculationUsage, {
        base: "Calculations::calculations",
        subcalculation: "Calculations::Calculation::subcalculations"
      })
    ], CalculationUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/case-usage.js
var require_case_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/case-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CaseUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var calculation_usage_1 = require_calculation_usage();
    var CaseUsageMeta = exports2.CaseUsageMeta = class CaseUsageMeta extends calculation_usage_1.CalculationUsageMeta {
      ast() {
        return this._ast;
      }
      getSubactionType() {
        return this.isSubcase() ? "subcase" : super.getSubactionType();
      }
      isSubcase() {
        const parent = this.owner();
        return Boolean(this.isNonEntryExitComposite() && (parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.CaseDefinition, ast_1.CaseUsage)));
      }
    };
    exports2.CaseUsageMeta = CaseUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.CaseUsage, {
        base: "Cases::cases",
        subcase: "Cases::Case::subcases"
      })
    ], CaseUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/analysis-case-usage.js
var require_analysis_case_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/analysis-case-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnalysisCaseUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var case_usage_1 = require_case_usage();
    var AnalysisCaseUsageMeta = exports2.AnalysisCaseUsageMeta = class AnalysisCaseUsageMeta extends case_usage_1.CaseUsageMeta {
      ast() {
        return this._ast;
      }
      getSubactionType() {
        return this.isSubAnalysisCase() ? "subAnalysisCase" : super.getSubactionType();
      }
      isSubAnalysisCase() {
        const parent = this.owner();
        return this.isNonEntryExitComposite() && Boolean(parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.AnalysisCaseUsage, ast_1.AnalysisCaseDefinition));
      }
    };
    exports2.AnalysisCaseUsageMeta = AnalysisCaseUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.AnalysisCaseUsage, {
        base: "AnalysisCases::analysisCases",
        subAnalysisCase: "AnalysisCases::AnalysisCase::subAnalysisCases"
      })
    ], AnalysisCaseUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/constraint-usage.js
var require_constraint_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/constraint-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConstraintUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var boolean_expression_1 = require_boolean_expression();
    var metamodel_1 = require_metamodel();
    var occurrence_usage_1 = require_occurrence_usage();
    var ConstraintUsageMeta = exports2.ConstraintUsageMeta = class ConstraintUsageMeta extends (0, ts_mixer_1.Mixin)(boolean_expression_1.BooleanExpressionMeta, occurrence_usage_1.OccurrenceUsageMeta) {
      defaultGeneralTypes() {
        const supertype = this.requirementConstraintSupertype();
        const supertypes = supertype ? [supertype] : [];
        supertypes.push(...super.defaultGeneralTypes());
        if (this.isCheckedConstraint())
          supertypes.push("checkedConstraint");
        if (this.isStructureOwnedComposite())
          supertypes.push("ownedPerformance");
        if (this.isBehaviorOwnedComposite())
          supertypes.push("subperformance");
        if (this.isBehaviorOwned())
          supertypes.push("enclosedPerformance");
        return supertypes;
      }
      defaultSupertype() {
        return "base";
      }
      isCheckedConstraint() {
        if (!this.isComposite)
          return false;
        const parent = this.owner();
        return Boolean(parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.ItemDefinition, ast_1.ItemUsage));
      }
      ast() {
        return this._ast;
      }
      requirementConstraintKind() {
        const parent = this.parent();
        return (parent === null || parent === void 0 ? void 0 : parent.is(ast_1.RequirementConstraintMembership)) ? parent.kind : void 0;
      }
      namingFeature() {
        return this.requirementConstraintKind() ? this.referencedFeature(ast_1.ConstraintUsage) : super.namingFeature();
      }
      requirementConstraintSupertype() {
        return this.requirementConstraintKind();
      }
      static create(provider, document, options) {
        const model = occurrence_usage_1.OccurrenceUsageMeta.create.call(this, provider, document, options);
        if (options)
          boolean_expression_1.BooleanExpressionMeta.applyExpressionOptions(model, options);
        return model;
      }
    };
    exports2.ConstraintUsageMeta = ConstraintUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ConstraintUsage, {
        base: "Constraints::constraintChecks",
        checkedConstraint: "Items::Item::checkedConstraints",
        enclosedPerformance: "Performances::Performance::enclosedPerformances",
        subperformance: "Performances::Performance::subperformances",
        ownedPerformance: "Objects::Object::ownedPerformances",
        assumption: "Requirements::RequirementCheck::assumptions",
        requirement: "Requirements::RequirementCheck::constraints"
      })
    ], ConstraintUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/assert-constraint-usage.js
var require_assert_constraint_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/assert-constraint-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AssertConstraintUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var invariant_1 = require_invariant();
    var metamodel_1 = require_metamodel();
    var constraint_usage_1 = require_constraint_usage();
    var AssertConstraintUsageMeta = exports2.AssertConstraintUsageMeta = class AssertConstraintUsageMeta extends (0, ts_mixer_1.Mixin)(invariant_1.InvariantMeta, constraint_usage_1.ConstraintUsageMeta) {
      defaultSupertype() {
        return this.isNegated ? "negated" : "base";
      }
      isBehaviorOwned() {
        const parent = this.owner();
        return Boolean(parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.ActionDefinition, ast_1.ActionUsage));
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        const model = constraint_usage_1.ConstraintUsageMeta.create.call(this, provider, document, options);
        if (options)
          invariant_1.InvariantMeta.applyInvariantOptions(model, options);
        return model;
      }
    };
    exports2.AssertConstraintUsageMeta = AssertConstraintUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.AssertConstraintUsage, {
        base: "Constraints::assertedConstraintChecks",
        negated: "Constraints::negatedConstraintChecks"
      })
    ], AssertConstraintUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/assignment-action-usage.js
var require_assignment_action_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/assignment-action-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var AssignmentActionUsageMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AssignmentActionUsageMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var action_usage_1 = require_action_usage();
    var AssignmentActionUsageMeta = exports2.AssignmentActionUsageMeta = AssignmentActionUsageMeta_1 = class AssignmentActionUsageMeta extends action_usage_1.ActionUsageMeta {
      get target() {
        return this._target;
      }
      set target(value) {
        this._target = this.swapEdgeOwnership(this._target, value);
      }
      get targetMember() {
        return this._targetMember;
      }
      set targetMember(value) {
        this._targetMember = this.swapEdgeOwnership(this._targetMember, value);
      }
      get assignedValue() {
        return this._assignedValue;
      }
      set assignedValue(value) {
        this._assignedValue = this.swapEdgeOwnership(this._assignedValue, value);
      }
      ast() {
        return this._ast;
      }
      featureMembers() {
        const baseFeatures = super.featureMembers();
        return [this.target, this.targetMember, this.assignedValue].filter(utils_1.NonNullable).concat(baseFeatures);
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        if (this.target)
          parts.push(["target", [this.target]]);
        if (this.targetMember)
          parts.push(["targetMember", [this.targetMember]]);
        if (this.assignedValue)
          parts.push(["assignedValue", [this.assignedValue]]);
      }
      static applyAssignmentActionOptions(model, options) {
        model.target = options.target;
        model.targetMember = options.targetMember;
        model.assignedValue = options.assignedValue;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          AssignmentActionUsageMeta_1.applyAssignmentActionOptions(model, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], AssignmentActionUsageMeta.prototype, "target", null);
    __decorate([
      utils_1.enumerable
    ], AssignmentActionUsageMeta.prototype, "targetMember", null);
    __decorate([
      utils_1.enumerable
    ], AssignmentActionUsageMeta.prototype, "assignedValue", null);
    exports2.AssignmentActionUsageMeta = AssignmentActionUsageMeta = AssignmentActionUsageMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.AssignmentActionUsage, {
        base: "Actions::assignmentActions",
        subaction: "Actions::Action::assignments",
        featureWrite: "Actions::AssignmentAction"
      })
    ], AssignmentActionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/attribute-definition.js
var require_attribute_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/attribute-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttributeDefinitionMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var data_type_1 = require_data_type();
    var metamodel_1 = require_metamodel();
    var definition_1 = require_definition();
    var AttributeDefinitionMeta = exports2.AttributeDefinitionMeta = class AttributeDefinitionMeta extends (0, ts_mixer_1.Mixin)(data_type_1.DataTypeMeta, definition_1.DefinitionMeta) {
      ast() {
        return this._ast;
      }
    };
    exports2.AttributeDefinitionMeta = AttributeDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.AttributeDefinition, {
        base: "Base::DataValue"
      })
    ], AttributeDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/attribute-usage.js
var require_attribute_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/attribute-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttributeUsageMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var usage_1 = require_usage();
    var AttributeUsageMeta = exports2.AttributeUsageMeta = class AttributeUsageMeta extends usage_1.UsageMeta {
      get isComposite() {
        return false;
      }
      set isComposite(value) {
      }
      ast() {
        return this._ast;
      }
    };
    __decorate([
      utils_1.enumerable
    ], AttributeUsageMeta.prototype, "isComposite", null);
    exports2.AttributeUsageMeta = AttributeUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.AttributeUsage, {
        base: "Base::dataValues"
      })
    ], AttributeUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/binding-connector-as-usage.js
var require_binding_connector_as_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/binding-connector-as-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BindingConnectorAsUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var binding_connector_1 = require_binding_connector();
    var metamodel_1 = require_metamodel();
    var connector_as_usage_1 = require_connector_as_usage();
    var BindingConnectorAsUsageMeta = exports2.BindingConnectorAsUsageMeta = class BindingConnectorAsUsageMeta extends (0, ts_mixer_1.Mixin)(binding_connector_1.BindingConnectorMeta, connector_as_usage_1.ConnectorAsUsageMeta) {
      ast() {
        return this._ast;
      }
    };
    exports2.BindingConnectorAsUsageMeta = BindingConnectorAsUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.BindingConnectorAsUsage, {
        base: "Links::selfLinks",
        binary: "Links::selfLinks"
      })
    ], BindingConnectorAsUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/constraint-definition.js
var require_constraint_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/constraint-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConstraintDefinitionMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var predicate_1 = require_predicate();
    var metamodel_1 = require_metamodel();
    var occurrence_definition_1 = require_occurrence_definition();
    var ConstraintDefinitionMeta = exports2.ConstraintDefinitionMeta = class ConstraintDefinitionMeta extends (0, ts_mixer_1.Mixin)(predicate_1.PredicateMeta, occurrence_definition_1.OccurrenceDefinitionMeta) {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        const model = occurrence_definition_1.OccurrenceDefinitionMeta.create.call(this, provider, document, options);
        if (options)
          predicate_1.PredicateMeta.applyFunctionOptions(model, options);
        return model;
      }
    };
    exports2.ConstraintDefinitionMeta = ConstraintDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ConstraintDefinition, {
        base: "Constraints::ConstraintCheck"
      })
    ], ConstraintDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/requirement-definition.js
var require_requirement_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/requirement-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RequirementDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var constraint_definition_1 = require_constraint_definition();
    var RequirementDefinitionMeta = exports2.RequirementDefinitionMeta = class RequirementDefinitionMeta extends constraint_definition_1.ConstraintDefinitionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.RequirementDefinitionMeta = RequirementDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.RequirementDefinition, {
        base: "Requirements::RequirementCheck"
      })
    ], RequirementDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/concern-definition.js
var require_concern_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/concern-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConcernDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var requirement_definition_1 = require_requirement_definition();
    var ConcernDefinitionMeta = exports2.ConcernDefinitionMeta = class ConcernDefinitionMeta extends requirement_definition_1.RequirementDefinitionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.ConcernDefinitionMeta = ConcernDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ConcernDefinition, {
        base: "Requirements::ConcernCheck"
      })
    ], ConcernDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/requirement-usage.js
var require_requirement_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/requirement-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RequirementUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var constraint_usage_1 = require_constraint_usage();
    var RequirementUsageMeta = exports2.RequirementUsageMeta = class RequirementUsageMeta extends constraint_usage_1.ConstraintUsageMeta {
      defaultSupertype() {
        return this.isSubrequirement() ? "subrequirement" : "base";
      }
      isVerifiedRequirement() {
        const parent = this.parent();
        return Boolean((parent === null || parent === void 0 ? void 0 : parent.is(ast_1.RequirementVerificationMembership)) && parent.isLegalVerification());
      }
      isSubrequirement() {
        var _a;
        if (this.requirementConstraintKind() === "assumption")
          return false;
        return Boolean(this.isComposite && ((_a = this.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast_1.RequirementUsage, ast_1.RequirementDefinition)));
      }
      requirementConstraintSupertype() {
        return this.isVerifiedRequirement() ? "verification" : super.requirementConstraintSupertype();
      }
      ast() {
        return this._ast;
      }
    };
    exports2.RequirementUsageMeta = RequirementUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.RequirementUsage, {
        base: "Requirements::requirementChecks",
        subrequirement: "Requirements::RequirementCheck::subrequirements",
        verification: "VerificationCases::VerificationCase::obj::requirementVerifications"
      })
    ], RequirementUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/concern-usage.js
var require_concern_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/concern-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConcernUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var requirement_usage_1 = require_requirement_usage();
    var ConcernUsageMeta = exports2.ConcernUsageMeta = class ConcernUsageMeta extends requirement_usage_1.RequirementUsageMeta {
      ast() {
        return this._ast;
      }
      defaultSupertype() {
        return "base";
      }
      defaultGeneralTypes() {
        const supertypes = super.defaultGeneralTypes();
        if (this.isSubrequirement()) {
          supertypes.push("subrequirement");
        }
        return supertypes;
      }
      requirementConstraintSupertype() {
        var _a;
        return ((_a = this.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.FramedConcernMembership)) ? "concern" : super.requirementConstraintKind();
      }
    };
    exports2.ConcernUsageMeta = ConcernUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ConcernUsage, {
        base: "Requirements::concernChecks",
        concern: "Requirements::RequirementCheck::concerns"
      })
    ], ConcernUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/control-node.js
var require_control_node = __commonJS({
  "../syside-languageserver/lib/model/SysML/control-node.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ControlNodeMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var action_usage_1 = require_action_usage();
    var ControlNodeMeta = exports2.ControlNodeMeta = class ControlNodeMeta extends action_usage_1.ActionUsageMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.ControlNodeMeta = ControlNodeMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ControlNode)
    ], ControlNodeMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/decision-node.js
var require_decision_node = __commonJS({
  "../syside-languageserver/lib/model/SysML/decision-node.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DecisionNodeMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var control_node_1 = require_control_node();
    var DecisionNodeMeta = exports2.DecisionNodeMeta = class DecisionNodeMeta extends control_node_1.ControlNodeMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.DecisionNodeMeta = DecisionNodeMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.DecisionNode, {
        subaction: "Actions::Action::decisions"
      })
    ], DecisionNodeMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/enumeration-definition.js
var require_enumeration_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/enumeration-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnumerationDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var attribute_definition_1 = require_attribute_definition();
    var EnumerationDefinitionMeta = exports2.EnumerationDefinitionMeta = class EnumerationDefinitionMeta extends attribute_definition_1.AttributeDefinitionMeta {
      get isVariation() {
        return true;
      }
      set isVariation(value) {
      }
      ast() {
        return this._ast;
      }
    };
    __decorate([
      utils_1.enumerable
    ], EnumerationDefinitionMeta.prototype, "isVariation", null);
    exports2.EnumerationDefinitionMeta = EnumerationDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.EnumerationDefinition)
    ], EnumerationDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/enumeration-usage.js
var require_enumeration_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/enumeration-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnumerationUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var attribute_usage_1 = require_attribute_usage();
    var EnumerationUsageMeta = exports2.EnumerationUsageMeta = class EnumerationUsageMeta extends attribute_usage_1.AttributeUsageMeta {
      ast() {
        return this._ast;
      }
      isVariantNode() {
        var _a;
        return Boolean((_a = this.owner()) === null || _a === void 0 ? void 0 : _a.is(ast_1.EnumerationDefinition));
      }
    };
    exports2.EnumerationUsageMeta = EnumerationUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.EnumerationUsage)
    ], EnumerationUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/event-occurrence-usage.js
var require_event_occurrence_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/event-occurrence-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventOccurrenceUsageMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var occurrence_usage_1 = require_occurrence_usage();
    var EventOccurrenceUsageMeta = exports2.EventOccurrenceUsageMeta = class EventOccurrenceUsageMeta extends occurrence_usage_1.OccurrenceUsageMeta {
      get isComposite() {
        return false;
      }
      set isComposite(value) {
      }
      defaultSupertype() {
        return this.isSuboccurrence() ? "suboccurrence" : super.defaultSupertype();
      }
      isSuboccurrence() {
        const parent = this.owner();
        return Boolean(parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.OccurrenceUsage, ast_1.OccurrenceDefinition));
      }
      ast() {
        return this._ast;
      }
    };
    __decorate([
      utils_1.enumerable
    ], EventOccurrenceUsageMeta.prototype, "isComposite", null);
    exports2.EventOccurrenceUsageMeta = EventOccurrenceUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.EventOccurrenceUsage, {
        suboccurrence: "Occurrences::Occurrence::timeEnclosedOccurrences"
      })
    ], EventOccurrenceUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/perform-action-usage.js
var require_perform_action_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/perform-action-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PerformActionUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var action_usage_1 = require_action_usage();
    var event_occurrence_usage_1 = require_event_occurrence_usage();
    var utils_1 = require_utils2();
    var PerformActionUsageMeta = exports2.PerformActionUsageMeta = class PerformActionUsageMeta extends (0, ts_mixer_1.Mixin)(event_occurrence_usage_1.EventOccurrenceUsageMeta, action_usage_1.ActionUsageMeta) {
      get isComposite() {
        return false;
      }
      set isComposite(value) {
      }
      defaultGeneralTypes() {
        const supertypes = super.defaultGeneralTypes();
        if (this.isPerformedAction())
          supertypes.push("performedAction");
        return supertypes;
      }
      ast() {
        return this._ast;
      }
      namingFeature() {
        return this.types(ast_1.ReferenceSubsetting).head();
      }
    };
    __decorate([
      utils_1.enumerable
      // @ts-expect-error issue with mixins
    ], PerformActionUsageMeta.prototype, "isComposite", null);
    exports2.PerformActionUsageMeta = PerformActionUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.PerformActionUsage, {
        performedAction: "Parts::Part::performedActions"
      })
    ], PerformActionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/state-usage.js
var require_state_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/state-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StateUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var action_usage_1 = require_action_usage();
    var StateUsageMeta = exports2.StateUsageMeta = class StateUsageMeta extends action_usage_1.ActionUsageMeta {
      constructor() {
        super(...arguments);
        this.isParallel = false;
      }
      getSubactionType() {
        if (this.isExclusiveState())
          return "exclusiveState";
        if (this.isSubstate())
          return "substate";
        return super.getSubactionType();
      }
      isExclusiveState() {
        const parent = this.owner();
        return Boolean((parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.StateDefinition, ast_1.StateUsage)) && !parent.isParallel);
      }
      isSubstate() {
        var _a;
        return Boolean(this.isNonEntryExitComposite() && ((_a = this.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast_1.StateDefinition, ast_1.StateUsage)));
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          model.isParallel = Boolean(options.isParallel);
        return model;
      }
    };
    exports2.StateUsageMeta = StateUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.StateUsage, {
        base: "States::stateActions",
        substate: "States::StateAction::substates",
        exclusiveState: "States::StateAction::exclusiveStates",
        ownedAction: "Parts::Part::ownedStates"
      })
    ], StateUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/exhibit-state-usage.js
var require_exhibit_state_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/exhibit-state-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExhibitStateUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var perform_action_usage_1 = require_perform_action_usage();
    var state_usage_1 = require_state_usage();
    var utils_1 = require_utils2();
    var ExhibitStateUsageMeta = exports2.ExhibitStateUsageMeta = class ExhibitStateUsageMeta extends (0, ts_mixer_1.Mixin)(perform_action_usage_1.PerformActionUsageMeta, state_usage_1.StateUsageMeta) {
      get isComposite() {
        return false;
      }
      set isComposite(value) {
      }
      defaultGeneralTypes() {
        const supertypes = super.defaultGeneralTypes();
        if (this.isPerformedAction())
          supertypes.push("performedAction");
        return supertypes;
      }
      ast() {
        return this._ast;
      }
      namingFeature() {
        return this.types(ast_1.ReferenceSubsetting).head();
      }
    };
    __decorate([
      utils_1.enumerable
      // @ts-expect-error issue with mixins
    ], ExhibitStateUsageMeta.prototype, "isComposite", null);
    exports2.ExhibitStateUsageMeta = ExhibitStateUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ExhibitStateUsage, {
        performedAction: "Parts::Part::exhibitedStates"
      })
    ], ExhibitStateUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/expressions/trigger-invocation-expression.js
var require_trigger_invocation_expression = __commonJS({
  "../syside-languageserver/lib/model/SysML/expressions/trigger-invocation-expression.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TriggerInvocationExpressionMeta = void 0;
    var ast_1 = require_ast2();
    var invocation_expression_1 = require_invocation_expression();
    var metamodel_1 = require_metamodel();
    var TriggerInvocationExpressionMeta = exports2.TriggerInvocationExpressionMeta = class TriggerInvocationExpressionMeta extends invocation_expression_1.InvocationExpressionMeta {
      constructor() {
        super(...arguments);
        this.kind = "when";
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          model.kind = options.kind;
        return model;
      }
    };
    exports2.TriggerInvocationExpressionMeta = TriggerInvocationExpressionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.TriggerInvocationExpression, {
        when: "Triggers::TriggerWhen",
        at: "Triggers::TriggerAt",
        after: "Triggers::TriggerAfter"
      })
    ], TriggerInvocationExpressionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/expressions/index.js
var require_expressions2 = __commonJS({
  "../syside-languageserver/lib/model/SysML/expressions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_trigger_invocation_expression(), exports2);
  }
});

// ../syside-languageserver/lib/model/SysML/flow-connection-definition.js
var require_flow_connection_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/flow-connection-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FlowConnectionDefinitionMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var interaction_1 = require_interaction();
    var metamodel_1 = require_metamodel();
    var action_definition_1 = require_action_definition();
    var FlowConnectionDefinitionMeta = exports2.FlowConnectionDefinitionMeta = class FlowConnectionDefinitionMeta extends (0, ts_mixer_1.Mixin)(interaction_1.InteractionMeta, action_definition_1.ActionDefinitionMeta) {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        const model = action_definition_1.ActionDefinitionMeta.create.call(this, provider, document, options);
        return model;
      }
    };
    exports2.FlowConnectionDefinitionMeta = FlowConnectionDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.FlowConnectionDefinition, {
        base: "FlowConnections::MessageConnection",
        binary: "FlowConnections::MessageTransferConnection"
      })
      // @ts-expect-error ignoring static inheritance error
    ], FlowConnectionDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/flow-connection-usage.js
var require_flow_connection_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/flow-connection-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FlowConnectionUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var item_flow_1 = require_item_flow();
    var metamodel_1 = require_metamodel();
    var action_usage_1 = require_action_usage();
    var connector_as_usage_1 = require_connector_as_usage();
    var KerML_1 = require_KerML();
    var utils_1 = require_utils2();
    var FlowConnectionUsageMeta = exports2.FlowConnectionUsageMeta = class FlowConnectionUsageMeta extends (0, ts_mixer_1.Mixin)(action_usage_1.ActionUsageMeta, item_flow_1.ItemFlowMeta, connector_as_usage_1.ConnectorAsUsageMeta) {
      constructor() {
        super(...arguments);
        this._messages = [];
      }
      get messages() {
        return this._messages;
      }
      get isMessageConnection() {
        return this._messages.length > 0;
      }
      /**
       * Adds owned message members and returns the new number of message members.
       * Any messages will be used in place of `ends`.
       */
      addMessage(...value) {
        return this.addOwnedEdges(this._messages, value);
      }
      /**
       * Removes message sby value and returns the new number of message members.
       */
      removeMessage(...value) {
        return this.removeOwnedElements(this._messages, value);
      }
      /**
       * Removes messages by predicate and returns the new number of message members.
       */
      removeMessageIf(predicate) {
        return this.removeOwnedElementsIf(this._messages, predicate);
      }
      defaultGeneralTypes() {
        const supertypes = super.defaultGeneralTypes();
        if (this.isPartOwnedComposite())
          supertypes.push("ownedAction");
        else if (this.isStructureOwnedComposite())
          supertypes.push("ownedPerformance");
        if (this.isActionOwnedComposite())
          supertypes.push("subaction");
        else if (this.isBehaviorOwnedComposite())
          supertypes.push("subperformance");
        else if (this.isBehaviorOwned())
          supertypes.push("enclosedPerformance");
        return supertypes;
      }
      defaultSupertype() {
        return this.isMessageConnection ? "message" : "base";
      }
      ast() {
        return this._ast;
      }
      collectDeclaration(parts) {
        KerML_1.FeatureMeta.prototype["collectDeclaration"].call(this, parts);
        if (this.isMessageConnection)
          parts.push(["messages", this.messages]);
        else if (this.ends.length > 0)
          parts.push(["ends", this.ends]);
      }
      static create(provider, document, options) {
        const model = action_usage_1.ActionUsageMeta.create.call(this, provider, document, options);
        if (options) {
          connector_as_usage_1.ConnectorAsUsageMeta.applyConnectorOptions(model, options);
          item_flow_1.ItemFlowMeta.applyItemFlowOptions(model, options);
          if (options.messages)
            model.addMessage(...options.messages);
        }
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], FlowConnectionUsageMeta.prototype, "messages", null);
    exports2.FlowConnectionUsageMeta = FlowConnectionUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.FlowConnectionUsage, {
        base: "FlowConnections::flowConnections",
        message: "FlowConnections::messageConnections",
        enclosedPerformance: "Performances::Performance::enclosedPerformances",
        subperformance: "Performances::Performance::subperformances",
        ownedPerformance: "Objects::Object::ownedPerformances",
        subaction: "Actions::Action::subactions",
        ownedAction: "Parts::Part::ownedActions",
        entry: "States::StateAction::entryAction",
        do: "States::StateAction::doAction",
        exit: "States::StateAction::exitAction",
        trigger: "Actions::TransitionAction::accepter",
        guard: "Actions::TransitionAction::guard",
        effect: "Actions::TransitionAction::effect",
        timeslice: "Occurrences::Occurrence::timeSlices",
        snapshot: "Occurrences::Occurrence::snapshots"
      })
    ], FlowConnectionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/loop-action-usage.js
var require_loop_action_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/loop-action-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LoopActionUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var action_usage_1 = require_action_usage();
    var LoopActionUsageMeta = exports2.LoopActionUsageMeta = class LoopActionUsageMeta extends action_usage_1.ActionUsageMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.LoopActionUsageMeta = LoopActionUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.LoopActionUsage, "abstract")
    ], LoopActionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/for-loop-action-usage.js
var require_for_loop_action_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/for-loop-action-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var ForLoopActionUsageMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForLoopActionUsageMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var loop_action_usage_1 = require_loop_action_usage();
    var ForLoopActionUsageMeta = exports2.ForLoopActionUsageMeta = ForLoopActionUsageMeta_1 = class ForLoopActionUsageMeta extends loop_action_usage_1.LoopActionUsageMeta {
      get variable() {
        return this._variable;
      }
      set variable(value) {
        this._variable = this.swapEdgeOwnership(this._variable, value);
      }
      get sequence() {
        return this._sequence;
      }
      set sequence(value) {
        this._sequence = this.swapEdgeOwnership(this._sequence, value);
      }
      get body() {
        return this._body;
      }
      set body(value) {
        this._body = this.swapEdgeOwnership(this._body, value);
      }
      ast() {
        return this._ast;
      }
      featureMembers() {
        const baseFeatures = super.featureMembers();
        return [this.variable, this.sequence, this.body].filter(utils_1.NonNullable).concat(baseFeatures);
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        if (this.variable)
          parts.push(["variable", [this.variable]]);
        if (this.sequence)
          parts.push(["sequence", [this.sequence]]);
        if (this.body)
          parts.push(["body", [this.body]]);
      }
      static applyForLoopOptions(model, options) {
        model.variable = options.variable;
        model.sequence = options.sequence;
        model.body = options.body;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          ForLoopActionUsageMeta_1.applyForLoopOptions(model, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], ForLoopActionUsageMeta.prototype, "variable", null);
    __decorate([
      utils_1.enumerable
    ], ForLoopActionUsageMeta.prototype, "sequence", null);
    __decorate([
      utils_1.enumerable
    ], ForLoopActionUsageMeta.prototype, "body", null);
    exports2.ForLoopActionUsageMeta = ForLoopActionUsageMeta = ForLoopActionUsageMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ForLoopActionUsage, {
        base: "Actions::forLoopActions",
        subaction: "Actions::Action::forLoops",
        loopVariable: "Actions::ForLoopAction::var"
        // TODO:
      })
    ], ForLoopActionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/for-node.js
var require_for_node = __commonJS({
  "../syside-languageserver/lib/model/SysML/for-node.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForkNodeMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var control_node_1 = require_control_node();
    var ForkNodeMeta = exports2.ForkNodeMeta = class ForkNodeMeta extends control_node_1.ControlNodeMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.ForkNodeMeta = ForkNodeMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ForkNode, {
        subaction: "Actions::Action::forks"
      })
    ], ForkNodeMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/if-action-usage.js
var require_if_action_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/if-action-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var IfActionUsageMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IfActionUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var action_usage_1 = require_action_usage();
    var utils_1 = require_utils2();
    var IfActionUsageMeta = exports2.IfActionUsageMeta = IfActionUsageMeta_1 = class IfActionUsageMeta extends action_usage_1.ActionUsageMeta {
      get condition() {
        return this._condition;
      }
      set condition(value) {
        this._condition = this.swapEdgeOwnership(this._condition, value);
      }
      get then() {
        return this._then;
      }
      set then(value) {
        this._then = this.swapEdgeOwnership(this._then, value);
      }
      get else() {
        return this._else;
      }
      set else(value) {
        this._else = this.swapEdgeOwnership(this._else, value);
      }
      ast() {
        return this._ast;
      }
      defaultGeneralTypes() {
        const supertypes = super.defaultGeneralTypes();
        if (this.isIfThenElse())
          supertypes.push("ifThenElse");
        return supertypes;
      }
      featureMembers() {
        const baseFeatures = super.featureMembers();
        return [this._condition, this._then, this._else].filter(utils_1.NonNullable).concat(baseFeatures);
      }
      isIfThenElse() {
        return this.else !== void 0;
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        if (this.condition)
          parts.push(["condition", [this.condition]]);
        if (this.then)
          parts.push(["then", [this.then]]);
        if (this.else)
          parts.push(["else", [this.else]]);
      }
      static applyIfOptions(model, options) {
        model.condition = options.condition;
        model.then = options.then;
        model.else = options.else;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          IfActionUsageMeta_1.applyIfOptions(model, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], IfActionUsageMeta.prototype, "condition", null);
    __decorate([
      utils_1.enumerable
    ], IfActionUsageMeta.prototype, "then", null);
    __decorate([
      utils_1.enumerable
    ], IfActionUsageMeta.prototype, "else", null);
    exports2.IfActionUsageMeta = IfActionUsageMeta = IfActionUsageMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.IfActionUsage, {
        base: "Actions::ifThenActions",
        ifThenElse: "Actions::ifThenElseActions",
        subaction: "Actions::Action::ifSubactions"
      })
    ], IfActionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/use-case-usage.js
var require_use_case_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/use-case-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UseCaseUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var case_usage_1 = require_case_usage();
    var UseCaseUsageMeta = exports2.UseCaseUsageMeta = class UseCaseUsageMeta extends case_usage_1.CaseUsageMeta {
      getSubactionType() {
        return this.isSubUseCase() ? "subUseCase" : super.getSubactionType();
      }
      isSubUseCase() {
        const parent = this.owner();
        return Boolean(this.isNonEntryExitComposite() && (parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.UseCaseUsage, ast_1.UseCaseDefinition)));
      }
      ast() {
        return this._ast;
      }
    };
    exports2.UseCaseUsageMeta = UseCaseUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.UseCaseUsage, {
        base: "UseCases::useCases",
        subUseCase: "UseCases::UseCase::subUseCases"
      })
    ], UseCaseUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/include-use-case-usage.js
var require_include_use_case_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/include-use-case-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IncludeUseCaseUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var perform_action_usage_1 = require_perform_action_usage();
    var use_case_usage_1 = require_use_case_usage();
    var utils_1 = require_utils2();
    var IncludeUseCaseUsageMeta = exports2.IncludeUseCaseUsageMeta = class IncludeUseCaseUsageMeta extends (0, ts_mixer_1.Mixin)(perform_action_usage_1.PerformActionUsageMeta, use_case_usage_1.UseCaseUsageMeta) {
      get isComposite() {
        return false;
      }
      set isComposite(value) {
      }
      ast() {
        return this._ast;
      }
      defaultGeneralTypes() {
        const supertypes = super.defaultGeneralTypes();
        if (this.isPerformedAction())
          supertypes.push("performedAction");
        return supertypes;
      }
      hasRelevantSubjectParameter() {
        const parent = this.owner();
        return Boolean(parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.CaseDefinition, ast_1.CaseUsage));
      }
      namingFeature() {
        return this.types(ast_1.ReferenceSubsetting).head();
      }
    };
    __decorate([
      utils_1.enumerable
      // @ts-expect-error issue with mixins
    ], IncludeUseCaseUsageMeta.prototype, "isComposite", null);
    exports2.IncludeUseCaseUsageMeta = IncludeUseCaseUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.IncludeUseCaseUsage, {
        base: "UseCases::useCases",
        subUseCase: "UseCases::UseCase::includedUseCases",
        performedAction: "Parts::Part::performedActions"
      })
    ], IncludeUseCaseUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/interface-definition.js
var require_interface_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/interface-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InterfaceDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var connection_definition_1 = require_connection_definition();
    var InterfaceDefinitionMeta = exports2.InterfaceDefinitionMeta = class InterfaceDefinitionMeta extends connection_definition_1.ConnectionDefinitionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.InterfaceDefinitionMeta = InterfaceDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.InterfaceDefinition, {
        base: "Interfaces::Interface",
        binary: "Interfaces::BinaryInterface"
      })
    ], InterfaceDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/interface-usage.js
var require_interface_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/interface-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InterfaceUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var connection_usage_1 = require_connection_usage();
    var InterfaceUsageMeta = exports2.InterfaceUsageMeta = class InterfaceUsageMeta extends connection_usage_1.ConnectionUsageMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.InterfaceUsageMeta = InterfaceUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.InterfaceUsage, {
        base: "Interfaces::interfaces",
        binary: "Interfaces::binaryInterfaces"
      })
    ], InterfaceUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/join-node.js
var require_join_node = __commonJS({
  "../syside-languageserver/lib/model/SysML/join-node.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JoinNodeMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var control_node_1 = require_control_node();
    var JoinNodeMeta = exports2.JoinNodeMeta = class JoinNodeMeta extends control_node_1.ControlNodeMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.JoinNodeMeta = JoinNodeMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.JoinNode, {
        subaction: "Actions::Action::joins"
      })
    ], JoinNodeMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/merge-node.js
var require_merge_node = __commonJS({
  "../syside-languageserver/lib/model/SysML/merge-node.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MergeNodeMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var control_node_1 = require_control_node();
    var MergeNodeMeta = exports2.MergeNodeMeta = class MergeNodeMeta extends control_node_1.ControlNodeMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.MergeNodeMeta = MergeNodeMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.MergeNode, {
        subaction: "Actions::Action::merges"
      })
    ], MergeNodeMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/metadata-definition.js
var require_metadata_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/metadata-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetadataDefinitionMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metaclass_1 = require_metaclass();
    var metamodel_1 = require_metamodel();
    var item_definition_1 = require_item_definition();
    var MetadataDefinitionMeta = exports2.MetadataDefinitionMeta = class MetadataDefinitionMeta extends (0, ts_mixer_1.Mixin)(metaclass_1.MetaclassMeta, item_definition_1.ItemDefinitionMeta) {
      ast() {
        return this._ast;
      }
    };
    exports2.MetadataDefinitionMeta = MetadataDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.MetadataDefinition, {
        base: "Metadata::MetadataItem"
      })
    ], MetadataDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/metadata-usage.js
var require_metadata_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/metadata-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetadataUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metadata_feature_1 = require_metadata_feature();
    var metamodel_1 = require_metamodel();
    var item_usage_1 = require_item_usage();
    var MetadataUsageMeta = exports2.MetadataUsageMeta = class MetadataUsageMeta extends (0, ts_mixer_1.Mixin)(metadata_feature_1.MetadataFeatureMeta, item_usage_1.ItemUsageMeta) {
      defaultSupertype() {
        return "base";
      }
      ast() {
        return this._ast;
      }
    };
    exports2.MetadataUsageMeta = MetadataUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.MetadataUsage, {
        base: "Metadata::metadataItems",
        annotatedElement: "Metaobjects::Metaobject::annotatedElement",
        baseType: "Metaobjects::SemanticMetadata::baseType"
      })
    ], MetadataUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/actor-membership.js
var require_actor_membership = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/actor-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActorMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var parameter_membership_1 = require_parameter_membership();
    var metamodel_1 = require_metamodel();
    var ActorMembershipMeta = exports2.ActorMembershipMeta = class ActorMembershipMeta extends parameter_membership_1.ParameterMembershipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.ActorMembershipMeta = ActorMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ActorMembership)
    ], ActorMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/conjugated-port-typing.js
var require_conjugated_port_typing = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/conjugated-port-typing.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConjugatedPortTypingMeta = void 0;
    var ast_1 = require_ast2();
    var KerML_1 = require_KerML();
    var metamodel_1 = require_metamodel();
    var ConjugatedPortTypingMeta = exports2.ConjugatedPortTypingMeta = class ConjugatedPortTypingMeta extends KerML_1.FeatureTypingMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.ConjugatedPortTypingMeta = ConjugatedPortTypingMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ConjugatedPortTyping)
      // @ts-expect-error ignoring static inheritance error
    ], ConjugatedPortTypingMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/expose.js
var require_expose = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/expose.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExposeMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var import_1 = require_import();
    var metamodel_1 = require_metamodel();
    var ExposeMeta = exports2.ExposeMeta = class ExposeMeta extends import_1.ImportMeta {
      /**
       * Visibility of the element at the end of this import
       * @see {@link element}
       */
      get visibility() {
        return 1;
      }
      set visibility(value) {
        if (value != 1) {
          throw new Error("Expose visibility must be protected");
        }
      }
      get importsAll() {
        return true;
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    __decorate([
      utils_1.enumerable
    ], ExposeMeta.prototype, "visibility", null);
    __decorate([
      utils_1.enumerable
    ], ExposeMeta.prototype, "importsAll", null);
    exports2.ExposeMeta = ExposeMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.Expose, "abstract")
    ], ExposeMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/requirement-constraint-membership.js
var require_requirement_constraint_membership = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/requirement-constraint-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RequirementConstraintMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var feature_membership_1 = require_feature_membership();
    var metamodel_1 = require_metamodel();
    var RequirementConstraintMembershipMeta = exports2.RequirementConstraintMembershipMeta = class RequirementConstraintMembershipMeta extends feature_membership_1.FeatureMembershipMeta {
      constructor() {
        super(...arguments);
        this._kind = "requirement";
      }
      get kind() {
        return this._kind;
      }
      set kind(value) {
        this._kind = value;
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options === null || options === void 0 ? void 0 : options.kind)
          model.kind = options.kind;
        return model;
      }
    };
    exports2.RequirementConstraintMembershipMeta = RequirementConstraintMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.RequirementConstraintMembership)
    ], RequirementConstraintMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/framed-concern-membership.js
var require_framed_concern_membership = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/framed-concern-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FramedConcernMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var requirement_constraint_membership_1 = require_requirement_constraint_membership();
    var FramedConcernMembershipMeta = exports2.FramedConcernMembershipMeta = class FramedConcernMembershipMeta extends requirement_constraint_membership_1.RequirementConstraintMembershipMeta {
      get kind() {
        return "requirement";
      }
      set kind(value) {
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.FramedConcernMembershipMeta = FramedConcernMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.FramedConcernMembership)
    ], FramedConcernMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/membership-expose.js
var require_membership_expose = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/membership-expose.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MembershipExposeMeta = void 0;
    var ast_1 = require_ast2();
    var membership_import_1 = require_membership_import();
    var metamodel_1 = require_metamodel();
    var expose_1 = require_expose();
    var MembershipExposeMeta = exports2.MembershipExposeMeta = class MembershipExposeMeta {
      // eslint-disable-next-line unused-imports/no-unused-vars
      constructor(id) {
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return expose_1.ExposeMeta.create.call(this, provider, document, options);
      }
    };
    exports2.MembershipExposeMeta = MembershipExposeMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.MembershipExpose),
      (0, metamodel_1.mix)(expose_1.ExposeMeta, membership_import_1.MembershipImportMeta)
      // eslint-disable-next-line unused-imports/no-unused-vars
    ], MembershipExposeMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/namespace-expose.js
var require_namespace_expose = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/namespace-expose.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NamespaceExposeMeta = void 0;
    var ast_1 = require_ast2();
    var namespace_import_1 = require_namespace_import();
    var metamodel_1 = require_metamodel();
    var expose_1 = require_expose();
    var NamespaceExposeMeta = exports2.NamespaceExposeMeta = class NamespaceExposeMeta {
      // eslint-disable-next-line unused-imports/no-unused-vars
      constructor(id) {
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return expose_1.ExposeMeta.create.call(this, provider, document, options);
      }
    };
    exports2.NamespaceExposeMeta = NamespaceExposeMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.NamespaceExpose),
      (0, metamodel_1.mix)(expose_1.ExposeMeta, namespace_import_1.NamespaceImportMeta)
      // eslint-disable-next-line unused-imports/no-unused-vars
    ], NamespaceExposeMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/objective-membership.js
var require_objective_membership = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/objective-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ObjectiveMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var feature_membership_1 = require_feature_membership();
    var metamodel_1 = require_metamodel();
    var ObjectiveMembershipMeta = exports2.ObjectiveMembershipMeta = class ObjectiveMembershipMeta extends feature_membership_1.FeatureMembershipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.ObjectiveMembershipMeta = ObjectiveMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ObjectiveMembership)
    ], ObjectiveMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/port-conjugation.js
var require_port_conjugation = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/port-conjugation.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortConjugationMeta = void 0;
    var ast_1 = require_ast2();
    var KerML_1 = require_KerML();
    var metamodel_1 = require_metamodel();
    var PortConjugationMeta = exports2.PortConjugationMeta = class PortConjugationMeta extends KerML_1.ConjugationMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.PortConjugationMeta = PortConjugationMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.PortConjugation)
      // @ts-expect-error ignoring static inheritance error
    ], PortConjugationMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/requirement-verification-membership.js
var require_requirement_verification_membership = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/requirement-verification-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RequirementVerificationMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var requirement_constraint_membership_1 = require_requirement_constraint_membership();
    var RequirementVerificationMembershipMeta = exports2.RequirementVerificationMembershipMeta = class RequirementVerificationMembershipMeta extends requirement_constraint_membership_1.RequirementConstraintMembershipMeta {
      get kind() {
        return "requirement";
      }
      set kind(value) {
      }
      ast() {
        return this._ast;
      }
      isLegalVerification() {
        var _a;
        let owner = this.owner();
        if (!(owner === null || owner === void 0 ? void 0 : owner.is(ast_1.RequirementUsage)) || !((_a = owner.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.ObjectiveMembership)))
          return false;
        owner = owner.owner();
        return Boolean(owner === null || owner === void 0 ? void 0 : owner.isAny(ast_1.VerificationCaseDefinition, ast_1.VerificationCaseUsage));
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.RequirementVerificationMembershipMeta = RequirementVerificationMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.RequirementVerificationMembership)
    ], RequirementVerificationMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/stakeholder-membership.js
var require_stakeholder_membership = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/stakeholder-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StakeholderMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var parameter_membership_1 = require_parameter_membership();
    var metamodel_1 = require_metamodel();
    var StakeholderMembershipMeta = exports2.StakeholderMembershipMeta = class StakeholderMembershipMeta extends parameter_membership_1.ParameterMembershipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.StakeholderMembershipMeta = StakeholderMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.StakeholderMembership)
    ], StakeholderMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/state-subaction-membership.js
var require_state_subaction_membership = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/state-subaction-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StateSubactionMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var feature_membership_1 = require_feature_membership();
    var metamodel_1 = require_metamodel();
    var StateSubactionMembershipMeta = exports2.StateSubactionMembershipMeta = class StateSubactionMembershipMeta extends feature_membership_1.FeatureMembershipMeta {
      constructor() {
        super(...arguments);
        this.kind = "entry";
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options === null || options === void 0 ? void 0 : options.kind)
          model.kind = options.kind;
        return model;
      }
    };
    exports2.StateSubactionMembershipMeta = StateSubactionMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.StateSubactionMembership)
    ], StateSubactionMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/subject-membership.js
var require_subject_membership = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/subject-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SubjectMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var parameter_membership_1 = require_parameter_membership();
    var metamodel_1 = require_metamodel();
    var SubjectMembershipMeta = exports2.SubjectMembershipMeta = class SubjectMembershipMeta extends parameter_membership_1.ParameterMembershipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.SubjectMembershipMeta = SubjectMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.SubjectMembership)
    ], SubjectMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/transition-feature-membership.js
var require_transition_feature_membership = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/transition-feature-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransitionFeatureMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var feature_membership_1 = require_feature_membership();
    var metamodel_1 = require_metamodel();
    var utils_1 = require_utils2();
    var TransitionFeatureMembershipMeta = exports2.TransitionFeatureMembershipMeta = class TransitionFeatureMembershipMeta extends feature_membership_1.FeatureMembershipMeta {
      constructor() {
        super(...arguments);
        this._kind = "trigger";
      }
      get kind() {
        return this._kind;
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], TransitionFeatureMembershipMeta.prototype, "kind", null);
    exports2.TransitionFeatureMembershipMeta = TransitionFeatureMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.TransitionFeatureMembership)
    ], TransitionFeatureMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/variant-membership.js
var require_variant_membership = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/variant-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VariantMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var owning_membership_1 = require_owning_membership();
    var metamodel_1 = require_metamodel();
    var VariantMembershipMeta = exports2.VariantMembershipMeta = class VariantMembershipMeta extends owning_membership_1.OwningMembershipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.VariantMembershipMeta = VariantMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.VariantMembership)
    ], VariantMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/view-rendering-membership.js
var require_view_rendering_membership = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/view-rendering-membership.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ViewRenderingMembershipMeta = void 0;
    var ast_1 = require_ast2();
    var feature_membership_1 = require_feature_membership();
    var metamodel_1 = require_metamodel();
    var ViewRenderingMembershipMeta = exports2.ViewRenderingMembershipMeta = class ViewRenderingMembershipMeta extends feature_membership_1.FeatureMembershipMeta {
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return super.create(provider, document, options);
      }
    };
    exports2.ViewRenderingMembershipMeta = ViewRenderingMembershipMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ViewRenderingMembership)
    ], ViewRenderingMembershipMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/relationships/index.js
var require_relationships2 = __commonJS({
  "../syside-languageserver/lib/model/SysML/relationships/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actor_membership(), exports2);
    __exportStar(require_conjugated_port_typing(), exports2);
    __exportStar(require_expose(), exports2);
    __exportStar(require_framed_concern_membership(), exports2);
    __exportStar(require_membership_expose(), exports2);
    __exportStar(require_namespace_expose(), exports2);
    __exportStar(require_objective_membership(), exports2);
    __exportStar(require_port_conjugation(), exports2);
    __exportStar(require_requirement_constraint_membership(), exports2);
    __exportStar(require_requirement_verification_membership(), exports2);
    __exportStar(require_stakeholder_membership(), exports2);
    __exportStar(require_state_subaction_membership(), exports2);
    __exportStar(require_subject_membership(), exports2);
    __exportStar(require_transition_feature_membership(), exports2);
    __exportStar(require_variant_membership(), exports2);
    __exportStar(require_view_rendering_membership(), exports2);
  }
});

// ../syside-languageserver/lib/model/SysML/port-definition.js
var require_port_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/port-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConjugatedPortDefinitionMeta = exports2.PortDefinitionMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var structure_1 = require_structure();
    var metamodel_1 = require_metamodel();
    var occurrence_definition_1 = require_occurrence_definition();
    var KerML_1 = require_KerML();
    var utils_1 = require_utils2();
    var relationships_1 = require_relationships2();
    var PortDefinitionMeta = exports2.PortDefinitionMeta = class PortDefinitionMeta extends (0, ts_mixer_1.Mixin)(structure_1.StructureMeta, occurrence_definition_1.OccurrenceDefinitionMeta) {
      get conjugatedDefinition() {
        return this._conjugatedDefinition;
      }
      ast() {
        return this._ast;
      }
      setName(name) {
        var _a;
        super.setName(name);
        const def = (_a = this._conjugatedDefinition) === null || _a === void 0 ? void 0 : _a.element();
        if (def)
          def.declaredName = this.name ? `~${this.name}` : void 0;
      }
      setShortName(name) {
        var _a;
        super.setShortName(name);
        const def = (_a = this._conjugatedDefinition) === null || _a === void 0 ? void 0 : _a.element();
        if (def)
          def.declaredShortName = this.shortName ? `~${this.shortName}` : void 0;
      }
      static create(provider, document, options) {
        const portDef = super.create(provider, document, options);
        const conjugated = ConjugatedPortDefinitionMeta.create(provider, document);
        conjugated.addHeritage([relationships_1.PortConjugationMeta.create(provider, document), portDef]);
        portDef._conjugatedDefinition = KerML_1.OwningMembershipMeta.create(provider, document, {
          parent: portDef,
          target: conjugated
        });
        if (options === null || options === void 0 ? void 0 : options.declaredName)
          portDef.setName(options.declaredName);
        if (options === null || options === void 0 ? void 0 : options.declaredShortName)
          portDef.setShortName(options.declaredShortName);
        return portDef;
      }
      collectParts() {
        const parts = occurrence_definition_1.OccurrenceDefinitionMeta.prototype["collectParts"].call(this);
        if (this._conjugatedDefinition)
          parts.push(["conjugatedDefinition", [this._conjugatedDefinition]]);
        return parts;
      }
    };
    __decorate([
      utils_1.enumerable
    ], PortDefinitionMeta.prototype, "conjugatedDefinition", null);
    exports2.PortDefinitionMeta = PortDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.PortDefinition, {
        base: "Ports::Port"
      })
    ], PortDefinitionMeta);
    var ConjugatedPortDefinitionMeta = exports2.ConjugatedPortDefinitionMeta = class ConjugatedPortDefinitionMeta extends PortDefinitionMeta {
      get originalPortDefinition() {
        return this._owner;
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        return occurrence_definition_1.OccurrenceDefinitionMeta.create.call(this, provider, document, options);
      }
    };
    exports2.ConjugatedPortDefinitionMeta = ConjugatedPortDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ConjugatedPortDefinition)
    ], ConjugatedPortDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/port-usage.js
var require_port_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/port-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PortUsageMeta = void 0;
    var ast_1 = require_ast2();
    var common_1 = require_common();
    var metamodel_1 = require_metamodel();
    var occurrence_usage_1 = require_occurrence_usage();
    var PortUsageMeta = exports2.PortUsageMeta = class PortUsageMeta extends occurrence_usage_1.OccurrenceUsageMeta {
      get isComposite() {
        var _a;
        return ((_a = this.owningType) === null || _a === void 0 ? void 0 : _a.isAny(ast_1.PortDefinition, ast_1.PortUsage)) ? super.isComposite : false;
      }
      set isComposite(value) {
        super.isComposite = value;
      }
      defaultSupertype() {
        if (this.isOwnedPort())
          return "ownedPort";
        if (this.isSubport())
          return "subport";
        return "base";
      }
      isOwnedPort() {
        var _a;
        return Boolean(this.isComposite && ((_a = this.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast_1.PartDefinition, ast_1.PortUsage)));
      }
      isSubport() {
        var _a;
        return Boolean(this.isComposite && ((_a = this.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast_1.PortDefinition, ast_1.PortUsage)));
      }
      ast() {
        return this._ast;
      }
    };
    __decorate([
      common_1.enumerable
    ], PortUsageMeta.prototype, "isComposite", null);
    exports2.PortUsageMeta = PortUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.PortUsage, {
        base: "Ports::ports",
        ownedPort: "Parts::Part::ownedPorts",
        subport: "Ports::Port::subports"
      })
    ], PortUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/references/conjugated-port-reference.js
var require_conjugated_port_reference = __commonJS({
  "../syside-languageserver/lib/model/SysML/references/conjugated-port-reference.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConjugatedPortReferenceMeta = void 0;
    var ast_1 = require_ast2();
    var containers_1 = require_containers();
    var classifier_reference_1 = require_classifier_reference();
    var metamodel_1 = require_metamodel();
    var ConjugatedPortReferenceMeta = exports2.ConjugatedPortReferenceMeta = class ConjugatedPortReferenceMeta extends classifier_reference_1.ClassifierReferenceMeta {
      constructor() {
        super(...arguments);
        this.to = new containers_1.Target();
      }
      ast() {
        return this._ast;
      }
    };
    exports2.ConjugatedPortReferenceMeta = ConjugatedPortReferenceMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ConjugatedPortReference)
    ], ConjugatedPortReferenceMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/references/index.js
var require_references4 = __commonJS({
  "../syside-languageserver/lib/model/SysML/references/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_conjugated_port_reference(), exports2);
  }
});

// ../syside-languageserver/lib/model/SysML/rendering-definition.js
var require_rendering_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/rendering-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RenderingDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var part_definition_1 = require_part_definition();
    var RenderingDefinitionMeta = exports2.RenderingDefinitionMeta = class RenderingDefinitionMeta extends part_definition_1.PartDefinitionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.RenderingDefinitionMeta = RenderingDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.RenderingDefinition, {
        base: "Views::Rendering"
      })
    ], RenderingDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/rendering-usage.js
var require_rendering_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/rendering-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RenderingUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var part_usage_1 = require_part_usage();
    var RenderingUsageMeta = exports2.RenderingUsageMeta = class RenderingUsageMeta extends part_usage_1.PartUsageMeta {
      defaultSupertype() {
        return this.isSubrendering() ? "subrendering" : "base";
      }
      defaultGeneralTypes() {
        const supertypes = super.defaultGeneralTypes();
        if (this.isViewRendering()) {
          supertypes.push({ type: "viewRendering", specialization: ast_1.Redefinition });
        }
        return supertypes;
      }
      isSubrendering() {
        const parent = this.owner();
        return Boolean(parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.RenderingUsage, ast_1.RenderingDefinition));
      }
      isViewRendering() {
        const parent = this.parent();
        return Boolean(parent === null || parent === void 0 ? void 0 : parent.is(ast_1.ViewRenderingMembership));
      }
      ast() {
        return this._ast;
      }
      namingFeature() {
        var _a;
        return ((_a = this.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.ViewRenderingMembership)) ? this.types(ast_1.ReferenceSubsetting).head() : super.namingFeature();
      }
    };
    exports2.RenderingUsageMeta = RenderingUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.RenderingUsage, {
        base: "Views::renderings",
        subrendering: "Views::Rendering::subrenderings",
        viewRendering: "Views::View::viewRendering"
      })
    ], RenderingUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/satisfy-requirement-usage.js
var require_satisfy_requirement_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/satisfy-requirement-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var SatisfyRequirementUsageMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SatisfyRequirementUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var assert_constraint_usage_1 = require_assert_constraint_usage();
    var requirement_usage_1 = require_requirement_usage();
    var utils_1 = require_utils2();
    var occurrence_usage_1 = require_occurrence_usage();
    var SatisfyRequirementUsageMeta = exports2.SatisfyRequirementUsageMeta = SatisfyRequirementUsageMeta_1 = class SatisfyRequirementUsageMeta extends (0, ts_mixer_1.Mixin)(requirement_usage_1.RequirementUsageMeta, assert_constraint_usage_1.AssertConstraintUsageMeta) {
      get satisfactionSubject() {
        return this._satisfactionSubject;
      }
      set satisfactionSubject(value) {
        this._satisfactionSubject = this.swapEdgeOwnership(this._satisfactionSubject, value);
      }
      defaultSupertype() {
        return this.isNegated ? "negated" : "base";
      }
      ast() {
        return this._ast;
      }
      featureMembers() {
        const baseFeatures = occurrence_usage_1.OccurrenceUsageMeta.prototype.featureMembers.call(this);
        return [this.satisfactionSubject].filter(utils_1.NonNullable).concat(baseFeatures);
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        if (this.satisfactionSubject)
          parts.push(["satisfactionSubject", [this.satisfactionSubject]]);
      }
      static applySatisfyRequirementOptions(model, options) {
        model.satisfactionSubject = options.satisfactionSubject;
      }
      static create(provider, document, options) {
        const model = assert_constraint_usage_1.AssertConstraintUsageMeta.create.call(this, provider, document, options);
        if (options) {
          SatisfyRequirementUsageMeta_1.applySatisfyRequirementOptions(model, options);
        }
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], SatisfyRequirementUsageMeta.prototype, "satisfactionSubject", null);
    exports2.SatisfyRequirementUsageMeta = SatisfyRequirementUsageMeta = SatisfyRequirementUsageMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.SatisfyRequirementUsage, {
        base: "Requirements::satisfiedRequirementChecks",
        negated: "Requirements::notSatisfiedRequirementChecks"
      })
    ], SatisfyRequirementUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/send-action-usage.js
var require_send_action_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/send-action-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var SendActionUsageMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SendActionUsageMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var KerML_1 = require_KerML();
    var metamodel_1 = require_metamodel();
    var action_usage_1 = require_action_usage();
    var reference_usage_1 = require_reference_usage();
    var SendActionUsageMeta = exports2.SendActionUsageMeta = SendActionUsageMeta_1 = class SendActionUsageMeta extends action_usage_1.ActionUsageMeta {
      get payload() {
        var _a;
        return (_a = this._payload) !== null && _a !== void 0 ? _a : this._defaultPayload;
      }
      set payload(value) {
        this._payload = this.swapEdgeOwnership(this._payload, value);
      }
      get sender() {
        var _a;
        return (_a = this._sender) !== null && _a !== void 0 ? _a : this._defaultSender;
      }
      set sender(value) {
        this._sender = this.swapEdgeOwnership(this._sender, value);
      }
      get receiver() {
        var _a;
        return (_a = this._receiver) !== null && _a !== void 0 ? _a : this._defaultReceiver;
      }
      set receiver(value) {
        this._receiver = this.swapEdgeOwnership(this._receiver, value);
      }
      ast() {
        return this._ast;
      }
      featureMembers() {
        const baseFeatures = KerML_1.FeatureMeta.prototype.featureMembers.call(this);
        return [this.payload, this.sender, this.receiver].filter(utils_1.NonNullable).concat(baseFeatures);
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        if (this.payload)
          parts.push(["payload", [this.payload]]);
        if (this.sender)
          parts.push(["sender", [this.sender]]);
        if (this.receiver)
          parts.push(["body", [this.receiver]]);
      }
      static applySendOptions(model, provider, options) {
        model.payload = options === null || options === void 0 ? void 0 : options.payload;
        model.sender = options === null || options === void 0 ? void 0 : options.sender;
        model.receiver = options === null || options === void 0 ? void 0 : options.receiver;
        model._defaultPayload = model.swapEdgeOwnership(model._defaultPayload, (0, reference_usage_1.createEmptyParameterMember)(provider, model.document));
        model._defaultSender = model.swapEdgeOwnership(model._defaultSender, (0, reference_usage_1.createEmptyParameterMember)(provider, model.document));
        model._defaultReceiver = model.swapEdgeOwnership(model._defaultReceiver, (0, reference_usage_1.createEmptyParameterMember)(provider, model.document));
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        SendActionUsageMeta_1.applySendOptions(model, provider, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], SendActionUsageMeta.prototype, "payload", null);
    __decorate([
      utils_1.enumerable
    ], SendActionUsageMeta.prototype, "sender", null);
    __decorate([
      utils_1.enumerable
    ], SendActionUsageMeta.prototype, "receiver", null);
    exports2.SendActionUsageMeta = SendActionUsageMeta = SendActionUsageMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.SendActionUsage, {
        base: "Actions::sendActions",
        subaction: "Actions::Action::sendSubactions"
      })
    ], SendActionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/state-definition.js
var require_state_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/state-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StateDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var action_definition_1 = require_action_definition();
    var StateDefinitionMeta = exports2.StateDefinitionMeta = class StateDefinitionMeta extends action_definition_1.ActionDefinitionMeta {
      constructor() {
        super(...arguments);
        this.isParallel = false;
      }
      ast() {
        return this._ast;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          model.isParallel = Boolean(options.isParallel);
        return model;
      }
    };
    exports2.StateDefinitionMeta = StateDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.StateDefinition, {
        base: "States::StateAction"
      })
    ], StateDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/succession-as-usage.js
var require_succession_as_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/succession-as-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var SuccessionAsUsageMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SuccessionAsUsageMeta = void 0;
    var langium_1 = require_lib2();
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var succession_1 = require_succession();
    var metamodel_1 = require_metamodel();
    var connector_as_usage_1 = require_connector_as_usage();
    var SuccessionAsUsageMeta = exports2.SuccessionAsUsageMeta = SuccessionAsUsageMeta_1 = class SuccessionAsUsageMeta extends (0, ts_mixer_1.Mixin)(succession_1.SuccessionMeta, connector_as_usage_1.ConnectorAsUsageMeta) {
      ast() {
        return this._ast;
      }
      defaultSupertype() {
        return succession_1.SuccessionMeta.prototype.defaultSupertype.call(this);
      }
      targetFeature() {
        const owner = this.owner();
        if (!(owner === null || owner === void 0 ? void 0 : owner.is(ast_1.Type)))
          return;
        const parent = this.parent();
        const features = owner.featureMembers();
        const index = features.findIndex((m) => m === parent);
        if (index >= features.length)
          return;
        return (0, langium_1.stream)(features.slice(index + 1)).filter((m) => m.is(ast_1.FeatureMembership)).head();
      }
      static findPreviousFeature(feature, linker) {
        const owner = feature.owner();
        if (!(owner === null || owner === void 0 ? void 0 : owner.is(ast_1.Type)))
          return;
        const parent = feature.parent();
        const features = owner.featureMembers();
        let index = features.findIndex((m) => m === parent);
        while (--index >= 0) {
          const membership = features[index];
          if (membership.is(ast_1.TransitionFeatureMembership))
            continue;
          linker === null || linker === void 0 ? void 0 : linker.call(void 0, membership);
          const element = membership.element();
          if (!element)
            continue;
          if (!element.isParameter && !element.is(ast_1.TransitionUsage) && (!element.is(ast_1.Connector) || !owner.isAny(ast_1.ActionDefinition, ast_1.ActionUsage) && element.is(ast_1.ItemFlow)))
            return membership;
        }
        return owner.is(ast_1.Feature) ? SuccessionAsUsageMeta_1.findPreviousFeature(owner, linker) : void 0;
      }
      previousFeature(linker) {
        return SuccessionAsUsageMeta_1.findPreviousFeature(this, linker);
      }
    };
    exports2.SuccessionAsUsageMeta = SuccessionAsUsageMeta = SuccessionAsUsageMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.SuccessionAsUsage, {
        base: "Occurrences::happensBeforeLinks",
        binary: "Occurrences::happensBeforeLinks"
      })
    ], SuccessionAsUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/succession-flow-connection-usage.js
var require_succession_flow_connection_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/succession-flow-connection-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SuccessionFlowConnectionUsageMeta = void 0;
    var ts_mixer_1 = require_cjs();
    var ast_1 = require_ast2();
    var succession_item_flow_1 = require_succession_item_flow();
    var metamodel_1 = require_metamodel();
    var flow_connection_usage_1 = require_flow_connection_usage();
    var SuccessionFlowConnectionUsageMeta = exports2.SuccessionFlowConnectionUsageMeta = class SuccessionFlowConnectionUsageMeta extends (0, ts_mixer_1.Mixin)(succession_item_flow_1.SuccessionItemFlowMeta, flow_connection_usage_1.FlowConnectionUsageMeta) {
      ast() {
        return this._ast;
      }
    };
    exports2.SuccessionFlowConnectionUsageMeta = SuccessionFlowConnectionUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.SuccessionFlowConnectionUsage, {
        base: "FlowConnections::successionFlowConnections",
        message: "FlowConnections::successionFlowConnections"
      })
    ], SuccessionFlowConnectionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/terminate-action-usage.js
var require_terminate_action_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/terminate-action-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var TerminateActionUsageMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminateActionUsageMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var action_usage_1 = require_action_usage();
    var TerminateActionUsageMeta = exports2.TerminateActionUsageMeta = TerminateActionUsageMeta_1 = class TerminateActionUsageMeta extends action_usage_1.ActionUsageMeta {
      get terminatedOccurrence() {
        return this._terminatedOccurrence;
      }
      set terminatedOccurrence(value) {
        this._terminatedOccurrence = this.swapEdgeOwnership(this._terminatedOccurrence, value);
      }
      ast() {
        return this._ast;
      }
      featureMembers() {
        const baseFeatures = super.featureMembers();
        return [this.terminatedOccurrence].filter(utils_1.NonNullable).concat(baseFeatures);
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        if (this.terminatedOccurrence)
          parts.push(["terminatedOccurrence", [this.terminatedOccurrence]]);
      }
      static applyTerminateOptions(model, options) {
        model.terminatedOccurrence = options.terminatedOccurrence;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options) {
          TerminateActionUsageMeta_1.applyTerminateOptions(model, options);
        }
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], TerminateActionUsageMeta.prototype, "terminatedOccurrence", null);
    exports2.TerminateActionUsageMeta = TerminateActionUsageMeta = TerminateActionUsageMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.TerminateActionUsage, {
        base: "Actions::terminateActions",
        subaction: "Actions::Action::terminateSubactions"
      })
    ], TerminateActionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/transition-usage.js
var require_transition_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/transition-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var TransitionUsageMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransitionUsageMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var _internal_1 = require_internal();
    var metamodel_1 = require_metamodel();
    var action_usage_1 = require_action_usage();
    var reference_usage_1 = require_reference_usage();
    var TransitionUsageMeta = exports2.TransitionUsageMeta = TransitionUsageMeta_1 = class TransitionUsageMeta extends action_usage_1.ActionUsageMeta {
      get source() {
        return this._source;
      }
      set source(value) {
        this._source = this.swapEdgeOwnership(this._source, value);
      }
      get transitionLinkSource() {
        return this._transitionLinkSource;
      }
      // this is not optional since it will always be created implicitly and
      // shouldn't be modified interactively anyway
      set transitionLinkSource(value) {
        this._transitionLinkSource = this.swapEdgeOwnership(this._transitionLinkSource, value);
      }
      get payload() {
        return this._accepter ? this._payload : void 0;
      }
      // same non-optional as transitionLinkSource
      set payload(value) {
        this._payload = this.swapEdgeOwnership(this._payload, value);
      }
      get accepter() {
        return this._accepter;
      }
      set accepter(value) {
        this._accepter = this.swapEdgeOwnership(this._accepter, value);
        if (this._accepter)
          this._accepter["_kind"] = "trigger";
      }
      get guard() {
        return this._guard;
      }
      set guard(value) {
        this._guard = this.swapEdgeOwnership(this._guard, value);
        if (this._guard)
          this._guard["_kind"] = "guard";
      }
      get effect() {
        return this._effect;
      }
      set effect(value) {
        this._effect = this.swapEdgeOwnership(this._effect, value);
        if (this._effect)
          this._effect["_kind"] = "effect";
      }
      get then() {
        return this._then;
      }
      set then(value) {
        this._then = this.swapEdgeOwnership(this._then, value);
      }
      get else() {
        return this._else;
      }
      set else(value) {
        this._else = this.swapEdgeOwnership(this._else, value);
      }
      defaultSupertype() {
        if (this.isStateTransition())
          return "stateTransition";
        if (this.isActionTransition())
          return "actionTransition";
        return "base";
      }
      isActionTransition() {
        if (!this.isComposite)
          return false;
        const parent = this.owner();
        return Boolean(parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.ActionUsage, ast_1.ActionDefinition));
      }
      isStateTransition() {
        if (!this.isComposite)
          return false;
        const parent = this.owner();
        return Boolean(parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.StateDefinition, ast_1.StateUsage));
      }
      ast() {
        return this._ast;
      }
      payloadParameter() {
        var _a;
        return (_a = this.payload) === null || _a === void 0 ? void 0 : _a.element();
      }
      triggerActions() {
        var _a;
        return (_a = this.accepter) === null || _a === void 0 ? void 0 : _a.element();
      }
      accepterPayloadParameter() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.accepter) === null || _a === void 0 ? void 0 : _a.element()) === null || _b === void 0 ? void 0 : _b.payload) === null || _c === void 0 ? void 0 : _c.element();
      }
      transitionLinkFeature() {
        return this.transitionLinkSource.element();
      }
      featureMembers() {
        const baseFeatures = super.featureMembers();
        return [
          this.source,
          this.transitionLinkSource,
          this.payload,
          this.accepter,
          this.guard,
          this.effect,
          this.then,
          this.else
        ].filter(utils_1.NonNullable).concat(baseFeatures);
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        for (const kw of [
          "source",
          "transitionLinkSource",
          "payload",
          "accepter",
          "guard",
          "effect",
          "then",
          "else"
        ]) {
          const value = this[kw];
          if (value)
            parts.push([kw, [value]]);
        }
      }
      static applyTransitionOptions(model, options) {
        model.source = options.source;
        if (options.transitionLinkSource)
          model.transitionLinkSource = options.transitionLinkSource;
        if (options.payload)
          model.payload = options.payload;
        model.accepter = options.accepter;
        model.guard = options.guard;
        model.effect = options.effect;
        model.then = options.then;
        model.else = options.else;
      }
      static create(provider, document, options) {
        const usage = super.create(provider, document, options);
        if (options)
          TransitionUsageMeta_1.applyTransitionOptions(usage, options);
        for (const prop of ["_transitionLinkSource", "_payload"]) {
          if (usage[prop])
            continue;
          const target = reference_usage_1.ReferenceUsageMeta.create(provider, document);
          const member = _internal_1.ParameterMembershipMeta.create(provider, document, { target });
          usage[prop] = member;
          usage.takeOwnership(member);
        }
        return usage;
      }
    };
    __decorate([
      utils_1.enumerable
    ], TransitionUsageMeta.prototype, "source", null);
    __decorate([
      utils_1.enumerable
    ], TransitionUsageMeta.prototype, "accepter", null);
    __decorate([
      utils_1.enumerable
    ], TransitionUsageMeta.prototype, "guard", null);
    __decorate([
      utils_1.enumerable
    ], TransitionUsageMeta.prototype, "effect", null);
    __decorate([
      utils_1.enumerable
    ], TransitionUsageMeta.prototype, "then", null);
    __decorate([
      utils_1.enumerable
    ], TransitionUsageMeta.prototype, "else", null);
    exports2.TransitionUsageMeta = TransitionUsageMeta = TransitionUsageMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.TransitionUsage, {
        base: "Actions::transitionActions",
        actionTransition: "Actions::Action::decisionTransitions",
        stateTransition: "States::StateAction::stateTransitions"
      })
    ], TransitionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/use-case-definition.js
var require_use_case_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/use-case-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UseCaseDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var case_definition_1 = require_case_definition();
    var UseCaseDefinitionMeta = exports2.UseCaseDefinitionMeta = class UseCaseDefinitionMeta extends case_definition_1.CaseDefinitionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.UseCaseDefinitionMeta = UseCaseDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.UseCaseDefinition, {
        base: "UseCases::UseCase"
      })
    ], UseCaseDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/verification-case-definition.js
var require_verification_case_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/verification-case-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VerificationCaseDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var case_definition_1 = require_case_definition();
    var VerificationCaseDefinitionMeta = exports2.VerificationCaseDefinitionMeta = class VerificationCaseDefinitionMeta extends case_definition_1.CaseDefinitionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.VerificationCaseDefinitionMeta = VerificationCaseDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.VerificationCaseDefinition, {
        base: "VerificationCases::VerificationCase"
      })
    ], VerificationCaseDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/verification-case-usage.js
var require_verification_case_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/verification-case-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VerificationCaseUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var case_usage_1 = require_case_usage();
    var VerificationCaseUsageMeta = exports2.VerificationCaseUsageMeta = class VerificationCaseUsageMeta extends case_usage_1.CaseUsageMeta {
      getSubactionType() {
        return this.isSubVerificationCase() ? "subVerificationCase" : super.getSubactionType();
      }
      isSubVerificationCase() {
        const parent = this.owner();
        return Boolean(this.isNonEntryExitComposite() && (parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.VerificationCaseUsage, ast_1.VerificationCaseDefinition)));
      }
      ast() {
        return this._ast;
      }
    };
    exports2.VerificationCaseUsageMeta = VerificationCaseUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.VerificationCaseUsage, {
        base: "VerificationCases::verificationCases",
        subVerificationCase: "VerificationCases::VerificationCase::subVerificationCases"
      })
    ], VerificationCaseUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/view-definition.js
var require_view_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/view-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ViewDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var part_definition_1 = require_part_definition();
    var ViewDefinitionMeta = exports2.ViewDefinitionMeta = class ViewDefinitionMeta extends part_definition_1.PartDefinitionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.ViewDefinitionMeta = ViewDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ViewDefinition, {
        base: "Views::View"
      })
    ], ViewDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/view-usage.js
var require_view_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/view-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ViewUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var part_usage_1 = require_part_usage();
    var ViewUsageMeta = exports2.ViewUsageMeta = class ViewUsageMeta extends part_usage_1.PartUsageMeta {
      defaultSupertype() {
        return this.isSubview() ? "subview" : "base";
      }
      isSubview() {
        const parent = this.owner();
        return Boolean(parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.ViewDefinition, ast_1.ViewUsage));
      }
      ast() {
        return this._ast;
      }
    };
    exports2.ViewUsageMeta = ViewUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ViewUsage, {
        base: "Views::views",
        subview: "Views::View::subviews"
      })
    ], ViewUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/viewpoint-definition.js
var require_viewpoint_definition = __commonJS({
  "../syside-languageserver/lib/model/SysML/viewpoint-definition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ViewpointDefinitionMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var requirement_definition_1 = require_requirement_definition();
    var ViewpointDefinitionMeta = exports2.ViewpointDefinitionMeta = class ViewpointDefinitionMeta extends requirement_definition_1.RequirementDefinitionMeta {
      ast() {
        return this._ast;
      }
    };
    exports2.ViewpointDefinitionMeta = ViewpointDefinitionMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ViewpointDefinition, {
        base: "Views::ViewpointCheck"
      })
    ], ViewpointDefinitionMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/viewpoint-usage.js
var require_viewpoint_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/viewpoint-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ViewpointUsageMeta = void 0;
    var ast_1 = require_ast2();
    var metamodel_1 = require_metamodel();
    var requirement_usage_1 = require_requirement_usage();
    var ViewpointUsageMeta = exports2.ViewpointUsageMeta = class ViewpointUsageMeta extends requirement_usage_1.RequirementUsageMeta {
      defaultSupertype() {
        return this.isSatisfiedViewpoint() ? "satisfied" : "base";
      }
      isSatisfiedViewpoint() {
        const parent = this.owner();
        return Boolean(parent === null || parent === void 0 ? void 0 : parent.isAny(ast_1.ViewDefinition, ast_1.ViewUsage));
      }
      ast() {
        return this._ast;
      }
    };
    exports2.ViewpointUsageMeta = ViewpointUsageMeta = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.ViewpointUsage, {
        base: "Views::viewpointChecks",
        satisfied: "Views::View::viewpointSatisfactions"
      })
    ], ViewpointUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/while-loop-action-usage.js
var require_while_loop_action_usage = __commonJS({
  "../syside-languageserver/lib/model/SysML/while-loop-action-usage.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var WhileLoopActionUsageMeta_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WhileLoopActionUsageMeta = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var metamodel_1 = require_metamodel();
    var loop_action_usage_1 = require_loop_action_usage();
    var WhileLoopActionUsageMeta = exports2.WhileLoopActionUsageMeta = WhileLoopActionUsageMeta_1 = class WhileLoopActionUsageMeta extends loop_action_usage_1.LoopActionUsageMeta {
      get condition() {
        return this._condition;
      }
      set condition(value) {
        this._condition = this.swapEdgeOwnership(this._condition, value);
      }
      get body() {
        return this._body;
      }
      set body(value) {
        this._body = this.swapEdgeOwnership(this._body, value);
      }
      get until() {
        return this._until;
      }
      set until(value) {
        this._until = this.swapEdgeOwnership(this._until, value);
      }
      ast() {
        return this._ast;
      }
      featureMembers() {
        const baseFeatures = super.featureMembers();
        return [this.condition, this.body, this.until].filter(utils_1.NonNullable).concat(baseFeatures);
      }
      collectDeclaration(parts) {
        super.collectDeclaration(parts);
        if (this.condition)
          parts.push(["condition", [this.condition]]);
        if (this.body)
          parts.push(["body", [this.body]]);
        if (this.until)
          parts.push(["until", [this.until]]);
      }
      static applyWhileLoopOptions(model, options) {
        model.condition = options.condition;
        model.body = options.body;
        model.until = options.until;
      }
      static create(provider, document, options) {
        const model = super.create(provider, document, options);
        if (options)
          WhileLoopActionUsageMeta_1.applyWhileLoopOptions(model, options);
        return model;
      }
    };
    __decorate([
      utils_1.enumerable
    ], WhileLoopActionUsageMeta.prototype, "condition", null);
    __decorate([
      utils_1.enumerable
    ], WhileLoopActionUsageMeta.prototype, "body", null);
    __decorate([
      utils_1.enumerable
    ], WhileLoopActionUsageMeta.prototype, "until", null);
    exports2.WhileLoopActionUsageMeta = WhileLoopActionUsageMeta = WhileLoopActionUsageMeta_1 = __decorate([
      (0, metamodel_1.metamodelOf)(ast_1.WhileLoopActionUsage, {
        base: "Actions::whileLoopActions",
        subaction: "Actions::Action::whileLoops"
      })
    ], WhileLoopActionUsageMeta);
  }
});

// ../syside-languageserver/lib/model/SysML/index.js
var require_SysML = __commonJS({
  "../syside-languageserver/lib/model/SysML/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_accept_action_usage(), exports2);
    __exportStar(require_action_definition(), exports2);
    __exportStar(require_action_usage(), exports2);
    __exportStar(require_allocation_definition(), exports2);
    __exportStar(require_allocation_usage(), exports2);
    __exportStar(require_analysis_case_definition(), exports2);
    __exportStar(require_analysis_case_usage(), exports2);
    __exportStar(require_assert_constraint_usage(), exports2);
    __exportStar(require_assignment_action_usage(), exports2);
    __exportStar(require_attribute_definition(), exports2);
    __exportStar(require_attribute_usage(), exports2);
    __exportStar(require_binding_connector_as_usage(), exports2);
    __exportStar(require_calculation_definition(), exports2);
    __exportStar(require_calculation_usage(), exports2);
    __exportStar(require_case_definition(), exports2);
    __exportStar(require_case_usage(), exports2);
    __exportStar(require_concern_definition(), exports2);
    __exportStar(require_concern_usage(), exports2);
    __exportStar(require_connection_definition(), exports2);
    __exportStar(require_connection_usage(), exports2);
    __exportStar(require_connector_as_usage(), exports2);
    __exportStar(require_constraint_definition(), exports2);
    __exportStar(require_constraint_usage(), exports2);
    __exportStar(require_control_node(), exports2);
    __exportStar(require_decision_node(), exports2);
    __exportStar(require_definition(), exports2);
    __exportStar(require_enumeration_definition(), exports2);
    __exportStar(require_enumeration_usage(), exports2);
    __exportStar(require_event_occurrence_usage(), exports2);
    __exportStar(require_exhibit_state_usage(), exports2);
    __exportStar(require_expressions2(), exports2);
    __exportStar(require_flow_connection_definition(), exports2);
    __exportStar(require_flow_connection_usage(), exports2);
    __exportStar(require_for_loop_action_usage(), exports2);
    __exportStar(require_for_node(), exports2);
    __exportStar(require_if_action_usage(), exports2);
    __exportStar(require_include_use_case_usage(), exports2);
    __exportStar(require_interface_definition(), exports2);
    __exportStar(require_interface_usage(), exports2);
    __exportStar(require_item_definition(), exports2);
    __exportStar(require_item_usage(), exports2);
    __exportStar(require_join_node(), exports2);
    __exportStar(require_life_class(), exports2);
    __exportStar(require_loop_action_usage(), exports2);
    __exportStar(require_merge_node(), exports2);
    __exportStar(require_metadata_definition(), exports2);
    __exportStar(require_metadata_usage(), exports2);
    __exportStar(require_occurrence_definition(), exports2);
    __exportStar(require_occurrence_usage(), exports2);
    __exportStar(require_part_definition(), exports2);
    __exportStar(require_part_usage(), exports2);
    __exportStar(require_perform_action_usage(), exports2);
    __exportStar(require_port_definition(), exports2);
    __exportStar(require_port_usage(), exports2);
    __exportStar(require_reference_usage(), exports2);
    __exportStar(require_references4(), exports2);
    __exportStar(require_relationships2(), exports2);
    __exportStar(require_rendering_definition(), exports2);
    __exportStar(require_rendering_usage(), exports2);
    __exportStar(require_requirement_definition(), exports2);
    __exportStar(require_requirement_usage(), exports2);
    __exportStar(require_satisfy_requirement_usage(), exports2);
    __exportStar(require_send_action_usage(), exports2);
    __exportStar(require_state_definition(), exports2);
    __exportStar(require_state_usage(), exports2);
    __exportStar(require_succession_as_usage(), exports2);
    __exportStar(require_succession_flow_connection_usage(), exports2);
    __exportStar(require_terminate_action_usage(), exports2);
    __exportStar(require_transition_usage(), exports2);
    __exportStar(require_usage(), exports2);
    __exportStar(require_use_case_definition(), exports2);
    __exportStar(require_use_case_usage(), exports2);
    __exportStar(require_verification_case_definition(), exports2);
    __exportStar(require_verification_case_usage(), exports2);
    __exportStar(require_view_definition(), exports2);
    __exportStar(require_view_usage(), exports2);
    __exportStar(require_viewpoint_definition(), exports2);
    __exportStar(require_viewpoint_usage(), exports2);
    __exportStar(require_while_loop_action_usage(), exports2);
  }
});

// ../syside-languageserver/lib/model/expressions/functions/arithmetic.js
var require_arithmetic = __commonJS({
  "../syside-languageserver/lib/model/expressions/functions/arithmetic.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RangeFunction = exports2.ExponentiationFunction = exports2.AdditionFunction = exports2.SubtractionFunction = exports2.LessEqualFunction = exports2.LessThanFunction = exports2.GreaterEqualFunction = exports2.GreaterThanFunction = exports2.ProdFunction = exports2.RemainderFunction = exports2.DivideFunction = void 0;
    var __1 = require_model3();
    var util_1 = require_util2();
    var PACKAGE = "DataFunctions";
    var ArithmeticFunction = class extends util_1.BuiltinFunction {
      unaryNumber(x) {
        throw new Error("Cannot evaluate unary number");
      }
      binaryNumber(x, y) {
        throw new Error("Cannot evaluate binary numbers");
      }
      binaryString(x, y) {
        throw new Error("Cannot evaluate binary strings");
      }
      call(expression, target, evaluator) {
        const x = evaluator.asArgument(expression, 0, target);
        if (expression.args.length === 1) {
          if (typeof x === "number")
            return [this.unaryNumber(x)];
          throw new Error("Expected a number argument");
        }
        const y = evaluator.asArgument(expression, 1, target);
        if (typeof x === "number" && typeof y === "number")
          return [this.binaryNumber(x, y)];
        if (typeof x === "string" && typeof y === "string")
          return [this.binaryString(x, y)];
        throw new Error("Mismatched argument types");
      }
    };
    var DivideFunction = exports2.DivideFunction = class DivideFunction extends ArithmeticFunction {
      binaryNumber(x, y) {
        if (y === 0)
          throw new Error("Cannot divide by 0");
        return x / y;
      }
    };
    exports2.DivideFunction = DivideFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, __1.OPERATORS.DIVIDE)
    ], DivideFunction);
    var RemainderFunction = exports2.RemainderFunction = class RemainderFunction extends ArithmeticFunction {
      binaryNumber(x, y) {
        if (y === 0)
          throw new Error("Cannot use modulo operation on 0");
        return x % y;
      }
    };
    exports2.RemainderFunction = RemainderFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, __1.OPERATORS.MODULO)
    ], RemainderFunction);
    var ProdFunction = exports2.ProdFunction = class ProdFunction extends ArithmeticFunction {
      binaryNumber(x, y) {
        return x * y;
      }
    };
    exports2.ProdFunction = ProdFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, __1.OPERATORS.MULTIPLY)
    ], ProdFunction);
    var GreaterThanFunction = exports2.GreaterThanFunction = class GreaterThanFunction extends ArithmeticFunction {
      binaryNumber(x, y) {
        return x > y;
      }
      binaryString(x, y) {
        return x.localeCompare(y) > 0;
      }
    };
    exports2.GreaterThanFunction = GreaterThanFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, __1.OPERATORS.GREATER)
    ], GreaterThanFunction);
    var GreaterEqualFunction = exports2.GreaterEqualFunction = class GreaterEqualFunction extends ArithmeticFunction {
      binaryNumber(x, y) {
        return x >= y;
      }
      binaryString(x, y) {
        return x.localeCompare(y) >= 0;
      }
    };
    exports2.GreaterEqualFunction = GreaterEqualFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, __1.OPERATORS.GREATER_EQUAL)
    ], GreaterEqualFunction);
    var LessThanFunction = exports2.LessThanFunction = class LessThanFunction extends ArithmeticFunction {
      binaryNumber(x, y) {
        return x < y;
      }
      binaryString(x, y) {
        return x.localeCompare(y) < 0;
      }
    };
    exports2.LessThanFunction = LessThanFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, __1.OPERATORS.LESS)
    ], LessThanFunction);
    var LessEqualFunction = exports2.LessEqualFunction = class LessEqualFunction extends ArithmeticFunction {
      binaryNumber(x, y) {
        return x <= y;
      }
      binaryString(x, y) {
        return x.localeCompare(y) <= 0;
      }
    };
    exports2.LessEqualFunction = LessEqualFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, __1.OPERATORS.LESS_EQUAL)
    ], LessEqualFunction);
    var SubtractionFunction = exports2.SubtractionFunction = class SubtractionFunction extends ArithmeticFunction {
      unaryNumber(x) {
        return -x;
      }
      binaryNumber(x, y) {
        return x - y;
      }
    };
    exports2.SubtractionFunction = SubtractionFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, __1.OPERATORS.MINUS)
    ], SubtractionFunction);
    var AdditionFunction = exports2.AdditionFunction = class AdditionFunction extends ArithmeticFunction {
      unaryNumber(x) {
        return x;
      }
      binaryNumber(x, y) {
        return x + y;
      }
      binaryString(x, y) {
        return x.concat(y);
      }
    };
    exports2.AdditionFunction = AdditionFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, __1.OPERATORS.PLUS)
    ], AdditionFunction);
    var ExponentiationFunction = exports2.ExponentiationFunction = class ExponentiationFunction extends ArithmeticFunction {
      binaryNumber(x, y) {
        return Math.pow(x, y);
      }
    };
    exports2.ExponentiationFunction = ExponentiationFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, [__1.OPERATORS.EXPONENT_1, __1.OPERATORS.EXPONENT_2])
    ], ExponentiationFunction);
    var RangeFunction = exports2.RangeFunction = class RangeFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const start = evaluator.asNumber(expression, 0, target);
        const stop = evaluator.asNumber(expression, 1, target);
        return new __1.RangeGenerator({ start, stop });
      }
    };
    exports2.RangeFunction = RangeFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, __1.OPERATORS.RANGE)
    ], RangeFunction);
  }
});

// ../syside-languageserver/lib/model/expressions/functions/base.js
var require_base = __commonJS({
  "../syside-languageserver/lib/model/expressions/functions/base.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotEqualsFunction = exports2.ListConcatFunction = exports2.IsTypeFunction = exports2.IndexFunction = exports2.HasTypeFunction = exports2.EqualsFunction = exports2.AtFunction = exports2.AsFunction = void 0;
    var ast_1 = require_ast();
    var ast_2 = require_ast2();
    var KerML_1 = require_KerML();
    var range_1 = require_range();
    var util_1 = require_util2();
    var PACKAGE = "BaseFunctions";
    function getTypeArgument(expression) {
      const type = (0, util_1.typeArgument)(expression);
      if (!type)
        throw new Error("Error computing type argument");
      return type;
    }
    var AsFunction = exports2.AsFunction = class AsFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const type = getTypeArgument(expression);
        const values = evaluator.evaluateArgument(expression, 0, target);
        if (values instanceof range_1.RangeGenerator) {
          if (type.conforms((0, util_1.resultType)(0)))
            return values;
          return [];
        }
        return values.filter((v) => (0, util_1.isType)(v, type));
      }
    };
    exports2.AsFunction = AsFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, [KerML_1.OPERATORS.AS, KerML_1.OPERATORS.META])
    ], AsFunction);
    var AtFunction = exports2.AtFunction = class AtFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const type = getTypeArgument(expression);
        const values = evaluator.evaluateArgument(expression, 0, target);
        return [values.some((v) => (0, util_1.isType)(v, type))];
      }
    };
    exports2.AtFunction = AtFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, [KerML_1.OPERATORS.AT, KerML_1.OPERATORS.AT_AT])
    ], AtFunction);
    var EqualsFunction = exports2.EqualsFunction = class EqualsFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const x = evaluator.asArgument(expression, 0, target);
        const y = evaluator.asArgument(expression, 1, target);
        const result = evaluator.equal(x, y);
        return [result];
      }
    };
    exports2.EqualsFunction = EqualsFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, [KerML_1.OPERATORS.EQUALS, KerML_1.OPERATORS.SAME])
    ], EqualsFunction);
    var HasTypeFunction = exports2.HasTypeFunction = class HasTypeFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const type = getTypeArgument(expression);
        const values = evaluator.evaluateArgument(expression, 0, target);
        return [values.some((v) => (0, util_1.hasType)(v, type))];
      }
    };
    exports2.HasTypeFunction = HasTypeFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.OPERATORS.HAS_TYPE)
    ], HasTypeFunction);
    var IndexFunction = exports2.IndexFunction = class IndexFunction extends util_1.BuiltinFunction {
      isCollection(values, name) {
        return !(values instanceof range_1.RangeGenerator) && values.length === 1 && typeof values[0] === "object" && values[0].is(ast_1.Type) && values[0].conforms(name);
      }
      /**
       * Index any array
       */
      indexSequence(items, index) {
        const value = items.at(index - 1);
        if (value === void 0)
          throw new Error(`Index ${index} out of bounds for sequence of size ${items.length}`);
        return [value];
      }
      /**
       * Index `Collections::OrderedCollection`
       * @param collection `Collections::OrderedCollection`
       * @param index
       * @param evaluator
       * @returns
       */
      indexCollection(collection, index, evaluator) {
        const elementsFeature = evaluator.libraryType("Collections::Collection::elements", collection);
        if (!(elementsFeature === null || elementsFeature === void 0 ? void 0 : elementsFeature.is(ast_2.Feature)))
          throw new Error("Feature 'Collections::Collection::elements' not found");
        const elements = evaluator.evaluateFeatureChain([collection, elementsFeature], collection);
        return this.indexSequence(elements, index);
      }
      /**
       * Index multi-dimensional array `Collections::Array`
       * @param array `Collections::Array`
       * @param indices
       * @param evaluator
       * @returns
       */
      indexArray(array, indices, evaluator) {
        const dimensionsFeature = evaluator.libraryType("Collections::Array::dimensions", array);
        if (!(dimensionsFeature === null || dimensionsFeature === void 0 ? void 0 : dimensionsFeature.is(ast_2.Feature)))
          throw new Error("Feature 'Collections::Array::dimensions' not found");
        const dimensions = evaluator.evaluateFeatureChain([array, dimensionsFeature], array);
        if (dimensions.length !== indices.length)
          throw new Error(`Array and index dimensions do not match: ${dimensions.length} != ${indices.length}`);
        if (dimensions.length === 0)
          return this.indexCollection(array, 1, evaluator);
        let index = 1;
        for (let i = 0; i < dimensions.length; ++i) {
          const dim = dimensions.at(i);
          const offset = indices.at(i);
          if (typeof dim !== "number")
            throw new Error(`Dimension at index ${i} is not a number`);
          if (typeof offset !== "number")
            throw new Error(`Index at index ${i} is not a number`);
          if (offset > dim)
            throw new Error(`Index at dimension ${i} is out of bounds (${offset} > ${dim})`);
          index = dim * (index - 1) + offset;
        }
        return this.indexCollection(array, index, evaluator);
      }
      call(expression, target, evaluator) {
        const values = evaluator.evaluateArgument(expression, 0, target);
        const indices = evaluator.evaluateArgument(expression, 1, target);
        if (this.isCollection(values, "Collections::Array")) {
          return this.indexArray(values.at(0), indices, evaluator);
        }
        if (indices.length === 1) {
          const index = indices.at(0);
          if (typeof index !== "number")
            throw new Error("Index is not a number");
          if (this.isCollection(values, "Collections::OrderedCollection")) {
            return this.indexCollection(values.at(0), index, evaluator);
          }
          return this.indexSequence(values, index);
        }
        throw new Error("Cannot use multi-dimensional index on a one-dimensional sequence");
      }
    };
    exports2.IndexFunction = IndexFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.IMPLICIT_OPERATORS.INDEX)
    ], IndexFunction);
    var IsTypeFunction = exports2.IsTypeFunction = class IsTypeFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const type = getTypeArgument(expression);
        const values = evaluator.evaluateArgument(expression, 0, target);
        return [values.every((v) => (0, util_1.isType)(v, type))];
      }
    };
    exports2.IsTypeFunction = IsTypeFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.OPERATORS.IS_TYPE)
    ], IsTypeFunction);
    var ListConcatFunction = exports2.ListConcatFunction = class ListConcatFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const values = (0, util_1.normalize)(evaluator.evaluateArgument(expression, 0, target));
        const extra = (0, util_1.normalize)(evaluator.evaluateArgument(expression, 1, target));
        return values.concat(...extra);
      }
    };
    exports2.ListConcatFunction = ListConcatFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.OPERATORS.COMMA)
    ], ListConcatFunction);
    var NotEqualsFunction = exports2.NotEqualsFunction = class NotEqualsFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const x = evaluator.asArgument(expression, 0, target);
        const y = evaluator.asArgument(expression, 1, target);
        const result = evaluator.equal(x, y);
        return [!result];
      }
    };
    exports2.NotEqualsFunction = NotEqualsFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, [KerML_1.OPERATORS.NOT_EQUALS, KerML_1.OPERATORS.NOT_SAME])
    ], NotEqualsFunction);
  }
});

// ../syside-languageserver/lib/model/expressions/functions/boolean.js
var require_boolean = __commonJS({
  "../syside-languageserver/lib/model/expressions/functions/boolean.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XorFunction = exports2.NotFunction = exports2.OrFunction = exports2.AndFunction = void 0;
    var KerML_1 = require_KerML();
    var util_1 = require_util2();
    var PACKAGE = "DataFunctions";
    var BooleanFunction = class extends util_1.BuiltinFunction {
      unary(x) {
        throw new Error("Unary function is not implemented");
      }
      binary(x, y) {
        throw new Error("Binary function is not implemented");
      }
      call(expression, target, evaluator) {
        const x = evaluator.asBoolean(expression, 0, target);
        if (expression.args.length === 1)
          return [this.unary(x)];
        const y = evaluator.asBoolean(expression, 1, target);
        return [this.binary(x, y)];
      }
    };
    var AndFunction = exports2.AndFunction = class AndFunction extends BooleanFunction {
      binary(x, y) {
        return x && y;
      }
    };
    exports2.AndFunction = AndFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.OPERATORS.BITWISE_AND)
    ], AndFunction);
    var OrFunction = exports2.OrFunction = class OrFunction extends BooleanFunction {
      binary(x, y) {
        return x || y;
      }
    };
    exports2.OrFunction = OrFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.OPERATORS.BITWISE_OR)
    ], OrFunction);
    var NotFunction = exports2.NotFunction = class NotFunction extends BooleanFunction {
      unary(x) {
        return !x;
      }
    };
    exports2.NotFunction = NotFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.OPERATORS.NOT)
    ], NotFunction);
    var XorFunction = exports2.XorFunction = class XorFunction extends BooleanFunction {
      binary(x, y) {
        return x !== y;
      }
    };
    exports2.XorFunction = XorFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.OPERATORS.XOR)
    ], XorFunction);
  }
});

// ../syside-languageserver/lib/model/expressions/functions/control.js
var require_control = __commonJS({
  "../syside-languageserver/lib/model/expressions/functions/control.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NullCoalescingFunction = exports2.DotFunction = exports2.ConditionalFunction = exports2.ConditionalOrFunction = exports2.ConditionalImpliesFunction = exports2.ConditionalAndFunction = void 0;
    var ast_1 = require_ast2();
    var KerML_1 = require_KerML();
    var range_1 = require_range();
    var util_1 = require_util2();
    var PACKAGE = "ControlFunctions";
    var ConditionalLogicalFunction = class extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const first = evaluator.asBoolean(expression, 0, target);
        if (this.test(first))
          return [this.result()];
        const second = evaluator.asBoolean(expression, 1, target);
        return [second];
      }
    };
    var ConditionalAndFunction = exports2.ConditionalAndFunction = class ConditionalAndFunction extends ConditionalLogicalFunction {
      test(value) {
        return !value;
      }
      result() {
        return false;
      }
    };
    exports2.ConditionalAndFunction = ConditionalAndFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.OPERATORS.AND)
    ], ConditionalAndFunction);
    var ConditionalImpliesFunction = exports2.ConditionalImpliesFunction = class ConditionalImpliesFunction extends ConditionalLogicalFunction {
      test(value) {
        return !value;
      }
      result() {
        return true;
      }
    };
    exports2.ConditionalImpliesFunction = ConditionalImpliesFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.OPERATORS.IMPLIES)
    ], ConditionalImpliesFunction);
    var ConditionalOrFunction = exports2.ConditionalOrFunction = class ConditionalOrFunction extends ConditionalLogicalFunction {
      test(value) {
        return value;
      }
      result() {
        return true;
      }
    };
    exports2.ConditionalOrFunction = ConditionalOrFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.OPERATORS.OR)
    ], ConditionalOrFunction);
    var ConditionalFunction = exports2.ConditionalFunction = class ConditionalFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const test = evaluator.asBoolean(expression, 0, target);
        return evaluator.evaluateArgument(expression, test ? 1 : 2, target);
      }
    };
    exports2.ConditionalFunction = ConditionalFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.OPERATORS.IF)
    ], ConditionalFunction);
    var DotFunction = exports2.DotFunction = class DotFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const values = evaluator.evaluateArgument(expression, 0, target);
        const targetFeature = expression.targetFeature();
        if (!targetFeature)
          throw new Error("Missing target feature");
        if (values instanceof range_1.RangeGenerator)
          return [];
        if (!target.is(ast_1.Type))
          throw new Error("Cannot evaluate feature chain for non-type targets");
        return values.filter((value) => typeof value === "object" && value.is(ast_1.Feature)).flatMap((value) => {
          const chaining = [value];
          if (targetFeature.chainingFeatures.length > 0)
            chaining.push(...targetFeature.chainingFeatures);
          else
            chaining.push(targetFeature);
          return (0, util_1.normalize)(evaluator.evaluateFeatureChain(chaining, target));
        });
      }
    };
    exports2.DotFunction = DotFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.IMPLICIT_OPERATORS.DOT)
    ], DotFunction);
    var NullCoalescingFunction = exports2.NullCoalescingFunction = class NullCoalescingFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const values = evaluator.evaluateArgument(expression, 0, target);
        if (values.length === 0)
          return evaluator.evaluateArgument(expression, 1, target);
        return values;
      }
    };
    exports2.NullCoalescingFunction = NullCoalescingFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, KerML_1.OPERATORS.NULL_COALESCING)
    ], NullCoalescingFunction);
  }
});

// ../syside-languageserver/lib/model/expressions/functions/numerical.js
var require_numerical = __commonJS({
  "../syside-languageserver/lib/model/expressions/functions/numerical.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SumFunction = exports2.ProductFunction = void 0;
    var util_1 = require_util2();
    var PACKAGE = "NumericalFunctions";
    var ProductFunction = exports2.ProductFunction = class ProductFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const values = evaluator.evaluateArgument(expression, 0, target);
        let result = 1;
        for (const value of values) {
          if (typeof value !== "number")
            throw new Error("Not a number argument");
          result *= value;
        }
        return [result];
      }
    };
    exports2.ProductFunction = ProductFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, "product")
    ], ProductFunction);
    var SumFunction = exports2.SumFunction = class SumFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const values = evaluator.evaluateArgument(expression, 0, target);
        let result = 0;
        for (const value of values) {
          if (typeof value !== "number")
            throw new Error("Not a number argument");
          result += value;
        }
        return [result];
      }
    };
    exports2.SumFunction = SumFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, "sum")
    ], SumFunction);
  }
});

// ../syside-languageserver/lib/model/expressions/functions/sequence.js
var require_sequence = __commonJS({
  "../syside-languageserver/lib/model/expressions/functions/sequence.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SizeFunction = exports2.NotEmptyFunction = exports2.IsEmptyFunction = exports2.IncludesFunction = void 0;
    var util_1 = require_util2();
    var PACKAGE = "SequenceFunctions";
    var IncludesFunction = exports2.IncludesFunction = class IncludesFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const values = evaluator.evaluateArgument(expression, 0, target);
        const value = evaluator.asArgument(expression, 1, target);
        return [values.some((v) => evaluator.equal(v, value))];
      }
    };
    exports2.IncludesFunction = IncludesFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, "includes")
    ], IncludesFunction);
    var IsEmptyFunction = exports2.IsEmptyFunction = class IsEmptyFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const values = evaluator.evaluateArgument(expression, 0, target);
        return [values.length === 0];
      }
    };
    exports2.IsEmptyFunction = IsEmptyFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, "isEmpty")
    ], IsEmptyFunction);
    var NotEmptyFunction = exports2.NotEmptyFunction = class NotEmptyFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const values = evaluator.evaluateArgument(expression, 0, target);
        return [values.length !== 0];
      }
    };
    exports2.NotEmptyFunction = NotEmptyFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, "notEmpty")
    ], NotEmptyFunction);
    var SizeFunction = exports2.SizeFunction = class SizeFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const values = evaluator.evaluateArgument(expression, 0, target);
        return [values.length];
      }
    };
    exports2.SizeFunction = SizeFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, "size")
    ], SizeFunction);
  }
});

// ../syside-languageserver/lib/model/expressions/functions/string.js
var require_string = __commonJS({
  "../syside-languageserver/lib/model/expressions/functions/string.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StringLengthFunction = exports2.SubstringFunction = void 0;
    var util_1 = require_util2();
    var PACKAGE = "StringFunctions";
    var SubstringFunction = exports2.SubstringFunction = class SubstringFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const str = evaluator.asString(expression, 0, target);
        const lo = evaluator.asNumber(expression, 1, target);
        const hi = evaluator.asNumber(expression, 2, target);
        if (lo < 1)
          throw new Error(`Start ${lo} is out bounds`);
        if (hi > str.length)
          throw new Error(`End ${hi} is out bounds for string of size ${str.length}`);
        if (lo > hi + 1)
          throw new Error("Start is beyond end");
        return [str.substring(lo - 1, hi)];
      }
    };
    exports2.SubstringFunction = SubstringFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, "Substring")
    ], SubstringFunction);
    var StringLengthFunction = exports2.StringLengthFunction = class StringLengthFunction extends util_1.BuiltinFunction {
      call(expression, target, evaluator) {
        const str = evaluator.asString(expression, 0, target);
        return [str.length];
      }
    };
    exports2.StringLengthFunction = StringLengthFunction = __decorate([
      (0, util_1.functionFor)(PACKAGE, "Length")
    ], StringLengthFunction);
  }
});

// ../syside-languageserver/lib/model/expressions/functions/index.js
var require_functions = __commonJS({
  "../syside-languageserver/lib/model/expressions/functions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_arithmetic(), exports2);
    __exportStar(require_base(), exports2);
    __exportStar(require_boolean(), exports2);
    __exportStar(require_control(), exports2);
    __exportStar(require_numerical(), exports2);
    __exportStar(require_sequence(), exports2);
    __exportStar(require_string(), exports2);
  }
});

// ../syside-languageserver/lib/model/expressions/evaluator.js
var require_evaluator = __commonJS({
  "../syside-languageserver/lib/model/expressions/evaluator.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BuiltinFunctionEvaluator = exports2.defaultEvaluators = void 0;
    var ast_1 = require_ast2();
    var KerML_1 = require_KerML();
    var util_1 = require_util2();
    require_functions();
    var types_1 = require_types2();
    var range_1 = require_range();
    var Evaluators = {};
    function evaluates(...type) {
      return function(_, __, descriptor) {
        type.forEach((t) => Evaluators[t] = descriptor.value);
      };
    }
    function defaultEvaluators() {
      return types_1.typeIndex.expandToDerivedTypes(Evaluators);
    }
    exports2.defaultEvaluators = defaultEvaluators;
    var BuiltinFunctionEvaluator = class {
      constructor(services, evaluators) {
        this.stack = [];
        this.evaluators = evaluators;
        this.util = services.Util;
        this.index = services.workspace.IndexManager;
      }
      get currentEvaluationStack() {
        return this.stack;
      }
      libraryType(qualifiedName, context) {
        var _a;
        let document;
        if (context) {
          let root = context;
          for (; ; ) {
            const owner = root.owner();
            if (!owner)
              break;
            root = owner;
          }
          document = (_a = root.ast()) === null || _a === void 0 ? void 0 : _a.$document;
        }
        return this.index.findType(qualifiedName, document);
      }
      evaluate(expression, target) {
        this.stack.push(expression);
        const evaluator = this.evaluators.get(expression.nodeType());
        if (evaluator) {
          const result = evaluator.call(this, expression, target);
          this.stack.pop();
          return result;
        }
        throw new Error(`No evaluator found for ${expression.nodeType()}`);
      }
      targetFeatureFor(target) {
        if (target.is(ast_1.Feature))
          return target;
        const feature = KerML_1.FeatureMeta.create(this.util.idProvider, target.document);
        if (target.is(ast_1.Type)) {
          const typing = KerML_1.FeatureTypingMeta.create(this.util.idProvider, target.document, {
            isImplied: true
          });
          feature.addHeritage([typing, target]);
        }
        return feature;
      }
      evaluateFeatureChain(features, type) {
        if (features.length === 0)
          return [];
        const values = this.evaluateFeature(features[0], type);
        if (features.length === 1)
          return values;
        if (values instanceof range_1.RangeGenerator)
          return values;
        const subchain = features.slice(1);
        return values.flatMap((value) => {
          if (typeof value !== "object" || !value.is(ast_1.Type))
            return [value];
          const target = value.is(ast_1.Feature) ? type === value ? value : this.util.chainFeatures(this.targetFeatureFor(type), value) : type;
          return (0, util_1.normalize)(this.evaluateFeatureChain(subchain, target));
        });
      }
      evaluateNull() {
        return [];
      }
      evaluateInfinity(expression) {
        return [expression];
      }
      evaluateLiteral(expression) {
        return [expression.literal];
      }
      evaluateArgument(expression, index, target) {
        const arg = expression.args.at(index);
        if (!arg)
          throw new Error(`Missing argument at position ${index}`);
        return this.evaluate(arg, target);
      }
      asBoolean(expression, index, target) {
        const value = this.asArgument(expression, index, target);
        if (typeof value !== "boolean") {
          throw new Error("Not a boolean");
        }
        return value;
      }
      asString(expression, index, target) {
        const value = this.asArgument(expression, index, target);
        if (typeof value !== "string") {
          throw new Error("Not a string");
        }
        return value;
      }
      asNumber(expression, index, target) {
        const value = this.asArgument(expression, index, target);
        if (typeof value !== "number") {
          throw new Error("Not a number");
        }
        return value;
      }
      asArgument(expression, index, target) {
        const values = this.evaluateArgument(expression, index, target);
        if (values.length > 1) {
          throw new Error("Too many values, expected 1");
        }
        if (values.length === 0)
          return null;
        return values.at(0);
      }
      equal(left, right) {
        return left === right;
      }
      evaluateInvocation(expression, target) {
        const fn = expression.getFunction();
        if (!fn)
          throw new Error("No associated function found");
        const builtin = (0, util_1.builtinFunction)(fn);
        if (!builtin)
          throw new Error("No associated builtin function found");
        return builtin.call(expression, target, this);
      }
      evaluateFeatureReference(expression, target) {
        var _a;
        const referenced = (_a = expression.expression) === null || _a === void 0 ? void 0 : _a.element();
        if (!referenced)
          throw new Error("No referenced element");
        const type = target.is(ast_1.Type) ? target : void 0;
        if (referenced.is(ast_1.FeatureReference)) {
          const feature = referenced.to.target;
          if (!feature)
            throw new Error("No linked reference");
          if (!type)
            throw new Error("Cannot evaluate feature reference expression in a non-type context");
          return this.evaluateFeature(feature, type);
        }
        if (referenced.is(ast_1.TypeReference))
          return this.evaluateReference(referenced);
        if (referenced.is(ast_1.InlineExpression))
          return this.evaluate(referenced, target);
        if (!type)
          throw new Error("Cannot evaluate feature reference expression in a non-type context");
        return this.evaluateFeature(referenced, type);
      }
      evaluateMetadataAccess(expression, target) {
        const referenced = expression.reference;
        if (!referenced)
          throw new Error("No linked reference");
        const features = [...referenced.allMetadata()];
        const metaclass = referenced.metaclass;
        if (metaclass)
          features.push(metaclass);
        return features;
      }
      evaluateFeature(feature, type) {
        var _a, _b, _c;
        if (feature.conforms("Base::Anything::self")) {
          return [this.targetFeatureFor(type)];
        }
        if (feature.chainings.length > 0) {
          return this.evaluateFeatureChain(feature.chainingFeatures, type);
        }
        const types = type.is(ast_1.Feature) && type.chainings.length > 0 ? [...type.chainingFeatures] : [type];
        for (const t of types.reverse()) {
          if (t.is(ast_1.MetadataFeature) && feature.conforms("Metaobjects::Metaobject::annotatedElement")) {
            const annotated = (_a = t.annotatedElements().at(0)) !== null && _a !== void 0 ? _a : t.owner();
            const metaclass = annotated === null || annotated === void 0 ? void 0 : annotated.metaclass;
            return metaclass ? [metaclass] : [];
          }
          if ((0, util_1.isMetaclassFeature)(t)) {
            if (feature.is(ast_1.Expression))
              continue;
            return [];
          }
          const target = t.featureMembers().map((member) => member.element()).find((f) => f === null || f === void 0 ? void 0 : f.allTypes(ast_1.Redefinition).includes(feature));
          if (target) {
            const value2 = (_b = target.value) === null || _b === void 0 ? void 0 : _b.element();
            if (value2)
              return this.evaluate(value2, t);
          }
        }
        const value = (_c = feature.value) === null || _c === void 0 ? void 0 : _c.element();
        if (value) {
          return this.evaluate(value, type);
        }
        return [feature];
      }
      evaluateReference(ref) {
        const target = ref.to.target;
        if (!target)
          throw new Error("No linked reference");
        return [target];
      }
    };
    exports2.BuiltinFunctionEvaluator = BuiltinFunctionEvaluator;
    __decorate([
      evaluates(ast_1.NullExpression)
    ], BuiltinFunctionEvaluator.prototype, "evaluateNull", null);
    __decorate([
      evaluates(ast_1.LiteralInfinity)
    ], BuiltinFunctionEvaluator.prototype, "evaluateInfinity", null);
    __decorate([
      evaluates(ast_1.LiteralBoolean, ast_1.LiteralNumber, ast_1.LiteralString)
    ], BuiltinFunctionEvaluator.prototype, "evaluateLiteral", null);
    __decorate([
      evaluates(ast_1.InvocationExpression)
    ], BuiltinFunctionEvaluator.prototype, "evaluateInvocation", null);
    __decorate([
      evaluates(ast_1.FeatureReferenceExpression)
    ], BuiltinFunctionEvaluator.prototype, "evaluateFeatureReference", null);
    __decorate([
      evaluates(ast_1.MetadataAccessExpression)
    ], BuiltinFunctionEvaluator.prototype, "evaluateMetadataAccess", null);
    __decorate([
      evaluates(ast_1.ElementReference)
    ], BuiltinFunctionEvaluator.prototype, "evaluateReference", null);
  }
});

// ../syside-languageserver/lib/model/expressions/index.js
var require_expressions3 = __commonJS({
  "../syside-languageserver/lib/model/expressions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_evaluator(), exports2);
    __exportStar(require_functions(), exports2);
    __exportStar(require_range(), exports2);
    __exportStar(require_util2(), exports2);
  }
});

// ../syside-languageserver/lib/model/implicits.js
var require_implicits = __commonJS({
  "../syside-languageserver/lib/model/implicits.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.implicitIndex = void 0;
    var metamodel_1 = require_metamodel();
    var types_1 = require_types2();
    require_KerML();
    require_SysML();
    var SysMLImplicitIndex = class {
      constructor() {
        this.implicitMapping = /* @__PURE__ */ new Map();
        const expanded = types_1.typeIndex.expandAndMerge(metamodel_1.IMPLICIT_MAP);
        for (const [type, implicits] of expanded.entries()) {
          for (const [kind, supertype] of implicits.reverse()) {
            this.add(type, kind, supertype);
          }
        }
      }
      add(type, kind, supertype) {
        this.implicitMapping.set(this.makeKey(type, kind), supertype);
      }
      /**
       * Get a qualified element name from the registered {@link type} and
       * {@link kind} pair. Used by the metamodel builder to add implicit
       * specializations in a generic way.
       */
      get(type, kind = "base") {
        var _a;
        return (_a = this.implicitMapping.get(this.makeKey(type, kind))) !== null && _a !== void 0 ? _a : "";
      }
      makeKey(type, kind) {
        return `${type}^${kind}`;
      }
    };
    exports2.implicitIndex = new SysMLImplicitIndex();
  }
});

// ../syside-languageserver/lib/model/notes/attach.js
var require_attach = __commonJS({
  "../syside-languageserver/lib/model/notes/attach.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.needsHardlineAfterInnerNote = exports2.attachNotes = exports2.KerMLCommentAttachVisitor = void 0;
    var utils_1 = require_utils2();
    var ast_1 = require_ast2();
    var comments_1 = require_comments();
    var KerMLCommentAttachVisitor = class extends comments_1.AbstractKerMLCommentVisitor {
      visit(comment) {
        var _a, _b, _c, _d;
        const model = comment.$cstNode.element.$meta;
        if (!model)
          return;
        const note = comment;
        const left = (_a = comment.$precedingNode) === null || _a === void 0 ? void 0 : _a.$meta;
        const right = (_b = comment.$followingNode) === null || _b === void 0 ? void 0 : _b.$meta;
        let target = model;
        const onLeft = (left2) => {
          var _a2;
          if (((_a2 = note.$previous) === null || _a2 === void 0 ? void 0 : _a2.text) === "{" && !right) {
            note.localPlacement = "inner";
          } else {
            note.localPlacement = "trailing";
            target = left2;
          }
        };
        const onDefaultEndOfLine = () => {
          if (left) {
            onLeft(left);
          } else if (right) {
            note.localPlacement = "leading";
            target = right;
          } else if (model) {
            note.localPlacement = "inner";
          }
        };
        const onOverride = (method) => {
          const candidate = method.call(this, note);
          if (candidate) {
            target = candidate;
            return true;
          }
          return false;
        };
        switch (note.placement) {
          case "endOfLine": {
            if (onOverride(this.onEndOfLine))
              break;
            onDefaultEndOfLine();
            break;
          }
          case "ownLine": {
            if (onOverride(this.onOwnLine))
              break;
            if (right) {
              note.localPlacement = "leading";
              target = right;
            } else if (left) {
              onLeft(left);
            } else if (model) {
              note.localPlacement = "inner";
            }
            break;
          }
          case "remaining": {
            if (onOverride(this.onRemaining))
              break;
            if (left && right) {
              if (((_c = comment.$next) === null || _c === void 0 ? void 0 : _c.offset) === ((_d = comment.$followingNode.$cstNode) === null || _d === void 0 ? void 0 : _d.offset)) {
                note.localPlacement = "leading";
                target = right;
              } else {
                note.localPlacement = "trailing";
                target = left;
              }
            } else {
              onDefaultEndOfLine();
            }
            break;
          }
        }
        target.notes.push(note);
        this.onAttached(target, note);
      }
      // eslint-disable-next-line unused-imports/no-unused-vars
      onOwnLine(note) {
        return;
      }
      // eslint-disable-next-line unused-imports/no-unused-vars
      onEndOfLine(note) {
        return;
      }
      // eslint-disable-next-line unused-imports/no-unused-vars
      onRemaining(note) {
        return;
      }
      onAttached(target, note) {
        var _a, _b;
        if (note.localPlacement !== "inner" || !target.is(ast_1.ElementReference))
          return;
        let part = ((_a = note.$next) === null || _a === void 0 ? void 0 : _a.text) === "::" ? note.$previous : note.$next;
        if (!part)
          return;
        let index = (_b = target.ast()) === null || _b === void 0 ? void 0 : _b.parts.findIndex((ref) => ref.$refText === (part === null || part === void 0 ? void 0 : part.text));
        if (index === void 0 || index === -1)
          return;
        if (index !== 0 && note.placement === "endOfLine" && part !== note.$previous) {
          index--;
          part = note.$previous;
        }
        note.label = `${index}-${part === note.$next ? "leading" : "trailing"}`;
      }
    };
    exports2.KerMLCommentAttachVisitor = KerMLCommentAttachVisitor;
    function attachNotes(document) {
      if (document.commentsAttached)
        return;
      const root = document.parseResult.value.$cstNode;
      if (!root)
        return;
      (0, utils_1.visitComments)(root, new KerMLCommentAttachVisitor());
      document.commentsAttached = true;
    }
    exports2.attachNotes = attachNotes;
    function needsHardlineAfterInnerNote(element) {
      var _a;
      return ((_a = element.notes.findLast((note) => note.localPlacement === "inner")) === null || _a === void 0 ? void 0 : _a.kind) === "line";
    }
    exports2.needsHardlineAfterInnerNote = needsHardlineAfterInnerNote;
  }
});

// ../syside-languageserver/lib/model/notes/index.js
var require_notes = __commonJS({
  "../syside-languageserver/lib/model/notes/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_attach(), exports2);
  }
});

// ../syside-languageserver/lib/model/printer/format-options.js
var require_format_options = __commonJS({
  "../syside-languageserver/lib/model/printer/format-options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultFormatOptions = void 0;
    exports2.DefaultFormatOptions = {
      null_expression: { default: "preserve", fallback: "null" },
      literal_real: "none",
      strip_unnecessary_quotes: true,
      sequence_expression_trailing_comma: true,
      operator_break: "after",
      bracket_spacing: true,
      comment_keyword: { default: "preserve", fallback: "as_needed" },
      comment_about_break: "as_needed",
      markdown_comments: true,
      textual_representation_keyword: { default: "preserve", fallback: "as_needed" },
      textual_representation_language_break: "always",
      empty_namespace_brackets: { default: "preserve", fallback: "always" },
      merge_declaration_disjoining: false,
      merge_differencing: false,
      merge_intersecting: false,
      merge_unioning: false,
      merge_feature_chaining: false,
      merge_declaration_type_featuring: false,
      declaration_specialization: { default: "preserve", fallback: "token" },
      declaration_conjugation: { default: "preserve", fallback: "token" },
      declaration_subsetting: { default: "preserve", fallback: "token" },
      declaration_subclassification: { default: "preserve", fallback: "token" },
      declaration_redefinition: { default: "preserve", fallback: "token" },
      declaration_reference_subsetting: { default: "preserve", fallback: "token" },
      declaration_feature_typing: { default: "preserve", fallback: "token" },
      declaration_conjugated_port_typing: { default: "preserve", fallback: "token" },
      declaration_cross_subsetting: { default: "preserve", fallback: "token" },
      feature_value_equals: { default: "preserve", fallback: "as_needed" },
      feature_keyword: { default: "preserve", fallback: "as_needed" },
      public_keyword: { default: "preserve", fallback: "never" },
      conjugation_keyword: { default: "preserve", fallback: "as_needed" },
      specialization_keyword_specialization: { default: "preserve", fallback: "as_needed" },
      specialization_keyword_subclassification: { default: "preserve", fallback: "as_needed" },
      specialization_keyword_feature_typing: { default: "preserve", fallback: "as_needed" },
      specialization_keyword_subsetting: { default: "preserve", fallback: "as_needed" },
      specialization_keyword_redefinition: { default: "preserve", fallback: "as_needed" },
      disjoining_keyword: { default: "preserve", fallback: "as_needed" },
      inverting_keyword: { default: "preserve", fallback: "as_needed" },
      featuring_of_keyword: { default: "preserve", fallback: "as_needed" },
      dependency_from_keyword: { default: "always", fallback: "always" },
      invariant_true_keyword: { default: "preserve", fallback: "always" },
      multiplicity_placement: "first-specialization",
      metadata_feature_keyword: { default: "preserve", fallback: "@" },
      metadata_body_feature_keyword: { default: "preserve", fallback: "never" },
      metadata_body_feature_redefines: { default: "preserve", fallback: "none" },
      binary_allocation_usages: { default: "preserve", fallback: "always" },
      binary_connectors: { default: "preserve", fallback: "always" },
      binary_connectors_from_keyword: { default: "preserve", fallback: "always" },
      binary_binding_connectors: { default: "preserve", fallback: "always" },
      binary_binding_connector_of_keyword: { default: "preserve", fallback: "always" },
      binary_successions: { default: "preserve", fallback: "always" },
      binary_succession_first_keyword: { default: "preserve", fallback: "always" },
      item_flow_from_keyword: { default: "preserve", fallback: "always" },
      succession_item_flow_from_keyword: { default: "preserve", fallback: "always" },
      flow_connection_usage_from_keyword: { default: "preserve", fallback: "always" },
      succession_flow_connection_usage_from_keyword: { default: "preserve", fallback: "always" },
      ordered_nonunique_priority: { default: "preserve", fallback: "ordered" },
      enum_member_keyword: { default: "preserve", fallback: "never" },
      occurrence_keyword: { default: "preserve", fallback: "always" },
      event_occurrence_keyword: { default: "preserve", fallback: "always" },
      binding_connector_as_usage_keyword: { default: "preserve", fallback: "always" },
      assert_constraint_usage_keyword: { default: "preserve", fallback: "always" },
      succession_as_usage_keyword: { default: "preserve", fallback: "always" },
      exhibit_state_usage_keyword: { default: "preserve", fallback: "always" },
      include_use_case_usage_keyword: { default: "preserve", fallback: "always" },
      perform_action_usage_keyword: { default: "preserve", fallback: "always" },
      satisfy_requirement_keyword: { default: "preserve", fallback: "always" },
      satisfy_requirement_assert_keyword: { default: "preserve", fallback: "always" },
      allocation_usage_keyword: { default: "preserve", fallback: "always" },
      connection_usage_keyword: { default: "preserve", fallback: "always" },
      binary_connection_usages: { default: "preserve", fallback: "always" },
      binary_interface_usages: { default: "preserve", fallback: "always" },
      interface_usage_connect_keyword: { default: "preserve", fallback: "always" },
      interface_port_keyword: { default: "preserve", fallback: "always" },
      action_node_keyword: { default: "preserve", fallback: "as_needed" },
      while_loop_parenthesize_condition: "on_break",
      while_loop_parenthesize_until: "on_break",
      if_parenthesize_condition: "on_break",
      transition_usage_parenthesize_guard: "on_break",
      element_filter_parenthesize: "on_break",
      transition_usage_keyword: { default: "preserve", fallback: "always" },
      transition_usage_first_keyword: { default: "preserve", fallback: "always" },
      framed_concern_keyword: { default: "preserve", fallback: "always" },
      reference_usage_keyword: { default: "preserve", fallback: "always" },
      attribute_usage_reference_keyword: { default: "preserve", fallback: "never" },
      event_occurrence_reference_keyword: { default: "preserve", fallback: "never" },
      port_usage_reference_keyword: { default: "preserve", fallback: "never" },
      connection_usage_reference_keyword: { default: "preserve", fallback: "never" },
      connector_as_usage_reference_keyword: { default: "preserve", fallback: "never" },
      exhibit_state_reference_keyword: { default: "preserve", fallback: "never" },
      include_use_case_reference_keyword: { default: "preserve", fallback: "never" },
      perform_action_reference_keyword: { default: "preserve", fallback: "never" }
    };
  }
});

// ../syside-languageserver/lib/model/semantic-tokens.js
var require_semantic_tokens = __commonJS({
  "../syside-languageserver/lib/model/semantic-tokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenModifiers = exports2.tokenType = exports2.DefaultSysMLSemanticTokenOptions = exports2.SysMLSemanticTokenModifiers = exports2.SysMLHighlightType = exports2.SysMLSemanticTokenTypes = void 0;
    var langium_1 = require_lib2();
    var vscode_languageserver_1 = require_main4();
    var types_1 = require_types2();
    var ast_1 = require_ast2();
    exports2.SysMLSemanticTokenTypes = {
      // builtin
      class: vscode_languageserver_1.SemanticTokenTypes.class,
      comment: vscode_languageserver_1.SemanticTokenTypes.comment,
      enum: vscode_languageserver_1.SemanticTokenTypes.enum,
      enumMember: vscode_languageserver_1.SemanticTokenTypes.enumMember,
      event: vscode_languageserver_1.SemanticTokenTypes.event,
      function: vscode_languageserver_1.SemanticTokenTypes.function,
      interface: vscode_languageserver_1.SemanticTokenTypes.interface,
      keyword: vscode_languageserver_1.SemanticTokenTypes.keyword,
      macro: vscode_languageserver_1.SemanticTokenTypes.macro,
      method: vscode_languageserver_1.SemanticTokenTypes.method,
      modifier: vscode_languageserver_1.SemanticTokenTypes.modifier,
      namespace: vscode_languageserver_1.SemanticTokenTypes.namespace,
      number: vscode_languageserver_1.SemanticTokenTypes.number,
      operator: vscode_languageserver_1.SemanticTokenTypes.operator,
      parameter: vscode_languageserver_1.SemanticTokenTypes.parameter,
      property: vscode_languageserver_1.SemanticTokenTypes.property,
      regexp: vscode_languageserver_1.SemanticTokenTypes.regexp,
      string: vscode_languageserver_1.SemanticTokenTypes.string,
      struct: vscode_languageserver_1.SemanticTokenTypes.struct,
      type: vscode_languageserver_1.SemanticTokenTypes.type,
      typeParameter: vscode_languageserver_1.SemanticTokenTypes.typeParameter,
      variable: vscode_languageserver_1.SemanticTokenTypes.variable,
      decorator: vscode_languageserver_1.SemanticTokenTypes.decorator,
      // custom, need to be registered in package.json
      annotation: "annotation",
      annotationBody: "annotationBody",
      relationship: "relationship",
      metaclass: "metaclass"
    };
    exports2.SysMLHighlightType = Object.fromEntries(Object.entries(exports2.SysMLSemanticTokenTypes).map(([k, v]) => [k, { type: v }]));
    exports2.SysMLSemanticTokenModifiers = {
      // builtin
      abstract: vscode_languageserver_1.SemanticTokenModifiers.abstract,
      async: vscode_languageserver_1.SemanticTokenModifiers.async,
      declaration: vscode_languageserver_1.SemanticTokenModifiers.declaration,
      defaultLibrary: vscode_languageserver_1.SemanticTokenModifiers.defaultLibrary,
      definition: vscode_languageserver_1.SemanticTokenModifiers.definition,
      deprecated: vscode_languageserver_1.SemanticTokenModifiers.deprecated,
      documentation: vscode_languageserver_1.SemanticTokenModifiers.documentation,
      modification: vscode_languageserver_1.SemanticTokenModifiers.modification,
      readonly: vscode_languageserver_1.SemanticTokenModifiers.readonly,
      static: vscode_languageserver_1.SemanticTokenModifiers.static
      // custom, need to be registered in package.json
    };
    Object.values(exports2.SysMLSemanticTokenTypes).forEach((name, index) => langium_1.AllSemanticTokenTypes[name] = index);
    Object.values(exports2.SysMLSemanticTokenModifiers).forEach((name, index) => langium_1.AllSemanticTokenModifiers[name] = 1 << index);
    exports2.DefaultSysMLSemanticTokenOptions = Object.assign(Object.assign({}, langium_1.DefaultSemanticTokenOptions), { legend: {
      tokenTypes: Object.keys(exports2.SysMLSemanticTokenTypes),
      tokenModifiers: Object.keys(exports2.SysMLSemanticTokenModifiers)
    } });
    var TYPE_TOKENS = {
      Namespace: exports2.SysMLSemanticTokenTypes.namespace,
      Type: exports2.SysMLSemanticTokenTypes.type,
      Feature: exports2.SysMLSemanticTokenTypes.variable,
      Class: exports2.SysMLSemanticTokenTypes.class,
      Structure: exports2.SysMLSemanticTokenTypes.struct,
      Comment: exports2.SysMLSemanticTokenTypes.annotation,
      TextualRepresentation: exports2.SysMLSemanticTokenTypes.annotation,
      EnumerationDefinition: exports2.SysMLSemanticTokenTypes.enum,
      EnumerationUsage: exports2.SysMLSemanticTokenTypes.enumMember,
      SysMLFunction: exports2.SysMLSemanticTokenTypes.function,
      Expression: exports2.SysMLSemanticTokenTypes.method,
      LiteralNumber: exports2.SysMLSemanticTokenTypes.number,
      LiteralString: exports2.SysMLSemanticTokenTypes.string,
      Relationship: exports2.SysMLSemanticTokenTypes.relationship,
      Metaclass: exports2.SysMLSemanticTokenTypes.metaclass,
      Association: exports2.SysMLSemanticTokenTypes.type,
      AssociationStructure: exports2.SysMLSemanticTokenTypes.struct
    };
    var _tokenMap;
    function tokenMap() {
      return _tokenMap !== null && _tokenMap !== void 0 ? _tokenMap : _tokenMap = types_1.typeIndex.expandToDerivedTypes(TYPE_TOKENS);
    }
    function tokenType(element) {
      return tokenMap().get(element.nodeType());
    }
    exports2.tokenType = tokenType;
    function tokenModifiers(node) {
      const mods = [];
      if (node.is(ast_1.Type) && node.isAbstract) {
        mods.push(exports2.SysMLSemanticTokenModifiers.abstract);
      }
      if (node.is(ast_1.Classifier)) {
        mods.push(exports2.SysMLSemanticTokenModifiers.definition);
      }
      if (node.isStandardElement) {
        mods.push(exports2.SysMLSemanticTokenModifiers.defaultLibrary);
      }
      if (node.is(ast_1.Feature) && node.isReadonly) {
        mods.push(exports2.SysMLSemanticTokenModifiers.readonly);
      }
      return mods;
    }
    exports2.tokenModifiers = tokenModifiers;
  }
});

// ../syside-languageserver/lib/model/printer/utils.js
var require_utils3 = __commonJS({
  "../syside-languageserver/lib/model/printer/utils.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getChildrenRange = exports2.collectPrintRange = exports2.printDescendant = exports2.getElementEnd = exports2.getElementStart = exports2.hasFormatIgnore = exports2.shouldIgnoreRef = exports2.selectDeclarationKeyword = exports2.hasFeatureDeclaration = exports2.formatPreserved = exports2.SysMLKeywords = exports2.KerMLKeywords = exports2.getKeywordsFor = exports2.printReference = exports2.assertMember = exports2.throwError = exports2.printAstReference = exports2.printIdentifiers = exports2.printIdentifier = exports2.computeHighlighting = void 0;
    var vscode_languageserver_1 = require_main4();
    var utils_1 = require_utils2();
    var semantic_tokens_1 = require_semantic_tokens();
    var naming_1 = require_naming();
    var ast_1 = require_ast2();
    var print_1 = require_print3();
    var langium_1 = require_lib2();
    var ast_2 = require_ast();
    var grammar_1 = require_grammar3();
    var assert_1 = __importDefault(require("assert"));
    function computeHighlighting(element) {
      return {
        type: (0, semantic_tokens_1.tokenType)(element),
        modifiers: (0, semantic_tokens_1.tokenModifiers)(element)
      };
    }
    exports2.computeHighlighting = computeHighlighting;
    function printIdentifier(name, options = {}) {
      var _a;
      if (options.forceQuotes || ((_a = options.restricted) === null || _a === void 0 ? void 0 : _a.has(name)))
        return (0, utils_1.text)(`'${name}'`, options.semantic);
      return (0, utils_1.text)((0, naming_1.unsanitizeName)(name), options.semantic);
    }
    exports2.printIdentifier = printIdentifier;
    function printIdentifiers(element, context, separators = {}) {
      var _a, _b, _c, _d, _e;
      const doc = [];
      if (!element.declaredShortName && !element.declaredName)
        return doc;
      const semantic = (context === null || context === void 0 ? void 0 : context.highlighting) ? computeHighlighting(element) : {};
      (_a = semantic.modifiers) === null || _a === void 0 ? void 0 : _a.push(vscode_languageserver_1.SemanticTokenModifiers.declaration);
      if (separators.leading)
        doc.push(separators.leading);
      if (element.declaredShortName) {
        doc.push((0, utils_1.group)([
          utils_1.brackets.angle.open,
          (0, utils_1.indent)([
            utils_1.softline,
            printIdentifier(element.declaredShortName, {
              semantic,
              restricted: context === null || context === void 0 ? void 0 : context.keywords,
              forceQuotes: (context === null || context === void 0 ? void 0 : context.format.strip_unnecessary_quotes) === false && ((_c = (_b = element.ast()) === null || _b === void 0 ? void 0 : _b.declaredShortName) === null || _c === void 0 ? void 0 : _c.startsWith("'"))
            })
          ]),
          // if this group is broken, put the bracket on a new line
          (0, utils_1.ifBreak)(utils_1.hardlineWithoutBreakParent, utils_1.literals.emptytext),
          utils_1.brackets.angle.close
        ]));
        if (element.declaredName) {
          doc.push(utils_1.literals.space);
        }
      }
      if (element.declaredName) {
        doc.push(printIdentifier(element.declaredName, {
          semantic,
          restricted: context === null || context === void 0 ? void 0 : context.keywords,
          forceQuotes: (context === null || context === void 0 ? void 0 : context.format.strip_unnecessary_quotes) === false && ((_e = (_d = element.ast()) === null || _d === void 0 ? void 0 : _d.declaredName) === null || _e === void 0 ? void 0 : _e.startsWith("'"))
        }));
      }
      if (separators.trailing && doc.length > 0)
        doc.push(separators.trailing);
      return doc;
    }
    exports2.printIdentifiers = printIdentifiers;
    function printAstReference(reference, context) {
      let innerNotes = reference.$meta.notes.filter((note) => note.localPlacement === "inner" && note.label !== void 0);
      let linebreak = utils_1.softline;
      const printed = (0, utils_1.fill)(reference.parts.map((ref, index) => {
        let part = printIdentifier((0, naming_1.sanitizeName)(ref.$refText), {
          semantic: context.highlighting && ref.ref ? computeHighlighting(ref.ref.$meta) : {},
          restricted: context.keywords,
          forceQuotes: !context.format.strip_unnecessary_quotes && ref.$refText.startsWith("'")
        });
        if (innerNotes.length === 0)
          return index === 0 ? part : [(0, utils_1.indent)(linebreak), (0, utils_1.indent)([utils_1.literals.doublecolon, part])];
        const leadingLabel = `${index}-leading`;
        const trailingLabel = `${index}-trailing`;
        const leading = [];
        const trailing = [];
        innerNotes = innerNotes.filter((note) => {
          switch (note.label) {
            case leadingLabel:
              leading.push(note);
              return false;
            case trailingLabel:
              trailing.push(note);
              return false;
            default:
              return true;
          }
        });
        if (leading.length > 0) {
          part = [
            index !== 0 ? utils_1.line : utils_1.literals.emptytext,
            (0, utils_1.printInnerComments)(leading, Object.assign(Object.assign({}, context), { label: leadingLabel }), (note) => note.kind === "line" ? utils_1.hardline : void 0),
            utils_1.line,
            part
          ];
        }
        if (trailing.length > 0) {
          part = [
            part,
            utils_1.line,
            (0, utils_1.printInnerComments)(trailing, Object.assign(Object.assign({}, context), { label: trailingLabel }))
          ];
        }
        part = (0, utils_1.group)(part);
        if (index !== 0)
          part = [(0, utils_1.indent)(linebreak), (0, utils_1.indent)([utils_1.literals.doublecolon, part])];
        const lastNote = trailing.at(-1);
        if (lastNote) {
          if (lastNote.kind === "line")
            linebreak = utils_1.hardline;
          else
            linebreak = utils_1.softline;
        }
        return part;
      }).flat(1));
      const doc = (0, print_1.defaultPrintNotes)(printed, reference.$meta, context);
      if (reference.$meta.notes.some((note) => note.localPlacement === "leading"))
        return (0, utils_1.label)("with-leading-notes", doc);
      return doc;
    }
    exports2.printAstReference = printAstReference;
    function throwError(element, message) {
      var _a;
      const range = (_a = element.cst()) === null || _a === void 0 ? void 0 : _a.range;
      if (range)
        message += ` on line ${range.start.line + 1}, character: ${range.start.character + 1}`;
      throw new Error(message);
    }
    exports2.throwError = throwError;
    function assertMember(owner, member, kind, name) {
      if (!member)
        throwError(owner, `Invalid ${kind} - missing ${name} member`);
    }
    exports2.assertMember = assertMember;
    function printReference(target, options) {
      var _a, _b;
      if (!target) {
        if (!options.astNode) {
          throwError(options.scope, (_a = options.errorMessage) !== null && _a !== void 0 ? _a : `Missing reference in ${options.scope.nodeType()}`);
        }
        return printAstReference(options.astNode, options.context);
      }
      if (options.astNode) {
        const to = (_b = options.astNode) === null || _b === void 0 ? void 0 : _b.$meta.to;
        const targetRef = options.astNode.$type !== ast_1.MembershipReference && target.is(ast_1.Membership) ? target.element() : target;
        if (!(to === null || to === void 0 ? void 0 : to.cached) || to.target === targetRef)
          return printAstReference(options.astNode, options.context);
      }
      return options.context.referencePrinter(target, options.scope, options.context);
    }
    exports2.printReference = printReference;
    function collectKeywords(grammar) {
      return (0, langium_1.stream)(grammar.rules).flatMap(langium_1.streamAst).filter(ast_2.isKeyword).map((rule) => rule.value).toSet();
    }
    var CACHED_KEYWORDS = {};
    function getKeywordsFor(id, grammar) {
      var _a;
      return (_a = CACHED_KEYWORDS[id]) !== null && _a !== void 0 ? _a : CACHED_KEYWORDS[id] = collectKeywords(grammar);
    }
    exports2.getKeywordsFor = getKeywordsFor;
    function KerMLKeywords() {
      return getKeywordsFor(Symbol.for("KerML"), (0, grammar_1.KerMLGrammar)());
    }
    exports2.KerMLKeywords = KerMLKeywords;
    function SysMLKeywords() {
      return getKeywordsFor(Symbol.for("SysML"), (0, grammar_1.SysMLGrammar)());
    }
    exports2.SysMLKeywords = SysMLKeywords;
    function formatPreserved(node, option, fallback, config) {
      const { choose } = config;
      if (option.default !== "preserve")
        return choose[option.default]();
      const cst = node.cst();
      if (!cst)
        return choose[option.fallback || fallback]();
      const alt = choose.preserve(config.find(cst));
      return choose[alt]();
    }
    exports2.formatPreserved = formatPreserved;
    function hasFeatureDeclaration(node) {
      return Boolean(node.specializations().some((s) => !s.isImplied) || node.typeRelationships.some((r) => !r.isImplied) || node.declaredName || node.declaredShortName || node.multiplicity || node.isOrdered || node.isNonUnique);
    }
    exports2.hasFeatureDeclaration = hasFeatureDeclaration;
    function selectDeclarationKeyword(node, kw, option) {
      const token = formatPreserved(node, option, "always", {
        find: (node2) => (0, langium_1.findNodeForKeyword)(node2, kw),
        choose: {
          always: () => kw,
          as_needed: () => hasFeatureDeclaration(node) ? kw : void 0,
          preserve: (found) => found ? "always" : "as_needed"
        }
      });
      return token;
    }
    exports2.selectDeclarationKeyword = selectDeclarationKeyword;
    function shouldIgnoreRef(node, option) {
      return formatPreserved(node, option, "always", {
        find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "ref"),
        choose: {
          always: () => false,
          never: () => true,
          preserve: (found) => found ? "always" : "never"
        }
      });
    }
    exports2.shouldIgnoreRef = shouldIgnoreRef;
    function hasFormatIgnore(node) {
      return Boolean(node.cst() && node.notes.some((note) => note.localPlacement === "leading" && /syside-format ignore/.test(note.text)));
    }
    exports2.hasFormatIgnore = hasFormatIgnore;
    function getElementStart(node) {
      var _a, _b;
      return (_b = (_a = node.notes.filter((note) => note.localPlacement === "leading").find((note) => note.segment)) === null || _a === void 0 ? void 0 : _a.segment) !== null && _b !== void 0 ? _b : node.cst();
    }
    exports2.getElementStart = getElementStart;
    function getElementEnd(node) {
      var _a, _b;
      return (_b = (_a = node.notes.filter((note) => note.localPlacement === "trailing").findLast((note) => note.segment)) === null || _a === void 0 ? void 0 : _a.segment) !== null && _b !== void 0 ? _b : node.cst();
    }
    exports2.getElementEnd = getElementEnd;
    var DescendantPrinterImpl = class {
      constructor(root, context, kind) {
        this.root = root;
        this.context = context;
        this.kind = kind;
        this.stack = [];
      }
      /**
       * Descend one element at a time. Descending more risks losing attached
       * notes.
       */
      descend(selector) {
        const parent = this.descendant;
        const child = selector(parent);
        if (!child)
          throwError(parent, `Interrupted ${this.kind} chain at ${this.stack.length} link`);
        this.stack.push(child);
        return this;
      }
      print(options) {
        (0, assert_1.default)(this.stack.length > 0, "Cannot print empty descendant chain");
        let printed = (0, print_1.printModelElement)(this.stack[this.stack.length - 1], this.context, options);
        for (let i = this.stack.length - 2; i >= 0; --i)
          printed = (0, print_1.printModelElement)(this.stack[i], this.context, { printer: () => printed });
        return printed;
      }
      get descendant() {
        var _a;
        return (_a = this.stack.at(-1)) !== null && _a !== void 0 ? _a : this.root;
      }
    };
    function printDescendant(root, context, kind) {
      return new DescendantPrinterImpl(root, context, kind);
    }
    exports2.printDescendant = printDescendant;
    function rangesIntersect(a, b) {
      return a.offset > b.offset && a.offset < b.end || a.end < b.end && a.end > b.offset;
    }
    function rangesIntersectSym(a, b) {
      return rangesIntersect(a, b) || rangesIntersect(b, a);
    }
    function cstRangeIntersector(range) {
      return (child) => {
        const cst = child.cst();
        if (!cst)
          return false;
        return rangesIntersectSym(cst, range);
      };
    }
    var ignoredPrinter = (node, context, sibling) => {
      var _a;
      return (_a = (0, print_1.printElementIgnored)(node, context)) !== null && _a !== void 0 ? _a : (0, print_1.DefaultElementPrinter)(node, context, sibling);
    };
    function collectPrintRange(document, range) {
      var _a, _b, _c, _d, _e;
      const root = document.parseResult.value.$meta;
      const cst = root.cst();
      if (!cst)
        return;
      const { offset, end } = range;
      if (end <= cst.offset || offset >= cst.end)
        return;
      let level = 0;
      let scope = root;
      let scopeCst = cst;
      let children = root.children;
      let leading;
      for (; ; ) {
        const blockOffset = (_c = (_b = (0, langium_1.findNodeForKeyword)((_a = scope.cst()) !== null && _a !== void 0 ? _a : scopeCst, "{")) === null || _b === void 0 ? void 0 : _b.offset) !== null && _c !== void 0 ? _c : -1;
        if (scope.parent() !== void 0 && blockOffset === -1 || blockOffset >= offset) {
          const parent = scope.parent();
          if (parent === null || parent === void 0 ? void 0 : parent.is(ast_1.OwningMembership))
            scope = parent;
          return {
            elements: [scope],
            range: getChildrenRange([scope]),
            // ascending one level back up
            level: level - 1,
            leading,
            options: {
              printer: print_1.DefaultElementPrinter,
              previousSibling: leading === null || leading === void 0 ? void 0 : leading.at(-1)
            }
          };
        }
        const allChildrenRange = getChildrenRange(children);
        const first = children.findIndex(cstRangeIntersector(range));
        const last = children.findLastIndex(cstRangeIntersector(range));
        leading = first > 0 ? children.slice(0, first) : void 0;
        if (first === -1 || last === -1) {
          switch (children.length) {
            case 0:
              return;
            case 1:
              if (!allChildrenRange)
                return;
              return {
                elements: children,
                range: allChildrenRange,
                level,
                options: {
                  printer: ignoredPrinter
                }
              };
            default: {
              const next = children.findIndex((child) => {
                const cst2 = child.cst();
                return cst2 && cst2.offset >= end;
              });
              if (next === -1)
                return;
              let prev = next - 1;
              while (!children[prev].cst() && prev >= 0) {
                --prev;
              }
              const surrounding = prev >= 0 ? children.slice(prev, next + 1) : [children[next]];
              leading = prev > 0 ? children.slice(0, prev) : void 0;
              return {
                elements: surrounding,
                range: getChildrenRange(surrounding),
                level,
                leading,
                options: {
                  printer: ignoredPrinter,
                  previousSibling: leading === null || leading === void 0 ? void 0 : leading.at(-1)
                }
              };
            }
          }
        }
        if (first === last) {
          const child = children[first];
          if (child.is(ast_1.Relationship) && !((_d = child.element()) === null || _d === void 0 ? void 0 : _d.is(ast_1.InlineExpression)) || child.is(ast_1.Namespace)) {
            const target = child.is(ast_1.OwningMembership) && child.element().is(ast_1.Namespace) ? child.element() : child;
            level++;
            scope = target;
            scopeCst = (_e = target.cst()) !== null && _e !== void 0 ? _e : child.cst();
            children = target.children;
            continue;
          }
        }
        const elements = children.slice(first, last + 1);
        return {
          elements,
          range: getChildrenRange(elements),
          level,
          leading,
          options: {
            printer: print_1.DefaultElementPrinter,
            previousSibling: leading === null || leading === void 0 ? void 0 : leading.at(-1)
          }
        };
      }
    }
    exports2.collectPrintRange = collectPrintRange;
    function getChildrenRange(children) {
      const first = children.find((e) => e.cst());
      const last = children.findLast((e) => e.cst());
      if (first === void 0 || last === void 0)
        return;
      const left = [first];
      if (first.is(ast_1.Relationship)) {
        left.push(...[first.source(), first.element()].filter(utils_1.NonNullable).filter((e) => e.parent() === first));
      }
      let right = [last];
      if (first === last) {
        right = left;
      } else if (last.is(ast_1.Relationship)) {
        right.push(...[last.source(), last.element()].filter(utils_1.NonNullable).filter((e) => e.parent() === first));
      }
      const start = Math.min(...left.map(getElementStart).filter(utils_1.NonNullable).map((s) => s.offset));
      const end = Math.max(...right.map(getElementEnd).filter(utils_1.NonNullable).map((s) => s.end));
      if (!Number.isFinite(start) || !Number.isFinite(end))
        return;
      return { offset: start, end };
    }
    exports2.getChildrenRange = getChildrenRange;
  }
});

// ../syside-languageserver/lib/model/printer/expressions.js
var require_expressions4 = __commonJS({
  "../syside-languageserver/lib/model/printer/expressions.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printFeatureReferenceExpression = exports2.printTriggerInvocationExpression = exports2.printMetadataAccessExpression = exports2.printExpression = exports2.printExpressionBody = exports2.printNullExpression = exports2.printLiteralNumber = exports2.printInvocationExpr = exports2.printArgumentValue = exports2.printArgument = exports2.printOperatorExpression = exports2.shouldFlatten = exports2.getOperator = exports2.getArguments = exports2.precedence = exports2.PREC_LEVELS = void 0;
    var ast2 = __importStar(require_ast2());
    var KerML_1 = require_KerML();
    var vscode_languageserver_1 = require_main4();
    var print_1 = require_print3();
    var utils_1 = require_utils2();
    var utils_2 = require_utils3();
    var edges_1 = require_edges();
    var metamodel_1 = require_metamodel();
    var langium_1 = require_lib2();
    var namespaces_1 = require_namespaces();
    exports2.PREC_LEVELS = {
      NONE: 0,
      IF: 1,
      NULL_COALESCING: 2,
      IMPLIES: 3,
      OR: 4,
      XOR: 5,
      AND: 6,
      EQUALITY: 7,
      CLASSIFICATION: 8,
      COMPARISON: 9,
      RANGE: 10,
      ADDITION: 11,
      MULTIPLICITY: 12,
      EXPONENTATION: 13,
      UNARY: 14,
      ALL: 15,
      ACCESS: 16,
      LITERAL: 1e4
    };
    function precedence(node) {
      var _a;
      switch (getOperator(node)) {
        case "":
          return exports2.PREC_LEVELS.LITERAL;
        case "'if'":
          return exports2.PREC_LEVELS.IF;
        case "'??'":
          return exports2.PREC_LEVELS.NULL_COALESCING;
        case "'implies'":
          return exports2.PREC_LEVELS.IMPLIES;
        case "'or'":
        case "'|'":
          return exports2.PREC_LEVELS.OR;
        case "'xor'":
          return exports2.PREC_LEVELS.XOR;
        case "'and'":
        case "'&'":
          return exports2.PREC_LEVELS.AND;
        case "'=='":
        case "'==='":
        case "'!='":
        case "'!=='":
          return exports2.PREC_LEVELS.EQUALITY;
        case "'istype'":
        case "'hastype'":
        case "'@'":
        case "'@@'":
        case "'as'":
        case "'meta'":
          return exports2.PREC_LEVELS.CLASSIFICATION;
        case "'<'":
        case "'<='":
        case "'>'":
        case "'>='":
          return exports2.PREC_LEVELS.COMPARISON;
        case "'..'":
          return exports2.PREC_LEVELS.RANGE;
        case "'+'":
        case "'-'":
          return ((_a = getArguments(node)) === null || _a === void 0 ? void 0 : _a.length) === 1 ? exports2.PREC_LEVELS.UNARY : exports2.PREC_LEVELS.ADDITION;
        case "'*'":
        case "'/'":
        case "'%'":
          return exports2.PREC_LEVELS.MULTIPLICITY;
        case "'**'":
        case "'^'":
          return exports2.PREC_LEVELS.EXPONENTATION;
        case "'~'":
        case "'not'":
          return exports2.PREC_LEVELS.UNARY;
        case "'all'":
          return exports2.PREC_LEVELS.ALL;
        case "'#'":
        case "'['":
        case "'.?'":
        case "'.'":
        case "collect":
        case "'.metadata'":
          return exports2.PREC_LEVELS.ACCESS;
        case "','":
          return exports2.PREC_LEVELS.NONE;
      }
    }
    exports2.precedence = precedence;
    function getArguments(node) {
      if (!(node === null || node === void 0 ? void 0 : node.is(ast2.OperatorExpression)))
        return;
      return node.arguments();
    }
    exports2.getArguments = getArguments;
    var HighlightOperator = { type: vscode_languageserver_1.SemanticTokenTypes.operator };
    function getOperator(expr) {
      var _a;
      switch (expr === null || expr === void 0 ? void 0 : expr.nodeType()) {
        case ast2.SelectExpression:
          return KerML_1.IMPLICIT_OPERATORS.SELECT;
        case ast2.FeatureChainExpression:
          return KerML_1.IMPLICIT_OPERATORS.DOT;
        case ast2.CollectExpression:
          return KerML_1.IMPLICIT_OPERATORS.COLLECT;
        case ast2.IndexExpression:
          return KerML_1.IMPLICIT_OPERATORS.INDEX;
        case ast2.OperatorExpression: {
          return expr.operator;
        }
        case ast2.FeatureReferenceExpression:
          return getOperator((_a = expr.expression) === null || _a === void 0 ? void 0 : _a.element());
        case ast2.MetadataAccessExpression: {
          const owner = expr.owner();
          if ((owner === null || owner === void 0 ? void 0 : owner.is(ast2.OperatorExpression)) && (owner.operator === KerML_1.OPERATORS.AT_AT || owner.operator === KerML_1.OPERATORS.META)) {
            return KerML_1.OPERATORS.NONE;
          }
          return KerML_1.IMPLICIT_OPERATORS.METADATA;
        }
        default:
          return KerML_1.OPERATORS.NONE;
      }
    }
    exports2.getOperator = getOperator;
    function shouldFlatten(expr, lhs) {
      const leftPrec = precedence(expr);
      const rightPrec = precedence(lhs);
      if (leftPrec !== rightPrec)
        return false;
      if (leftPrec === exports2.PREC_LEVELS.EXPONENTATION)
        return false;
      if (leftPrec === exports2.PREC_LEVELS.EQUALITY)
        return false;
      const leftOp = getOperator(expr);
      const lhsOp = getOperator(lhs);
      if ((leftOp === KerML_1.OPERATORS.MODULO || leftOp !== lhsOp) && leftPrec === exports2.PREC_LEVELS.MULTIPLICITY)
        return false;
      return true;
    }
    exports2.shouldFlatten = shouldFlatten;
    function printBinaryOpRhs(expr, operator, right, context, options) {
      let ws;
      let shouldIndent = false;
      switch (operator) {
        case "":
          return [paren(right, options.parens)];
        case "'??'":
        case "'implies'":
        case "'or'":
        case "'|'":
        case "'xor'":
        case "'and'":
        case "'&'":
        case "'=='":
        case "'==='":
        case "'!='":
        case "'!=='":
        case "'<'":
        case "'<='":
        case "'>'":
        case "'>='":
        case "'+'":
        case "'-'":
        case "'*'":
        case "'/'":
        case "'%'": {
          ws = [utils_1.literals.space, utils_1.line];
          break;
        }
        case "'istype'":
        case "'hastype'":
        case "'@'":
        case "'@@'":
        case "'as'":
        case "'meta'": {
          ws = [options.hasLhs ? utils_1.literals.space : utils_1.literals.emptytext, utils_1.line];
          break;
        }
        case "'..'":
        case "'**'":
        case "'^'": {
          ws = [utils_1.literals.emptytext, utils_1.softline];
          shouldIndent = context.format.operator_break === "before";
          break;
        }
        case "'#'":
          return [
            utils_1.literals.emptytext,
            (0, utils_1.group)([
              (0, utils_1.text)("#", HighlightOperator),
              (0, utils_1.text)("("),
              (0, utils_1.indent)([utils_1.softline, right]),
              utils_1.softline,
              (0, utils_1.text)(")")
            ])
          ];
        case "'['":
          return [
            utils_1.literals.space,
            (0, utils_1.group)([
              utils_1.brackets.square.open,
              (0, utils_1.indent)([utils_1.softline, right]),
              utils_1.softline,
              utils_1.brackets.square.close
            ])
          ];
        case "','": {
          const parts = [utils_1.literals.emptytext, utils_1.literals.comma, utils_1.line];
          if (Array.isArray(right))
            return [...parts, ...right];
          return [...parts, right];
        }
        case "'.'":
          return [(0, utils_1.indent)([utils_1.softline, (0, utils_1.text)(".", HighlightOperator), right])];
        case "collect":
          return [(0, utils_1.text)(".", HighlightOperator), right];
        case "'.?'":
          return [(0, utils_1.text)(".?", HighlightOperator), right];
        case "'if'":
        case "'~'":
        case "'not'":
        case "'all'":
        case "'.metadata'":
          throw new Error(`${operator} is not a binary operator!`);
      }
      const op = (0, utils_1.text)(operator.slice(1, -1), HighlightOperator);
      if (context.format.operator_break === "before") {
        ws = [ws[1], ws[0]];
      }
      const contents = [ws[0], op, ws[1], paren(right, options.parens)];
      return shouldIndent ? [utils_1.literals.emptytext, (0, utils_1.indent)(contents)] : contents;
    }
    function paren(doc, condition) {
      return condition ? [utils_1.brackets.round.open, (0, utils_1.indent)(doc), utils_1.brackets.round.close] : doc;
    }
    var defaultFeaturePrinter = (node, context) => {
      if (node.nodeType() === ast2.Feature) {
        if (node.chainings.length === 0) {
          return utils_1.literals.emptytext;
        }
        return (0, edges_1.printChaining)(node, context);
      }
      return (0, print_1.DefaultElementPrinter)(node, context);
    };
    function shouldParenthesize(expr, branch) {
      const exprPrec = precedence(expr);
      const branchPrec = precedence(branch);
      if (branchPrec <= exprPrec) {
        return true;
      }
      if (branchPrec == exports2.PREC_LEVELS.AND) {
        return exprPrec == exports2.PREC_LEVELS.OR || exprPrec == exports2.PREC_LEVELS.XOR;
      }
      if (branchPrec == exports2.PREC_LEVELS.UNARY || branchPrec == exports2.PREC_LEVELS.ALL) {
        return exprPrec == exports2.PREC_LEVELS.RANGE || exprPrec == exports2.PREC_LEVELS.ADDITION || exprPrec == exports2.PREC_LEVELS.EXPONENTATION || exprPrec == exports2.PREC_LEVELS.MULTIPLICITY;
      }
      if (exprPrec == exports2.PREC_LEVELS.RANGE) {
        return branchPrec == exports2.PREC_LEVELS.ADDITION || branchPrec == exports2.PREC_LEVELS.EXPONENTATION || branchPrec == exports2.PREC_LEVELS.MULTIPLICITY;
      }
      return false;
    }
    function printBinaryishExpressions(expr, context, printer = print_1.DefaultElementPrinter) {
      var _a;
      let [lhs, rhs] = expr.arguments();
      rhs !== null && rhs !== void 0 ? rhs : rhs = (_a = expr.children.filter(metamodel_1.BasicMetamodel.is(ast2.Membership)).find((m) => !m.is(ast2.ParameterMembership) || !m.element().value)) === null || _a === void 0 ? void 0 : _a.element();
      let right;
      if ((rhs === null || rhs === void 0 ? void 0 : rhs.owner()) === expr)
        right = (0, print_1.printModelElement)(rhs, context, { printer });
      else {
        const member = expr.children.find((m) => m.element() === rhs);
        if (!member)
          (0, utils_2.throwError)(expr, "Invalid operator expression - missing membership to referenced RHS element");
        right = (0, edges_1.printTarget)(member, context);
      }
      const flatten = shouldFlatten(expr, lhs);
      let hasLhs = true;
      let parts;
      if (flatten) {
        parts = (0, print_1.printModelElement)(lhs, context, {
          printer: (node, context2) => printBinaryishExpressions(node, context2, printer)
        });
      } else {
        const left = (0, print_1.printModelElement)(lhs, context);
        hasLhs = left !== utils_1.literals.emptytext;
        const lhsOp = getOperator(lhs);
        parts = [paren(left, lhsOp !== KerML_1.OPERATORS.COMMA && shouldParenthesize(expr, lhs))];
      }
      const operator = getOperator(expr);
      parts.push(...printBinaryOpRhs(expr, operator, right, context, {
        // less_equal since we use left-associative parsing which would put
        // nodes with the same precedence on the lhs by default
        parens: shouldParenthesize(expr, rhs),
        flatten,
        hasLhs
      }));
      if (context.format.sequence_expression_trailing_comma && operator === KerML_1.OPERATORS.COMMA && getOperator(rhs) !== KerML_1.OPERATORS.COMMA) {
        parts.push(utils_1.literals.emptytext, (0, utils_1.ifBreak)(utils_1.literals.comma, utils_1.literals.emptytext, "sequence-expr"));
      }
      return parts;
    }
    function printConditionalExpression(expr, context, nested = false) {
      var _a, _b;
      if (expr.is(ast2.FeatureReferenceExpression)) {
        const target = (_a = expr.expression) === null || _a === void 0 ? void 0 : _a.element();
        if (!target || !target.is(ast2.OperatorExpression) || target.operator != KerML_1.OPERATORS.IF)
          (0, utils_2.throwError)(expr, "FeatureReferenceExpression does not refer to a conditional expression!");
        expr = target;
      }
      const [test, then, else_] = expr.arguments();
      let hasChain = false;
      let printedElse;
      if (getOperator(else_) === KerML_1.OPERATORS.IF) {
        hasChain = true;
        printedElse = printConditionalExpression(else_, context, true);
      } else if (else_.is(ast2.FeatureReferenceExpression) && getOperator((_b = else_.expression) === null || _b === void 0 ? void 0 : _b.element()) === KerML_1.OPERATORS.IF) {
        hasChain = true;
        printedElse = (0, utils_2.printDescendant)(else_, context, "else branch").descend((node) => node.expression).descend((node) => node.element()).print({
          printer(node, context2) {
            return printConditionalExpression(node, context2, true);
          }
        });
      } else {
        printedElse = (0, print_1.printModelElement)(else_, context);
      }
      const branches = [
        utils_1.line,
        // align nested branches
        (0, utils_1.ifBreak)((0, utils_1.text)("?    "), (0, utils_1.text)("? ")),
        (0, utils_1.indent)((0, print_1.printModelElement)(then, context)),
        utils_1.line,
        (0, utils_1.text)("else "),
        hasChain ? printedElse : (0, utils_1.indent)(printedElse)
      ];
      const printedTest = (0, print_1.printModelElement)(test, context);
      const condition = (0, utils_1.group)([
        (0, utils_1.text)("if", HighlightOperator),
        utils_1.literals.space,
        getOperator(test) === KerML_1.OPERATORS.IF ? (0, utils_1.group)([
          utils_1.brackets.round.open,
          (0, utils_1.indent)([utils_1.softline, printedTest]),
          utils_1.softline,
          utils_1.brackets.round.close
        ]) : (0, utils_1.indent)(printedTest)
      ]);
      if (nested) {
        return [condition, ...branches];
      }
      return (0, utils_1.group)([condition, (0, utils_1.indent)(branches)]);
    }
    function printArrowExpression(expr, context) {
      var _a;
      const args = expr.arguments();
      const nonArg = (_a = expr.children.find((m) => m.nodeType() == ast2.FeatureMembership)) === null || _a === void 0 ? void 0 : _a.element();
      const isExpr = args.length === 1 && nonArg && nonArg.nodeType() === ast2.Expression && nonArg.specializations().every((s) => s.isImplied);
      const isList = Boolean(!nonArg || args.length >= 2);
      const target = paren((0, print_1.printModelElement)(args[0], context), precedence(args[0]) < exports2.PREC_LEVELS.ACCESS && getOperator(args[0]) !== KerML_1.OPERATORS.COMMA);
      const func = (0, utils_1.indent)([
        (0, utils_1.text)("->", HighlightOperator),
        (0, edges_1.printTarget)(expr.specializations(ast2.FeatureTyping)[0], context)
      ]);
      if (isList) {
        const inner = (0, utils_1.join)([utils_1.literals.comma, utils_1.line], args.slice(1).map((arg) => printArgument(
          // args are owned so owner is not null
          arg.owner(),
          context
        )));
        return (0, utils_1.group)([
          target,
          func,
          utils_1.brackets.round.open,
          (0, utils_1.indent)([utils_1.softline, inner]),
          utils_1.softline,
          utils_1.brackets.round.close
        ], { id: "arg-list" });
      }
      if (isExpr) {
        const inner = (0, print_1.printModelElement)(nonArg, context);
        return (0, utils_1.group)([target, func, utils_1.literals.space, inner]);
      }
      if (!nonArg)
        (0, utils_2.throwError)(expr, "InvocationExpression is missing a FunctionReferenceMember!");
      return (0, utils_1.fill)([
        target,
        utils_1.softline,
        func,
        (0, utils_1.indent)(utils_1.line),
        (0, utils_1.indent)((0, edges_1.printTarget)(nonArg.specializations(ast2.FeatureTyping)[0], context))
      ]);
    }
    function printUnaryExpression(expr, context) {
      var _a;
      const operator = expr.operator;
      const arg = (_a = expr.arguments().at(0)) !== null && _a !== void 0 ? _a : expr.children[0].element();
      if (!arg)
        (0, utils_2.throwError)(expr, `Unary expression ${expr} is missing an argument or a result member!`);
      return [
        (0, utils_1.text)(operator.slice(1, -1), HighlightOperator),
        operator === KerML_1.OPERATORS.NOT || operator === KerML_1.OPERATORS.ALL ? utils_1.literals.space : utils_1.literals.emptytext,
        paren((0, print_1.printModelElement)(arg, context), precedence(arg) < exports2.PREC_LEVELS.UNARY && getOperator(arg) !== KerML_1.OPERATORS.COMMA)
      ];
    }
    function printOperatorExpression(expr, context) {
      const operator = getOperator(expr);
      switch (operator) {
        case KerML_1.OPERATORS.IF:
          return printConditionalExpression(expr, context);
        case KerML_1.OPERATORS.BITWISE_NOT:
        case KerML_1.OPERATORS.NOT:
        case KerML_1.OPERATORS.ALL:
          return printUnaryExpression(expr, context);
        case KerML_1.IMPLICIT_OPERATORS.DOT: {
          const contents = printBinaryishExpressions(expr, context, defaultFeaturePrinter);
          const owner = expr.owner();
          if (!owner || getOperator(owner) !== KerML_1.IMPLICIT_OPERATORS.DOT)
            return (0, utils_1.fill)(contents);
          return (0, utils_1.group)(contents);
        }
        case KerML_1.OPERATORS.COMMA: {
          const contents = printBinaryishExpressions(expr, context);
          const owner = expr.owner();
          const ownerOp = owner ? getOperator(owner) : KerML_1.OPERATORS.NONE;
          if (!owner || ownerOp !== KerML_1.OPERATORS.COMMA) {
            return (0, utils_1.group)([
              utils_1.brackets.round.open,
              (0, utils_1.indent)([utils_1.softline, (0, utils_1.fill)(contents)]),
              utils_1.softline,
              utils_1.brackets.round.close
            ], { id: "sequence-expr" });
          }
          return contents;
        }
        case "'+'":
        case "'-'": {
          if (expr.arguments().length === 1)
            return printUnaryExpression(expr, context);
        }
        default: {
          return (0, utils_1.group)(printBinaryishExpressions(expr, context));
        }
      }
    }
    exports2.printOperatorExpression = printOperatorExpression;
    function printArgument(arg, context) {
      var _a;
      const value = (_a = arg.value) === null || _a === void 0 ? void 0 : _a.element();
      if (!value)
        (0, utils_2.throwError)(arg, "Invalid argument - missing value");
      let rhs = printArgumentValue(value, context);
      const name = arg.specializations().find((s) => !s.isImplied && s.is(ast2.Redefinition));
      if (!name)
        return rhs;
      const space = (0, utils_1.ifBreak)(utils_1.literals.space, utils_1.literals.emptytext, "arg-list");
      if (getOperator(value) !== KerML_1.OPERATORS.COMMA) {
        rhs = (0, utils_1.indentIfBreak)([(0, utils_1.ifBreak)(utils_1.line, utils_1.literals.emptytext, "arg-list"), rhs], {
          groupId: "assignment"
        });
      } else {
        rhs = [space, rhs];
      }
      return (0, utils_1.group)([(0, edges_1.printTarget)(name, context), space, (0, utils_1.text)("="), rhs], {
        id: "assignment"
      });
    }
    exports2.printArgument = printArgument;
    function printArgumentValue(value, context) {
      return (0, print_1.printModelElement)(value, context);
    }
    exports2.printArgumentValue = printArgumentValue;
    function printInvocationExpr(node, context) {
      if (node.operands.length > 0) {
        return printArrowExpression(node, context);
      }
      const typing = node.specializations(ast2.FeatureTyping).at(0);
      if (!typing)
        (0, utils_2.throwError)(node, "Invalid InvocationExpression - missing feature typing");
      return [
        (0, edges_1.printTarget)(typing, context),
        (0, utils_1.group)([
          utils_1.brackets.round.open,
          (0, utils_1.indent)([
            utils_1.softline,
            (0, utils_1.join)([utils_1.literals.comma, utils_1.line], [
              ...node.operands.map((arg) => printArgumentValue(arg, context)),
              ...node.argumentMembers().map((arg) => printArgument(arg, context))
            ])
          ]),
          utils_1.softline,
          utils_1.brackets.round.close
        ], { id: "arg-list" })
      ];
    }
    exports2.printInvocationExpr = printInvocationExpr;
    function printLiteralNumber(node, context) {
      var _a, _b;
      let str;
      const cst = (_a = node.cst()) === null || _a === void 0 ? void 0 : _a.text;
      const format = context.format.literal_real;
      if (cst && ((_b = node.ast()) === null || _b === void 0 ? void 0 : _b.literal) === node.literal) {
        str = cst;
        if (str.endsWith(","))
          str = str.slice(0, -1).trimEnd();
      } else if (node.isInteger) {
        str = node.literal.toFixed(0);
      } else {
        switch (format) {
          case "exp": {
            str = node.literal.toExponential();
            break;
          }
          case "none": {
            str = node.literal.toString();
            break;
          }
          case "prec": {
            str = node.literal.toPrecision();
            break;
          }
        }
      }
      return (0, utils_1.text)(str, { type: vscode_languageserver_1.SemanticTokenTypes.number });
    }
    exports2.printLiteralNumber = printLiteralNumber;
    function printNullExpression(node, context) {
      let inner = (0, utils_1.printInnerComments)(node.notes, context, (note) => note.kind === "line" ? utils_1.hardline : void 0);
      if (inner !== utils_1.literals.emptytext) {
        inner = [utils_1.literals.space, inner];
      }
      return (0, utils_2.formatPreserved)(node, context.format.null_expression, "null", {
        find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "null"),
        choose: {
          null: () => (0, utils_1.group)([(0, utils_1.keyword)("null"), inner]),
          brackets: () => (0, utils_1.group)([utils_1.brackets.round.open, utils_1.brackets.round.close, inner]),
          preserve: (found) => found ? "null" : "brackets"
        }
      });
    }
    exports2.printNullExpression = printNullExpression;
    function printExpressionBody(node, context) {
      if (node.specializations().some((s) => !s.isImplied))
        return (0, edges_1.printTarget)(node.specializations(ast2.FeatureTyping)[0], context);
      return (0, utils_1.group)((0, namespaces_1.printChildrenBlock)(node, node.children, context, {
        result: node.result,
        insertSpaceBeforeBrackets: false,
        forceEmptyBrackets: true
      }));
    }
    exports2.printExpressionBody = printExpressionBody;
    function printExpression(node, context) {
      var _a, _b, _c;
      if (((_a = node.parent()) === null || _a === void 0 ? void 0 : _a.is(ast2.FeatureMembership)) && ((_b = node.owner()) === null || _b === void 0 ? void 0 : _b.isAny(ast2.InvocationExpression, ast2.FeatureReferenceExpression))) {
        return printExpressionBody(node, context);
      }
      if ((_c = node.owner()) === null || _c === void 0 ? void 0 : _c.is(ast2.TriggerInvocationExpression)) {
        if (!node.result)
          (0, utils_2.throwError)(node, "Invalid change expression - missing result member");
        return (0, print_1.printModelElement)(node.result, context);
      }
      return (0, namespaces_1.printKerMLFeature)("expr", node, context);
    }
    exports2.printExpression = printExpression;
    function printMetadataAccessExpression(node, context) {
      var _a;
      const op = getOperator(node);
      const target = (0, utils_2.printReference)(node.reference, {
        scope: node,
        context,
        astNode: (_a = node.ast()) === null || _a === void 0 ? void 0 : _a.reference
      });
      if (op === KerML_1.OPERATORS.NONE)
        return target;
      return (0, utils_1.group)([
        target,
        (0, utils_1.indent)([utils_1.softline, (0, utils_1.text)(op.slice(1, -1), { type: vscode_languageserver_1.SemanticTokenTypes.operator })])
      ]);
    }
    exports2.printMetadataAccessExpression = printMetadataAccessExpression;
    function printTriggerInvocationExpression(node, context) {
      (0, print_1.assertSysML)(context, node.nodeType());
      const exprPrinter = (() => {
        const descendant = (0, utils_2.printDescendant)(node.children[0], context, `trigger invocation expression ${node.kind === "when" ? "change" : "owned"} expression`).descend((node2) => {
          if (!node2.is(ast2.FeatureMembership))
            (0, utils_2.throwError)(node2, "Expected a feature membership as first trigger invocation expression member");
          return node2.element();
        });
        switch (node.kind) {
          case "at":
          case "after": {
            return descendant;
          }
          case "when": {
            return descendant.descend((node2) => {
              if (!node2.is(ast2.Feature))
                (0, utils_2.throwError)(node2, "Expected an owned feature value");
              return node2.value;
            }).descend((node2) => node2.element());
          }
        }
      })();
      return (0, edges_1.printAssignmentExpression)([(0, utils_1.keyword)(node.kind)], exprPrinter.descendant, context, (0, print_1.printModelElement)(node.children[0], context, { printer: () => exprPrinter.print() }));
    }
    exports2.printTriggerInvocationExpression = printTriggerInvocationExpression;
    function printFeatureReferenceExpression(node, context) {
      if (!node.expression)
        (0, utils_2.throwError)(node, "Invalid FeatureReferenceExpression - missing expression");
      return (0, edges_1.printTarget)(node.expression, context, {
        printer: defaultFeaturePrinter
      });
    }
    exports2.printFeatureReferenceExpression = printFeatureReferenceExpression;
  }
});

// ../syside-languageserver/lib/model/printer/annotating-elements.js
var require_annotating_elements = __commonJS({
  "../syside-languageserver/lib/model/printer/annotating-elements.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printMetadataFeature = exports2.printTextualRepresentation = exports2.printDocumentation = exports2.printCommentElement = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var semantic_tokens_1 = require_semantic_tokens();
    var edges_1 = require_edges();
    var namespaces_1 = require_namespaces();
    var print_1 = require_print3();
    var utils_2 = require_utils3();
    function printBody(body, preserveTrailingWhitespace) {
      const linebreak = preserveTrailingWhitespace ? utils_1.literalline : utils_1.hardline;
      return (0, utils_1.markAsRoot)([
        (0, utils_1.text)("/*", { type: semantic_tokens_1.SysMLSemanticTokenTypes.annotationBody }),
        linebreak,
        body.split("\n").map((line) => {
          if (line.length === 0) {
            return [(0, utils_1.text)(" *", { type: semantic_tokens_1.SysMLSemanticTokenTypes.annotationBody }), linebreak];
          }
          return [
            (0, utils_1.text)(" * ", { type: semantic_tokens_1.SysMLSemanticTokenTypes.annotationBody }),
            (0, utils_1.text)(line, { type: semantic_tokens_1.SysMLSemanticTokenTypes.annotationBody }),
            linebreak
          ];
        }),
        (0, utils_1.text)(" */", { type: semantic_tokens_1.SysMLSemanticTokenTypes.annotationBody })
      ]);
    }
    function printAbout(about, context, mustBreak = false) {
      if (about.length === 0)
        return [];
      return [
        (0, utils_1.indent)(mustBreak || context.format.comment_about_break === "always" ? utils_1.hardline : utils_1.line),
        (0, utils_1.group)((0, utils_1.indent)([
          (0, utils_1.keyword)("about"),
          (0, utils_1.indent)([
            utils_1.line,
            ...(0, utils_1.join)([utils_1.literals.comma, utils_1.line], about.map((a) => (0, edges_1.printTarget)(a, context)))
          ])
        ]))
      ];
    }
    function printLocale(locale) {
      if (!locale)
        return;
      return (0, utils_1.group)((0, utils_1.indent)([
        (0, utils_1.keyword)("locale"),
        utils_1.literals.space,
        (0, utils_1.text)(JSON.stringify(locale), { type: semantic_tokens_1.SysMLSemanticTokenTypes.string })
      ]));
    }
    function printCommentElement(node, context) {
      var _a;
      const parts = [];
      const { comment_keyword, markdown_comments } = context.format;
      const about = node.annotations().filter((a) => !a.isImplied);
      const identifiers = (0, utils_2.printIdentifiers)(node, context, { leading: utils_1.literals.space });
      const cst = (_a = node.cst()) === null || _a === void 0 ? void 0 : _a.text;
      if (comment_keyword.default === "always" || comment_keyword.default === "preserve" && (!cst && comment_keyword.fallback === "always" || (cst === null || cst === void 0 ? void 0 : cst.startsWith("comment"))) || identifiers.length > 0 || about.length > 0) {
        parts.push((0, utils_1.keyword)("comment"), (0, utils_1.indent)(identifiers));
      }
      let mustBreak = false;
      const innerNotes = (0, utils_1.printInnerComments)(node.notes, Object.assign(Object.assign({}, context), { indent: true }), (note) => {
        mustBreak = note.kind === "line";
        return void 0;
      });
      if (innerNotes !== utils_1.literals.emptytext) {
        parts.push(utils_1.literals.space, innerNotes);
      }
      parts.push(...printAbout(about, context, mustBreak));
      const locale = printLocale(node.locale);
      if (locale) {
        if (parts.length > 0) {
          parts.push((0, utils_1.indent)(mustBreak ? utils_1.hardline : utils_1.line));
        }
        parts.push(locale);
      }
      return [
        (0, utils_1.group)(parts),
        parts.length > 0 ? utils_1.hardline : utils_1.literals.emptytext,
        printBody(node.body, markdown_comments)
      ];
    }
    exports2.printCommentElement = printCommentElement;
    function printDocumentation(node, context) {
      const parts = [
        (0, utils_1.keyword)("doc"),
        (0, utils_1.indent)((0, utils_2.printIdentifiers)(node, context, { leading: utils_1.literals.space }))
      ];
      const inner = (0, utils_1.printInnerComments)(node.notes, Object.assign(Object.assign({}, context), { indent: true }));
      if (inner !== utils_1.literals.emptytext) {
        parts.push(utils_1.line, inner);
      }
      const locale = printLocale(node.locale);
      if (locale) {
        parts.push((0, utils_1.indent)(utils_1.line), locale);
      }
      return [(0, utils_1.group)(parts), utils_1.hardline, printBody(node.body, context.format.markdown_comments)];
    }
    exports2.printDocumentation = printDocumentation;
    function printTextualRepresentation(node, context) {
      var _a;
      const parts = [];
      const { textual_representation_keyword, textual_representation_language_break } = context.format;
      const identifiers = (0, utils_2.printIdentifiers)(node, context, { leading: utils_1.literals.space });
      const cst = (_a = node.cst()) === null || _a === void 0 ? void 0 : _a.text;
      if (identifiers.length > 0 || textual_representation_keyword.default === "always" || textual_representation_keyword.default === "preserve" && (!cst && textual_representation_keyword.fallback === "always" || (cst === null || cst === void 0 ? void 0 : cst.startsWith("rep")))) {
        parts.push((0, utils_1.keyword)("rep"));
        parts.push((0, utils_1.indent)(identifiers));
      }
      const declaration = [
        (0, utils_1.group)(parts),
        (0, utils_1.indent)([
          parts.length > 0 ? textual_representation_language_break === "always" ? utils_1.hardline : utils_1.line : utils_1.literals.emptytext,
          (0, utils_1.keyword)("language "),
          (0, utils_1.text)(JSON.stringify(node.language), { type: semantic_tokens_1.SysMLSemanticTokenTypes.string })
        ])
      ];
      const inner = (0, utils_1.printInnerComments)(node.notes, Object.assign(Object.assign({}, context), { indent: true }));
      if (inner !== utils_1.literals.emptytext) {
        declaration.push(utils_1.line, inner);
      }
      return [
        (0, utils_1.group)(declaration),
        utils_1.hardline,
        // we can't be certain that the code is not whitespace sensitive so
        // preserve all trailing whitespace
        printBody(node.body, true)
      ];
    }
    exports2.printTextualRepresentation = printTextualRepresentation;
    function printMetadataFeature(node, context) {
      const prefixes = (0, utils_1.join)(utils_1.line, (0, namespaces_1.printPrefixes)(node.prefixes, context));
      const prefix = [
        (0, utils_2.formatPreserved)(node, context.format.metadata_feature_keyword, "@", {
          find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "metadata"),
          choose: {
            "@": () => (0, utils_1.text)("@"),
            metadata: () => (0, utils_1.keyword)("metadata "),
            preserve: (found) => found ? "metadata" : "@"
          }
        })
      ];
      const heritage = [];
      const identifier = (0, utils_2.printIdentifiers)(node, context, { trailing: (0, utils_1.indent)(utils_1.line) });
      if (identifier.length > 0) {
        prefix.push(...identifier);
        heritage.push((0, utils_2.formatPreserved)(node, context.format.declaration_feature_typing, "token", {
          find: (node2) => (0, langium_1.findNodeForKeyword)(node2, ":"),
          choose: {
            keyword: () => (0, utils_1.keyword)(context.mode === "kerml" ? "typed by " : "defined by "),
            token: () => (0, utils_1.text)(": "),
            preserve: (found) => found ? "token" : "keyword"
          }
        }));
      }
      const typing = node.specializations(ast_1.FeatureTyping).at(0);
      if (!typing)
        (0, utils_2.throwError)(node, "Invalid MetadataFeature - missing FeatureTyping");
      heritage.push((0, edges_1.printTarget)(typing, context));
      const groups = [];
      if (prefixes.length > 0) {
        groups.push((0, utils_1.indent)((0, utils_1.fill)(prefixes)), utils_1.line);
      }
      groups.push((0, utils_1.group)(prefix), (0, utils_1.indent)((0, utils_1.group)(heritage)));
      return [
        (0, utils_1.group)([
          (0, utils_1.group)(groups),
          ...printAbout(node.annotations().filter((a) => !a.isImplied), context)
        ]),
        (0, namespaces_1.printChildrenBlock)(node, node.children, context, {
          insertSpaceBeforeBrackets: true,
          printer: MetadataBodyElementPrinter
        })
      ];
    }
    exports2.printMetadataFeature = printMetadataFeature;
    var MetadataBodyElementPrinter = (node, context) => {
      if (node.nodeType() !== ast_1.FeatureMembership)
        return (0, print_1.DefaultElementPrinter)(node, context);
      const kw = context.mode === "kerml" ? "feature" : "ref";
      const target = node.element();
      if (!target)
        (0, utils_2.throwError)(node, "Invalid FeatureMembership - missing owned feature");
      const heritage = target.specializations().filter((s) => !s.isImplied);
      const redef = heritage.at(0);
      if ((redef === null || redef === void 0 ? void 0 : redef.nodeType()) !== ast_1.Redefinition)
        (0, utils_2.throwError)(target, "Invalid MetadataFeature body feature - should start with redefinition");
      const relationships = [
        [
          (0, utils_2.formatPreserved)(redef, context.format.metadata_body_feature_redefines, "token", {
            find: (node2) => (0, utils_1.getPreviousNode)(node2, false),
            choose: {
              keyword: () => (0, utils_1.keyword)("redefines "),
              token: () => (0, utils_1.text)(":>> "),
              none: () => utils_1.literals.emptytext,
              preserve: (node2) => {
                if (!node2)
                  return "none";
                if (node2.text === ":>>")
                  return "token";
                return node2.text === "redefines" ? "keyword" : "none";
              }
            }
          }),
          (0, edges_1.printTarget)(redef, context)
        ]
      ];
      relationships.push(...(0, namespaces_1.printDeclaredRelationships)(target, heritage.slice(1), context));
      return [
        (0, utils_1.group)([
          (0, utils_2.formatPreserved)(target, context.format.metadata_body_feature_keyword, "always", {
            find: (node2) => (0, langium_1.findNodeForKeyword)(node2, kw),
            choose: {
              always: () => [(0, utils_1.keyword)(kw), utils_1.literals.space],
              never: () => utils_1.literals.emptytext,
              preserve: (found) => found ? "always" : "never"
            }
          }),
          (0, utils_1.group)((0, utils_1.indent)((0, utils_1.join)(utils_1.line, relationships))),
          target.value ? [utils_1.literals.space, (0, print_1.printModelElement)(target.value, context)] : utils_1.literals.emptytext
        ]),
        (0, namespaces_1.printChildrenBlock)(target, target.children, context, {
          insertSpaceBeforeBrackets: true,
          printer: MetadataBodyElementPrinter
        })
      ];
    };
  }
});

// ../syside-languageserver/lib/model/printer/connectors.js
var require_connectors = __commonJS({
  "../syside-languageserver/lib/model/printer/connectors.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printSuccession = exports2.printInterfaceUsage = exports2.printConnector = exports2.printConnectionUsage = exports2.printBindingConnectorAsUsage = exports2.printBindingConnector = exports2.printAllocationUsage = exports2.printConnectorAsUsage = exports2.printFlowConnectionUsage = exports2.printGenericFlowConnectionUsage = exports2.printItemFlow = exports2.printGenericItemFlow = exports2.printItemFeature = exports2.printKerMLConnector = exports2.printGenericConnector = exports2.printNaryEnds = exports2.printBinaryEnds = exports2.SourceFormatAlways = exports2.printItemFlowEndMember = exports2.printItemFlowEnd = exports2.printConnectorEndMember = exports2.printEndReferenceSubsetting = void 0;
    var utils_1 = require_utils2();
    var print_1 = require_print3();
    var utils_2 = require_utils3();
    var ast2 = __importStar(require_ast2());
    var langium_1 = require_lib2();
    var edges_1 = require_edges();
    var namespaces_1 = require_namespaces();
    var metamodel_1 = require_metamodel();
    var definition_usages_1 = require_definition_usages();
    var actions_1 = require_actions();
    function printEndReferenceSubsetting(node, context, kind = "connector end") {
      const target = node.element();
      if (!target)
        (0, utils_2.throwError)(node, `Invalid ${kind} member - missing target element`);
      const ref = target.specializations(ast2.ReferenceSubsetting).at(0);
      if (!ref)
        (0, utils_2.throwError)(target, `Invalid ${kind} feature - missing reference subsetting`);
      return { target, doc: (0, edges_1.printTarget)(ref, context) };
    }
    exports2.printEndReferenceSubsetting = printEndReferenceSubsetting;
    function printConnectorEndMember(node, context) {
      const { target, doc } = printEndReferenceSubsetting(node, context);
      const parts = [];
      const heritage = [];
      const cross = (0, namespaces_1.printOwnedCrossMultiplicityPart)(target, context);
      if (cross) {
        parts.push(cross);
        parts.push(utils_1.literals.space);
      }
      if (target.declaredName) {
        parts.push((0, utils_2.printIdentifier)(target.declaredName, {
          semantic: context.highlighting ? (0, utils_2.computeHighlighting)(target) : {},
          restricted: context.keywords
        }));
        heritage.push(utils_1.line, (0, utils_2.formatPreserved)(target, context.format.declaration_reference_subsetting, "token", {
          find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "::>"),
          choose: {
            keyword: () => (0, utils_1.keyword)("references "),
            token: () => (0, utils_1.text)("::> "),
            preserve: (found) => found ? "token" : "keyword"
          }
        }));
      }
      heritage.push(doc);
      return [...parts, (0, utils_1.indent)((0, utils_1.group)(heritage))];
    }
    exports2.printConnectorEndMember = printConnectorEndMember;
    function printItemFlowEnd(node, context) {
      var _a;
      const ref = node.specializations(ast2.ReferenceSubsetting).at(0);
      const member = (_a = node.children.find(metamodel_1.BasicMetamodel.is(ast2.FeatureMembership))) === null || _a === void 0 ? void 0 : _a.element();
      if (!member)
        (0, utils_2.throwError)(node, "Invalid item flow end - missing item flow feature member");
      const memberRedef = member.specializations(ast2.Redefinition).find((r) => !r.isImplied);
      if (!memberRedef)
        (0, utils_2.throwError)(member, "Invalid item flow feature member - missing redefinition");
      if (!ref) {
        return (0, edges_1.printTarget)(memberRedef, context);
      }
      return (0, utils_1.appendFill)((0, utils_1.unwrapIndent)((0, edges_1.printTarget)(ref, context)), utils_1.softline, [
        utils_1.literals.dot,
        (0, edges_1.printTarget)(memberRedef, context)
      ]);
    }
    exports2.printItemFlowEnd = printItemFlowEnd;
    function printItemFlowEndMember(node, context) {
      const target = node.element();
      if (!target)
        (0, utils_2.throwError)(node, "Invalid connector end member - missing target element");
      if (!target.is(ast2.ItemFlowEnd))
        (0, utils_2.throwError)(node, `Invalid connector end member - bad target element type (${target.nodeType()}`);
      return printItemFlowEnd(target, context);
    }
    exports2.printItemFlowEndMember = printItemFlowEndMember;
    exports2.SourceFormatAlways = {
      default: "always",
      fallback: "always"
    };
    function printBinaryEnds(node, ends, context, options) {
      var _a;
      const printer = (_a = options.printer) !== null && _a !== void 0 ? _a : printConnectorEndMember;
      const [src, dst] = ends.map((end) => (0, print_1.printModelElement)(end, context, { printer }));
      const format = options.source.format;
      const kw = options.source.keyword;
      const sourceKeyword = format ? (0, utils_2.formatPreserved)(node, format, "always", {
        find: (node2) => (0, langium_1.findNodeForKeyword)(node2, kw),
        choose: {
          always: () => [(0, utils_1.keyword)(kw), utils_1.literals.space],
          as_needed: () => (0, utils_2.hasFeatureDeclaration)(node) ? [(0, utils_1.keyword)(kw), utils_1.literals.space] : [],
          preserve: (found) => found ? "always" : "as_needed"
        }
      }) : [(0, utils_1.keyword)(kw), utils_1.literals.space];
      return (0, utils_1.group)([
        (0, utils_1.group)([...sourceKeyword, (0, utils_1.indent)(src)]),
        (0, utils_1.group)([utils_1.line, options.binding, utils_1.literals.space, (0, utils_1.indent)(dst)])
      ]);
    }
    exports2.printBinaryEnds = printBinaryEnds;
    function printNaryEnds(ends, context, printer = printConnectorEndMember) {
      return (0, utils_1.group)([
        utils_1.brackets.round.open,
        (0, utils_1.indent)([
          utils_1.softline,
          (0, utils_1.join)([utils_1.literals.comma, utils_1.line], (0, print_1.printModelElements)(ends, context, { printer }))
        ]),
        utils_1.softline,
        utils_1.brackets.round.close
      ]);
    }
    exports2.printNaryEnds = printNaryEnds;
    function printGenericConnector(modifiers, kw, crossFeature, node, context, options) {
      var _a;
      const ends = (_a = options.ends) !== null && _a !== void 0 ? _a : node.ends;
      const suffix = options.suffix;
      const push_suffix = (decl) => {
        if (!suffix) {
          return;
        }
        typeof suffix == "function" ? suffix(decl) : decl.push(suffix);
      };
      if (ends.length === 0) {
        return (0, namespaces_1.printGenericFeature)(modifiers, kw, crossFeature, node, context, {
          appendToDeclaration: push_suffix
        });
      }
      if (ends.length === 1)
        (0, utils_2.throwError)(node, `Invalid ${node.nodeType()} - must have at least 2 ends`);
      const printNary = () => {
        return (0, namespaces_1.printGenericFeature)(modifiers, kw, crossFeature, node, context, {
          appendToDeclaration(decl) {
            push_suffix(decl);
            const linebreak = (0, utils_1.indent)((0, utils_1.group)(utils_1.line, { id: "nary-ends" }));
            if (decl.length > 0)
              decl.push(options.naryPrefix ? utils_1.literals.space : linebreak);
            if (options.naryPrefix)
              decl.push(options.naryPrefix, linebreak);
            decl.push((0, utils_1.indentIfBreak)(printNaryEnds(ends, context, options.printer), {
              groupId: "nary-ends"
            }));
          },
          join: options.join
        });
      };
      const printBinary = () => {
        return (0, namespaces_1.printGenericFeature)(modifiers, kw, crossFeature, node, context, {
          appendToDeclaration(decl) {
            push_suffix(decl);
            if (decl.length > 0)
              decl.push((0, utils_1.indent)(utils_1.line));
            decl.push((0, utils_1.indent)(printBinaryEnds(node, ends, context, options)));
          },
          join: options.join
        });
      };
      if (options.format === "binary")
        return printBinary();
      if (options.format === "nary")
        return printNary();
      if (ends.length > 2)
        return printNary();
      return (0, utils_2.formatPreserved)(node, options.format, "always", {
        find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "("),
        choose: {
          always: printBinary,
          never: printNary,
          preserve: (found) => found ? "never" : "always"
        }
      });
    }
    exports2.printGenericConnector = printGenericConnector;
    function printKerMLConnector(kw, node, context, options) {
      return printGenericConnector((0, namespaces_1.kermlFeatureModifiers)(node), node.isSufficient ? `${kw} all` : kw, (0, namespaces_1.printKerMLOwnedCrossFeature)(node, context), node, context, options);
    }
    exports2.printKerMLConnector = printKerMLConnector;
    function printItemFeature(node, context) {
      const parts = (0, utils_2.printIdentifiers)(node, context);
      const specialization = (0, namespaces_1.printSpecializationPart)(node, context, {
        skipFirstKeyword: (
          // shorthand requires no identifiers
          parts.length === 0 && // shorthand requires no feature value
          !node.value && // shorthand requires a single specialization
          node.specializations().reduce((count, s) => s.isImplied ? count : count + 1, 0) === 1 && // shorthand requires a single feature typing
          node.specializations(ast2.FeatureTyping).filter((s) => !s.isImplied).length === 1
        ),
        specializations: (0, namespaces_1.defaultSpecializationGrouper)(context)
      });
      if (specialization.length > 0) {
        if (parts.length > 0)
          parts.push((0, utils_1.indent)(utils_1.line));
        parts.push(...specialization);
      }
      if (node.value) {
        parts.push(utils_1.literals.space, (0, print_1.printModelElement)(node.value, context));
      }
      return (0, utils_1.group)(parts);
    }
    exports2.printItemFeature = printItemFeature;
    function printGenericItemFlow(modifiers, kw, crossFeature, node, context, options) {
      const { printer = printItemFlowEndMember } = options;
      const suffix = [];
      if (node.value)
        suffix.push((0, utils_1.indent)([utils_1.literals.space, (0, print_1.printModelElement)(node.value, context)]));
      if (node.item) {
        suffix.push((0, utils_1.indent)([utils_1.line, (0, utils_1.keyword)("of "), (0, print_1.printModelElement)(node.item, context)]));
      }
      return printGenericConnector(modifiers, kw, crossFeature, node, context, {
        format: "binary",
        binding: (0, utils_1.keyword)("to"),
        printer,
        ends: options.ends,
        source: {
          keyword: "from",
          format: options.sourceFormat
        },
        suffix: suffix.length > 0 ? suffix.map((doc) => (0, utils_1.group)(doc)) : void 0,
        join: options.join
      });
    }
    exports2.printGenericItemFlow = printGenericItemFlow;
    function printItemFlow(kw, node, context, options) {
      return printGenericItemFlow((0, namespaces_1.kermlFeatureModifiers)(node), kw, (0, namespaces_1.printKerMLOwnedCrossFeature)(node, context), node, context, options);
    }
    exports2.printItemFlow = printItemFlow;
    function printGenericFlowConnectionUsage(kw, node, context, options) {
      return printGenericItemFlow((0, definition_usages_1.occurrenceUsageModifiers)(node, (0, utils_2.shouldIgnoreRef)(node, context.format.connection_usage_reference_keyword)), kw, (0, definition_usages_1.printSysmlOwnedCrossFeature)(node, context), node, context, Object.assign(Object.assign({}, options), { join: (0, actions_1.actionBodyJoiner)() }));
    }
    exports2.printGenericFlowConnectionUsage = printGenericFlowConnectionUsage;
    function printFlowConnectionUsage(node, context) {
      const cst = node.cst();
      const isMessage = node.isMessageConnection || node.ends.length === 0 && cst && (0, langium_1.findNodeForKeyword)(cst, "message");
      if (isMessage)
        return printGenericFlowConnectionUsage("message", node, context, {
          printer(node2, context2) {
            return printEndReferenceSubsetting(node2, context2).doc;
          },
          ends: node.messages,
          sourceFormat: context.format.flow_connection_usage_from_keyword
        });
      return printGenericFlowConnectionUsage("flow", node, context, {
        sourceFormat: context.format.flow_connection_usage_from_keyword
      });
    }
    exports2.printFlowConnectionUsage = printFlowConnectionUsage;
    function printConnectorAsUsage(kw, node, context, options) {
      return printGenericConnector((0, definition_usages_1.sysmlUsageModifiers)(node, (0, utils_2.shouldIgnoreRef)(node, context.format.connector_as_usage_reference_keyword)), kw, (0, definition_usages_1.printSysmlOwnedCrossFeature)(node, context), node, context, Object.assign(Object.assign({}, options), { join: (0, actions_1.actionBodyJoiner)() }));
    }
    exports2.printConnectorAsUsage = printConnectorAsUsage;
    function printAllocationUsage(node, context) {
      return printConnectorAsUsage((0, utils_2.selectDeclarationKeyword)(node, "allocation", context.format.allocation_usage_keyword), node, context, {
        binding: (0, utils_1.keyword)("to"),
        format: context.format.binary_allocation_usages,
        naryPrefix: (0, utils_1.keyword)("allocate"),
        source: {
          keyword: "allocate",
          format: exports2.SourceFormatAlways
        },
        printer: printConnectorEndMember
      });
    }
    exports2.printAllocationUsage = printAllocationUsage;
    function printBindingConnector(node, context) {
      return printKerMLConnector("binding", node, context, {
        format: context.format.binary_binding_connectors,
        binding: (0, utils_1.text)("="),
        printer: printConnectorEndMember,
        source: {
          keyword: "of",
          format: context.format.binary_binding_connector_of_keyword
        },
        suffix: void 0
      });
    }
    exports2.printBindingConnector = printBindingConnector;
    function printBindingConnectorAsUsage(node, context) {
      return printConnectorAsUsage((0, utils_2.selectDeclarationKeyword)(node, "binding", context.format.binding_connector_as_usage_keyword), node, context, {
        format: "binary",
        binding: (0, utils_1.text)("="),
        printer: printConnectorEndMember,
        source: {
          keyword: "bind",
          format: exports2.SourceFormatAlways
        },
        suffix: void 0
      });
    }
    exports2.printBindingConnectorAsUsage = printBindingConnectorAsUsage;
    function printConnectionUsage(node, context) {
      return printConnectorAsUsage((0, utils_2.selectDeclarationKeyword)(node, "connection", context.format.connection_usage_keyword), node, context, {
        binding: (0, utils_1.keyword)("to"),
        format: context.format.binary_connection_usages,
        naryPrefix: (0, utils_1.keyword)("connect"),
        source: {
          keyword: "connect",
          format: exports2.SourceFormatAlways
        },
        printer: printConnectorEndMember,
        suffix: node.value ? (0, namespaces_1.featureValueAppender)(node, context) : void 0
      });
    }
    exports2.printConnectionUsage = printConnectionUsage;
    function printConnector(node, context) {
      return printKerMLConnector("connector", node, context, {
        format: context.format.binary_connectors,
        binding: (0, utils_1.text)("to"),
        printer: printConnectorEndMember,
        source: {
          keyword: "from",
          format: context.format.binary_connectors_from_keyword
        },
        suffix: node.value ? (0, namespaces_1.featureValueAppender)(node, context) : void 0
      });
    }
    exports2.printConnector = printConnector;
    function printInterfaceUsage(node, context) {
      const connect = (0, utils_2.selectDeclarationKeyword)(node, "connect", context.format.interface_usage_connect_keyword);
      return printConnectorAsUsage("interface", node, context, {
        binding: (0, utils_1.keyword)("to"),
        format: context.format.binary_interface_usages,
        naryPrefix: connect ? (0, utils_1.keyword)(connect) : void 0,
        source: {
          keyword: "connect",
          format: context.format.interface_usage_connect_keyword
        },
        printer: printConnectorEndMember
      });
    }
    exports2.printInterfaceUsage = printInterfaceUsage;
    function printSuccession(node, context) {
      return printKerMLConnector("succession", node, context, {
        format: context.format.binary_successions,
        binding: (0, utils_1.text)("then"),
        printer: printConnectorEndMember,
        source: {
          keyword: "first",
          format: context.format.binary_succession_first_keyword
        },
        suffix: void 0
      });
    }
    exports2.printSuccession = printSuccession;
  }
});

// ../syside-languageserver/lib/model/printer/successions.js
var require_successions = __commonJS({
  "../syside-languageserver/lib/model/printer/successions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printTransitionUsage = exports2.printSuccessionAsUsage = exports2.successionAsUsageKind = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var actions_1 = require_actions();
    var connectors_1 = require_connectors();
    var edges_1 = require_edges();
    var namespaces_1 = require_namespaces();
    var print_1 = require_print3();
    var utils_2 = require_utils3();
    var isExplicitConnectorEnd = (end) => {
      var _a;
      return Boolean((_a = end.element()) === null || _a === void 0 ? void 0 : _a.specializations().some((s) => !s.isImplied));
    };
    function successionAsUsageKind(node, previousSibling) {
      if ((previousSibling === null || previousSibling === void 0 ? void 0 : previousSibling.is(ast_1.StateSubactionMembership)) && previousSibling.kind === "entry") {
        return node.ends.some(isExplicitConnectorEnd) ? "transition" : "empty";
      }
      const ends = node.ends;
      switch (ends.length) {
        case 1: {
          return isExplicitConnectorEnd(ends[0]) ? "target" : "empty";
        }
        case 0: {
          return "empty";
        }
        default: {
          if (ends.every(isExplicitConnectorEnd)) {
            return "regular";
          }
          if (isExplicitConnectorEnd(ends[1])) {
            return "target";
          }
          return "empty";
        }
      }
    }
    exports2.successionAsUsageKind = successionAsUsageKind;
    function printMultiplicitySourceEnd(node, context) {
      var _a, _b, _c, _d;
      const range = (_d = (_c = (_b = (_a = node.ends[0].element()) === null || _a === void 0 ? void 0 : _a.multiplicity) === null || _b === void 0 ? void 0 : _b.element()) === null || _c === void 0 ? void 0 : _c.range) === null || _d === void 0 ? void 0 : _d.element();
      if (!range)
        return void 0;
      return (0, utils_1.group)((0, utils_2.printDescendant)(node, context, "empty succession").descend((node2) => node2.ends[0]).descend((node2) => node2.element()).descend((node2) => node2.multiplicity).descend((node2) => node2.element()).descend((node2) => node2.range).descend((node2) => node2.element()).print({
        printer(range2, context2) {
          return (0, namespaces_1.printDeclaredMultiplicityRange)(range2, context2);
        }
      }));
    }
    function printEmptySuccessionAsUsage(node, context) {
      const src = printMultiplicitySourceEnd(node, context);
      if (!src)
        return (0, utils_1.keyword)("then");
      return [(0, utils_1.keyword)("then "), src];
    }
    function printTargetSuccession(node, context) {
      const parts = [];
      const src = printMultiplicitySourceEnd(node, context);
      if (src) {
        parts.push(src);
        parts.push(utils_1.literals.space);
      }
      parts.push((0, utils_1.keyword)("then "));
      parts.push((0, connectors_1.printConnectorEndMember)(node.ends[node.ends.length - 1], context));
      parts.push((0, namespaces_1.printChildrenBlock)(node, node.children, context, {
        insertSpaceBeforeBrackets: true,
        join: (0, actions_1.actionBodyJoiner)()
      }));
      return parts;
    }
    function printRegularSuccession(node, context) {
      return (0, connectors_1.printConnectorAsUsage)((0, utils_2.selectDeclarationKeyword)(node, "succession", context.format.succession_as_usage_keyword), node, context, {
        binding: (0, utils_1.keyword)("then"),
        format: "binary",
        source: {
          keyword: "first",
          format: connectors_1.SourceFormatAlways
        },
        printer: connectors_1.printConnectorEndMember
      });
    }
    function printSuccessionAfterEntry(node, context) {
      if (!isExplicitConnectorEnd(node.ends[node.ends.length - 1]))
        return printEmptySuccessionAsUsage(node, context);
      return [
        printEmptySuccessionAsUsage(node, context),
        utils_1.literals.space,
        (0, connectors_1.printConnectorEndMember)(node.ends[node.ends.length - 1], context),
        utils_1.literals.semicolon
      ];
    }
    function printSuccessionAsUsage(node, context, previousSibling) {
      switch (successionAsUsageKind(node, previousSibling)) {
        case "target":
          return printTargetSuccession(node, context);
        case "empty":
          return printEmptySuccessionAsUsage(node, context);
        case "regular":
          return printRegularSuccession(node, context);
        case "transition":
          return printSuccessionAfterEntry(node, context);
      }
    }
    exports2.printSuccessionAsUsage = printSuccessionAsUsage;
    function printAccepter(node, context) {
      return (0, print_1.printModelElement)(node, context, {
        printer: (node2, context2) => (0, utils_1.group)([
          (0, utils_1.keyword)("accept "),
          (0, utils_1.indent)((0, actions_1.printAccepterParameterPart)(node2.element(), context2))
        ])
      });
    }
    function printGuard(node, context) {
      return (0, print_1.printModelElement)(node, context, {
        printer: (node2, context2) => (0, utils_1.group)((0, actions_1.printCondition)((0, utils_1.keyword)("if"), node2, context2, context2.format.transition_usage_parenthesize_guard))
      });
    }
    function printEffect(node, context) {
      return (0, print_1.printModelElement)(node, context, {
        printer: (node2, context2) => {
          const decl = (0, actions_1.printSubaction)(node2.element(), context2, utils_1.literals.emptytext);
          if (decl === utils_1.literals.emptytext)
            return (0, utils_1.keyword)("do");
          return (0, utils_1.group)([(0, utils_1.keyword)("do "), decl]);
        }
      });
    }
    function printThenElse(kw, node, context) {
      return (0, print_1.printModelElement)(node, context, {
        printer: (node2, context2) => (0, utils_1.group)([
          (0, utils_1.keyword)(kw),
          utils_1.literals.space,
          printTransitionSuccession(node2.element(), context2)
        ])
      });
    }
    function printSource(node, context) {
      if (node.nodeType() === ast_1.Membership)
        return (0, edges_1.printAsTarget)(node, context);
      return (0, print_1.printModelElement)(node, context, {
        printer: (node2, context2) => (0, edges_1.printChaining)(node2.element(), context2)
      });
    }
    function printTransitionSuccession(node, context) {
      return (0, print_1.printModelElement)(node, context, {
        printer: (node2, context2) => (0, connectors_1.printConnectorEndMember)(node2.ends[1], context2)
      });
    }
    function transitionUsageKind(node, previousSibling) {
      var _a;
      if (node.else)
        return "default-target";
      if ((_a = node.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast_1.StateUsage, ast_1.StateDefinition)) {
        if (node.source)
          return "transition";
        if (node.accepter || node.effect)
          return "target-transition";
        if ((previousSibling === null || previousSibling === void 0 ? void 0 : previousSibling.is(ast_1.StateSubactionMembership)) && previousSibling.kind === "entry" && node.guard)
          return "guarded-target";
        return "target-transition";
      }
      return node.source ? "guarded-succession" : "guarded-target";
    }
    function printDefaultTargetSuccession(node, context) {
      (0, utils_2.assertMember)(node, node.else, "default target succession", "else");
      return [
        printThenElse("else", node.else, context),
        (0, namespaces_1.printChildrenBlock)(node, node.children, context, {
          insertSpaceBeforeBrackets: true,
          join: (0, actions_1.actionBodyJoiner)()
        })
      ];
    }
    function printGuardedTargetSuccession(node, context) {
      var _a;
      (0, utils_2.assertMember)(node, node.guard, "guarded target succession", "guard");
      (0, utils_2.assertMember)(node, node.then, "guarded target succession", "then");
      const parts = [
        (0, utils_1.group)([
          printGuard(node.guard, context),
          (0, utils_1.indent)([utils_1.line, printThenElse("then", node.then, context)])
        ])
      ];
      if ((_a = node.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast_1.StateDefinition, ast_1.StateUsage)) {
        parts.push(utils_1.literals.semicolon);
      } else {
        parts.push((0, namespaces_1.printChildrenBlock)(node, node.children, context, {
          insertSpaceBeforeBrackets: true,
          join: (0, actions_1.actionBodyJoiner)()
        }));
      }
      return parts;
    }
    function printGuardedSuccession(node, context) {
      (0, utils_2.assertMember)(node, node.source, "guarded succession", "source");
      (0, utils_2.assertMember)(node, node.guard, "guarded succession", "guard");
      (0, utils_2.assertMember)(node, node.then, "guarded succession", "then");
      const suffix = [
        (0, utils_1.group)([(0, utils_1.keyword)("first "), (0, utils_1.indent)(printSource(node.source, context))]),
        utils_1.line,
        (0, utils_1.group)([
          printGuard(node.guard, context),
          (0, utils_1.indent)([utils_1.line, printThenElse("then", node.then, context)])
        ])
      ];
      return (0, namespaces_1.printGenericFeature)([], (0, utils_2.hasFeatureDeclaration)(node) ? "succession" : void 0, void 0, node, context, {
        appendToDeclaration(decl) {
          if (decl.length > 0)
            decl.push((0, utils_1.indent)(utils_1.line));
          decl.push((0, utils_1.indent)((0, utils_1.group)(suffix)));
        },
        join: (0, actions_1.actionBodyJoiner)()
      });
    }
    function printDefaultTransitionUsage(node, context) {
      (0, utils_2.assertMember)(node, node.then, "transition usage", "then");
      const parts = [];
      const accepter = node.accepter ? (0, utils_1.group)(printAccepter(node.accepter, context)) : void 0;
      let guard = node.guard ? (0, utils_1.group)(printGuard(node.guard, context)) : void 0;
      let effect = node.effect ? (0, utils_1.group)(printEffect(node.effect, context)) : void 0;
      let then = (0, utils_1.group)(printThenElse("then", node.then, context));
      if (accepter)
        parts.push(accepter);
      if (guard) {
        if (effect) {
          guard = (0, utils_1.group)([guard, (0, utils_1.indent)([utils_1.line, effect])]);
          effect = void 0;
        } else {
          guard = (0, utils_1.group)([guard, (0, utils_1.indent)([utils_1.line, then])]);
          then = void 0;
        }
        parts.push(guard);
      }
      if (effect)
        parts.push(effect);
      if (then)
        parts.push(then);
      const suffix = parts.map((part, i) => (0, utils_1.indent)(i === 0 ? part : [utils_1.line, part]));
      if (node.source) {
        const first = (0, utils_2.selectDeclarationKeyword)(node, "first", context.format.transition_usage_first_keyword);
        let source = printSource(node.source, context);
        if (first)
          source = (0, utils_1.group)((0, utils_1.indent)([(0, utils_1.keyword)(first), utils_1.literals.space, (0, utils_1.indent)(source)]));
        else
          source = (0, utils_1.indent)(source);
        return (0, namespaces_1.printGenericFeature)([], "transition", void 0, node, context, {
          appendToDeclaration(decl2) {
            decl2.push((0, utils_1.indent)(utils_1.line), (0, utils_1.group)([source, (0, utils_1.indent)(utils_1.line), suffix]));
          },
          join: (0, actions_1.actionBodyJoiner)()
        });
      }
      const kw = node.effect && !node.guard && !node.accepter ? "transition" : (0, utils_2.formatPreserved)(node, context.format.transition_usage_keyword, "always", {
        find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "transition"),
        choose: {
          always: () => "transition",
          as_needed: () => void 0,
          preserve: (found) => found ? "always" : "as_needed"
        }
      });
      const decl = [];
      if (kw)
        decl.push((0, utils_1.keyword)(kw), (0, utils_1.indent)(utils_1.line));
      decl.push((0, utils_1.group)(suffix));
      return [
        (0, utils_1.group)(decl),
        (0, namespaces_1.printChildrenBlock)(node, node.children, context, {
          insertSpaceBeforeBrackets: true,
          join: (0, actions_1.actionBodyJoiner)()
        })
      ];
    }
    function printTransitionUsage(node, context, previousSibling) {
      switch (transitionUsageKind(node, previousSibling)) {
        case "default-target":
          return printDefaultTargetSuccession(node, context);
        case "guarded-target":
          return printGuardedTargetSuccession(node, context);
        case "guarded-succession":
          return printGuardedSuccession(node, context);
        case "transition":
        case "target-transition":
          return printDefaultTransitionUsage(node, context);
      }
    }
    exports2.printTransitionUsage = printTransitionUsage;
  }
});

// ../syside-languageserver/lib/model/printer/print.js
var require_print3 = __commonJS({
  "../syside-languageserver/lib/model/printer/print.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printModelRange = exports2.printElementIgnored = exports2.collectUnprintedNotes = exports2.printModelElements = exports2.printModelElement = exports2.printModelReference = exports2.DefaultElementPrinter = exports2.defaultPrintNotes = exports2.defaultSysMLPrinterContext = exports2.defaultKerMLPrinterContext = exports2.assertKerML = exports2.assertSysML = void 0;
    var utils_1 = require_utils2();
    var ast2 = __importStar(require_ast2());
    var vscode_languageserver_1 = require_main4();
    var format_options_1 = require_format_options();
    var expr = __importStar(require_expressions4());
    var edges = __importStar(require_edges());
    var utils_2 = require_utils3();
    var assert_1 = __importDefault(require("assert"));
    var annotating_elements_1 = require_annotating_elements();
    var nss = __importStar(require_namespaces());
    var connectors = __importStar(require_connectors());
    var sysml = __importStar(require_definition_usages());
    var actions = __importStar(require_actions());
    var successions = __importStar(require_successions());
    function assertSysML(context, type) {
      (0, assert_1.default)(context.mode === "sysml", `${type} can only be printed in SysML mode`);
    }
    exports2.assertSysML = assertSysML;
    function assertKerML(context, type) {
      (0, assert_1.default)(context.mode === "kerml", `${type} can only be printed in KerML mode`);
    }
    exports2.assertKerML = assertKerML;
    function defaultKerMLPrinterContext(options = {}) {
      var _a;
      return {
        mode: "kerml",
        keywords: (0, utils_2.KerMLKeywords)(),
        format: (_a = options.format) !== null && _a !== void 0 ? _a : format_options_1.DefaultFormatOptions,
        referencePrinter: function() {
          throw new Error("Programmatic reference printing is not implemented.");
        },
        printComment: utils_1.printKerMLNote,
        printed: /* @__PURE__ */ new Set(),
        highlighting: Boolean(options.highlighting),
        forceFormatting: Boolean(options.forceFormatting)
      };
    }
    exports2.defaultKerMLPrinterContext = defaultKerMLPrinterContext;
    function defaultSysMLPrinterContext(options = {}) {
      return Object.assign(Object.assign({}, defaultKerMLPrinterContext(options)), { keywords: (0, utils_2.SysMLKeywords)(), mode: "sysml" });
    }
    exports2.defaultSysMLPrinterContext = defaultSysMLPrinterContext;
    var abstractElement = (node) => (0, utils_2.throwError)(node, `Cannot print abstract element with type ${node.nodeType()}`);
    var typeUnion = (node) => (0, utils_2.throwError)(node, `Cannot print type union ${node.nodeType()}`);
    var directPrint = (node) => (0, utils_2.throwError)(node, `Cannot print element with  type ${node.nodeType()} directly`);
    var ModelPrinter = {
      // Expressions
      [ast2.CollectExpression](node, context) {
        return expr.printOperatorExpression(node, context);
      },
      [ast2.FeatureChainExpression](node, context) {
        return expr.printOperatorExpression(node, context);
      },
      [ast2.FeatureReferenceExpression](node, context) {
        return expr.printFeatureReferenceExpression(node, context);
      },
      [ast2.IndexExpression](node, context) {
        return expr.printOperatorExpression(node, context);
      },
      [ast2.InvocationExpression](node, context) {
        return expr.printInvocationExpr(node, context);
      },
      [ast2.MetadataAccessExpression](node, context) {
        return expr.printMetadataAccessExpression(node, context);
      },
      [ast2.OperatorExpression](node, context) {
        return expr.printOperatorExpression(node, context);
      },
      [ast2.SelectExpression](node, context) {
        return expr.printOperatorExpression(node, context);
      },
      [ast2.TriggerInvocationExpression](node, context) {
        return expr.printTriggerInvocationExpression(node, context);
      },
      [ast2.LiteralBoolean](node) {
        return node.literal ? utils_1.literals.true : utils_1.literals.false;
      },
      [ast2.LiteralInfinity]() {
        return (0, utils_1.text)("*");
      },
      [ast2.LiteralNumber](node, context) {
        return expr.printLiteralNumber(node, context);
      },
      [ast2.LiteralString](node) {
        return (0, utils_1.text)(JSON.stringify(node.literal), { type: vscode_languageserver_1.SemanticTokenTypes.string });
      },
      [ast2.NullExpression](node, context) {
        return expr.printNullExpression(node, context);
      },
      // Memberships
      [ast2.ActorMembership](node, context, previousSibling) {
        return edges.printActorMembership(node, context, previousSibling);
      },
      [ast2.ElementFilterMembership](node, context) {
        return edges.printElementFilterMembership(node, context);
      },
      [ast2.FeatureMembership](node, context, previousSibling) {
        return edges.printGenericMembership(void 0, node, context, { previousSibling });
      },
      [ast2.FramedConcernMembership](node, context, previousSibling) {
        return edges.printFramedConcernMembership(node, context, previousSibling);
      },
      [ast2.Membership](node, context, previousSibling) {
        return edges.printMembership(node, context, { previousSibling });
      },
      [ast2.ObjectiveMembership](node, context, previousSibling) {
        return edges.printObjectiveMembership(node, context, previousSibling);
      },
      [ast2.OwningMembership](node, context, previousSibling) {
        return edges.printOwningMembership(node, context, previousSibling);
      },
      [ast2.RequirementConstraintMembership](node, context, previousSibling) {
        return edges.printRequirementConstraintMembership(node, context, previousSibling);
      },
      [ast2.RequirementVerificationMembership](node, context, previousSibling) {
        return edges.printRequirementVerificationMembership(node, context, previousSibling);
      },
      [ast2.ResultExpressionMembership](node, context, previousSibling) {
        return edges.printGenericMembership(void 0, node, context, { previousSibling });
      },
      [ast2.ReturnParameterMembership](node, context, previousSibling) {
        return edges.printGenericMembership("return", node, context, { previousSibling });
      },
      [ast2.StakeholderMembership](node, context, previousSibling) {
        return edges.printStakeholderMembership(node, context, previousSibling);
      },
      [ast2.StateSubactionMembership](node, context) {
        return actions.printStateSubactionMembership(node, context);
      },
      [ast2.SubjectMembership](node, context, previousSibling) {
        return edges.printSubjectMembership(node, context, previousSibling);
      },
      [ast2.VariantMembership](node, context, previousSibling) {
        return edges.printVariantMembership(node, context, previousSibling);
      },
      [ast2.ViewRenderingMembership](node, context, previousSibling) {
        return edges.printViewRenderingMembership(node, context, previousSibling);
      },
      // Other Relationships
      [ast2.Annotation](node, context) {
        const source = node.source();
        if ((source === null || source === void 0 ? void 0 : source.parent()) === node)
          return printModelElement(source, context);
        return edges.printTarget(node, context);
      },
      [ast2.Conjugation](node, context) {
        return edges.printConjugation(node, context);
      },
      [ast2.Dependency](node, context) {
        return edges.printDependency(node, context);
      },
      [ast2.Disjoining](node, context) {
        return edges.printDisjoining(node, context);
      },
      [ast2.FeatureInverting](node, context) {
        return edges.printFeatureInverting(node, context);
      },
      [ast2.FeatureTyping](node, context) {
        return edges.printFeatureTyping(node, context);
      },
      [ast2.FeatureValue](node, context) {
        return edges.printFeatureValue(node, context);
      },
      [ast2.NamespaceExpose](node, context) {
        assertSysML(context, node.nodeType());
        return edges.printNamespaceImport("expose", node, context);
      },
      [ast2.NamespaceImport](node, context) {
        return edges.printNamespaceImport(node.importsAll ? "import all" : "import", node, context);
      },
      [ast2.MembershipExpose](node, context) {
        assertSysML(context, node.nodeType());
        return edges.printMembershipImport("expose", node, context);
      },
      [ast2.MembershipImport](node, context) {
        return edges.printMembershipImport(node.importsAll ? "import all" : "import", node, context);
      },
      [ast2.Redefinition](node, context) {
        return edges.printRedefinition(node, context);
      },
      [ast2.Specialization](node, context) {
        return edges.printSpecialization(node, context);
      },
      [ast2.Subclassification](node, context) {
        return edges.printSubclassification(node, context);
      },
      [ast2.Subsetting](node, context) {
        return edges.printSubsetting(node, context);
      },
      [ast2.TypeFeaturing](node, context) {
        return edges.printTypeFeaturing(node, context);
      },
      // Annotating Elements
      [ast2.Comment]: annotating_elements_1.printCommentElement,
      [ast2.Documentation]: annotating_elements_1.printDocumentation,
      [ast2.MetadataFeature]: annotating_elements_1.printMetadataFeature,
      [ast2.TextualRepresentation]: annotating_elements_1.printTextualRepresentation,
      // Connectors
      [ast2.AllocationUsage](node, context) {
        return connectors.printAllocationUsage(node, context);
      },
      [ast2.BindingConnector](node, context) {
        return connectors.printBindingConnector(node, context);
      },
      [ast2.BindingConnectorAsUsage](node, context) {
        return connectors.printBindingConnectorAsUsage(node, context);
      },
      [ast2.ConnectionUsage](node, context) {
        return connectors.printConnectionUsage(node, context);
      },
      [ast2.Connector](node, context) {
        return connectors.printConnector(node, context);
      },
      [ast2.FlowConnectionUsage](node, context) {
        return connectors.printFlowConnectionUsage(node, context);
      },
      [ast2.ItemFlow](node, context) {
        return connectors.printItemFlow("flow", node, context, {
          sourceFormat: context.format.item_flow_from_keyword
        });
      },
      [ast2.ItemFlowEnd](node, context) {
        return connectors.printItemFlowEnd(node, context);
      },
      [ast2.ItemFeature](node, context) {
        return connectors.printItemFeature(node, context);
      },
      [ast2.Succession](node, context) {
        return connectors.printSuccession(node, context);
      },
      [ast2.SuccessionAsUsage](node, context, previousSibling) {
        return successions.printSuccessionAsUsage(node, context, previousSibling);
      },
      [ast2.SuccessionFlowConnectionUsage](node, context) {
        return connectors.printGenericFlowConnectionUsage("succession flow", node, context, {
          sourceFormat: context.format.succession_flow_connection_usage_from_keyword
        });
      },
      [ast2.SuccessionItemFlow](node, context) {
        return connectors.printItemFlow("succession flow", node, context, {
          sourceFormat: context.format.item_flow_from_keyword
        });
      },
      [ast2.TransitionUsage](node, context, previousSibling) {
        return successions.printTransitionUsage(node, context, previousSibling);
      },
      [ast2.InterfaceUsage](node, context) {
        return connectors.printInterfaceUsage(node, context);
      },
      // KerML
      [ast2.Association](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printType("auto", "assoc", node, context);
      },
      [ast2.AssociationStructure](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printType("auto", "assoc struct", node, context);
      },
      [ast2.Behavior](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printType("auto", "behavior", node, context);
      },
      [ast2.BooleanExpression](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printKerMLFeature("bool", node, context);
      },
      [ast2.Class](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printType("auto", "class", node, context);
      },
      [ast2.Classifier](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printType("auto", "classifier", node, context);
      },
      [ast2.DataType](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printType("auto", "datatype", node, context);
      },
      [ast2.Expression](node, context) {
        return expr.printExpression(node, context);
      },
      [ast2.Feature](node, context) {
        return nss.printFeature(node, context);
      },
      [ast2.Interaction](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printType("auto", "interaction", node, context);
      },
      [ast2.Invariant](node, context) {
        return nss.printInvariant(node, context);
      },
      [ast2.LibraryPackage](node, context) {
        return nss.printNonTypeNamespace(node.isStandard ? "standard library" : "library", "package", node, context);
      },
      [ast2.Metaclass](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printType("auto", "metaclass", node, context);
      },
      [ast2.Multiplicity](node, context) {
        return nss.printMultiplicity(node, context);
      },
      [ast2.MultiplicityRange](node, context) {
        return nss.printMultiplicityRange(node, context);
      },
      [ast2.Namespace](node, context) {
        return nss.printNamespace(node, context);
      },
      [ast2.Package](node, context) {
        return nss.printNonTypeNamespace(void 0, "package", node, context);
      },
      [ast2.Predicate](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printType("auto", "predicate", node, context);
      },
      [ast2.Step](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printKerMLFeature("step", node, context);
      },
      [ast2.Structure](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printType("auto", "struct", node, context);
      },
      [ast2.SysMLFunction](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printType("auto", "function", node, context);
      },
      [ast2.Type](node, context) {
        assertKerML(context, node.nodeType());
        return nss.printType("auto", "type", node, context);
      },
      // SysML
      [ast2.AcceptActionUsage](node, context) {
        return actions.printAcceptActionUsage(node, context);
      },
      [ast2.ActionDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "action def", node, context, {
          join: actions.actionBodyJoiner()
        });
      },
      [ast2.ActionUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "action", node, context, {
          join: actions.actionBodyJoiner()
        });
      },
      [ast2.AllocationDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "allocation def", node, context);
      },
      [ast2.AnalysisCaseDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "analysis def", node, context);
      },
      [ast2.AnalysisCaseUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "analysis", node, context);
      },
      [ast2.AssertConstraintUsage](node, context) {
        return sysml.printAssertConstraint(node, context);
      },
      [ast2.AssignmentActionUsage](node, context) {
        return actions.printAssignmentAction(node, context);
      },
      [ast2.AttributeDefinition](node, context) {
        return sysml.printGenericDefinition("auto", "attribute def", node, context);
      },
      [ast2.AttributeUsage](node, context) {
        return sysml.printAttributeUsage(node, context);
      },
      [ast2.CalculationDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "calc def", node, context);
      },
      [ast2.CalculationUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "calc", node, context);
      },
      [ast2.CaseDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "case def", node, context);
      },
      [ast2.CaseUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "case", node, context);
      },
      [ast2.ConcernDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "concern def", node, context);
      },
      [ast2.ConcernUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "concern", node, context);
      },
      [ast2.ConnectionDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "connection def", node, context);
      },
      [ast2.ConstraintDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "constraint def", node, context);
      },
      [ast2.ConstraintUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "constraint", node, context);
      },
      [ast2.Definition](node, context) {
        return sysml.printGenericDefinition("auto", "def", node, context);
      },
      [ast2.EnumerationDefinition](node, context) {
        return sysml.printGenericDefinition([], "enum def", node, context);
      },
      [ast2.EnumerationUsage](node, context) {
        return sysml.printEnumerationUsage(node, context);
      },
      [ast2.EventOccurrenceUsage](node, context) {
        return sysml.printEventOccurrence(node, context);
      },
      [ast2.ExhibitStateUsage](node, context) {
        return sysml.printExhibitState(node, context);
      },
      [ast2.FlowConnectionDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "flow def", node, context);
      },
      [ast2.IncludeUseCaseUsage](node, context) {
        return sysml.printIncludeUseCase(node, context);
      },
      [ast2.InterfaceDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "interface def", node, context);
      },
      [ast2.ItemDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "item def", node, context);
      },
      [ast2.ItemUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "item", node, context);
      },
      /* istanbul ignore next */
      // matches empty string so not parsed as AST
      [ast2.LifeClass]() {
        return utils_1.literals.emptytext;
      },
      [ast2.MetadataDefinition](node, context) {
        return sysml.printGenericDefinition("auto", "metadata def", node, context);
      },
      [ast2.MetadataUsage]: annotating_elements_1.printMetadataFeature,
      [ast2.OccurrenceDefinition](node, context) {
        return sysml.printOccurrenceDefinition(node, context);
      },
      [ast2.OccurrenceUsage](node, context) {
        return sysml.printOccurrenceUsage(node, context);
      },
      [ast2.PartDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "part def", node, context);
      },
      [ast2.PartUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "part", node, context);
      },
      [ast2.PerformActionUsage](node, context) {
        return sysml.printPerformAction(node, context);
      },
      [ast2.PortDefinition](node, context) {
        return sysml.printGenericDefinition("auto", "port def", node, context);
      },
      [ast2.PortUsage](node, context) {
        return sysml.printPortUsage(node, context);
      },
      [ast2.ReferenceUsage](node, context) {
        return sysml.printReferenceUsage(node, context);
      },
      [ast2.RenderingDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "rendering def", node, context);
      },
      [ast2.RenderingUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "rendering", node, context);
      },
      [ast2.RequirementDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "requirement def", node, context);
      },
      [ast2.RequirementUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "requirement", node, context);
      },
      [ast2.SatisfyRequirementUsage](node, context) {
        return sysml.printSatisfyRequirement(node, context);
      },
      [ast2.SendActionUsage](node, context) {
        return actions.printSendAction(node, context);
      },
      [ast2.StateDefinition](node, context) {
        return actions.printStateDefinition(node, context);
      },
      [ast2.StateUsage](node, context) {
        return actions.printStateUsage(node, context);
      },
      [ast2.TerminateActionUsage](node, context) {
        return actions.printTerminateAction(node, context);
      },
      [ast2.Usage](node, context) {
        return sysml.printGenericUsage("auto", void 0, node, context);
      },
      [ast2.UseCaseDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "use case def", node, context);
      },
      [ast2.UseCaseUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "use case", node, context);
      },
      [ast2.VerificationCaseDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "verification def", node, context);
      },
      [ast2.VerificationCaseUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "verification", node, context);
      },
      [ast2.ViewDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "view def", node, context);
      },
      [ast2.ViewUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "view", node, context);
      },
      [ast2.ViewpointDefinition](node, context) {
        return sysml.printGenericOccurrenceDefinition("auto", "viewpoint def", node, context);
      },
      [ast2.ViewpointUsage](node, context) {
        return sysml.printGenericOccurrenceUsage("auto", "viewpoint", node, context);
      },
      // SysML Control Flow
      [ast2.DecisionNode](node, context) {
        return actions.printControlNode("decide", node, context);
      },
      [ast2.ForLoopActionUsage](node, context) {
        return actions.printForLoop(node, context);
      },
      [ast2.ForkNode](node, context) {
        return actions.printControlNode("fork", node, context);
      },
      [ast2.IfActionUsage](node, context) {
        return actions.printIfAction(node, context);
      },
      [ast2.JoinNode](node, context) {
        return actions.printControlNode("join", node, context);
      },
      [ast2.MergeNode](node, context) {
        return actions.printControlNode("merge", node, context);
      },
      [ast2.WhileLoopActionUsage](node, context) {
        return actions.printWhileLoop(node, context);
      },
      [ast2.AnnotatingElement]: abstractElement,
      [ast2.ConnectorAsUsage]: abstractElement,
      [ast2.ControlNode]: abstractElement,
      [ast2.Element]: abstractElement,
      [ast2.Expose]: abstractElement,
      [ast2.Featuring]: abstractElement,
      [ast2.Import]: abstractElement,
      [ast2.Inheritance]: abstractElement,
      [ast2.LiteralExpression]: abstractElement,
      [ast2.LoopActionUsage]: abstractElement,
      [ast2.Relationship]: abstractElement,
      [ast2.TextualAnnotatingElement]: abstractElement,
      [ast2.InlineExpression]: typeUnion,
      [ast2.FeatureRelationship]: typeUnion,
      [ast2.NonOwnerType]: typeUnion,
      [ast2.TransparentElement]: typeUnion,
      [ast2.TypeRelationship]: typeUnion,
      // these elements can't appear on their own in textual syntax
      [ast2.ConjugatedPortDefinition]: directPrint,
      [ast2.ConjugatedPortTyping]: directPrint,
      [ast2.CrossSubsetting]: directPrint,
      [ast2.Differencing]: directPrint,
      [ast2.EndFeatureMembership]: directPrint,
      [ast2.FeatureChaining]: directPrint,
      [ast2.Intersecting]: directPrint,
      [ast2.ParameterMembership]: directPrint,
      [ast2.PortConjugation]: directPrint,
      [ast2.ReferenceSubsetting]: directPrint,
      [ast2.TransitionFeatureMembership]: directPrint,
      [ast2.Unioning]: directPrint
    };
    var UnprintedWarnings = {
      // The only way for namespace notes to not be printed is if the root node
      // had no children, only some notes. This is safe to ignore since such notes
      // have no way of interfering with any other elements.
      Namespace: true
    };
    function printMissedInnerNotes(doc, notes, context, debugType) {
      const unprintedTrailingNotes = notes.filter((note) => note.localPlacement === "inner" && !context.printed.has(note));
      if (unprintedTrailingNotes.length === 0)
        return doc;
      if (unprintedTrailingNotes.some((note) => note.$cstNode) && !UnprintedWarnings[debugType]) {
        console.warn(`${debugType} printer did not print some inner comments, please FIX ME.`);
        UnprintedWarnings[debugType] = true;
      }
      return (0, utils_1.inheritLabel)(doc, (contents) => [
        (0, utils_1.join)(
          utils_1.hardline,
          // already filtered so don't have to use `printInnerComments`
          unprintedTrailingNotes.map((note) => (0, utils_1.printComment)(note, context)),
          true
        ),
        contents
      ]);
    }
    function defaultPrintNotes(doc, element, context) {
      doc = printMissedInnerNotes(doc, element.notes, context, element.nodeType());
      doc = (0, utils_1.surroundWithComments)(doc, element.notes, context);
      return doc;
    }
    exports2.defaultPrintNotes = defaultPrintNotes;
    var DefaultElementPrinter = (node, context, previousSibling) => {
      const type = node.nodeType();
      return ModelPrinter[type].call(ModelPrinter, node, context, previousSibling);
    };
    exports2.DefaultElementPrinter = DefaultElementPrinter;
    function printModelReference(element, context, options) {
      const cst = element.cst();
      let doc = !context.forceFormatting && (0, utils_2.hasFormatIgnore)(element) && cst ? (0, utils_1.printIgnored)(element.document.textDocument.getText(), cst, element.notes, context.printed) : void 0;
      doc !== null && doc !== void 0 ? doc : doc = options.printer(element, context);
      return defaultPrintNotes(doc, element, context);
    }
    exports2.printModelReference = printModelReference;
    function printModelElement(element, context, options = {}) {
      var _a, _b;
      let doc = !context.forceFormatting && (0, utils_2.hasFormatIgnore)(element) ? printElementIgnored(element, context) : void 0;
      doc !== null && doc !== void 0 ? doc : doc = ((_a = options.printer) !== null && _a !== void 0 ? _a : exports2.DefaultElementPrinter)(element, context, options.previousSibling);
      doc = defaultPrintNotes(doc, element, context);
      const { previousSibling } = options;
      if (!previousSibling || ((_b = element.parent()) === null || _b === void 0 ? void 0 : _b.is(ast2.OwningMembership)))
        return doc;
      const start = (0, utils_2.getElementStart)(element);
      const end = (0, utils_2.getElementEnd)(previousSibling);
      doc = (0, utils_1.newLineCount)(end, start) > 1 ? (0, utils_1.inheritLabel)(doc, (doc2) => [utils_1.hardline, doc2]) : doc;
      return doc;
    }
    exports2.printModelElement = printModelElement;
    function printModelElements(elements, context, options = {}) {
      return elements.map((e, i) => printModelElement(e, context, Object.assign(Object.assign({}, options), { previousSibling: i > 0 ? elements[i - 1] : options.previousSibling })));
    }
    exports2.printModelElements = printModelElements;
    function collectUnprintedNotes(root, printed) {
      return (0, utils_1.streamModel)(root).flatMap((e) => e.notes).filter((note) => !printed.has(note)).toArray();
    }
    exports2.collectUnprintedNotes = collectUnprintedNotes;
    function printElementIgnored(node, context) {
      const cst = node.cst();
      if (!cst)
        return;
      return (0, utils_1.printIgnored)(node.document.textDocument.getText(), cst, (0, utils_1.streamModel)(node).flatMap((e) => e.notes), context.printed);
    }
    exports2.printElementIgnored = printElementIgnored;
    function printModelRange(range, context) {
      const printed = printModelElements(range.elements, context, range.options);
      let doc;
      if (context.mode === "kerml")
        doc = (0, utils_1.join)(utils_1.hardline, printed);
      else {
        doc = actions.actionBodyJoiner()(range.elements, printed, range.leading);
      }
      for (let i = 0; i < range.level; ++i)
        doc = (0, utils_1.indent)(doc);
      return doc;
    }
    exports2.printModelRange = printModelRange;
  }
});

// ../syside-languageserver/lib/model/printer/edges.js
var require_edges = __commonJS({
  "../syside-languageserver/lib/model/printer/edges.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printViewRenderingMembership = exports2.printObjectiveMembership = exports2.printRequirementVerificationMembership = exports2.printRequirementConstraintMembership = exports2.printFramedConcernMembership = exports2.printStakeholderMembership = exports2.printSubjectMembership = exports2.printActorMembership = exports2.printRedefinition = exports2.printVariantMembership = exports2.printTypeFeaturing = exports2.printSubsetting = exports2.printSubclassification = exports2.printSpecialization = exports2.printOwningMembership = exports2.printFeatureValue = exports2.printAssignmentExpression = exports2.printFeatureTyping = exports2.printFeatureInverting = exports2.printElementFilterMembership = exports2.printDisjoining = exports2.printConjugation = exports2.printMembershipImport = exports2.printNamespaceImport = exports2.printDependency = exports2.selectToken = exports2.printSourceTargetRelationship = exports2.printMembership = exports2.printGenericMembership = exports2.printWithVisibility = exports2.printSource = exports2.printAsTarget = exports2.printTarget = exports2.printEdgeEnd = exports2.printChaining = void 0;
    var utils_1 = require_utils2();
    var KerML_1 = require_KerML();
    var print_1 = require_print3();
    var ast2 = __importStar(require_ast2());
    var utils_2 = require_utils3();
    var namespaces_1 = require_namespaces();
    var langium_1 = require_lib2();
    var definition_usages_1 = require_definition_usages();
    var actions_1 = require_actions();
    var expressions_1 = require_expressions4();
    function printChaining(target, context) {
      const chaining = (0, utils_1.fill)((0, utils_1.join)(utils_1.softline, target.chainings.map((chaining2, index) => {
        var _a, _b, _c;
        const target2 = (0, print_1.defaultPrintNotes)(printTarget(chaining2, context), (_c = (_b = (_a = chaining2.ast()) === null || _a === void 0 ? void 0 : _a.targetRef) === null || _b === void 0 ? void 0 : _b.$meta) !== null && _c !== void 0 ? _c : chaining2, context);
        if (index === 0)
          return target2;
        return (0, utils_1.indent)([utils_1.literals.dot, target2]);
      })));
      return (0, print_1.defaultPrintNotes)(chaining, target, context);
    }
    exports2.printChaining = printChaining;
    function printEdgeEnd(edge, value, context, options) {
      const { target, astNode } = value;
      if ((target === null || target === void 0 ? void 0 : target.parent()) === edge) {
        if (target.is(ast2.Feature) && edge.isAny(ast2.Inheritance, ast2.FeatureRelationship))
          return (0, print_1.printModelElement)(target, context, {
            printer: (target2, context2) => (0, utils_1.indent)(printChaining(target2, context2))
          });
        return (0, print_1.printModelElement)(target, context, options);
      }
      return (0, utils_2.printReference)(target, {
        scope: edge,
        context,
        astNode,
        errorMessage: `${edge.nodeType()} is missing ${value.kind} reference`
      });
    }
    exports2.printEdgeEnd = printEdgeEnd;
    function printTarget(edge, context, options) {
      var _a;
      return printEdgeEnd(edge, { target: edge.element(), astNode: (_a = edge.ast()) === null || _a === void 0 ? void 0 : _a.targetRef, kind: "target" }, context, options);
    }
    exports2.printTarget = printTarget;
    function printAsTarget(edge, context, options) {
      return (0, print_1.printModelElement)(edge, context, {
        printer: (node, context2, sibling) => printTarget(node, context2, Object.assign(Object.assign({}, options), { previousSibling: sibling })),
        previousSibling: options === null || options === void 0 ? void 0 : options.previousSibling
      });
    }
    exports2.printAsTarget = printAsTarget;
    function printSource(edge, context, options) {
      var _a;
      return printEdgeEnd(edge, { target: edge.source(), astNode: (_a = edge.ast()) === null || _a === void 0 ? void 0 : _a.sourceRef, kind: "source" }, context, options);
    }
    exports2.printSource = printSource;
    function printWithVisibility(edge, doc, context) {
      const format = context.format.public_keyword;
      if (edge.is(ast2.Expose) || !edge.is(ast2.Import) && !edge.hasExplicitVisibility) {
        return doc;
      }
      switch (edge.visibility) {
        case 0:
          return [(0, utils_1.keyword)("public "), doc];
        case 1:
          return [(0, utils_1.keyword)("protected "), doc];
        case 2:
          return [(0, utils_1.keyword)("private "), doc];
      }
    }
    exports2.printWithVisibility = printWithVisibility;
    function printGenericMembership(kw, node, context, options) {
      if (!kw)
        return printWithVisibility(node, printTarget(node, context, options), context);
      return printWithVisibility(node, (0, utils_1.group)([(0, utils_1.keyword)(kw), utils_1.literals.space, printTarget(node, context, options)]), context);
    }
    exports2.printGenericMembership = printGenericMembership;
    function printMembership(node, context, options) {
      var _a;
      if ((_a = node.owner()) === null || _a === void 0 ? void 0 : _a.is(ast2.InlineExpression)) {
        return (0, utils_1.indent)(printTarget(node, context));
      }
      if (node.isAlias) {
        return printWithVisibility(node, [
          (0, utils_1.group)([
            (0, utils_1.keyword)("alias"),
            (0, utils_1.indent)((0, utils_2.printIdentifiers)(node, context, { leading: utils_1.literals.space })),
            (0, utils_1.indent)([utils_1.line, (0, utils_1.keyword)("for "), (0, utils_1.indent)(printTarget(node, context, options))])
          ]),
          (0, namespaces_1.printChildrenBlock)(node, node.children, context, {
            insertSpaceBeforeBrackets: true
          })
        ], context);
      }
      (0, print_1.assertSysML)(context, "Membership (InitialNodeMember)");
      return [
        printGenericMembership("first", node, context, options),
        (0, namespaces_1.printChildrenBlock)(node, node.children, context, {
          insertSpaceBeforeBrackets: true
        })
      ];
    }
    exports2.printMembership = printMembership;
    function printSourceTargetRelationship(kw, node, context, options) {
      (0, print_1.assertKerML)(context, node.nodeType());
      const declaration = [];
      const prefix = options.format ? (0, utils_2.formatPreserved)(node, options.format, "always", {
        find: (node2) => (0, langium_1.findNodeForKeyword)(node2, kw),
        choose: {
          always: () => (0, utils_1.keyword)(kw),
          as_needed: () => node.declaredName || node.declaredShortName ? (0, utils_1.keyword)(kw) : utils_1.literals.emptytext,
          preserve: (found) => found ? "always" : "as_needed"
        }
      }) : (0, utils_1.keyword)(kw);
      if (prefix !== utils_1.literals.emptytext)
        declaration.push(prefix);
      const identifiers = (0, utils_2.printIdentifiers)(node, context);
      if (identifiers.length > 0)
        declaration.push(identifiers);
      return [
        (0, utils_1.group)([
          (0, utils_1.group)((0, utils_1.join)(utils_1.literals.space, declaration)),
          (0, utils_1.indent)(declaration.length > 0 ? utils_1.line : utils_1.literals.emptytext),
          (0, utils_1.indent)((0, utils_1.group)([
            options.sourceKw,
            options.sourceKw.contents ? utils_1.literals.space : utils_1.literals.emptytext,
            printSource(node, context),
            utils_1.line,
            options.targetKw,
            utils_1.literals.space,
            printTarget(node, context)
          ]))
        ]),
        (0, namespaces_1.printChildrenBlock)(node, node.children, context, { insertSpaceBeforeBrackets: true })
      ];
    }
    exports2.printSourceTargetRelationship = printSourceTargetRelationship;
    function selectToken(kw, token, node, option) {
      return (0, utils_2.formatPreserved)(node, option, "token", {
        find: (node2) => (0, langium_1.findNodeForKeyword)(node2, token.contents),
        choose: {
          keyword: () => kw,
          token: () => token,
          preserve: (found) => found ? "token" : "keyword"
        }
      });
    }
    exports2.selectToken = selectToken;
    function printDependency(node, context) {
      var _a, _b;
      const prefixes = (0, utils_1.join)(utils_1.line, (0, namespaces_1.printPrefixes)(node.prefixes, context, (prefix) => prefix.source()));
      const declaration = [];
      if (prefixes.length > 0) {
        declaration.push((0, utils_1.indent)((0, utils_1.fill)(prefixes)), utils_1.line);
      }
      declaration.push((0, utils_1.keyword)("dependency"));
      const identifiers = (0, utils_2.printIdentifiers)(node, context, { leading: utils_1.literals.space });
      const from = [];
      const to = [(0, utils_1.keyword)("to"), utils_1.line];
      if (identifiers.length > 0) {
        declaration.push((0, utils_1.indent)(identifiers));
        from.push((0, utils_1.keyword)("from"), utils_1.line);
      } else {
        const kw = (0, utils_2.formatPreserved)(node, context.format.dependency_from_keyword, "always", {
          find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "from"),
          choose: {
            always: () => (0, utils_1.keyword)("from"),
            as_needed: () => utils_1.literals.emptytext,
            preserve: (found) => found ? "always" : "as_needed"
          }
        });
        if (kw !== utils_1.literals.emptytext)
          from.push(kw, utils_1.line);
        else
          from.push((0, utils_1.ifBreak)([(0, utils_1.keyword)("from"), utils_1.line], utils_1.literals.emptytext));
      }
      const printRefs = (refs, astProp, kind) => {
        let targets;
        if (refs.length === 0) {
          if (!astProp)
            (0, utils_2.throwError)(node, `Invalid dependency - missing ${kind}`);
          targets = astProp.map((ref) => (0, utils_2.printAstReference)(ref, context));
        } else {
          targets = refs.map((target) => {
            const source = astProp === null || astProp === void 0 ? void 0 : astProp.find((ref) => ref.$meta.to.target === target);
            return printEdgeEnd(node, {
              target,
              astNode: source,
              kind
            }, context);
          });
        }
        return (0, utils_1.join)([utils_1.literals.comma, utils_1.line], targets);
      };
      from.push(...printRefs(node.client, (_a = node.ast()) === null || _a === void 0 ? void 0 : _a.client, "client"));
      to.push(...printRefs(node.supplier, (_b = node.ast()) === null || _b === void 0 ? void 0 : _b.supplier, "supplier"));
      return [
        (0, utils_1.group)([
          (0, utils_1.group)(declaration),
          (0, utils_1.indent)([utils_1.line, (0, utils_1.group)((0, utils_1.indent)(from))]),
          (0, utils_1.indent)([utils_1.line, (0, utils_1.group)((0, utils_1.indent)(to))])
        ]),
        (0, namespaces_1.printChildrenBlock)(node, node.children, context, {
          insertSpaceBeforeBrackets: true
        })
      ];
    }
    exports2.printDependency = printDependency;
    function printNamespaceImport(kw, node, context) {
      const declaration = [(0, utils_1.keyword)(kw), utils_1.literals.space];
      const doc = [(0, utils_1.group)(declaration)];
      const target = node.element();
      if ((target === null || target === void 0 ? void 0 : target.parent()) === node && target.nodeType() === ast2.Package) {
        const children = target.children;
        declaration.push((0, utils_1.indent)(printTarget(children[0], context)));
        if (children[0].is(ast2.NamespaceImport))
          declaration.push((0, utils_1.text)("::*"));
        doc.push((0, utils_1.indent)(children.slice(1).map((child) => (0, print_1.printModelElement)(child, context))));
      } else {
        declaration.push((0, utils_1.indent)(printTarget(node, context)), (0, utils_1.text)("::*"));
      }
      if (node.isRecursive) {
        declaration.push((0, utils_1.text)("::**"));
      }
      doc.push((0, namespaces_1.printChildrenBlock)(node, node.children, context, {
        insertSpaceBeforeBrackets: true
      }));
      return printWithVisibility(node, doc, context);
    }
    exports2.printNamespaceImport = printNamespaceImport;
    function printMembershipImport(kw, node, context) {
      return printWithVisibility(node, [
        (0, utils_1.group)([
          (0, utils_1.keyword)(kw),
          utils_1.literals.space,
          (0, utils_1.indent)(printTarget(node, context)),
          node.isRecursive ? (0, utils_1.text)("::**") : utils_1.literals.emptytext
        ]),
        (0, namespaces_1.printChildrenBlock)(node, node.children, context, {
          insertSpaceBeforeBrackets: true
        })
      ], context);
    }
    exports2.printMembershipImport = printMembershipImport;
    function printConjugation(node, context) {
      (0, print_1.assertKerML)(context, node.nodeType());
      return printSourceTargetRelationship("conjugation", node, context, {
        format: context.format.conjugation_keyword,
        sourceKw: (0, utils_1.keyword)("conjugate"),
        targetKw: selectToken((0, utils_1.keyword)("conjugates"), (0, utils_1.text)("~"), node, context.format.declaration_conjugation)
      });
    }
    exports2.printConjugation = printConjugation;
    function printDisjoining(node, context) {
      (0, print_1.assertKerML)(context, node.nodeType());
      return printSourceTargetRelationship("disjoining", node, context, {
        format: context.format.disjoining_keyword,
        sourceKw: (0, utils_1.keyword)("disjoint"),
        targetKw: (0, utils_1.keyword)("from")
      });
    }
    exports2.printDisjoining = printDisjoining;
    function printElementFilterMembership(node, context) {
      var _a, _b, _c;
      if (((_a = node.parent()) === null || _a === void 0 ? void 0 : _a.nodeType()) === ast2.Package && ((_c = (_b = node.parent()) === null || _b === void 0 ? void 0 : _b.parent()) === null || _c === void 0 ? void 0 : _c.is(ast2.NamespaceImport))) {
        return (0, utils_1.group)([
          utils_1.brackets.square.open,
          (0, utils_1.indent)([utils_1.softline, printTarget(node, context)]),
          utils_1.softline,
          utils_1.brackets.square.close
        ]);
      }
      const contents = [
        (0, actions_1.printCondition)((0, utils_1.keyword)("filter"), node, context, context.format.element_filter_parenthesize),
        utils_1.literals.semicolon
      ];
      return printWithVisibility(node, (0, utils_1.group)(contents), context);
    }
    exports2.printElementFilterMembership = printElementFilterMembership;
    function printFeatureInverting(node, context) {
      (0, print_1.assertKerML)(context, node.nodeType());
      return printSourceTargetRelationship("inverting", node, context, {
        format: context.format.inverting_keyword,
        sourceKw: (0, utils_1.keyword)("inverse"),
        targetKw: (0, utils_1.keyword)("of")
      });
    }
    exports2.printFeatureInverting = printFeatureInverting;
    function printFeatureTyping(node, context) {
      (0, print_1.assertKerML)(context, node.nodeType());
      return printSourceTargetRelationship("specialization", node, context, {
        format: context.format.specialization_keyword_feature_typing,
        sourceKw: (0, utils_1.keyword)("typing"),
        targetKw: selectToken((0, utils_1.keyword)("typed by"), (0, utils_1.text)(":"), node, context.format.declaration_feature_typing)
      });
    }
    exports2.printFeatureTyping = printFeatureTyping;
    function printAssignmentExpression(prefix, node, context, doc) {
      let target;
      if (doc) {
        target = doc;
      } else {
        if (!node)
          throw new Error("Cannot print an undefined expression");
        target = (0, print_1.printModelElement)(node, context);
      }
      if (prefix.length === 0)
        return target;
      if (node) {
        const op = (0, expressions_1.getOperator)(node);
        if (node.nodeType() === ast2.InvocationExpression || (0, expressions_1.precedence)(node) === expressions_1.PREC_LEVELS.ACCESS && op !== KerML_1.IMPLICIT_OPERATORS.DOT && op !== KerML_1.IMPLICIT_OPERATORS.METADATA || op === KerML_1.OPERATORS.COMMA) {
          return (0, utils_1.group)([
            ...prefix,
            (0, utils_1.group)((0, utils_1.indent)(utils_1.line), { id: "assignment-expr" }),
            utils_1.lineSuffixBoundary,
            (0, utils_1.indentIfBreak)((0, utils_1.group)(target), { groupId: "assignment-expr" })
          ]);
        }
      }
      return (0, utils_1.group)([...prefix, (0, utils_1.indent)([utils_1.line, (0, utils_1.group)(target)])]);
    }
    exports2.printAssignmentExpression = printAssignmentExpression;
    function printFeatureValue(node, context) {
      if (node.element().is(ast2.TriggerInvocationExpression))
        return printTarget(node, context);
      const parts = [];
      const prefix = [];
      if (node.isDefault) {
        prefix.push((0, utils_1.keyword)("default"));
        if (node.isInitial) {
          prefix.push((0, utils_1.text)(":="));
        } else {
          const equals = (0, utils_2.formatPreserved)(node, context.format.feature_value_equals, "always", {
            find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "="),
            choose: {
              as_needed: () => void 0,
              always: () => (0, utils_1.text)("="),
              preserve: (found) => found ? "always" : "as_needed"
            }
          });
          if (equals)
            prefix.push(equals);
        }
      } else if (node.isInitial) {
        prefix.push((0, utils_1.text)(":="));
      } else {
        prefix.push((0, utils_1.text)("="));
      }
      parts.push(...(0, utils_1.join)(utils_1.literals.space, prefix));
      return printAssignmentExpression(parts, node.element(), context);
    }
    exports2.printFeatureValue = printFeatureValue;
    function printOwningMembership(node, context, previousSibling) {
      var _a, _b;
      if (context.mode === "kerml" && node.element().nodeType() !== ast2.MetadataFeature && ((_a = node.element()) === null || _a === void 0 ? void 0 : _a.is(ast2.Feature)) && !node.element().is(ast2.Multiplicity) && ((_b = node.parent()) === null || _b === void 0 ? void 0 : _b.is(ast2.Type)))
        return printGenericMembership("member", node, context, { previousSibling });
      return printGenericMembership(void 0, node, context, { previousSibling });
    }
    exports2.printOwningMembership = printOwningMembership;
    function printSpecialization(node, context) {
      (0, print_1.assertKerML)(context, node.nodeType());
      return printSourceTargetRelationship("specialization", node, context, {
        format: context.format.specialization_keyword_specialization,
        sourceKw: (0, utils_1.keyword)("subtype"),
        targetKw: selectToken((0, utils_1.keyword)("specializes"), (0, utils_1.text)(":>"), node, context.format.declaration_specialization)
      });
    }
    exports2.printSpecialization = printSpecialization;
    function printSubclassification(node, context) {
      (0, print_1.assertKerML)(context, node.nodeType());
      return printSourceTargetRelationship("specialization", node, context, {
        format: context.format.specialization_keyword_subclassification,
        sourceKw: (0, utils_1.keyword)("subclassifier"),
        targetKw: selectToken((0, utils_1.keyword)("specializes"), (0, utils_1.text)(":>"), node, context.format.declaration_subclassification)
      });
    }
    exports2.printSubclassification = printSubclassification;
    function printSubsetting(node, context) {
      (0, print_1.assertKerML)(context, node.nodeType());
      return printSourceTargetRelationship("specialization", node, context, {
        format: context.format.specialization_keyword_subsetting,
        sourceKw: (0, utils_1.keyword)("subset"),
        targetKw: selectToken((0, utils_1.keyword)("subsets"), (0, utils_1.text)(":>"), node, context.format.declaration_subsetting)
      });
    }
    exports2.printSubsetting = printSubsetting;
    function printTypeFeaturing(node, context) {
      (0, print_1.assertKerML)(context, node.nodeType());
      return printSourceTargetRelationship("featuring", node, context, {
        sourceKw: (0, utils_2.formatPreserved)(node, context.format.featuring_of_keyword, "always", {
          find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "of"),
          choose: {
            always: () => (0, utils_1.keyword)("of"),
            as_needed: () => node.declaredName || node.declaredShortName ? (0, utils_1.keyword)("of") : utils_1.literals.emptytext,
            preserve: (found) => found ? "always" : "as_needed"
          }
        }),
        targetKw: (0, utils_1.keyword)("by")
      });
    }
    exports2.printTypeFeaturing = printTypeFeaturing;
    function printVariantMembership(node, context, previousSibling) {
      var _a;
      (0, print_1.assertSysML)(context, node.nodeType());
      return printGenericMembership(((_a = node.parent()) === null || _a === void 0 ? void 0 : _a.is(ast2.EnumerationDefinition)) ? void 0 : "variant", node, context, { previousSibling });
    }
    exports2.printVariantMembership = printVariantMembership;
    function printRedefinition(node, context) {
      (0, print_1.assertKerML)(context, node.nodeType());
      return printSourceTargetRelationship("specialization", node, context, {
        format: context.format.specialization_keyword_redefinition,
        sourceKw: (0, utils_1.keyword)("redefinition"),
        targetKw: selectToken((0, utils_1.keyword)("redefines"), (0, utils_1.text)(":>>"), node, context.format.declaration_redefinition)
      });
    }
    exports2.printRedefinition = printRedefinition;
    function printRequirementParticipant(node, context, options) {
      (0, print_1.assertSysML)(context, node.nodeType());
      return printGenericMembership(options.keyword, node, context, {
        previousSibling: options.previousSibling,
        printer(node2, context2) {
          return (0, namespaces_1.printGenericFeature)([], void 0, void 0, node2, context2);
        }
      });
    }
    function printActorMembership(node, context, previousSibling) {
      return printRequirementParticipant(node, context, { previousSibling, keyword: "actor" });
    }
    exports2.printActorMembership = printActorMembership;
    function printSubjectMembership(node, context, previousSibling) {
      return printRequirementParticipant(node, context, { previousSibling, keyword: "subject" });
    }
    exports2.printSubjectMembership = printSubjectMembership;
    function printStakeholderMembership(node, context, previousSibling) {
      return printRequirementParticipant(node, context, { previousSibling, keyword: "stakeholder" });
    }
    exports2.printStakeholderMembership = printStakeholderMembership;
    function printSpecialRequirementMember(node, context, options) {
      (0, print_1.assertSysML)(context, node.nodeType());
      return printGenericMembership(options.memberKeyword, node, context, {
        previousSibling: options.previousSibling,
        printer(node2, context2) {
          const allowShorthand = (0, definition_usages_1.canPrintShorthandUsage)(node2, ast2.ReferenceSubsetting);
          const kw = (0, utils_2.formatPreserved)(node2, context2.format.framed_concern_keyword, "always", {
            find: (node3) => (0, langium_1.findNodeForKeyword)(node3, options.targetKeyword),
            choose: {
              always: () => options.targetKeyword,
              as_needed: () => allowShorthand || node2.prefixes.length > 0 ? void 0 : options.targetKeyword,
              preserve: (found) => found ? "always" : "as_needed"
            }
          });
          if (kw || !allowShorthand) {
            return (0, definition_usages_1.printGenericOccurrenceUsage)([], kw, node2, context2);
          }
          return (0, definition_usages_1.printShorthandUsage)(node2, context2);
        }
      });
    }
    function printFramedConcernMembership(node, context, previousSibling) {
      return printSpecialRequirementMember(node, context, {
        previousSibling,
        memberKeyword: "frame",
        targetKeyword: "concern"
      });
    }
    exports2.printFramedConcernMembership = printFramedConcernMembership;
    function printRequirementConstraintMembership(node, context, previousSibling) {
      return printSpecialRequirementMember(node, context, {
        previousSibling,
        memberKeyword: node.kind === "assumption" ? "assume" : "require",
        targetKeyword: "constraint"
      });
    }
    exports2.printRequirementConstraintMembership = printRequirementConstraintMembership;
    function printRequirementVerificationMembership(node, context, previousSibling) {
      return printSpecialRequirementMember(node, context, {
        previousSibling,
        memberKeyword: "verify",
        targetKeyword: "requirement"
      });
    }
    exports2.printRequirementVerificationMembership = printRequirementVerificationMembership;
    function printObjectiveMembership(node, context, previousSibling) {
      (0, print_1.assertSysML)(context, node.nodeType());
      return printGenericMembership("objective", node, context, {
        previousSibling,
        printer(node2, context2) {
          return (0, namespaces_1.printGenericFeature)([], void 0, void 0, node2, context2, {
            appendToDeclaration: (0, namespaces_1.featureValueAppender)(node2, context2)
          });
        }
      });
    }
    exports2.printObjectiveMembership = printObjectiveMembership;
    function printViewRenderingMembership(node, context, previousSibling) {
      (0, print_1.assertSysML)(context, node.nodeType());
      return printSpecialRequirementMember(node, context, {
        previousSibling,
        memberKeyword: "render",
        targetKeyword: "rendering"
      });
    }
    exports2.printViewRenderingMembership = printViewRenderingMembership;
  }
});

// ../syside-languageserver/lib/model/printer/namespaces.js
var require_namespaces = __commonJS({
  "../syside-languageserver/lib/model/printer/namespaces.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printKerMLOwnedCrossFeature = exports2.printNamespace = exports2.printMultiplicityRange = exports2.printMultiplicity = exports2.printInvariant = exports2.printFeature = exports2.printKerMLFeature = exports2.printGenericFeature = exports2.featureValueAppender = exports2.kermlFeatureModifiers = exports2.kermlBasicFeatureModifiers = exports2.printType = exports2.printNonTypeNamespace = exports2.printGenericNamespace = exports2.printNamespaceDecl = exports2.printSpecializationPart = exports2.defaultSpecializationGrouper = exports2.printOwnedCrossFeaturePart = exports2.printOwnedCrossMultiplicityPart = exports2.printMultiplicityPart = exports2.printDeclaredMultiplicityRange = exports2.printChildrenBlock = exports2.printDeclaredRelationships = exports2.printPrefixes = void 0;
    var langium_1 = require_lib2();
    var ast2 = __importStar(require_ast2());
    var utils_1 = require_utils2();
    var edges_1 = require_edges();
    var print_1 = require_print3();
    var utils_2 = require_utils3();
    var expressions_1 = require_expressions4();
    function printPrefixes(prefixes, context, select = (prefix) => prefix.element()) {
      return prefixes.map((prefix) => (0, print_1.printModelElement)(prefix, context, {
        printer: (prefix2, context2) => {
          const feature = select(prefix2);
          if (!feature)
            (0, utils_2.throwError)(prefix2, "Invalid metadata prefix - relationship is missing target element");
          return (0, print_1.printModelElement)(feature, context2, {
            printer(prefix3, context3) {
              const target = prefix3.specializations(ast2.FeatureTyping).at(0);
              if (!target)
                (0, utils_2.throwError)(prefix3, "Invalid metadata prefix - metadata feature is missing feature typing");
              const doc = (0, print_1.printModelElement)(target, context3, {
                printer: (target2, context4) => (0, edges_1.printTarget)(target2, context4)
              });
              return [
                (0, utils_1.text)(target.notes.some((note) => note.localPlacement === "leading") || (0, utils_1.getLabel)(doc) === "with-leading-notes" ? "# " : "#"),
                (0, utils_1.indent)(doc)
              ];
            }
          });
        }
      }));
    }
    exports2.printPrefixes = printPrefixes;
    function getDeclaredRelationshipFormatInfo(node, context) {
      const type = node.nodeType();
      switch (type) {
        case "ConjugatedPortTyping": {
          (0, print_1.assertSysML)(context, type);
          return {
            keyword: (0, utils_1.keyword)("defined by"),
            token: utils_1.literals.colon,
            format: context.format.declaration_conjugated_port_typing,
            prefix: utils_1.literals.tilde,
            groupable: true,
            merge: false
          };
        }
        case "Conjugation": {
          (0, print_1.assertKerML)(context, type);
          return {
            keyword: (0, utils_1.keyword)("conjugates"),
            token: utils_1.literals.tilde,
            format: context.format.declaration_conjugation,
            groupable: false,
            merge: false
          };
        }
        case "CrossSubsetting":
          return {
            keyword: (0, utils_1.keyword)("crosses"),
            token: (0, utils_1.text)("=>"),
            format: context.format.declaration_cross_subsetting,
            groupable: false,
            merge: false
          };
        case "FeatureTyping": {
          return {
            keyword: (0, utils_1.keyword)(context.mode === "sysml" ? "defined by" : "typed by"),
            token: utils_1.literals.colon,
            format: context.format.declaration_feature_typing,
            groupable: true,
            merge: false
          };
        }
        case "Inheritance":
          throw new Error("Cannot format abstract 'Inheritance'");
        case "PortConjugation": {
          throw new Error("Cannot print 'PortConjugation' - is an empty string in textual syntax");
        }
        case "Redefinition":
          return {
            keyword: (0, utils_1.keyword)("redefines"),
            token: (0, utils_1.text)(":>>"),
            format: context.format.declaration_redefinition,
            groupable: true,
            merge: false
          };
        case "ReferenceSubsetting":
          return {
            keyword: (0, utils_1.keyword)("references"),
            token: (0, utils_1.text)("::>"),
            format: context.format.declaration_reference_subsetting,
            groupable: false,
            merge: false
          };
        case "Specialization":
          return {
            keyword: (0, utils_1.keyword)("specializes"),
            token: (0, utils_1.text)(":>"),
            format: context.format.declaration_specialization,
            groupable: true,
            merge: false
          };
        case "Subclassification":
          return {
            keyword: (0, utils_1.keyword)("specializes"),
            token: (0, utils_1.text)(":>"),
            format: context.format.declaration_subclassification,
            groupable: true,
            merge: false
          };
        case "Subsetting":
          return {
            keyword: (0, utils_1.keyword)("subsets"),
            token: (0, utils_1.text)(":>"),
            format: context.format.declaration_subsetting,
            groupable: true,
            merge: false
          };
        case "Differencing":
          (0, print_1.assertKerML)(context, type);
          return {
            keyword: (0, utils_1.keyword)("differences"),
            format: { default: "keyword", fallback: "keyword" },
            groupable: true,
            merge: context.format.merge_differencing
          };
        case "Disjoining":
          (0, print_1.assertKerML)(context, type);
          return {
            keyword: (0, utils_1.keyword)("disjoint from"),
            format: { default: "keyword", fallback: "keyword" },
            groupable: true,
            merge: context.format.merge_declaration_disjoining
          };
        case "FeatureChaining":
          (0, print_1.assertKerML)(context, type);
          return {
            keyword: (0, utils_1.keyword)("chains"),
            format: { default: "keyword", fallback: "keyword" },
            groupable: true,
            merge: context.format.merge_feature_chaining,
            separator: [utils_1.softline, utils_1.literals.dot]
          };
        case "Intersecting":
          (0, print_1.assertKerML)(context, type);
          return {
            keyword: (0, utils_1.keyword)("intersects"),
            format: { default: "keyword", fallback: "keyword" },
            groupable: true,
            merge: context.format.merge_intersecting
          };
        case "Unioning":
          (0, print_1.assertKerML)(context, type);
          return {
            keyword: (0, utils_1.keyword)("unions"),
            format: { default: "keyword", fallback: "keyword" },
            groupable: true,
            merge: context.format.merge_unioning
          };
        case "FeatureInverting":
          (0, print_1.assertKerML)(context, type);
          return {
            keyword: (0, utils_1.keyword)("inverse of"),
            format: { default: "keyword", fallback: "keyword" },
            groupable: false,
            merge: false
          };
        case "TypeFeaturing":
          (0, print_1.assertKerML)(context, type);
          return {
            keyword: (0, utils_1.keyword)("featured by"),
            format: { default: "keyword", fallback: "keyword" },
            groupable: true,
            merge: context.format.merge_declaration_type_featuring
          };
      }
    }
    function selectDeclaredRelationshipToken(current, info) {
      if (!info.token)
        return info.keyword;
      const token = info.token;
      const fallback = info.format.fallback || "token";
      return (0, utils_2.formatPreserved)(current, info.format, fallback, {
        // have to look at the previous node since type declarations may have
        // multiple keywords/tokens
        find: (node) => (0, utils_1.getPreviousNode)(node, false),
        choose: {
          keyword: () => info.keyword,
          token: () => token,
          preserve: (found) => {
            switch (found === null || found === void 0 ? void 0 : found.text) {
              case token.contents:
                return "token";
              case info.keyword.contents:
                return "keyword";
              default:
                return fallback;
            }
          }
        }
      });
    }
    function printDeclaredRelationships(node, heritage, context, options = {}) {
      const explicit = heritage.filter((h) => !h.isImplied && h.parent() === node);
      if (explicit.length === 0)
        return [];
      const merged = {};
      const groups = [];
      explicit.forEach((r, i) => {
        var _a;
        const type = r.nodeType();
        const info = getDeclaredRelationshipFormatInfo(r, context);
        const token = selectDeclaredRelationshipToken(r, info);
        let subgroup;
        if (info.merge) {
          subgroup = (_a = merged[type]) !== null && _a !== void 0 ? _a : merged[type] = { parts: [] };
        } else {
          const previous = i > 0 ? explicit[i - 1] : void 0;
          if (info.groupable && (previous === null || previous === void 0 ? void 0 : previous.nodeType()) === type) {
            subgroup = groups[groups.length - 1];
          } else {
            subgroup = { parts: [] };
          }
        }
        let target = (0, edges_1.printTarget)(r, context);
        if (info.prefix)
          target = [info.prefix, target];
        if (subgroup.parts.length === 0) {
          groups.push(subgroup);
          if (i !== 0 || !options.skipFirstKeyword)
            subgroup.token = token;
        } else {
          if (info.separator)
            subgroup.parts.push(info.separator);
          else
            subgroup.parts.push(utils_1.literals.comma, utils_1.line);
        }
        subgroup.parts.push(target);
      });
      return groups.map((g, i) => {
        const sub = g.token ? (0, utils_1.group)([g.token, (0, utils_1.indent)([utils_1.line, (0, utils_1.group)(g.parts)])]) : (0, utils_1.indent)((0, utils_1.group)(g.parts));
        return i === 0 ? sub : (0, utils_1.group)([utils_1.line, sub]);
      });
    }
    exports2.printDeclaredRelationships = printDeclaredRelationships;
    function printChildrenBlock(node, children, context, options) {
      var _a, _b;
      if (children.length === 0 && !(options === null || options === void 0 ? void 0 : options.result)) {
        const innerNotes = (semi) => (0, utils_1.printInnerComments)(node.notes, Object.assign(Object.assign({}, context), { indent: !semi }), semi ? void 0 : (note) => note.kind === "line" || (options === null || options === void 0 ? void 0 : options.forceBreak) ? utils_1.hardline : utils_1.line);
        const asBrackets = () => {
          const body = innerNotes(false);
          let contents2 = [utils_1.brackets.curly.open, utils_1.brackets.curly.close];
          if (body !== utils_1.literals.emptytext)
            contents2 = [(0, utils_1.group)([contents2[0], (0, utils_1.indent)(utils_1.line), body, contents2[1]])];
          else if (options === null || options === void 0 ? void 0 : options.forceBreak)
            contents2 = [contents2[0], utils_1.hardline, contents2[1]];
          if (options === null || options === void 0 ? void 0 : options.insertSpaceBeforeBrackets)
            return [utils_1.literals.space, ...contents2];
          return contents2;
        };
        const asSemi = () => {
          var _a2;
          const body = innerNotes(true);
          const token = (_a2 = options === null || options === void 0 ? void 0 : options.semicolon) !== null && _a2 !== void 0 ? _a2 : utils_1.literals.semicolon;
          if (body === utils_1.literals.emptytext)
            return token;
          return (0, utils_1.group)([token, utils_1.line, body]);
        };
        if (options === null || options === void 0 ? void 0 : options.forceEmptyBrackets)
          return asBrackets();
        return (0, utils_2.formatPreserved)(node, context.format.empty_namespace_brackets, "always", {
          find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "{"),
          choose: {
            always: asBrackets,
            never: asSemi,
            preserve: (found) => found ? "always" : "never"
          }
        });
      }
      const linebreak = (options === null || options === void 0 ? void 0 : options.forceBreak) ? utils_1.hardline : context.format.bracket_spacing ? utils_1.line : utils_1.softline;
      const printed = (0, print_1.printModelElements)(children, context, options);
      let joined = (options === null || options === void 0 ? void 0 : options.join) ? options.join(children, printed) : (0, utils_1.join)(linebreak, printed);
      if (options === null || options === void 0 ? void 0 : options.result) {
        const result = (0, print_1.printModelElement)(options.result, context, {
          previousSibling: children.at(-1),
          printer: options.printer
        });
        joined = printed.length > 0 ? [joined, linebreak, result] : [joined, result];
      }
      const contents = [
        utils_1.brackets.curly.open,
        (0, utils_1.indent)([linebreak, joined]),
        linebreak,
        utils_1.brackets.curly.close
      ];
      const first = (_b = (_a = children.at(0)) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.result) === null || _b === void 0 ? void 0 : _b.cst();
      if (first && (0, utils_1.newLineCount)((0, utils_1.getPreviousNode)(first, false), first) > 0) {
        contents.push(utils_1.breakParent);
      }
      if (options === null || options === void 0 ? void 0 : options.insertSpaceBeforeBrackets)
        return [utils_1.literals.space, contents];
      return contents;
    }
    exports2.printChildrenBlock = printChildrenBlock;
    function printNamespaceLeadingParts(node, context, parts) {
      const groups = [];
      const prefix = [];
      if (parts.modifiers.length > 0) {
        let lead = (0, utils_1.fill)((0, utils_1.join)(utils_1.line, parts.modifiers));
        if (parts.crossFeature)
          lead = (0, utils_1.appendFill)(lead, utils_1.literals.space, parts.crossFeature);
        prefix.push(lead);
      } else if (parts.crossFeature) {
        prefix.push(parts.crossFeature);
      }
      if (parts.printPrefixes) {
        const prefixes = printPrefixes(node.prefixes, context);
        if (prefixes.length > 0) {
          prefix.push(...prefixes);
        }
      }
      if (prefix.length > 0) {
        groups.push((0, utils_1.indent)((0, utils_1.fill)((0, utils_1.join)(utils_1.line, prefix))));
      }
      const id = [];
      if (parts.keyword) {
        id.push((0, utils_1.keyword)(parts.keyword));
      }
      const identifiers = (0, utils_2.printIdentifiers)(node, context);
      if (identifiers.length > 0) {
        id.push(identifiers);
      }
      if (id.length > 0) {
        groups.push((0, utils_1.group)((0, utils_1.indent)((0, utils_1.join)(utils_1.literals.space, id))));
      }
      switch (groups.length) {
        case 0:
          return [];
        case 1:
          return [groups[0]];
        default:
          return [(0, utils_1.group)((0, utils_1.join)(utils_1.line, groups))];
      }
    }
    function printDeclaredMultiplicityRange(node, context) {
      return [
        utils_1.brackets.square.open,
        (0, utils_1.indent)([utils_1.softline, (0, print_1.printModelElement)(node, context)]),
        utils_1.softline,
        utils_1.brackets.square.close
      ];
    }
    exports2.printDeclaredMultiplicityRange = printDeclaredMultiplicityRange;
    function printMultiplicityPart(node, context, range) {
      var _a, _b, _c;
      if (range === void 0) {
        range = (_c = (_b = (_a = node.multiplicity) === null || _a === void 0 ? void 0 : _a.element()) === null || _b === void 0 ? void 0 : _b.range) === null || _c === void 0 ? void 0 : _c.element();
      }
      const props = [];
      let suffix = [];
      if (node.is(ast2.Feature)) {
        if (node.isOrderedExplicitly)
          props.push((0, utils_1.keyword)("ordered"));
        if (node.isNonUnique)
          props.push((0, utils_1.keyword)("nonunique"));
        if (props.length > 1) {
          suffix = (0, utils_2.formatPreserved)(node, context.format.ordered_nonunique_priority, "ordered", {
            find: (cst) => {
              const ordered = (0, langium_1.findNodeForKeyword)(cst, "ordered");
              const nonunique = (0, langium_1.findNodeForKeyword)(cst, "nonunique");
              if (!ordered)
                return nonunique;
              if (!nonunique)
                return ordered;
              return ordered.offset < nonunique.offset ? ordered : nonunique;
            },
            choose: {
              ordered: () => props,
              nonunique: () => props.reverse(),
              preserve: (found) => (found === null || found === void 0 ? void 0 : found.text) === "ordered" ? "ordered" : "nonunique"
            }
          });
        } else {
          suffix = props;
        }
      }
      if (!range) {
        if (suffix.length === 0)
          return;
        return (0, utils_1.group)((0, utils_1.join)(utils_1.literals.space, suffix));
      }
      const parts = printDeclaredMultiplicityRange(range, context);
      if (suffix.length > 0) {
        parts.push(utils_1.literals.space, (0, utils_1.join)(utils_1.literals.space, suffix));
      }
      return (0, utils_1.group)(parts);
    }
    exports2.printMultiplicityPart = printMultiplicityPart;
    function printOwnedCrossMultiplicityPart(node, context) {
      var _a;
      if (!((_a = node.ownedCrossFeature) === null || _a === void 0 ? void 0 : _a.multiplicity)) {
        return void 0;
      }
      return (0, utils_1.group)((0, utils_2.printDescendant)(node, context, "owned cross multiplicity").descend((node2) => node2.ownedCrossFeatureMember).descend((node2) => node2.element()).descend((node2) => node2.multiplicity).descend((node2) => node2.element()).descend((node2) => node2.range).descend((node2) => node2.element()).print({
        printer(range, context2) {
          return printDeclaredMultiplicityRange(range, context2);
        }
      }));
    }
    exports2.printOwnedCrossMultiplicityPart = printOwnedCrossMultiplicityPart;
    function printOwnedCrossFeaturePart(node, modifiers, context) {
      if (!node.ownedCrossFeatureMember || !node.isEnd) {
        return void 0;
      }
      const result = (0, utils_1.group)((0, utils_2.printDescendant)(node, context, "owned cross feature").descend((node2) => node2.ownedCrossFeatureMember).descend((node2) => node2.element()).print({
        printer(cross, context2) {
          return printNamespaceDecl(cross, context2, {
            modifiers: modifiers(cross),
            keyword: void 0
          });
        }
      }));
      return result;
    }
    exports2.printOwnedCrossFeaturePart = printOwnedCrossFeaturePart;
    function defaultSpecializationGrouper(context) {
      return (node) => {
        let placement = context.format.multiplicity_placement;
        if (!node.multiplicity && (!node.is(ast2.Feature) || !node.isNonUnique || !node.isOrdered) || context.mode === "kerml" && node.is(ast2.Type) && !node.is(ast2.Feature))
          placement = "first";
        const specializations = node.specializations().filter((s) => !s.isImplied);
        switch (placement) {
          case "first-specialization":
            if (specializations.length > 0)
              return [[specializations[0]], specializations.slice(1)];
          case "first":
            return [[], specializations];
          case "last":
            return [specializations, []];
        }
      };
    }
    exports2.defaultSpecializationGrouper = defaultSpecializationGrouper;
    function printSpecializationPart(node, context, options) {
      const multi = options.ignoreMultiplicity ? void 0 : printMultiplicityPart(node, context);
      let skipFirstKeyword = Boolean(options.skipFirstKeyword);
      const groups = options.specializations(node).map((group) => {
        const printed = printDeclaredRelationships(node, group, context, { skipFirstKeyword });
        skipFirstKeyword && (skipFirstKeyword = printed.length === 0);
        return printed;
      });
      if (groups.length === 0 || groups.every((g) => g.length === 0)) {
        if (multi)
          return [(0, utils_1.indent)(multi)];
        return [];
      }
      if (multi) {
        const lhs = groups[0];
        if (lhs.length === 0) {
          groups[1][0] = [multi, utils_1.line, groups[1][0]];
        } else {
          lhs[lhs.length - 1] = [lhs[lhs.length - 1], utils_1.line, multi];
        }
      }
      return groups.filter((g) => g.length > 0).map((g, i) => {
        const contents = g.map((sub) => (0, utils_1.group)(sub));
        return (0, utils_1.indent)(i === 0 ? contents : [utils_1.line, contents]);
      });
    }
    exports2.printSpecializationPart = printSpecializationPart;
    function printNamespaceDecl(node, context, parts) {
      var _a;
      let declaration = printNamespaceLeadingParts(node, context, {
        modifiers: parts.modifiers,
        crossFeature: parts === null || parts === void 0 ? void 0 : parts.crossFeature,
        keyword: parts.keyword,
        printPrefixes: true
      });
      const pushGroup = (doc, linebreak = (0, utils_1.indent)(utils_1.line)) => {
        if (declaration.length > 0)
          declaration.push(linebreak);
        declaration.push(doc);
      };
      if (node.is(ast2.Type)) {
        const options = parts;
        const specialization = printSpecializationPart(node, context, {
          specializations: (_a = options.specializations) !== null && _a !== void 0 ? _a : defaultSpecializationGrouper(context),
          skipFirstKeyword: options.skipFirstSpecializationKeyword
        });
        const other = printDeclaredRelationships(node, node.typeRelationships, context);
        if (other.length > 0) {
          const relationships = (0, utils_1.indent)((0, utils_1.group)(other));
          if (specialization.length > 0)
            specialization.push((0, utils_1.indent)(utils_1.line));
          specialization.push(relationships);
        }
        if (specialization.length > 0) {
          pushGroup((0, utils_1.group)(specialization));
        }
      }
      if (parts.appendToDeclaration) {
        if (declaration.length > 0)
          declaration = [(0, utils_1.group)(declaration)];
        parts.appendToDeclaration(declaration);
      }
      return declaration;
    }
    exports2.printNamespaceDecl = printNamespaceDecl;
    function printGenericNamespace(node, context, parts) {
      const declaration = printNamespaceDecl(node, context, parts);
      if (parts.skipChildren === true)
        return (0, utils_1.group)(declaration);
      const children = printChildrenBlock(node, node.children, context, {
        result: parts.result,
        insertSpaceBeforeBrackets: declaration.length > 0,
        forceEmptyBrackets: parts.forceBrackets,
        forceBreak: parts.forceBreakChildren,
        join: parts.join
      });
      return [(0, utils_1.group)(declaration), children];
    }
    exports2.printGenericNamespace = printGenericNamespace;
    function printNonTypeNamespace(modifiers, kw, node, context) {
      return printGenericNamespace(node, context, {
        modifiers: modifiers ? [(0, utils_1.keyword)(modifiers)] : [],
        keyword: kw
      });
    }
    exports2.printNonTypeNamespace = printNonTypeNamespace;
    function printType(modifiers, kw, node, context, options = {}) {
      return printGenericNamespace(node, context, Object.assign({ modifiers: modifiers === "auto" ? node.isAbstract ? [(0, utils_1.keyword)("abstract")] : [] : modifiers, keyword: node.isSufficient ? `${kw} all` : kw, result: node.result }, options));
    }
    exports2.printType = printType;
    function kermlBasicFeatureModifiers(node) {
      const modifiers = [];
      if (node.explicitDirection !== "none")
        modifiers.push((0, utils_1.keyword)(node.explicitDirection));
      if (node.isAbstract)
        modifiers.push((0, utils_1.keyword)("abstract"));
      if (node.isPortion)
        modifiers.push((0, utils_1.keyword)("portion"));
      else if (node.isComposite)
        modifiers.push((0, utils_1.keyword)("composite"));
      if (node.isReadonly)
        modifiers.push((0, utils_1.keyword)("readonly"));
      if (node.isDerived)
        modifiers.push((0, utils_1.keyword)("derived"));
      return modifiers;
    }
    exports2.kermlBasicFeatureModifiers = kermlBasicFeatureModifiers;
    function kermlFeatureModifiers(node) {
      if (node.isEnd) {
        return [(0, utils_1.keyword)("end")];
      }
      return kermlBasicFeatureModifiers(node);
    }
    exports2.kermlFeatureModifiers = kermlFeatureModifiers;
    function featureValueAppender(node, context, printer = print_1.DefaultElementPrinter) {
      return (decl) => {
        if (!node.value)
          return;
        if (decl.length > 0)
          decl.push(utils_1.literals.space);
        decl.push((0, print_1.printModelElement)(node.value, context, { printer }));
      };
    }
    exports2.featureValueAppender = featureValueAppender;
    function printGenericFeature(modifiers, kw, crossFeature, node, context, options = { appendToDeclaration: featureValueAppender(node, context) }) {
      return printGenericNamespace(node, context, Object.assign({ modifiers, keyword: kw, crossFeature, result: node.result }, options));
    }
    exports2.printGenericFeature = printGenericFeature;
    function printKerMLFeature(kw, node, context, options = { appendToDeclaration: featureValueAppender(node, context) }) {
      (0, print_1.assertKerML)(context, node.nodeType());
      return printGenericFeature(kermlFeatureModifiers(node), node.isSufficient ? kw ? `${kw} all` : "all" : kw, node.isEnd ? printOwnedCrossFeaturePart(node, kermlFeatureModifiers, context) : void 0, node, context, options);
    }
    exports2.printKerMLFeature = printKerMLFeature;
    function printFeature(node, context) {
      var _a, _b;
      const owner = node.owner();
      if (owner) {
        if (((_a = node.parent()) === null || _a === void 0 ? void 0 : _a.nodeType()) == ast2.ParameterMembership && owner.is(ast2.InvocationExpression)) {
          return (0, expressions_1.printArgument)(node, context);
        }
        switch (owner.nodeType()) {
          case ast2.FeatureChainExpression:
            return (0, edges_1.printChaining)(node, context);
          case ast2.OperatorExpression: {
            const typing = node.specializations(ast2.FeatureTyping)[0];
            if (!typing)
              (0, utils_2.throwError)(node, "Invalid operator expression argument feature - missing feature typing");
            return (0, edges_1.printTarget)(typing, context);
          }
          case ast2.FeatureReferenceExpression: {
            if (((_b = node.parent()) === null || _b === void 0 ? void 0 : _b.nodeType()) === ast2.ReturnParameterMembership)
              return utils_1.literals.emptytext;
            break;
          }
          default:
            break;
        }
      }
      const kw = (0, utils_2.formatPreserved)(node, context.format.feature_keyword, "always", {
        find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "feature"),
        choose: {
          always: () => "feature",
          as_needed: () => {
            if (node.prefixes.length > 0 || node.isSufficient || node.declaredName || node.declaredShortName || node.specializations().some((s) => !s.isImplied)) {
              return void 0;
            }
            return "feature";
          },
          preserve: (found) => found ? "always" : "as_needed"
        }
      });
      return printKerMLFeature(kw, node, context);
    }
    exports2.printFeature = printFeature;
    function printInvariant(node, context) {
      const kw = node.isNegated ? utils_1.literals.false : (0, utils_2.formatPreserved)(node, context.format.invariant_true_keyword, "always", {
        find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "true"),
        choose: {
          always: () => utils_1.literals.true,
          never: () => utils_1.literals.emptytext,
          preserve: (found) => found ? "always" : "never"
        }
      });
      return printKerMLFeature(kw.contents ? `inv ${kw.contents}` : "inv", node, context);
    }
    exports2.printInvariant = printInvariant;
    function printMultiplicity(node, context) {
      (0, print_1.assertKerML)(context, node.nodeType());
      return [
        (0, utils_1.group)([
          (0, utils_1.group)([
            (0, utils_1.keyword)("multiplicity"),
            (0, utils_1.indent)((0, utils_2.printIdentifiers)(node, context, { leading: utils_1.literals.space }))
          ]),
          (0, utils_1.indent)([[utils_1.line, ...printDeclaredRelationships(node, node.specializations(), context)]])
        ]),
        printChildrenBlock(node, node.children, context, { insertSpaceBeforeBrackets: true })
      ];
    }
    exports2.printMultiplicity = printMultiplicity;
    function printMultiplicityRange(node, context) {
      var _a, _b;
      (0, print_1.assertKerML)(context, node.nodeType());
      return [
        (0, utils_1.group)([
          (0, utils_1.keyword)("multiplicity"),
          (0, utils_1.indent)((0, utils_2.printIdentifiers)(node, context, { leading: utils_1.literals.space })),
          utils_1.literals.space,
          (0, utils_1.indent)((_b = printMultiplicityPart(node, context, (_a = node.range) === null || _a === void 0 ? void 0 : _a.element())) !== null && _b !== void 0 ? _b : utils_1.literals.emptytext)
        ]),
        printChildrenBlock(node, node.children, context, { insertSpaceBeforeBrackets: true })
      ];
    }
    exports2.printMultiplicityRange = printMultiplicityRange;
    function printNamespace(node, context) {
      if (!node.parent()) {
        return (0, utils_1.join)(utils_1.hardline, (0, print_1.printModelElements)(node.children, context));
      }
      (0, print_1.assertKerML)(context, node.nodeType());
      return printNonTypeNamespace(void 0, "namespace", node, context);
    }
    exports2.printNamespace = printNamespace;
    function printKerMLOwnedCrossFeature(node, context) {
      return printOwnedCrossFeaturePart(node, kermlBasicFeatureModifiers, context);
    }
    exports2.printKerMLOwnedCrossFeature = printKerMLOwnedCrossFeature;
  }
});

// ../syside-languageserver/lib/model/printer/definition-usages.js
var require_definition_usages = __commonJS({
  "../syside-languageserver/lib/model/printer/definition-usages.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printSysmlOwnedCrossFeature = exports2.printAttributeUsage = exports2.printShorthandUsage = exports2.canPrintShorthandUsage = exports2.printReferenceUsage = exports2.printPortUsage = exports2.printOccurrenceUsage = exports2.printOccurrenceDefinition = exports2.printEnumerationUsage = exports2.printSatisfyRequirement = exports2.printPerformAction = exports2.printIncludeUseCase = exports2.printExhibitState = exports2.printEventOccurrence = exports2.printAssertConstraint = exports2.printOccurrenceUsageSubtype = exports2.printGenericOccurrenceDefinition = exports2.printGenericDefinition = exports2.printGenericOccurrenceUsage = exports2.printGenericUsage = exports2.occurrenceDefinitionModifiers = exports2.occurrenceUsageModifiers = exports2.basicOccurrenceUsageModifiers = exports2.definitionModifiers = exports2.sysmlUsageModifiers = void 0;
    var langium_1 = require_lib2();
    var ast2 = __importStar(require_ast2());
    var utils_1 = require_utils2();
    var namespaces_1 = require_namespaces();
    var print_1 = require_print3();
    var utils_2 = require_utils3();
    var edges_1 = require_edges();
    var actions_1 = require_actions();
    function usageBasicModifiers(node, ignoreRef = false) {
      const modifiers = [];
      if (node.explicitDirection !== "none")
        modifiers.push((0, utils_1.keyword)(node.explicitDirection));
      if (node.isVariation)
        modifiers.push((0, utils_1.keyword)("variation"));
      else if (node.isAbstract)
        modifiers.push((0, utils_1.keyword)("abstract"));
      if (node.isReadonly)
        modifiers.push((0, utils_1.keyword)("readonly"));
      if (node.isDerived)
        modifiers.push((0, utils_1.keyword)("derived"));
      if (node.isEndExplicitly)
        modifiers.push((0, utils_1.keyword)("end"));
      if (!ignoreRef && node.isReferenceExplicitly && node.nodeType() !== ast2.ReferenceUsage)
        modifiers.push((0, utils_1.keyword)("ref"));
      return modifiers;
    }
    function sysmlUsageModifiers(node, ignoreRef = false) {
      if (node.isEndExplicitly) {
        return [(0, utils_1.keyword)("end")];
      }
      return usageBasicModifiers(node, ignoreRef);
    }
    exports2.sysmlUsageModifiers = sysmlUsageModifiers;
    function definitionModifiers(node) {
      return node.isVariation ? [(0, utils_1.keyword)("variation")] : node.isAbstract ? [(0, utils_1.keyword)("abstract")] : [];
    }
    exports2.definitionModifiers = definitionModifiers;
    function basicOccurrenceUsageModifiers(node, ignoreRef = false) {
      const modifiers = sysmlUsageModifiers(node, ignoreRef);
      if (node.isIndividual)
        modifiers.push((0, utils_1.keyword)("individual"));
      if (node.portionKind)
        modifiers.push((0, utils_1.keyword)(node.portionKind));
      return modifiers;
    }
    exports2.basicOccurrenceUsageModifiers = basicOccurrenceUsageModifiers;
    function occurrenceUsageModifiers(node, ignoreRef = false) {
      if (node.isEndExplicitly)
        return sysmlUsageModifiers(node, ignoreRef);
      return basicOccurrenceUsageModifiers(node, ignoreRef);
    }
    exports2.occurrenceUsageModifiers = occurrenceUsageModifiers;
    function occurrenceDefinitionModifiers(node) {
      const modifiers = definitionModifiers(node);
      if (node.isIndividual)
        modifiers.push((0, utils_1.keyword)("individual"));
      return modifiers;
    }
    exports2.occurrenceDefinitionModifiers = occurrenceDefinitionModifiers;
    function printGenericUsage(modifiers, kw, node, context, options = { appendToDeclaration: (0, namespaces_1.featureValueAppender)(node, context) }) {
      (0, print_1.assertSysML)(context, node.nodeType());
      return (0, namespaces_1.printGenericFeature)(modifiers === "auto" ? sysmlUsageModifiers(node, options === null || options === void 0 ? void 0 : options.ignoreRef) : modifiers, kw, printSysmlOwnedCrossFeature(node, context), node, context, Object.assign(Object.assign({}, options), { join: (0, actions_1.actionBodyJoiner)() }));
    }
    exports2.printGenericUsage = printGenericUsage;
    function printGenericOccurrenceUsage(modifiers, kw, node, context, options = { appendToDeclaration: (0, namespaces_1.featureValueAppender)(node, context) }) {
      (0, print_1.assertSysML)(context, node.nodeType());
      return (0, namespaces_1.printGenericFeature)(modifiers === "auto" ? occurrenceUsageModifiers(node, options === null || options === void 0 ? void 0 : options.ignoreRef) : modifiers, kw, printSysmlOwnedCrossFeature(node, context), node, context, Object.assign(Object.assign({}, options), { join: (0, actions_1.actionBodyJoiner)() }));
    }
    exports2.printGenericOccurrenceUsage = printGenericOccurrenceUsage;
    function printGenericDefinition(modifiers, kw, node, context, options = {}) {
      return (0, namespaces_1.printType)(modifiers === "auto" ? definitionModifiers(node) : modifiers, kw, node, context, Object.assign(Object.assign({}, options), { join: (0, actions_1.actionBodyJoiner)() }));
    }
    exports2.printGenericDefinition = printGenericDefinition;
    function printGenericOccurrenceDefinition(modifiers, kw, node, context, options = {}) {
      return (0, namespaces_1.printType)(modifiers === "auto" ? occurrenceDefinitionModifiers(node) : modifiers, kw, node, context, Object.assign(Object.assign({}, options), { join: (0, actions_1.actionBodyJoiner)() }));
    }
    exports2.printGenericOccurrenceDefinition = printGenericOccurrenceDefinition;
    function printOccurrenceUsageSubtype(keywords, node, context, options) {
      var _a;
      const hasIdentifier = node.declaredName || node.declaredShortName;
      const { suffix } = options;
      const appendToDeclaration = suffix === "default" ? (0, namespaces_1.featureValueAppender)(node, context) : (decl) => {
        if (suffix)
          decl.push(suffix);
      };
      const optionalKw = keywords.length > 1 ? keywords[keywords.length - 1] : void 0;
      let hasKw = Boolean(optionalKw);
      const required = hasKw ? keywords.slice(0, -1) : keywords;
      if (optionalKw && !hasIdentifier && ((_a = node.specializations().find((s) => !s.isImplied)) === null || _a === void 0 ? void 0 : _a.nodeType()) === ast2.ReferenceSubsetting) {
        const kw2 = (0, utils_2.formatPreserved)(node, options.format, "always", {
          find: (node2) => (0, langium_1.findNodeForKeyword)(node2, optionalKw.split(" ").at(-1)),
          choose: {
            always: () => optionalKw,
            as_needed: () => void 0,
            preserve: (found) => found ? "always" : "as_needed"
          }
        });
        hasKw = Boolean(kw2);
      }
      const kw = options.declarationOnly ? hasKw ? optionalKw : void 0 : (hasKw ? keywords : required).join(" ");
      return printGenericOccurrenceUsage(options.declarationOnly ? [] : "auto", kw, node, context, {
        skipFirstSpecializationKeyword: !hasKw,
        specializations: (node2) => {
          if (hasKw)
            return (0, namespaces_1.defaultSpecializationGrouper)(context)(node2);
          const explicit = node2.specializations().filter((s) => !s.isImplied);
          return [[explicit[0]], explicit.slice(1)];
        },
        appendToDeclaration,
        skipChildren: Boolean(options.declarationOnly),
        forceBrackets: options.forceBrackets,
        join: options.join,
        ignoreRef: options.ignoreRef
      });
    }
    exports2.printOccurrenceUsageSubtype = printOccurrenceUsageSubtype;
    function printAssertConstraint(node, context, declarationOnly) {
      return printOccurrenceUsageSubtype([node.isNegated ? "assert not" : "assert", "constraint"], node, context, {
        format: context.format.assert_constraint_usage_keyword,
        suffix: void 0,
        declarationOnly
      });
    }
    exports2.printAssertConstraint = printAssertConstraint;
    function printEventOccurrence(node, context, declarationOnly) {
      return printOccurrenceUsageSubtype(["event", "occurrence"], node, context, {
        format: context.format.event_occurrence_keyword,
        declarationOnly,
        suffix: "default",
        ignoreRef: (0, utils_2.shouldIgnoreRef)(node, context.format.event_occurrence_reference_keyword)
      });
    }
    exports2.printEventOccurrence = printEventOccurrence;
    function printExhibitState(node, context, declarationOnly) {
      let suffix = "default";
      if (node.isParallel) {
        suffix = [];
        if (node.value) {
          suffix.push(utils_1.literals.space, (0, print_1.printModelElement)(node.value, context));
        }
        suffix.push((0, utils_1.indent)([utils_1.line, (0, utils_1.keyword)("parallel")]));
      }
      return printOccurrenceUsageSubtype(["exhibit", "state"], node, context, {
        format: context.format.exhibit_state_usage_keyword,
        declarationOnly,
        suffix,
        forceBrackets: node.isParallel,
        join: (0, actions_1.actionBodyJoiner)(),
        ignoreRef: (0, utils_2.shouldIgnoreRef)(node, context.format.exhibit_state_reference_keyword)
      });
    }
    exports2.printExhibitState = printExhibitState;
    function printIncludeUseCase(node, context, declarationOnly) {
      return printOccurrenceUsageSubtype(["include", "use case"], node, context, {
        format: context.format.include_use_case_usage_keyword,
        declarationOnly,
        suffix: "default",
        ignoreRef: (0, utils_2.shouldIgnoreRef)(node, context.format.include_use_case_reference_keyword)
      });
    }
    exports2.printIncludeUseCase = printIncludeUseCase;
    function printPerformAction(node, context, declarationOnly) {
      return printOccurrenceUsageSubtype(["perform", "action"], node, context, {
        format: context.format.perform_action_usage_keyword,
        declarationOnly,
        suffix: "default",
        ignoreRef: (0, utils_2.shouldIgnoreRef)(node, context.format.perform_action_reference_keyword)
      });
    }
    exports2.printPerformAction = printPerformAction;
    function printSatisfyRequirement(node, context, declarationOnly) {
      var _a;
      const suffix = [];
      if (node.value)
        suffix.push(utils_1.literals.space, (0, print_1.printModelElement)(node.value, context));
      if (node.satisfactionSubject) {
        const subjectValue = (_a = node.satisfactionSubject.element()) === null || _a === void 0 ? void 0 : _a.value;
        if (!subjectValue)
          (0, utils_2.throwError)(node.satisfactionSubject, "Invalid satisfaction subject - target element doesn't have value");
        suffix.push(utils_1.line, (0, utils_1.keyword)("by "), (0, utils_1.indent)((0, edges_1.printTarget)(subjectValue, context)));
      }
      const assert = (0, utils_2.formatPreserved)(node, context.format.satisfy_requirement_assert_keyword, "always", {
        find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "assert"),
        choose: {
          always: () => "assert ",
          never: () => "",
          preserve: (found) => found ? "always" : "never"
        }
      });
      return printOccurrenceUsageSubtype([assert + (node.isNegated ? "not satisfy" : "satisfy"), "requirement"], node, context, {
        format: context.format.satisfy_requirement_keyword,
        suffix: (0, utils_1.indent)((0, utils_1.group)(suffix)),
        declarationOnly
      });
    }
    exports2.printSatisfyRequirement = printSatisfyRequirement;
    function printEnumerationUsage(node, context) {
      var _a;
      if (!((_a = node.owner()) === null || _a === void 0 ? void 0 : _a.is(ast2.EnumerationDefinition)))
        return printGenericUsage("auto", "enum", node, context, {
          appendToDeclaration: (0, namespaces_1.featureValueAppender)(node, context),
          ignoreRef: (0, utils_2.shouldIgnoreRef)(node, context.format.attribute_usage_reference_keyword)
        });
      const kw = (0, utils_2.formatPreserved)(node, context.format.enum_member_keyword, "always", {
        find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "enum"),
        choose: {
          always: () => (0, utils_1.keyword)("enum"),
          never: () => utils_1.literals.emptytext,
          preserve: (found) => found ? "always" : "never"
        }
      });
      return printGenericUsage("auto", kw === utils_1.literals.emptytext ? void 0 : kw.contents, node, context, { appendToDeclaration: (0, namespaces_1.featureValueAppender)(node, context), ignoreRef: true });
    }
    exports2.printEnumerationUsage = printEnumerationUsage;
    function printOccurrenceDefinition(node, context) {
      let kw;
      if (node.isIndividual)
        kw = (0, utils_2.formatPreserved)(node, context.format.occurrence_keyword, "always", {
          find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "occurrence"),
          choose: {
            always: () => "occurrence def",
            as_needed: () => "def",
            preserve: (found) => found ? "always" : "as_needed"
          }
        });
      else
        kw = "occurrence def";
      return printGenericOccurrenceDefinition("auto", kw, node, context);
    }
    exports2.printOccurrenceDefinition = printOccurrenceDefinition;
    function printOccurrenceUsage(node, context) {
      let kw;
      if (node.isIndividual || node.portionKind)
        kw = (0, utils_2.formatPreserved)(node, context.format.occurrence_keyword, "always", {
          find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "occurrence"),
          choose: {
            always: () => "occurrence",
            as_needed: () => void 0,
            preserve: (found) => found ? "always" : "as_needed"
          }
        });
      else
        kw = "occurrence";
      return printGenericOccurrenceUsage("auto", kw, node, context);
    }
    exports2.printOccurrenceUsage = printOccurrenceUsage;
    function printPortUsage(node, context) {
      var _a, _b, _c;
      if (node.isEndExplicitly && ((_a = node.parent()) === null || _a === void 0 ? void 0 : _a.is(ast2.FeatureMembership)) && ((_b = node.owner()) === null || _b === void 0 ? void 0 : _b.isAny(ast2.InterfaceDefinition, ast2.InterfaceUsage)) && (0, utils_2.formatPreserved)(node, context.format.interface_port_keyword, "always", {
        find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "port"),
        choose: {
          always: () => (0, utils_1.keyword)("port"),
          never: () => utils_1.literals.emptytext,
          preserve: (found) => found ? "always" : "never"
        }
      }) === utils_1.literals.emptytext) {
        return (0, namespaces_1.printGenericFeature)([(0, utils_1.keyword)("end")], void 0, void 0, node, context);
      }
      return printGenericOccurrenceUsage("auto", "port", node, context, {
        appendToDeclaration: (0, namespaces_1.featureValueAppender)(node, context),
        ignoreRef: ((_c = node.owningType) === null || _c === void 0 ? void 0 : _c.isAny(ast2.PortUsage, ast2.PortDefinition)) ? false : (0, utils_2.shouldIgnoreRef)(node, context.format.port_usage_reference_keyword)
      });
    }
    exports2.printPortUsage = printPortUsage;
    function printReferenceUsage(node, context) {
      var _a, _b, _c;
      let refKw;
      const getKw = () => {
        if (refKw === void 0) {
          refKw = (0, utils_2.formatPreserved)(node, context.format.reference_usage_keyword, "always", {
            find: (node2) => (0, langium_1.findNodeForKeyword)(node2, "ref"),
            choose: {
              always: () => "ref",
              as_needed: () => "missing",
              preserve: (found) => found ? "always" : "as_needed"
            }
            // seems like there's a bug in typescript inference which adds
            // `preserve` return types to actual return types
          });
        }
        return refKw === "missing" ? void 0 : refKw;
      };
      if (((_a = node.parent()) === null || _a === void 0 ? void 0 : _a.nodeType()) === ast2.VariantMembership && canPrintShorthandUsage(node, ast2.ReferenceSubsetting) && !getKw()) {
        return printShorthandUsage(node, context);
      }
      return printGenericUsage(
        "auto",
        // DefaultReferenceUsage cannot be used in variant memberships and as
        // interface members
        ((_b = node.parent()) === null || _b === void 0 ? void 0 : _b.nodeType()) === ast2.VariantMembership || ((_c = node.owner()) === null || _c === void 0 ? void 0 : _c.isAny(ast2.InterfaceDefinition, ast2.InterfaceUsage)) ? "ref" : getKw(),
        node,
        context
      );
    }
    exports2.printReferenceUsage = printReferenceUsage;
    function canPrintShorthandUsage(node, firstSpec = ast2.ReferenceSubsetting) {
      var _a;
      return node.prefixes.length === 0 && sysmlUsageModifiers(node).length === 0 && !node.value && !node.declaredName && !node.declaredShortName && !node.multiplicity && !node.isOrderedExplicitly && !node.isNonUnique && ((_a = node.specializations().find((s) => !s.isImplied)) === null || _a === void 0 ? void 0 : _a.nodeType()) === firstSpec;
    }
    exports2.canPrintShorthandUsage = canPrintShorthandUsage;
    function printShorthandUsage(node, context) {
      return [
        (0, namespaces_1.printSpecializationPart)(node, context, {
          skipFirstKeyword: true,
          specializations(node2) {
            const explicit = node2.specializations().filter((s) => !s.isImplied);
            return [[explicit[0]], explicit.slice(1)];
          },
          ignoreMultiplicity: true
        }),
        (0, namespaces_1.printChildrenBlock)(node, node.children, context, {
          insertSpaceBeforeBrackets: true
        })
      ];
    }
    exports2.printShorthandUsage = printShorthandUsage;
    function printAttributeUsage(node, context) {
      return printGenericUsage("auto", "attribute", node, context, {
        appendToDeclaration: (0, namespaces_1.featureValueAppender)(node, context),
        ignoreRef: (0, utils_2.shouldIgnoreRef)(node, context.format.attribute_usage_reference_keyword)
      });
    }
    exports2.printAttributeUsage = printAttributeUsage;
    function printSysmlOwnedCrossFeature(node, context) {
      return (0, namespaces_1.printOwnedCrossFeaturePart)(node, (node2) => usageBasicModifiers(node2, true), context);
    }
    exports2.printSysmlOwnedCrossFeature = printSysmlOwnedCrossFeature;
  }
});

// ../syside-languageserver/lib/model/printer/actions.js
var require_actions = __commonJS({
  "../syside-languageserver/lib/model/printer/actions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.actionBodyJoiner = exports2.printTerminateAction = exports2.printStateUsage = exports2.printStateDefinition = exports2.printStateSubactionMembership = exports2.printSubaction = exports2.printSendAction = exports2.printIfAction = exports2.printForLoop = exports2.printWhileLoop = exports2.printCondition = exports2.printControlNode = exports2.printAcceptActionUsage = exports2.printAccepterParameterPart = exports2.printAssignmentAction = void 0;
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var KerML_1 = require_KerML();
    var definition_usages_1 = require_definition_usages();
    var edges_1 = require_edges();
    var expressions_1 = require_expressions4();
    var namespaces_1 = require_namespaces();
    var print_1 = require_print3();
    var successions_1 = require_successions();
    var utils_2 = require_utils3();
    function printNodeParameter(node, prop, context, kind = "node parameter") {
      return (0, utils_2.printDescendant)(node, context, kind).descend((node2) => node2[prop]).descend((param) => param.element()).descend((target) => target.value).descend((fv) => fv.element()).print();
    }
    function printPayloadParameter(node, prop, context, kind = "payload parameter") {
      return (0, utils_2.printDescendant)(node, context, kind).descend((node2) => node2[prop]).descend((member) => member.element()).print({
        printer(param, context2) {
          var _a;
          return (0, namespaces_1.printGenericNamespace)(param, context2, {
            modifiers: [],
            keyword: void 0,
            skipChildren: true,
            skipFirstSpecializationKeyword: Boolean(!param.declaredName && !param.declaredShortName && param.specializations().filter((s) => !s.isImplied).length === 1 && ((_a = param.specializations().find((s) => !s.isImplied)) === null || _a === void 0 ? void 0 : _a.is(ast_1.FeatureTyping)) && !param.value),
            appendToDeclaration: (0, namespaces_1.featureValueAppender)(param, context2)
          });
        }
      });
    }
    function printActionSubtype(node, context, options) {
      return (0, definition_usages_1.printGenericOccurrenceUsage)(options.declarationOnly ? [] : "auto", (0, utils_2.selectDeclarationKeyword)(node, "action", context.format.action_node_keyword), node, context, {
        appendToDeclaration(declaration) {
          const suffix = options.suffix ? (0, utils_1.group)([(0, utils_1.keyword)(options.keyword), utils_1.literals.space, (0, utils_1.group)(options.suffix)]) : (0, utils_1.keyword)(options.keyword);
          if (declaration.length > 0)
            declaration.push((0, utils_1.group)([
              (0, utils_1.indent)(utils_1.line),
              (0, utils_1.indentIfBreak)(suffix, { groupId: "action-subtype-suffix" })
            ], {
              id: "action-subtype-suffix"
            }));
          else
            declaration.push(suffix);
        },
        skipChildren: options.declarationOnly,
        join: actionBodyJoiner()
      });
    }
    function printAssignmentAction(node, context, declarationOnly) {
      var _a, _b, _c, _d, _e;
      const suffix = [];
      const target = (_c = (_b = (_a = node.target) === null || _a === void 0 ? void 0 : _a.element()) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.element();
      if (target)
        suffix.push((0, utils_2.printDescendant)(node, context, "assignment action target").descend((node2) => node2.target).descend((node2) => node2.element()).descend((node2) => node2.value).descend((node2) => node2.element()).print(), (0, utils_1.indent)([utils_1.softline, utils_1.literals.dot]));
      if (!node.targetMember)
        (0, utils_2.throwError)(node, "Invalid assignment action - missing target member");
      suffix.push((0, edges_1.printAsTarget)(node.targetMember, context, {
        printer(node2, context2) {
          var _a2;
          if ((_a2 = node2.parent()) === null || _a2 === void 0 ? void 0 : _a2.is(ast_1.OwningMembership))
            return (0, utils_1.indent)((0, edges_1.printChaining)(node2, context2));
          return (0, print_1.DefaultElementPrinter)(node2, context2);
        }
      }));
      (0, utils_2.assertMember)(node, node.assignedValue, "assignment action", "assigned value");
      suffix.push((0, edges_1.printAssignmentExpression)([utils_1.literals.space, (0, utils_1.text)(":=")], (_e = (_d = node.assignedValue) === null || _d === void 0 ? void 0 : _d.element().value) === null || _e === void 0 ? void 0 : _e.element(), context, printNodeParameter(node, "assignedValue", context, "assigned value")));
      return printActionSubtype(node, context, {
        suffix,
        keyword: "assign",
        declarationOnly
      });
    }
    exports2.printAssignmentAction = printAssignmentAction;
    function printAccepterParameterPart(node, context) {
      const suffix = [printPayloadParameter(node, "payload", context)];
      if (!node.receiver.isImplied)
        suffix.push((0, utils_1.indent)([
          utils_1.line,
          (0, utils_1.keyword)("via "),
          printNodeParameter(node, "receiver", context, "receiver")
        ]));
      return suffix;
    }
    exports2.printAccepterParameterPart = printAccepterParameterPart;
    function printAcceptActionUsage(node, context, declarationOnly) {
      return printActionSubtype(node, context, {
        suffix: printAccepterParameterPart(node, context),
        keyword: "accept",
        declarationOnly
      });
    }
    exports2.printAcceptActionUsage = printAcceptActionUsage;
    function printControlNode(kw, node, context) {
      (0, print_1.assertSysML)(context, node.nodeType());
      const modifiers = (0, definition_usages_1.basicOccurrenceUsageModifiers)(node);
      return (0, namespaces_1.printGenericFeature)(modifiers, kw, void 0, node, context, {
        join: actionBodyJoiner(),
        appendToDeclaration: (0, namespaces_1.featureValueAppender)(node, context)
      });
    }
    exports2.printControlNode = printControlNode;
    function printControlFlow(node, context, options) {
      return (0, definition_usages_1.printGenericOccurrenceUsage)("auto", (0, utils_2.selectDeclarationKeyword)(node, "action", context.format.action_node_keyword), node, context, {
        appendToDeclaration(declaration) {
          if (declaration.length > 0)
            declaration.push(utils_1.line);
          declaration.push(options.suffix);
        },
        skipChildren: true
      });
    }
    function printActionBodyParameter(node, prop, context, options) {
      return (0, utils_2.printDescendant)(node, context, options.kind).descend((node2) => node2[prop]).descend((member) => member.element()).print({
        printer(param, context2) {
          const kw = (0, utils_2.selectDeclarationKeyword)(param, "action", context2.format.action_node_keyword);
          let body = (0, namespaces_1.printGenericFeature)([], kw, void 0, param, context2, {
            forceBrackets: true,
            appendToDeclaration() {
            },
            forceBreakChildren: options.mustBreak,
            join: actionBodyJoiner()
          });
          if (options.mustBreak)
            body = (0, utils_1.ifBreak)(body, (0, utils_1.group)(body));
          if (kw) {
            return [(0, utils_1.indent)(utils_1.line), body];
          }
          return [utils_1.literals.space, body];
        }
      });
    }
    function printCondition(kw, edge, context, parenthesize) {
      let expr;
      let target;
      if (edge.is(ast_1.OwningMembership)) {
        expr = (0, edges_1.printTarget)(edge, context);
        target = edge.element();
      } else {
        expr = (0, print_1.printModelElement)(edge, context);
        target = edge;
      }
      if ((0, expressions_1.getOperator)(target) === KerML_1.OPERATORS.COMMA)
        parenthesize = "never";
      if (parenthesize === "always") {
        expr = (0, utils_1.group)([
          utils_1.brackets.round.open,
          (0, utils_1.indent)([utils_1.softline, expr]),
          utils_1.softline,
          utils_1.brackets.round.close
        ]);
      } else if (parenthesize === "on_break") {
        expr = (0, utils_1.group)([
          (0, utils_1.ifBreak)(utils_1.brackets.round.open, utils_1.literals.emptytext),
          (0, utils_1.indent)([utils_1.softline, expr]),
          utils_1.softline,
          (0, utils_1.ifBreak)(utils_1.brackets.round.close, utils_1.literals.emptytext)
        ]);
      }
      if (parenthesize !== "never") {
        return [
          kw,
          (0, utils_1.group)((0, utils_1.indent)(utils_1.line), { id: "condition" }),
          (0, utils_1.indentIfBreak)(expr, { groupId: "condition" })
        ];
      }
      return (0, edges_1.printAssignmentExpression)([kw], target, context, expr);
    }
    exports2.printCondition = printCondition;
    function printWhileLoop(node, context) {
      var _a;
      const suffix = [];
      const body = printActionBodyParameter(node, "body", context, {
        kind: "while loop body parameter",
        mustBreak: node.until !== void 0
      });
      if (!node.condition || !((_a = node.condition.element()) === null || _a === void 0 ? void 0 : _a.is(ast_1.Expression))) {
        suffix.push((0, utils_1.keyword)("loop "), body[1]);
      } else {
        suffix.push((0, utils_1.group)(printCondition((0, utils_1.keyword)("while"), node.condition, context, context.format.while_loop_parenthesize_condition)), body);
      }
      if (node.until) {
        suffix.push((0, utils_1.group)([
          printCondition((0, utils_1.keyword)(" until"), node.until, context, context.format.while_loop_parenthesize_until),
          (0, utils_1.text)(";")
        ]));
      }
      return printControlFlow(node, context, { suffix: (0, utils_1.group)(suffix) });
    }
    exports2.printWhileLoop = printWhileLoop;
    function printForLoop(node, context) {
      return (0, utils_2.printDescendant)(node, context, "for loop").descend((node2) => node2.variable).descend((member) => member.element()).print({
        printer(variable, context2) {
          const suffix = [];
          suffix.push((0, namespaces_1.printGenericFeature)([], void 0, void 0, variable, context2, {
            appendToDeclaration() {
            },
            skipChildren: true
          }), utils_1.line, (0, utils_1.keyword)("in "), printNodeParameter(node, "sequence", context2, "for loop sequence"));
          return printControlFlow(node, context2, {
            suffix: (0, utils_1.group)([
              (0, utils_1.keyword)("for "),
              (0, utils_1.group)((0, utils_1.indent)(suffix)),
              printActionBodyParameter(node, "body", context2, {
                kind: "for loop body",
                mustBreak: false
              })
            ])
          });
        }
      });
    }
    exports2.printForLoop = printForLoop;
    function printIfAction(node, context) {
      var _a, _b;
      const suffix = [];
      const elseBranch = (_a = node.else) === null || _a === void 0 ? void 0 : _a.element();
      if (!node.condition)
        (0, utils_2.throwError)(node, "Invalid if action - missing condition");
      suffix.push((0, utils_1.group)(printCondition((0, utils_1.keyword)("if"), node.condition, context, context.format.if_parenthesize_condition)), printActionBodyParameter(node, "then", context, {
        kind: "if then branch",
        mustBreak: Boolean(elseBranch) || ((_b = node.owner()) === null || _b === void 0 ? void 0 : _b.nodeType()) === ast_1.IfActionUsage
      }));
      if (elseBranch) {
        suffix.push((0, utils_1.keyword)(" else"));
        if (elseBranch.is(ast_1.IfActionUsage)) {
          suffix.push(utils_1.literals.space, printIfAction(elseBranch, context));
        } else {
          suffix.push(printActionBodyParameter(node, "else", context, {
            kind: "if else branch",
            mustBreak: true
          }));
        }
      }
      return printControlFlow(node, context, { suffix: (0, utils_1.group)(suffix) });
    }
    exports2.printIfAction = printIfAction;
    function printSendAction(node, context, declarationOnly) {
      const suffix = [];
      suffix.push(printNodeParameter(node, "payload", context, "payload"));
      if (!node.sender.isImplied)
        suffix.push((0, utils_1.indent)([utils_1.line, (0, utils_1.keyword)("via "), printNodeParameter(node, "sender", context)]));
      if (!node.receiver.isImplied)
        suffix.push((0, utils_1.indent)([utils_1.line, (0, utils_1.keyword)("to "), printNodeParameter(node, "receiver", context)]));
      return printActionSubtype(node, context, {
        keyword: "send",
        suffix,
        declarationOnly
      });
    }
    exports2.printSendAction = printSendAction;
    function printSubaction(node, context, semicolon = utils_1.literals.semicolon) {
      const decl = (() => {
        switch (node.nodeType()) {
          case ast_1.PerformActionUsage:
            return (0, definition_usages_1.printPerformAction)(node, context, true);
          case ast_1.AcceptActionUsage:
            return printAcceptActionUsage(node, context, true);
          case ast_1.SendActionUsage:
            return printSendAction(node, context, true);
          case ast_1.AssignmentActionUsage:
            return printAssignmentAction(node, context, true);
          default:
            return;
        }
      })();
      if (!decl)
        return semicolon;
      return (0, print_1.printModelElement)(node, context, {
        printer: (node2, context2) => (0, utils_1.group)([
          decl,
          (0, namespaces_1.printChildrenBlock)(node2, node2.children, context2, {
            insertSpaceBeforeBrackets: true,
            semicolon,
            result: node2.result,
            join: actionBodyJoiner()
          })
        ])
      });
    }
    exports2.printSubaction = printSubaction;
    function printStateSubactionMembership(node, context) {
      (0, print_1.assertSysML)(context, node.nodeType());
      const target = (0, print_1.printModelElement)(node.element(), context, {
        printer: (node2, ctx) => printSubaction(node2, ctx)
      });
      const contents = target === utils_1.literals.semicolon ? [(0, utils_1.keyword)(node.kind), utils_1.literals.semicolon] : [(0, utils_1.keyword)(node.kind), utils_1.literals.space, target];
      return (0, edges_1.printWithVisibility)(node, contents, context);
    }
    exports2.printStateSubactionMembership = printStateSubactionMembership;
    function printStateDefinition(node, context) {
      return (0, definition_usages_1.printGenericOccurrenceDefinition)("auto", "state def", node, context, {
        appendToDeclaration(declaration) {
          if (node.isParallel)
            declaration.push([utils_1.line, (0, utils_1.keyword)("parallel")]);
        },
        forceBrackets: node.isParallel
      });
    }
    exports2.printStateDefinition = printStateDefinition;
    function printStateUsage(node, context) {
      return (0, definition_usages_1.printGenericOccurrenceUsage)("auto", "state", node, context, {
        appendToDeclaration(declaration) {
          if (node.isParallel)
            declaration.push([utils_1.line, (0, utils_1.keyword)("parallel")]);
        },
        forceBrackets: node.isParallel
      });
    }
    exports2.printStateUsage = printStateUsage;
    function printTerminateAction(node, context, declarationOnly) {
      const suffix = node.terminatedOccurrence ? printNodeParameter(node, "terminatedOccurrence", context) : void 0;
      return printActionSubtype(node, context, {
        keyword: "terminate",
        suffix,
        declarationOnly
      });
    }
    exports2.printTerminateAction = printTerminateAction;
    function actionBodyJoiner() {
      const state = {
        stack: [],
        continuation: void 0
      };
      const applyIndent = (doc) => {
        return state.stack.reduce((doc2) => (0, utils_1.indent)(doc2), doc);
      };
      const advance = (child, index, doc, previous) => {
        var _a, _b, _c;
        let target = child;
        if (target.is(ast_1.OwningMembership))
          target = target.element();
        if (state.continuation) {
          const continuation = state.continuation;
          state.continuation = void 0;
          if (doc)
            doc = [continuation, (0, utils_1.group)((0, utils_1.indent)(utils_1.line)), doc];
          index--;
        } else {
          switch (target.nodeType()) {
            case ast_1.TransitionUsage: {
              if (target.source) {
                state.stack.length = 0;
                break;
              }
              if (target.else && ((_a = state.stack.at(-1)) === null || _a === void 0 ? void 0 : _a.type) === ast_1.DecisionNode) {
                state.stack[state.stack.length - 1].isDone = true;
                break;
              }
              if ((_b = state.stack.at(-1)) === null || _b === void 0 ? void 0 : _b.isDone)
                state.stack.pop();
              break;
            }
            case ast_1.SuccessionAsUsage: {
              const kind = (0, successions_1.successionAsUsageKind)(target, previous);
              if (kind === "regular")
                state.stack.length = 0;
              else if ((_c = state.stack.at(-1)) === null || _c === void 0 ? void 0 : _c.isDone)
                state.stack.pop();
              if (kind === "empty") {
                state.continuation = doc;
                return;
              }
              break;
            }
            default: {
              state.stack.length = 0;
              break;
            }
          }
        }
        if (doc) {
          if (index !== 0)
            doc = applyIndent([utils_1.hardline, doc]);
        }
        if (target.is(ast_1.ControlNode)) {
          const type = target.nodeType();
          if (type === ast_1.DecisionNode || type === ast_1.ForkNode)
            state.stack.push({
              type,
              isDone: false
            });
        }
        return doc;
      };
      return function(children, docs, leading) {
        leading === null || leading === void 0 ? void 0 : leading.forEach((e, i) => advance(e, 0, void 0, i > 0 ? leading[i - 1] : void 0));
        return children.map((child, i) => advance(child, i, docs[i], i === 0 ? leading === null || leading === void 0 ? void 0 : leading.at(-1) : children[i - 1])).filter(utils_1.NonNullable);
      };
    }
    exports2.actionBodyJoiner = actionBodyJoiner;
  }
});

// ../syside-languageserver/lib/model/printer/index.js
var require_printer2 = __commonJS({
  "../syside-languageserver/lib/model/printer/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_actions(), exports2);
    __exportStar(require_annotating_elements(), exports2);
    __exportStar(require_connectors(), exports2);
    __exportStar(require_definition_usages(), exports2);
    __exportStar(require_edges(), exports2);
    __exportStar(require_expressions4(), exports2);
    __exportStar(require_format_options(), exports2);
    __exportStar(require_namespaces(), exports2);
    __exportStar(require_print3(), exports2);
    __exportStar(require_successions(), exports2);
    __exportStar(require_utils3(), exports2);
  }
});

// ../syside-languageserver/lib/model/util.js
var require_util3 = __commonJS({
  "../syside-languageserver/lib/model/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prettyAnnotationBody = void 0;
    function prettyAnnotationBody(body, isMarkdown = true) {
      body = body.trim();
      body = body.replace("/*", "").trimStart();
      if (body.endsWith("*/"))
        body = body.substring(0, body.length - 2).trimEnd();
      const lines = body.split(/\r?\n/);
      lines.forEach((line, index) => {
        line = isMarkdown ? line.trimLeft() : line.trim();
        if (line.startsWith("*")) {
          line = line.replace(/^\* ?/, "");
        }
        lines[index] = line;
      });
      return lines.join("\n");
    }
    exports2.prettyAnnotationBody = prettyAnnotationBody;
  }
});

// ../syside-languageserver/lib/model/index.js
var require_model3 = __commonJS({
  "../syside-languageserver/lib/model/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_KerML(), exports2);
    __exportStar(require_SysML(), exports2);
    __exportStar(require_containers2(), exports2);
    __exportStar(require_enums(), exports2);
    __exportStar(require_expressions3(), exports2);
    __exportStar(require_implicits(), exports2);
    __exportStar(require_metamodel(), exports2);
    __exportStar(require_mixins2(), exports2);
    __exportStar(require_naming(), exports2);
    __exportStar(require_notes(), exports2);
    __exportStar(require_printer2(), exports2);
    __exportStar(require_semantic_tokens(), exports2);
    __exportStar(require_types2(), exports2);
    __exportStar(require_util3(), exports2);
  }
});

// ../syside-languageserver/lib/services/validation/validation-registry.js
var require_validation_registry2 = __commonJS({
  "../syside-languageserver/lib/services/validation/validation-registry.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseValidationRegistry = exports2.validateSysML = exports2.validateKerML = exports2.ValidationRules = void 0;
    var langium_1 = require_lib2();
    var vscode_languageserver_1 = require_main4();
    var model_1 = require_model3();
    exports2.ValidationRules = {
      kerml: {},
      sysml: {}
    };
    function validate(type, kerml = true, sysml = true, bounds = []) {
      const add = (checks, check, bounds2) => {
        var _a, _b;
        (_b = (_a = checks[type]) !== null && _a !== void 0 ? _a : checks[type] = []) === null || _b === void 0 ? void 0 : _b.push({ rule: check, bounds: bounds2 });
      };
      return function(_, __, descriptor) {
        const value = descriptor.value;
        if (!value)
          return;
        if (kerml)
          add(exports2.ValidationRules.kerml, value, bounds);
        if (sysml)
          add(exports2.ValidationRules.sysml, value, bounds);
      };
    }
    function validateKerML(type, options = {}) {
      var _a, _b;
      return validate(type, true, (_a = options.sysml) !== null && _a !== void 0 ? _a : true, (_b = options.bounds) !== null && _b !== void 0 ? _b : []);
    }
    exports2.validateKerML = validateKerML;
    function validateSysML(type, bounds = []) {
      return validate(type, false, true, bounds);
    }
    exports2.validateSysML = validateSysML;
    var BaseValidationRegistry = class extends langium_1.ValidationRegistry {
      constructor() {
        super(...arguments);
        this.checks = new langium_1.MultiMap();
      }
      registerBoundRules(rules, thisObj) {
        for (const [type, checks] of Object.entries(rules)) {
          for (const check of checks) {
            this.registerModelValidationRule(type, check.rule, thisObj, check.bounds);
          }
        }
      }
      /**
       * Register a custom validation rule for all elements `type`
       * @deprecated use {@link registerModelValidationRule} instead
       * @param type element type this rule is for
       * @param check validation check for `type`
       * @param thisObj `this` parameter the `check` will be invoked with
       * @param bounds upper type bounds `check` applies to
       * @returns a `Disposable` object that removes `check` from this registry
       */
      registerValidationRule(type, check, thisObj = this, bounds = []) {
        return this.registerModelValidationRule(type, this.convertToModelCheck(check), thisObj, bounds);
      }
      /**
       * Register a custom validation rule for all elements `type`
       * @param type element type this rule is for
       * @param check validation check for `type`
       * @param thisObj `this` parameter the `check` will be invoked with
       * @param bounds upper type bounds `check` applies to
       * @returns a `Disposable` object that removes `check` from this registry
       */
      registerModelValidationRule(type, check, thisObj = this, bounds = []) {
        const types = [type].concat(Array.from(model_1.typeIndex.getSubtypes(type)).filter((subtype) => !bounds.some((bound) => this.astReflection.isSubtype(subtype, bound))));
        const wrapped = this.wrapModelValidationException(check, thisObj);
        types.forEach((type2) => {
          this.checks.add(type2, wrapped);
        });
        return vscode_languageserver_1.Disposable.create(() => {
          types.forEach((type2) => this.checks.delete(type2, wrapped));
        });
      }
      doRegister(type, check) {
        const modelCheck = this.convertToModelCheck(check);
        this.checks.add(type, modelCheck);
        for (const subtype of this.astReflection.getSubtypes(type)) {
          this.checks.add(subtype, modelCheck);
        }
      }
      get astReflection() {
        return this["reflection"];
      }
      convertToModelCheck(check) {
        return (element, accept, token) => {
          const node = element.ast();
          const acceptor = (severity, message, info) => {
            accept(severity, message, Object.assign({ element: info.node.$meta }, this.getSharedInfo(info)));
          };
          if (node)
            return check(node, acceptor, token);
        };
      }
      wrapModelValidationException(check, thisObj) {
        return (element, accept, cancelToken) => __awaiter(this, void 0, void 0, function* () {
          try {
            yield check.call(thisObj, element, accept, cancelToken);
          } catch (err) {
            if ((0, langium_1.isOperationCancelled)(err)) {
              throw err;
            }
            console.error("An error occurred during validation:", err);
            const message = err instanceof Error ? err.message : String(err);
            if (err instanceof Error && err.stack) {
              console.error(err.stack);
            }
            accept("error", "An error occurred during validation: " + message, { element });
          }
        });
      }
      getChecks(type) {
        return this.getModelChecks(type).map((check) => (node, accept, token) => {
          return check(node.$meta, (severity, message, info) => {
            const node2 = info.element.ast();
            if (!node2)
              return;
            accept(severity, message, Object.assign({ node: node2 }, this.getSharedInfo(info)));
          }, token);
        });
      }
      getModelChecks(type) {
        return this.checks.get(type);
      }
      getSharedInfo(info) {
        return {
          code: info.code,
          codeDescription: info.codeDescription,
          data: info.data,
          index: info.index,
          keyword: info.keyword,
          property: info.property,
          range: info.range,
          relatedInformation: info.relatedInformation,
          tags: info.tags
        };
      }
    };
    exports2.BaseValidationRegistry = BaseValidationRegistry;
  }
});

// ../syside-languageserver/lib/services/validation/sysml-validation-registry.js
var require_sysml_validation_registry = __commonJS({
  "../syside-languageserver/lib/services/validation/sysml-validation-registry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLValidationRegistry = void 0;
    var validation_registry_1 = require_validation_registry2();
    var SysMLValidationRegistry = class extends validation_registry_1.BaseValidationRegistry {
      constructor(services) {
        super(services);
        const validator = services.validation.SysMLValidator;
        this.registerBoundRules(validation_registry_1.ValidationRules.sysml, validator);
      }
    };
    exports2.SysMLValidationRegistry = SysMLValidationRegistry;
  }
});

// ../syside-languageserver/lib/services/references/scope-computation.js
var require_scope_computation2 = __commonJS({
  "../syside-languageserver/lib/services/references/scope-computation.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLScopeComputation = void 0;
    var langium_1 = require_lib2();
    var vscode_languageserver_1 = require_main4();
    var ast_1 = require_ast2();
    var SysMLScopeComputation = class extends langium_1.DefaultScopeComputation {
      constructor(services) {
        super(services);
        this.descriptions = services.workspace.AstNodeDescriptionProvider;
      }
      /**
       * Compute global scope exports as {@link SysMLIndexManager} expects
       * @param document document to compute exports for
       * @param cancelToken optional cancellation token
       * @returns An array of exported elements with the first element to the root
       * namespace
       */
      computeExports(document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const exports3 = [
            this.descriptions.createDescription(document.parseResult.value, "", document)
          ];
          for (const node of document.parseResult.value.$children) {
            yield (0, langium_1.interruptAndCheck)(cancelToken);
            if ((0, ast_1.isMembership)(node)) {
              exports3.push(this.createDescription((_a = node.target) !== null && _a !== void 0 ? _a : node, document));
            }
          }
          return exports3;
        });
      }
      /**
       * Compute node local exports
       * @param document document to compute local exports for
       * @param cancelToken optional cancellation token
       * @returns MultiMap of AstNode exported children
       */
      computeLocalScopes(document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        return __awaiter(this, void 0, void 0, function* () {
          const model = document.parseResult.value;
          const scopes = new langium_1.MultiMap();
          yield this.processContainer(model, scopes, document, false, cancelToken);
          return scopes;
        });
      }
      /**
       * Recursively compute local exports
       * @param container current root AST node
       * @param scopes already computes local exports
       * @param document document that contains {@link container}
       * @param isStandardElement if true, {@link container} is owned by a
       * standard library package at any parent level
       * @param cancelToken cancellation token
       * @returns descriptions of exported elements by {@link container}
       */
      processContainer(container, scopes, document, isStandardElement, cancelToken) {
        return __awaiter(this, void 0, void 0, function* () {
          const localExports = [];
          isStandardElement || (isStandardElement = (0, ast_1.isLibraryPackage)(container) && container.isStandard);
          const meta = container.$meta;
          if (meta)
            meta.isStandardElement = isStandardElement;
          for (const element of container.$children) {
            yield (0, langium_1.interruptAndCheck)(cancelToken);
            const children = yield this.processContainer(element, scopes, document, isStandardElement, cancelToken);
            const extra = this.additionalExports(element, children);
            if (extra)
              localExports.push(...extra);
            if (!(0, ast_1.isElement)(element))
              continue;
            this.createDescription(element, document);
            if (element.$meta.is(ast_1.Membership))
              localExports.push(element.$meta);
          }
          scopes.addAll(container, (0, langium_1.stream)(localExports).map((m) => {
            var _a;
            return (_a = m.element()) === null || _a === void 0 ? void 0 : _a.description;
          }).nonNullable());
          if ((0, ast_1.isElement)(container)) {
            const meta2 = container.$meta;
            for (const member of localExports) {
              meta2["addLookupMember"](member);
            }
          }
          return localExports;
        });
      }
      /**
       * Construct export descriptions for {@link node}
       */
      createDescription(node, document) {
        var _a, _b;
        const regular = this.descriptions.createDescription(node, (_b = (_a = node.$meta.name) !== null && _a !== void 0 ? _a : node.$meta.shortName) !== null && _b !== void 0 ? _b : `${node.$meta.elementId}`, document);
        node.$meta["_description"] = regular;
        return regular;
      }
      /**
       * Compute additional exports to the parent scope
       * @param element child element
       * @param exports descriptions exported by {@link element}
       * @returns additionally exported element descriptions by {@link element} to
       * its parent scope
       */
      additionalExports(element, exports3) {
        if ((0, ast_1.isTransparentElement)(element))
          return exports3;
        return;
      }
    };
    exports2.SysMLScopeComputation = SysMLScopeComputation;
  }
});

// ../syside-languageserver/lib/services/references/name-provider.js
var require_name_provider2 = __commonJS({
  "../syside-languageserver/lib/services/references/name-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLNameProvider = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    var naming_1 = require_naming();
    var SysMLNameProvider = class extends langium_1.DefaultNameProvider {
      // overriding name provider methods since names can also be provided by the
      // short name
      getName(node) {
        if ((0, ast_1.isElement)(node)) {
          return (0, naming_1.getName)(node.$meta);
        }
        return void 0;
      }
      getNameNode(node) {
        var _a;
        return (_a = (0, langium_1.findNodeForProperty)(node.$cstNode, "declaredName")) !== null && _a !== void 0 ? _a : (0, langium_1.findNodeForProperty)(node.$cstNode, "declaredShortName");
      }
    };
    exports2.SysMLNameProvider = SysMLNameProvider;
  }
});

// ../syside-languageserver/lib/services/shared/workspace/document-builder.js
var require_document_builder2 = __commonJS({
  "../syside-languageserver/lib/services/shared/workspace/document-builder.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLDocumentBuilder = void 0;
    var langium_1 = require_lib2();
    var vscode_languageserver_1 = require_main4();
    var common_1 = require_common();
    var performance_now_1 = __importDefault(require_performance_now());
    var SysMLDocumentBuilder = class extends langium_1.DefaultDocumentBuilder {
      constructor(services) {
        super(services);
        this.openDocuments = /* @__PURE__ */ new Map();
        this.documentPhaseListeners = {
          [langium_1.DocumentState.Changed]: [],
          [langium_1.DocumentState.Parsed]: [],
          [langium_1.DocumentState.IndexedContent]: [],
          [langium_1.DocumentState.ComputedScopes]: [],
          [langium_1.DocumentState.Linked]: [],
          [langium_1.DocumentState.IndexedReferences]: [],
          [langium_1.DocumentState.Validated]: []
        };
        this.statistics = services.statistics;
        this.config = services.workspace.ConfigurationProvider;
        this.indexManager = services.workspace.IndexManager;
        const builder = services.workspace.MetamodelBuilder;
        this.onBuildPhase(langium_1.DocumentState.Parsed, (docs) => __awaiter(this, void 0, void 0, function* () {
          docs.forEach((d) => builder.onChanged(d));
        }));
        services.workspace.TextDocuments.onDidOpen((e) => {
          this.openDocuments.set(e.document.uri, (0, performance_now_1.default)());
        });
        services.workspace.TextDocuments.onDidClose((e) => {
          this.openDocuments.delete(e.document.uri);
        });
      }
      buildDocuments(documents, options, cancelToken) {
        return __awaiter(this, void 0, void 0, function* () {
          if (documents.length === 0)
            return;
          try {
            documents.forEach((doc) => doc.progress = 1);
            yield this.buildDocumentsImpl(documents, options, cancelToken);
            documents.forEach((doc) => doc.progress = 2);
          } catch (e) {
            documents.forEach((doc) => doc.progress = 3);
            throw e;
          }
        });
      }
      buildDocumentsImpl(documents, options, cancelToken) {
        const _super = Object.create(null, {
          buildDocuments: { get: () => super.buildDocuments }
        });
        return __awaiter(this, void 0, void 0, function* () {
          this.statistics.reset();
          options = (0, common_1.mergeWithPartial)(this.config.get().defaultBuildOptions, options);
          documents.forEach((doc) => {
            doc.buildOptions = options;
            doc.modelDiagnostics.clear();
          });
          if (this.config.get().logStatistics) {
            console.log(`Building documents:${documents.map((d) => `
	${d.uri.toString()} [${langium_1.DocumentState[d.state]}]`).join()}`);
          }
          yield _super.buildDocuments.call(this, documents, options, cancelToken);
          this.reportStats();
        });
      }
      /**
       * Print build time statistics to console
       */
      reportStats() {
        if (!this.config.get().logStatistics || this.statistics.isEmpty())
          return;
        const entries = Object.entries(this.statistics.dump());
        const stats = entries.map(([name, [elapsed, hits]]) => `
	${name}: ${elapsed.toFixed(3)} ms in ${hits} hits (avg: ${(elapsed / hits).toFixed(3)} ms)`);
        const total = entries.reduce((total2, [_, [elapsed, __]]) => total2 + elapsed, 0);
        console.log(`Build statistics ${total.toFixed(3)} ms:${stats}`);
      }
      runCancelable(documents, targetState, cancelToken, callback) {
        const _super = Object.create(null, {
          runCancelable: { get: () => super.runCancelable }
        });
        return __awaiter(this, void 0, void 0, function* () {
          const timer = new common_1.Timer();
          yield _super.runCancelable.call(this, documents, targetState, cancelToken, (doc) => __awaiter(this, void 0, void 0, function* () {
            yield callback(doc);
            this.notifyEarlyBuildPhase(doc, targetState);
          }));
          if (!this.config.get().logStatistics)
            return;
          console.log(`${cancelToken.isCancellationRequested ? "Canceled" : "Completed"} ${langium_1.DocumentState[targetState]} in ${timer.elapsed().toFixed(3)} ms`);
          if (targetState === langium_1.DocumentState.Parsed) {
            const docs = documents.filter((doc) => doc.state === langium_1.DocumentState.Parsed);
            const bytes = docs.reduce((total, doc) => total + doc.textDocument.getText().length, 0);
            const duration = docs.reduce((total, doc) => total + doc.parseDuration, 0);
            console.log("   Average parse speed:", (bytes / duration).toFixed(0), "bytes/ms");
          }
        });
      }
      /**
       * Notify listeners that {@link document} has reached {@link state}
       */
      notifyEarlyBuildPhase(document, state) {
        for (const listener of this.documentPhaseListeners[state]) {
          listener(document);
        }
      }
      update(changed, deleted, cancelToken) {
        const _super = Object.create(null, {
          update: { get: () => super.update }
        });
        return __awaiter(this, void 0, void 0, function* () {
          changed = changed.filter((uri) => {
            if (!this.langiumDocuments.hasDocument(uri))
              return true;
            const openingTime = this.openDocuments.get(uri.toString());
            if (!openingTime)
              return true;
            if ((0, performance_now_1.default)() - openingTime > 10)
              return true;
            const document = this.langiumDocuments.getOrCreateDocument(uri);
            return document.state < langium_1.DocumentState.Validated;
          });
          if (changed.length === 0 && deleted.length === 0)
            return;
          this.indexManager.invalidate(changed.concat(deleted));
          return _super.update.call(this, changed, deleted, cancelToken);
        });
      }
      /**
       * Register a listener on each built document reaching {@link targetState}.
       * Since listeners will be called after once for *each* document reaching
       * {@link targetState}, {@link callback} should not perform any long-running
       * tasks.
       * @param targetState State on which {@link callback} will be executed
       * @param callback
       * @returns Disposable that unregisters this callback
       */
      onDocumentPhase(targetState, callback) {
        this.documentPhaseListeners[targetState].push(callback);
        return vscode_languageserver_1.Disposable.create(() => {
          (0, common_1.erase)(this.documentPhaseListeners[targetState], callback);
        });
      }
    };
    exports2.SysMLDocumentBuilder = SysMLDocumentBuilder;
  }
});

// ../syside-languageserver/lib/services/references/linker.js
var require_linker2 = __commonJS({
  "../syside-languageserver/lib/services/references/linker.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLLinker = void 0;
    var langium_1 = require_lib2();
    var vscode_languageserver_1 = require_main4();
    var ast_1 = require_ast2();
    var types_1 = require_types2();
    var naming_1 = require_naming();
    var scope_util_1 = require_scope_util();
    var ast_util_1 = require_ast_util2();
    var utils_1 = require_utils2();
    var Linkers = {};
    function linker(type) {
      return function(_, __, descriptor) {
        Linkers[type] = descriptor.value;
      };
    }
    var SysMLLinker = class extends langium_1.DefaultLinker {
      constructor(services) {
        super(services);
        this.visitedAliases = /* @__PURE__ */ new Set();
        this.scopeProvider = services.references.ScopeProvider;
        this.referenceProvider = services.workspace.ReferenceDescriptionProvider;
        this.indexManager = services.shared.workspace.IndexManager;
        this.metamodelBuilder = services.shared.workspace.MetamodelBuilder;
        this.config = services.shared.workspace.ConfigurationProvider;
        this.linkFunctions = types_1.typeIndex.expandToDerivedTypes(Linkers);
      }
      link(document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.metamodelBuilder.preLink(void 0, document, cancelToken);
          for (const node of document.astNodes) {
            yield (0, langium_1.interruptAndCheck)(cancelToken);
            this.linkNode(node, document);
          }
          document.state = langium_1.DocumentState.Linked;
        });
      }
      /**
       * Generically link a specific {@link node}
       * @param node AST node to link
       * @param doc document that contains {@link node}
       * @returns the linked element or undefined
       */
      linkNode(node, doc) {
        const linker2 = this.linkFunctions.get(node.$type);
        return linker2 === null || linker2 === void 0 ? void 0 : linker2.call(this, node, doc);
      }
      /**
       * Link the imports owned by {@link node}
       * @param node namespace node to link imports for
       * @param document document that contains {@link node}
       */
      resolveImports(node, document) {
        if (!node.imports)
          return;
        let index = -1;
        for (const imp of node.imports) {
          ++index;
          const impNode = imp.ast();
          if (!impNode)
            continue;
          const imported = this.linkNode(impNode, document);
          if (!imported)
            continue;
          const ref = impNode.targetRef;
          if (imp.isRecursive || imp.is(ast_1.NamespaceImport)) {
            const namespace = imported.is(ast_1.Membership) ? imported.element() : imported;
            if (!namespace) {
              document.modelDiagnostics.add(imp, {
                severity: "error",
                // `namespace` is undefined only if `imported` has been
                // successfully resolved to an alias
                message: `Could not find Namespace referenced by ${ref === null || ref === void 0 ? void 0 : ref.$meta.text}`,
                element: imp,
                info: {
                  property: "targetRef",
                  index
                }
              });
            }
          }
        }
      }
      /**
       * Set linker error {@link value reference}
       * @param value reference to set error on
       * @param message error message
       */
      setLinkerError(value, message) {
        var _a;
        const ref = value;
        const error = {
          message,
          reference: value,
          container: value.ref.$container,
          property: (_a = value.ref.$containerProperty) !== null && _a !== void 0 ? _a : ""
        };
        ref._ref = error;
      }
      /**
       * Fully link {@link ref}
       * @param ref element reference node to link
       * @param document document that owns {@link ref}
       * @returns final reference of {@link ref} with aliases resolved or undefined
       */
      linkReference(ref, document) {
        const to = ref.$meta.to;
        if (to.cached)
          return to.target;
        let index = 0;
        for (const type of ref.parts) {
          this.doLink({
            reference: type,
            container: ref,
            property: "parts",
            index
          }, document);
          ++index;
          if (!type.ref)
            return void 0;
        }
        return to.target;
      }
      /**
       * Link a {@link FeatureReferenceExpression}
       * @returns the linked expression target or undefined
       */
      linkFeatureReferenceExpression(expr, document) {
        return this.linkNode(expr.expression, document);
      }
      linkMetadataAccessExpression(expr, document) {
        const target = this.linkReference(expr.reference, document);
        if (target)
          expr.$meta.reference = target;
        return target;
      }
      linkRelationship(node, document) {
        var _a;
        if (!node.targetRef)
          return (_a = node.target) === null || _a === void 0 ? void 0 : _a.$meta;
        const target = this.linkReference(node.targetRef, document);
        node.$meta["setElement"](target);
        return target;
      }
      linkMembership(node, document) {
        const meta = node.$meta;
        if (meta.element())
          return meta.element();
        if (this.visitedAliases.has(meta))
          return meta.element();
        const root = this.visitedAliases.size === 0;
        this.visitedAliases.add(meta);
        const target = this.linkRelationship(node, document);
        if (root)
          this.visitedAliases.clear();
        return target;
      }
      /**
       * @see {@link getCandidate}
       */
      getCandidateImp(refInfo) {
        var _a, _b, _c, _d;
        const container = refInfo.container.$meta;
        const index = (_a = refInfo.index) !== null && _a !== void 0 ? _a : 0;
        const scope = this.scopeProvider.getElementReferenceScope(container, index, this.getAliasResolver());
        if (!scope) {
          return this.createLinkingError(refInfo);
        }
        const name = (0, naming_1.sanitizeName)(refInfo.reference.$refText);
        let description = scope.getElement(name);
        if (!description) {
          return this.createLinkingError(refInfo);
        }
        const referenceType = this.reflection.getReferenceType(refInfo);
        let foundType = description.type;
        let target;
        const node = this.loadAstNode(description);
        if (description.type === ast_1.Membership && referenceType !== ast_1.Membership) {
          if (node) {
            target = this.linkMembership(node, node.$meta.document);
          }
        } else {
          target = node === null || node === void 0 ? void 0 : node.$meta;
        }
        container.found[index] = target;
        if (referenceType !== ast_1.Membership) {
          if (target === null || target === void 0 ? void 0 : target.is(ast_1.Membership)) {
            target = target.element();
          }
        }
        if (referenceType === ast_1.ConjugatedPortDefinition) {
          if (target === null || target === void 0 ? void 0 : target.is(ast_1.PortDefinition)) {
            target = (_b = target.conjugatedDefinition) === null || _b === void 0 ? void 0 : _b.element();
          }
        }
        if (target) {
          description = (_c = target.description) !== null && _c !== void 0 ? _c : description;
        }
        foundType = (_d = target === null || target === void 0 ? void 0 : target.nodeType()) !== null && _d !== void 0 ? _d : foundType;
        if (this.reflection.isSubtype(foundType, referenceType))
          return description;
        return this.createLinkingError(refInfo, void 0, { found: target, type: foundType });
      }
      getCandidate(refInfo) {
        try {
          return this.getCandidateImp(refInfo);
        } catch (err) {
          if (err === "unresolved reference") {
            return Object.assign(Object.assign({}, refInfo), { message: `Found an unresolved reference with name '${refInfo.reference.$refText}` });
          }
          if (err instanceof Error) {
            const linkingError = Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${err}` });
            if (this.config.get().debug.stacktraceInLinkingErrors) {
              linkingError.message += `
${err.stack}`;
            }
            return linkingError;
          }
          throw err;
        }
      }
      /**
       * @see {@link DefaultLinker.createLinkingError}
       * @param refInfo info on reference that failed to link
       * @param targetDescription doesn't seem to be used even by langium
       * @param unexpected additional context if a wrong type of element was found
       * @returns the constructed linking error
       */
      createLinkingError(refInfo, targetDescription, unexpected = {}) {
        var _a;
        const error = super.createLinkingError(refInfo, targetDescription);
        if (unexpected.type) {
          error.message = error.message.slice(0, -1) + `, instead found ${unexpected.type}`;
        }
        if (unexpected.found) {
          error.message += ` (${unexpected.found.qualifiedName})`;
        }
        if (unexpected.found || unexpected.type) {
          error.message += ".";
        }
        const extra = this.config.get().debug.scopeInLinkingErrors;
        if (!extra || extra === "none")
          return error;
        if (extra === "types") {
          const context = refInfo.index === 0 ? (_a = this.scopeProvider["getContext"](refInfo.container.$meta)) !== null && _a !== void 0 ? _a : refInfo.container.$meta.owner() : refInfo.container.$meta.found[refInfo.index - 1];
          if (!context || context === "error")
            return error;
          if (context.is(ast_1.Type))
            error.message += `
	MRO: [${context.allTypes(void 0, true).map((t) => `${t.qualifiedName} [${t.setupState}]`).join(",\n	      ")}].`;
          else {
            error.message += `
	NS:  [${(0, scope_util_1.streamParents)(context).map((m) => m.qualifiedName).join(",\n	      ")}].`;
          }
          return error;
        }
        const scope = this.scopeProvider.getElementReferenceScope(refInfo.container.$meta, refInfo.index, this.getAliasResolver());
        if (scope) {
          const names = scope.getAllElements().map((d) => `${d.name} [${d.node.$meta.qualifiedName}]`);
          error.message += `
Scope:
[
	${names.toArray().join(",\n	")}
]`;
        } else {
          error.message += " No scope found!";
        }
        return error;
      }
      doLink(refInfo, document) {
        var _a;
        super.doLink(refInfo, document);
        const ref = refInfo.container;
        const index = refInfo.index;
        let resolved = (_a = refInfo.reference.ref) === null || _a === void 0 ? void 0 : _a.$meta;
        if (index === ref.parts.length - 1) {
          if ((resolved === null || resolved === void 0 ? void 0 : resolved.is(ast_1.Membership)) && ref.$type !== ast_1.MembershipReference) {
            const ast2 = resolved.ast();
            resolved = ast2 ? this.linkMembership(ast2, resolved.document) : (0, ast_util_1.followAlias)(resolved);
          }
          if (ref.$type !== ast_1.MembershipReference && (resolved === null || resolved === void 0 ? void 0 : resolved.is(ast_1.Membership))) {
            resolved = resolved.element();
          }
          ref.$meta.to.set(resolved);
          if (resolved) {
            this.metamodelBuilder.onLinkedReference(ref, refInfo, document);
          }
        } else if (resolved) {
          this.metamodelBuilder.onLinkedPart(refInfo, document);
        }
      }
      getAliasResolver() {
        return (n) => {
          const node = n.ast();
          const target = n.element();
          if (!node || target || this.visitedAliases.has(n)) {
            return target;
          }
          return this.linkMembership(node, n.document);
        };
      }
      getLinkedNode(refInfo) {
        var _a, _b;
        const container = refInfo.container.$meta ? refInfo.container : (_a = refInfo.reference.$refNode) === null || _a === void 0 ? void 0 : _a.element;
        if (container) {
          const doc = container.$meta.document;
          if (doc) {
            this.metamodelBuilder.preLink(container.$container, doc, vscode_languageserver_1.CancellationToken.None);
            this.linkReference(container, doc);
            return {
              // don't use .ref here so it doesn't accidentally trigger
              // recursive linking
              node: (_b = refInfo.reference.$nodeDescription) === null || _b === void 0 ? void 0 : _b.node,
              descr: refInfo.reference.$nodeDescription,
              error: refInfo.reference.error
            };
          }
          const index = container.parts.indexOf(refInfo.reference);
          if (index >= 0)
            refInfo.index = index;
        }
        return super.getLinkedNode(refInfo);
      }
      buildReference(node, property, refNode, refText) {
        const linker2 = this;
        const reference = {
          $refNode: refNode,
          $refText: refText,
          get ref() {
            if ((0, ast_1.isElement)(this._ref)) {
              return this._ref;
            } else if ((0, langium_1.isAstNodeDescription)(this._nodeDescription)) {
              const linkedNode = linker2.loadAstNode(this._nodeDescription);
              this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker2.createLinkingError({
                reference,
                container: node,
                property,
                index: node.parts.indexOf(reference)
              }, this._nodeDescription);
            } else if (this._ref === void 0) {
              return void 0;
            }
            return (0, ast_1.isElement)(this._ref) ? this._ref : void 0;
          },
          get $nodeDescription() {
            return this._nodeDescription;
          },
          get error() {
            return (0, langium_1.isLinkingError)(this._ref) ? this._ref : void 0;
          }
        };
        return reference;
      }
      unlink(document) {
        document.astNodes.forEach((node) => {
          var _a;
          if (node.$meta)
            (0, utils_1.clearArtifacts)(node.$meta);
          if (!(0, ast_1.isElement)(node))
            return;
          const children = (_a = document.precomputedScopes) === null || _a === void 0 ? void 0 : _a.get(node);
          children === null || children === void 0 ? void 0 : children.forEach((child) => {
            var _a2;
            const meta = (_a2 = child.node) === null || _a2 === void 0 ? void 0 : _a2.$meta;
            if (!(meta === null || meta === void 0 ? void 0 : meta.is(ast_1.Membership)))
              return;
            node.$meta["_memberLookup"].set(child.name, meta);
          });
        });
        super.unlink(document);
      }
      loadAstNode(nodeDescription) {
        const node = super.loadAstNode(nodeDescription);
        if (node && !nodeDescription.node)
          this.metamodelBuilder.preLink(node, this.langiumDocuments().getOrCreateDocument(nodeDescription.documentUri), vscode_languageserver_1.CancellationToken.None);
        return node;
      }
    };
    exports2.SysMLLinker = SysMLLinker;
    __decorate([
      linker(ast_1.ElementReference)
    ], SysMLLinker.prototype, "linkReference", null);
    __decorate([
      linker(ast_1.FeatureReferenceExpression)
    ], SysMLLinker.prototype, "linkFeatureReferenceExpression", null);
    __decorate([
      linker(ast_1.MetadataAccessExpression)
    ], SysMLLinker.prototype, "linkMetadataAccessExpression", null);
    __decorate([
      linker(ast_1.Relationship)
    ], SysMLLinker.prototype, "linkRelationship", null);
    __decorate([
      linker(ast_1.Membership)
    ], SysMLLinker.prototype, "linkMembership", null);
  }
});

// ../syside-languageserver/lib/services/shared/workspace/index-manager.js
var require_index_manager2 = __commonJS({
  "../syside-languageserver/lib/services/shared/workspace/index-manager.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLIndexManager = void 0;
    var langium_1 = require_lib2();
    var vscode_languageserver_1 = require_main4();
    var ast_1 = require_ast2();
    var model_1 = require_model3();
    var global_scope_1 = require_global_scope();
    var scopes_1 = require_scopes();
    var SysMLIndexManager = class extends langium_1.DefaultIndexManager {
      constructor() {
        super(...arguments);
        this.globalElementsCache = /* @__PURE__ */ new Map();
        this.simpleIndex = /* @__PURE__ */ new Map();
        this.globalScopeCache = /* @__PURE__ */ new Map();
        this.modelDependencies = /* @__PURE__ */ new Map();
        this.globalScope = new global_scope_1.GlobalScope();
      }
      allElements(nodeType = "") {
        if (nodeType.length === 0)
          return this.globalScope.getAllElements();
        const cached = this.globalScopeCache.get(nodeType);
        if (cached) {
          return (0, langium_1.stream)(cached);
        } else {
          const elements = Array.from(this.globalScope.getAllElements().filter((e) => this.astReflection.isSubtype(e.type, nodeType)));
          this.globalScopeCache.set(nodeType, elements);
          return (0, langium_1.stream)(elements);
        }
      }
      updateContent(document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const uri = document.uriString;
          if (!((_a = document.buildOptions) === null || _a === void 0 ? void 0 : _a.standalone)) {
            this.globalScopeCache.clear();
            this.globalElementsCache.clear();
          }
          this.modelDependencies.delete(uri);
          document.namedElements.clear();
          const services = this.serviceRegistry.getServices(document.uri);
          const exports3 = yield services.references.ScopeComputation.computeExports(
            // all root nodes are namespaces
            document,
            cancelToken
          );
          document.exports.clear();
          exports3.forEach((d) => {
            if (d.node)
              document.exports.set(d.name, d.node.$meta);
          });
          if (!((_b = document.buildOptions) === null || _b === void 0 ? void 0 : _b.standalone)) {
            this.simpleIndex.set(uri, exports3);
            this.globalScope.collectDocument(document);
          }
          document.state = langium_1.DocumentState.IndexedContent;
        });
      }
      /**
       * Get currently indexed global scope. If {@link document} was provided and
       * built in standalone mode, the global scope refers to the document local
       * scope. Otherwise, the scope is constructed from all currently indexed
       * documents, optionally the scopes from matching language are prioritised
       * to resolve name clashes in SysML example files.
       * @param document document context
       * @returns the global scope
       */
      getGlobalScope(document) {
        var _a;
        if ((_a = document === null || document === void 0 ? void 0 : document.buildOptions) === null || _a === void 0 ? void 0 : _a.standalone) {
          return (0, scopes_1.makeScope)(document.parseResult.value.$meta);
        }
        if (!document)
          return this.globalScope;
        return this.globalScope.wrapForLang((0, global_scope_1.getLanguageId)(document.uri));
      }
      /**
       * Find an element based on its fully qualified name without following
       * aliases, safe to use after computing global exports. If {@link document}
       * was provided and was built with local standard library or in standalone
       * mode, the element is resolved in the document context only.
       * @see {@link DocumentState.IndexedContent}
       * @param qualifiedName Fully qualified name relative to the global
       * namespace
       * @param document document to use for context
       * @param addDependency if true and document is provided, the document
       * owning the found element is added to the dependencies of {@link document}
       * @returns description to the element with {@link qualifiedName} or
       * undefined if not found
       */
      findGlobalElement(qualifiedName, document, addDependency = false) {
        var _a, _b, _c, _d;
        const local = ((_a = document === null || document === void 0 ? void 0 : document.buildOptions) === null || _a === void 0 ? void 0 : _a.standardLibrary) === "local" || ((_b = document === null || document === void 0 ? void 0 : document.buildOptions) === null || _b === void 0 ? void 0 : _b.standalone);
        const uri = document === null || document === void 0 ? void 0 : document.uriString;
        const cache = local && uri ? document.namedElements : this.globalElementsCache;
        let candidate = cache.get(qualifiedName);
        if (candidate !== void 0)
          return candidate !== null && candidate !== void 0 ? candidate : void 0;
        let parts = qualifiedName.split("::").map((name) => (0, model_1.sanitizeName)(name));
        const root = parts[0];
        parts = parts.slice(1);
        candidate = cache.get(root);
        if (candidate === null) {
          return void 0;
        }
        if (candidate === void 0) {
          if (local && uri)
            candidate = document.exports.get(root);
          else
            candidate = (_c = this.globalScope.getStaticExportedElement(root)) === null || _c === void 0 ? void 0 : _c.element();
          cache.set(root, candidate !== null && candidate !== void 0 ? candidate : null);
        }
        for (const part of parts) {
          const child = candidate === null || candidate === void 0 ? void 0 : candidate.findMember(part);
          if (typeof child === "string" || !child)
            continue;
          let element;
          if (child.is(ast_1.Membership))
            element = child.element();
          else
            element = (_d = child.element()) === null || _d === void 0 ? void 0 : _d.element();
          candidate = element;
        }
        cache.set(qualifiedName, candidate !== null && candidate !== void 0 ? candidate : null);
        if (!local && uri && candidate && addDependency) {
          let deps = this.modelDependencies.get(uri);
          if (!deps) {
            deps = /* @__PURE__ */ new Set();
            this.modelDependencies.set(uri, deps);
          }
          const doc = candidate.document;
          deps.add(doc.uriString);
        }
        return candidate;
      }
      /**
       * Convenience method wrapping {@link findGlobalElement} that looks for
       * {@link Type} elements only
       * @see {@link findGlobalElement}
       * @param type qualified type name or the type itself
       * @param document document to use for context
       * @param addDependency if true and document is provided, the document
       * owning the found element is added to the dependencies of {@link document}
       * @returns the found type or undefined otherwise
       */
      findType(type, document, addDependency = false) {
        if (!type)
          return;
        if (typeof type !== "string")
          return type;
        const result = this.findGlobalElement(type, document, addDependency);
        if (result === null || result === void 0 ? void 0 : result.is(ast_1.Type))
          return result;
        return;
      }
      remove(uris) {
        for (const uri of uris) {
          const uriString = uri.toString();
          this.simpleIndex.delete(uriString);
          this.referenceIndex.delete(uriString);
          this.modelDependencies.delete(uriString);
        }
      }
      /**
       * Invalidate indexes
       * @param uris document URIs that should be invalidated in the index
       */
      invalidate(uris) {
        this.globalScope.invalidateDocuments(uris);
      }
      isAffected(document, changed) {
        if (super.isAffected(document, changed))
          return true;
        const deps = this.modelDependencies.get(document.uri.toString());
        if (!deps)
          return false;
        return deps.has(changed.toString());
      }
      conforms(left, type) {
        var _a;
        if (left === type)
          return true;
        if (typeof left === "string")
          left = (_a = this.findType(left)) !== null && _a !== void 0 ? _a : left;
        if (typeof left === "string")
          return left === (typeof type === "string" ? type : type.qualifiedName);
        return left.conforms(type);
      }
    };
    exports2.SysMLIndexManager = SysMLIndexManager;
  }
});

// ../syside-languageserver/lib/services/references/scope-provider.js
var require_scope_provider2 = __commonJS({
  "../syside-languageserver/lib/services/references/scope-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLScopeProvider = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    var scope_util_1 = require_scope_util();
    var scopes_1 = require_scopes();
    var vscode_languageserver_1 = require_main4();
    var cst_util_1 = require_cst_util2();
    var SysMLScopeProvider = class extends langium_1.DefaultScopeProvider {
      constructor(services) {
        super(services);
        this.indexManager = services.shared.workspace.IndexManager;
        this.metamodelBuilder = services.shared.workspace.MetamodelBuilder;
      }
      getScope(context) {
        const unfiltered = this.getScopeUnfiltered(context);
        const referenceType = this.reflection.getReferenceType(context);
        return new scopes_1.FilteredScope(unfiltered, (desc) => {
          var _a;
          return !!((_a = desc.element()) === null || _a === void 0 ? void 0 : _a.is(referenceType));
        });
      }
      /**
       * Get a scope with all named elements so that aliases are not filtered out
       * @param context
       * @returns Scope with all named elements
       */
      getScopeUnfiltered(context) {
        return (0, scopes_1.makeLinkingScope)(context.container.$meta, {}, this.indexManager.getGlobalScope());
      }
      /**
       * Get the scope for reference resolution
       * @param container reference owning container
       * @param index index of the reference
       * @param aliasResolver alias resolution function, a linker may use a
       * function that also links the alias to be resolved, while other services
       * may simply follow to the alias target
       * @returns scope that can be used to resolve the reference at {@link index}
       */
      getElementReferenceScope(container, index, aliasResolver = scope_util_1.DEFAULT_ALIAS_RESOLVER) {
        let parent;
        if (index === 0) {
          const context = this.getContext(container);
          if (context === "error")
            return;
          if (context) {
            parent = context;
          } else {
            return this.initialScope(container.owner(), container.document, { aliasResolver });
          }
        } else {
          parent = container.found.at(index - 1);
        }
        if (!parent)
          return;
        return this.localScope(parent, container.document, aliasResolver);
      }
      /**
       * Get the scope for reference resolution of the first reference in the
       * qualified chain
       * @param owner owner of the {@link ElementReference} that the reference is
       * a part of
       * @param document document that contains {@link owner}
       * @param aliasResolver alias resolution function
       * @see {@link getElementReferenceScope} (`index === 0`)
       * @returns scope that can be used to resolve the first reference in
       * {@link ElementReference}
       */
      initialScope(owner, document, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        options !== null && options !== void 0 ? options : options = { aliasResolver: scope_util_1.DEFAULT_ALIAS_RESOLVER };
        while (owner === null || owner === void 0 ? void 0 : owner.is(ast_1.InlineExpression)) {
          owner = owner.owner();
        }
        if (owner === null || owner === void 0 ? void 0 : owner.is(ast_1.FeatureChaining)) {
          owner = (_a = owner.owner()) === null || _a === void 0 ? void 0 : _a.owner();
        }
        if (owner === null || owner === void 0 ? void 0 : owner.isAny(ast_1.Specialization, ast_1.Conjugation)) {
          if (owner.nodeType() !== ast_1.Subsetting && owner.nodeType() !== ast_1.CrossSubsetting && owner.nodeType() !== ast_1.FeatureInverting) {
            options.skip = owner.source();
          }
          const parent2 = owner.parent();
          if ((_b = parent2 === null || parent2 === void 0 ? void 0 : parent2.parent()) === null || _b === void 0 ? void 0 : _b.is(ast_1.ParameterMembership)) {
            const outer = parent2.owner();
            if ((outer === null || outer === void 0 ? void 0 : outer.is(ast_1.InvocationExpression)) && parent2.value)
              return this.localScope((_c = outer.invokes()) !== null && _c !== void 0 ? _c : outer, void 0, options.aliasResolver);
          }
          owner = owner.source() === parent2 ? parent2 === null || parent2 === void 0 ? void 0 : parent2.owner() : parent2;
          if ((_e = (_d = options.skip) === null || _d === void 0 ? void 0 : _d.parent()) === null || _e === void 0 ? void 0 : _e.is(ast_1.EndFeatureMembership)) {
            owner = owner === null || owner === void 0 ? void 0 : owner.owner();
          }
        } else if ((_f = owner === null || owner === void 0 ? void 0 : owner.parent()) === null || _f === void 0 ? void 0 : _f.is(ast_1.ParameterMembership)) {
          if ((_g = owner.owner()) === null || _g === void 0 ? void 0 : _g.is(ast_1.InvocationExpression)) {
            return this.initialScope(owner.owner(), document, options);
          }
        } else if (owner === null || owner === void 0 ? void 0 : owner.is(ast_1.Membership)) {
          owner = owner.owner();
        }
        if (!owner)
          return;
        document !== null && document !== void 0 ? document : document = owner.document;
        const parent = owner.is(ast_1.Element) ? owner : owner.parent();
        if (parent)
          this.initializeParents(parent, document);
        return (0, scopes_1.makeLinkingScope)(owner, options, this.indexManager.getGlobalScope(document));
      }
      /**
       * Get the scope that can be used for reference resolution in the context of
       * {@link node}
       * @param node AST node to get scope for
       * @param document document that contains {@link node}
       * @param aliasResolver alias resolution function
       * @see {@link getElementReferenceScope} (`index > 0`)
       * @returns scope of publicly visible elements from {@link node} scope
       */
      localScope(node, document, aliasResolver = scope_util_1.DEFAULT_ALIAS_RESOLVER) {
        const ast2 = node.ast();
        if (ast2 && document)
          this.metamodelBuilder.preLink(ast2, document, vscode_languageserver_1.CancellationToken.None);
        return (0, scopes_1.makeScope)(node, Object.assign(Object.assign({}, scope_util_1.CHILD_CONTENTS_OPTIONS), { aliasResolver }));
      }
      /**
       * Get node final reference target
       * @param node
       * @returns Element referenced by `node` if linked, `"error"` if failed to link
       * and `undefined` for no reference
       */
      getElementTarget(node) {
        var _a, _b;
        if (node.is(ast_1.ElementReference)) {
          return (_a = node.to.target) !== null && _a !== void 0 ? _a : "error";
        } else if (node.isAny(ast_1.InlineExpression, ast_1.Expression, ast_1.SysMLFunction)) {
          const target = node.returnType();
          return (_b = this.indexManager.findType(target)) !== null && _b !== void 0 ? _b : "error";
        }
        return void 0;
      }
      /**
       * Get context for scope resolution
       * @param ref Reference to resolve context for
       * @returns `undefined` if implicit parent context, `"error"` if context failed to
       * be linked and {@link Element} for existing context
       */
      getContext(ref) {
        const ast2 = ref.ast();
        if (!ast2)
          return;
        const cst = ast2.$cstNode;
        if (!cst)
          return;
        let previous = (0, cst_util_1.getPreviousNode)(cst, false);
        if (previous && !(0, langium_1.isLeafCstNode)(previous)) {
          previous = (0, langium_1.findLeafNodeAtOffset)(previous, previous.end);
        }
        if (!previous || ![".", "::"].includes(previous.text)) {
          return;
        }
        let contextCst = (0, cst_util_1.getPreviousNode)(previous, false);
        if (!contextCst)
          return;
        if (!(0, langium_1.isLeafCstNode)(contextCst)) {
          contextCst = (0, langium_1.findLeafNodeAtOffset)(contextCst, contextCst.end);
        }
        const element = contextCst === null || contextCst === void 0 ? void 0 : contextCst.element;
        if (!(element === null || element === void 0 ? void 0 : element.$meta))
          return;
        return this.getElementTarget(element.$meta);
      }
      /**
       * Construct parent nodes of {@link node}, including itself, for scope
       * resolution
       * @param node AST node that scope is being constructed for
       * @param document document that contains {@link node}
       */
      initializeParents(node, document) {
        while (node) {
          this.metamodelBuilder.buildElement(node, document);
          node = node.parent();
        }
      }
    };
    exports2.SysMLScopeProvider = SysMLScopeProvider;
  }
});

// ../syside-languageserver/lib/services/lsp/completion-provider.js
var require_completion_provider2 = __commonJS({
  "../syside-languageserver/lib/services/lsp/completion-provider.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLCompletionProvider = exports2.SUPPORTED_TRIGGER_CHARACTERS = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    var vscode_languageserver_1 = require_main4();
    var scopes_1 = require_scopes();
    var common_1 = require_common();
    var ALPHA_NUM = /[a-zA-z\d_]/;
    var NON_ALPHA_NUM = /[^a-zA-z\d_\s]/;
    var NODE_END_CHAR = /[{};]$/;
    var SCOPE_TOKENS = ["::", ".", "'", "''"];
    var RELATIONSHIP_KEYWORDS = /* @__PURE__ */ new Set([
      ":",
      ":>>",
      ":>",
      "::>",
      "specializes",
      "subsets",
      "redefines",
      "references",
      /* typed, featured, defined */
      "by",
      "conjugates",
      /* disjoint */
      "from",
      "unions",
      "intersects",
      "differences",
      "chains",
      /* inverse */
      "of"
    ]);
    var TRIGGER_KEYWORDS = ["@", "@@", "#", "->"];
    exports2.SUPPORTED_TRIGGER_CHARACTERS = (0, langium_1.stream)(SCOPE_TOKENS, TRIGGER_KEYWORDS, RELATIONSHIP_KEYWORDS).map((v) => v.charAt(v.length - 1)).filter((c) => !ALPHA_NUM.test(c)).distinct().toArray();
    var SysMLCompletionProvider = class extends langium_1.DefaultCompletionProvider {
      constructor(services) {
        super(services);
        this.cancelTokens = /* @__PURE__ */ new WeakMap();
        this.indexManager = services.shared.workspace.IndexManager;
        this.scopeProvider = services.references.ScopeProvider;
        const lexer = services.parser.Lexer;
        this.keywords = new Set((0, langium_1.stream)(Object.entries(lexer.definition)).filter(([name, type]) => name === type.PATTERN).map(([name, _]) => name));
      }
      getCompletion(document, params, token = vscode_languageserver_1.CancellationToken.None) {
        const _super = Object.create(null, {
          getCompletion: { get: () => super.getCompletion }
        });
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          while (document.state === langium_1.DocumentState.Changed) {
            yield (0, langium_1.interruptAndCheck)(token);
          }
          let list = yield this.getTriggerCompletion(document, params, token);
          if (!list && ((_a = params.context) === null || _a === void 0 ? void 0 : _a.triggerKind) !== vscode_languageserver_1.CompletionTriggerKind.TriggerCharacter) {
            this.cancelTokens.set(document, token);
            list = yield _super.getCompletion.call(this, document, params);
          }
          if (list) {
            list.items = (0, langium_1.stream)(list.items).distinct((item) => item.label).toArray();
          }
          return list;
        });
      }
      /**
       * Custom completion computation method that only computes reference
       * completions
       * @see {@link getCompletion}
       */
      getTriggerCompletion(document, params, cancelToken) {
        const _super = Object.create(null, {
          buildCompletionTextEdit: { get: () => super.buildCompletionTextEdit }
        });
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const root = document.parseResult.value;
          const cst = root.$cstNode;
          if (!cst) {
            return void 0;
          }
          const textDocument = document.textDocument;
          const text = textDocument.getText();
          const offset = textDocument.offsetAt(params.position);
          let tokenEnd;
          if ((_a = params.context) === null || _a === void 0 ? void 0 : _a.triggerCharacter) {
            tokenEnd = this.backtrackToToken(text, offset, params.context.triggerCharacter);
          } else {
            tokenEnd = this.backtrackToAnyToken(text, offset);
            if (tokenEnd < text.length && NODE_END_CHAR.test(text.charAt(tokenEnd)))
              tokenEnd--;
          }
          let node = (0, langium_1.findLeafNodeAtOffset)(cst, tokenEnd);
          let token = "";
          let tokenStart;
          if (!node) {
            tokenStart = this.backtrackToAnyTriggerStart(text, tokenEnd);
            const nodeOffset = this.backtrackToAnyToken(text, tokenStart - 1);
            node = (0, langium_1.findLeafNodeAtOffset)(cst, nodeOffset);
            if (node)
              token = text.substring(node.end, tokenEnd + 1).trim();
          } else {
            const maybeToken = text.substring(node.end, tokenEnd + 1).trim();
            if (maybeToken.length > 0) {
              tokenStart = this.backtrackToAnyTriggerStart(text, tokenEnd);
              token = text.substring(tokenStart, tokenEnd + 1);
            } else {
              token = node.text;
              tokenStart = node.offset;
            }
          }
          if (token === ".") {
            const nodeOffset = this.backtrackToAnyToken(text, tokenStart - 1);
            node = (0, langium_1.findLeafNodeAtOffset)(cst, nodeOffset);
          }
          if (!node)
            return;
          const fillCompletionItem = (value) => {
            if (!startQuote && !endQuote || value.textEdit)
              return this.fillCompletionItem(textDocument, offset, value);
            const label = value.label;
            if (!label)
              return;
            let start = tokenStart;
            let end = tokenEnd;
            let identifier = token;
            if (startQuote) {
              start++;
              identifier = token.substring(1);
            }
            if (endQuote) {
              end--;
              identifier = identifier.substring(0, identifier.length - 1);
            }
            if (!this.charactersFuzzyMatch(identifier, label))
              return;
            value.textEdit = {
              newText: label,
              range: {
                start: textDocument.positionAt(start),
                end: textDocument.positionAt(end)
              }
            };
            return this.fillCompletionItem(textDocument, offset, value);
          };
          const items = [];
          const startQuote = offset !== tokenStart && token.startsWith("'");
          const endQuote = (token.length > 1 || !startQuote) && token.endsWith("'");
          const withQuotes = startQuote && endQuote;
          const refAcceptor = (value) => {
            const completionItem = fillCompletionItem(value);
            if (completionItem) {
              if (!withQuotes && completionItem.textEdit && this.isRestrictedName(completionItem.textEdit.newText)) {
                completionItem.textEdit.newText = `${startQuote ? "" : "'"}${completionItem.textEdit.newText}${endQuote ? "" : "'"}`;
              }
              items.push(completionItem);
            }
          };
          if (SCOPE_TOKENS.includes(token) || /^'.*'$/.test(token)) {
            if (!(0, ast_1.isElementReference)(node.element))
              return;
            const end = withQuotes ? 1 : 0;
            const lastRef = node.element.$meta.found.at(end - 1);
            if (token !== "." || !lastRef || (0, ast_1.isFeature)(lastRef)) {
              yield this.computeScopeCompletion(node.element, refAcceptor, document, cancelToken, { index: node.element.parts.length - end });
            }
            const owner = node.element.$meta.owner();
            if (token === "." && (owner === null || owner === void 0 ? void 0 : owner.is(ast_1.InlineExpression)) && !owner.is(ast_1.FeatureChainExpression)) {
              const item = this.fillCompletionItem(textDocument, offset, {
                label: "metadata",
                kind: vscode_languageserver_1.CompletionItemKind.Operator,
                detail: ast_1.MetadataAccessExpression,
                textEdit: _super.buildCompletionTextEdit.call(this, textDocument, offset, "metadata", "metadata"),
                sortText: "1"
              });
              if (item)
                items.push(item);
            }
          } else if (RELATIONSHIP_KEYWORDS.has(token)) {
            let element;
            if (/;|\{|\}/.test(node.text)) {
              element = node.element;
            } else {
              element = node.element.$container;
            }
            if (!element)
              return;
            yield this.computeScopeCompletion(element, refAcceptor, document, cancelToken, {
              skip: node.element.$meta
            });
          } else if (TRIGGER_KEYWORDS.includes(token) || (0, ast_1.isElementReference)(node.element)) {
            yield this.computeScopeCompletion(node.element, refAcceptor, document, cancelToken);
          } else {
            return void 0;
          }
          return vscode_languageserver_1.CompletionList.create(items, true);
        });
      }
      completionForCrossReference(context, _crossRef, acceptor) {
        const node = context.node;
        if (!node)
          return;
        return this.computeScopeCompletion(node, acceptor, context.document, vscode_languageserver_1.CancellationToken.None);
      }
      completionFor(context, next, acceptor, token = vscode_languageserver_1.CancellationToken.None) {
        var _a;
        if (token === vscode_languageserver_1.CancellationToken.None)
          token = (_a = this.cancelTokens.get(context.document)) !== null && _a !== void 0 ? _a : token;
        if ((0, ast_1.isElementReference)(context.node))
          return this.computeScopeCompletion(context.node, acceptor, context.document, token);
        return super.completionFor(context, next, acceptor);
      }
      computeScopeCompletion(node, acceptor, document, token, options) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            let scope;
            let index = options === null || options === void 0 ? void 0 : options.index;
            if ((0, ast_1.isElementReference)(node)) {
              if (index === void 0) {
                index = node.parts.length - 1;
              }
              if (index < 0)
                return;
              const meta = node.$meta;
              const predicate = () => !meta.to.cached && document.progress <= 1;
              yield (0, common_1.asyncWaitWhile)(predicate, {}, token);
              if (index === 0 || meta.found.at(index - 1))
                scope = this.scopeProvider.getElementReferenceScope(meta, index);
              else
                return;
              if (!scope) {
                node = node.$container;
              }
            }
            if (!scope) {
              const predicate = () => document.state < langium_1.DocumentState.ComputedScopes;
              yield (0, common_1.asyncWaitWhile)(predicate, {}, token);
              scope = this.scopeProvider.initialScope(node.$meta, document, options);
            }
            if (!scope)
              return;
            const visited = /* @__PURE__ */ new Set();
            const collect = (s, index2) => {
              s.getAllExportedElements().forEach(([name, e]) => {
                if (visited.has(name))
                  return;
                visited.add(name);
                const item = this.createMemberCompletionItem(e, name);
                item.sortText = index2.toString().padStart(4, "0");
                acceptor(item);
              });
            };
            if (scope instanceof scopes_1.ScopeStream)
              scope.getChildScopes().forEach(collect);
            else
              collect(scope, 0);
          } catch (err) {
            console.error(err);
          }
        });
      }
      // TODO: should be in custom lexer
      /**
       * Check if {@link name} is not a valid element identifier
       * @param name Name string to check
       * @returns True if name clashes with a reserved language keyword/token or
       * the name doesn't match the name RegExp
       */
      isRestrictedName(name) {
        return this.keywords.has(name) || !this.grammarConfig.nameRegexp.test(name);
      }
      /**
       * Backtrack to any token start that have triggered completion request
       * @param text document test
       * @param offset starting search offset (cursor)
       * @returns offset to the potential trigger token start
       */
      backtrackToAnyTriggerStart(text, offset) {
        if (offset >= text.length) {
          offset = text.length - 1;
        }
        const char = text.charAt(offset);
        if (char === "'") {
          return offset;
        } else {
          const test = ALPHA_NUM.test(text.charAt(offset)) ? ALPHA_NUM : NON_ALPHA_NUM;
          while (offset > 0 && test.test(text.charAt(offset - 1))) {
            offset--;
          }
        }
        return offset;
      }
      /**
       * Backtrack to {@link token}
       * @param text document test
       * @param offset starting search offset
       * @param token token to backtrack to, expects `token.length === 1`
       * @returns the offset at which `text.charAt(offset) === token` if found, 0
       * otherwise
       */
      backtrackToToken(text, offset, token) {
        if (token.length !== 1)
          return offset;
        if (offset >= text.length) {
          offset = text.length - 1;
        }
        while (offset > 0 && text.charAt(offset) !== token) {
          offset--;
        }
        return offset;
      }
      // TODO: remove since buildCompletionTextEdit is no longer overridden
      completionForKeyword(context, keyword, acceptor) {
        return super.completionForKeyword(context, keyword, (value) => {
          if (value.label) {
            value.textEdit = super.buildCompletionTextEdit(context.document.textDocument, context.offset, value.label, value.label);
          }
          acceptor(value);
        });
      }
      createMemberCompletionItem(member, name) {
        var _a, _b;
        return {
          label: name,
          kind: vscode_languageserver_1.CompletionItemKind.Reference,
          detail: (_a = member.element()) === null || _a === void 0 ? void 0 : _a.nodeType(),
          sortText: "0",
          labelDetails: {
            description: (_b = member.element()) === null || _b === void 0 ? void 0 : _b.qualifiedName
          }
        };
      }
    };
    exports2.SysMLCompletionProvider = SysMLCompletionProvider;
  }
});

// ../syside-languageserver/lib/services/validation/document-validator.js
var require_document_validator2 = __commonJS({
  "../syside-languageserver/lib/services/validation/document-validator.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getModelDiagnosticRange = exports2.getDiagnosticRange = exports2.SysMLDocumentValidator = void 0;
    var langium_1 = require_lib2();
    var vscode_languageserver_1 = require_main4();
    var common_1 = require_common();
    var ast_util_1 = require_ast_util2();
    var SysMLDocumentValidator = class extends langium_1.DefaultDocumentValidator {
      constructor(services) {
        super(services);
        this.linker = services.references.Linker;
        this.metamodelBuilder = services.shared.workspace.MetamodelBuilder;
        this.validationRegistry = services.validation.ValidationRegistry;
      }
      validateElement(element, document, cancelToken = vscode_languageserver_1.CancellationToken.None, items = []) {
        return __awaiter(this, void 0, void 0, function* () {
          const acceptor = (severity, message, info) => {
            items.push({ severity, message, element: info.element, info });
          };
          const checks = this.validationRegistry.getModelChecks(element.nodeType());
          yield Promise.all(checks.map((check) => check(element, acceptor, cancelToken)));
          return items;
        });
      }
      validateModel(rootNode, document, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        return __awaiter(this, void 0, void 0, function* () {
          const validationItems = [];
          const acceptor = (severity, message, info) => {
            validationItems.push({ severity, message, element: info.element, info });
          };
          yield Promise.all((0, ast_util_1.streamModel)(rootNode).map((node) => __awaiter(this, void 0, void 0, function* () {
            yield (0, langium_1.interruptAndCheck)(cancelToken);
            const checks = this.validationRegistry.getModelChecks(node.nodeType());
            for (const check of checks) {
              yield check(node, acceptor, cancelToken);
            }
          })));
          return validationItems;
        });
      }
      validateAst(rootNode, document, cancelToken) {
        return __awaiter(this, void 0, void 0, function* () {
          const diagnostics = yield this.validateModel(rootNode.$meta, document, cancelToken);
          diagnostics.forEach((d) => document.modelDiagnostics.add(d.element, d));
          return document.modelDiagnostics.values().map((d) => this.fromModelDiagnostic(d)).toArray();
        });
      }
      fromModelDiagnostic(diagnostic) {
        return {
          message: diagnostic.message,
          range: getModelDiagnosticRange(diagnostic.info, diagnostic.element),
          severity: (0, langium_1.toDiagnosticSeverity)(diagnostic.severity),
          code: diagnostic.info.code,
          codeDescription: diagnostic.info.codeDescription,
          tags: diagnostic.info.tags,
          relatedInformation: diagnostic.info.relatedInformation,
          data: diagnostic.info.data,
          source: this.getSource()
        };
      }
    };
    exports2.SysMLDocumentValidator = SysMLDocumentValidator;
    (function(SysMLDocumentValidator2) {
      SysMLDocumentValidator2.ImportError = "import-error";
      SysMLDocumentValidator2.MetamodelError = "metamodel-error";
    })(SysMLDocumentValidator || (exports2.SysMLDocumentValidator = SysMLDocumentValidator = {}));
    function getDiagnosticRangeImpl(info, node) {
      let cstNode;
      if (info.range)
        return info.range;
      if (typeof info.property === "string") {
        cstNode = (0, langium_1.findNodeForProperty)(node.$cstNode, info.property, info.index);
      } else if (typeof info.keyword === "string") {
        cstNode = (0, langium_1.findNodeForKeyword)(node.$cstNode, info.keyword, info.index);
      }
      cstNode !== null && cstNode !== void 0 ? cstNode : cstNode = node.$cstNode;
      if (!cstNode) {
        return {
          start: { line: 0, character: 0 },
          end: { line: 0, character: 0 }
        };
      }
      return cstNode.range;
    }
    function getDiagnosticRange(info) {
      return (0, common_1.sanitizeRange)(getDiagnosticRangeImpl(info, info.node));
    }
    exports2.getDiagnosticRange = getDiagnosticRange;
    var EMPTY_RANGE = { start: { character: 0, line: 0 }, end: { character: 0, line: 0 } };
    function getModelDiagnosticRange(info, element) {
      let node = element.ast();
      if (node)
        return (0, common_1.sanitizeRange)(getDiagnosticRangeImpl(info, node));
      let current = element.parent();
      while (current) {
        node = current.ast();
        if (node === null || node === void 0 ? void 0 : node.$cstNode)
          return node.$cstNode.range;
        current = current.parent();
      }
      return EMPTY_RANGE;
    }
    exports2.getModelDiagnosticRange = getModelDiagnosticRange;
  }
});

// ../syside-languageserver/lib/services/sysml-ast-reflection.js
var require_sysml_ast_reflection = __commonJS({
  "../syside-languageserver/lib/services/sysml-ast-reflection.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isProgrammaticNode = exports2.SysMLAstReflection = void 0;
    var langium_1 = require_lib2();
    var ast2 = __importStar(require_ast2());
    var types_1 = require_types2();
    var SysMLAstReflection = class extends ast2.SysMlAstReflection {
      constructor() {
        super(...arguments);
        this.metadata = /* @__PURE__ */ new Map();
      }
      getReferenceType(refInfo) {
        const container = refInfo.container;
        if (refInfo.index === container.parts.length - 1) {
          switch (container.$type) {
            case ast2.TypeReference:
              return ast2.Type;
            case ast2.ClassifierReference:
              return ast2.Classifier;
            case ast2.MetaclassReference:
              return ast2.Metaclass;
            case ast2.MembershipReference:
              return ast2.Membership;
            case ast2.NamespaceReference:
              return ast2.Namespace;
            case ast2.FeatureReference:
              return ast2.Feature;
            case ast2.ConjugatedPortReference:
              return ast2.ConjugatedPortDefinition;
          }
        }
        return ast2.Element;
      }
      isSubtype(subtype, supertype) {
        return types_1.typeIndex.isSubtype(subtype, supertype);
      }
      getTypeMetaData(type) {
        let meta = this.metadata.get(type);
        if (meta)
          return meta;
        const properties = new Map(super.getTypeMetaData(type).mandatory.map((p) => [p.name, p.type]));
        for (const base of types_1.typeIndex.getInheritanceChain(type)) {
          const baseMeta = super.getTypeMetaData(base);
          for (const { name, type: type2 } of baseMeta.mandatory) {
            if (properties.has(name))
              continue;
            properties.set(name, type2);
          }
        }
        meta = {
          name: type,
          mandatory: (0, langium_1.stream)(properties.entries()).map(([name, type2]) => {
            return { name, type: type2 };
          }).toArray()
        };
        meta.mandatory.push({ name: "$children", type: "array" });
        this.metadata.set(type, meta);
        return meta;
      }
      assignMandatoryProperties(obj) {
        const typeMetaData = this.getTypeMetaData(obj.$type);
        const out = obj;
        for (const mandatoryProperty of typeMetaData.mandatory) {
          const value = out[mandatoryProperty.name];
          if (mandatoryProperty.type === "array" && !Array.isArray(value)) {
            out[mandatoryProperty.name] = [];
          } else if (mandatoryProperty.type === "boolean" && value === void 0) {
            out[mandatoryProperty.name] = false;
          }
        }
        if (out["$childIndex"] === void 0)
          out["$childIndex"] = 0;
      }
      /**
       * Programmatically create an AST node with a given {@link type}
       * @param type AST node type
       * @param values AST node values
       * @returns Constructed AST node
       */
      createNode(type, values) {
        const partialNode = Object.assign({ $type: type }, values);
        if (values.$cstNode) {
          const cstNode = shallowClone(values.$cstNode);
          cstNode.element = partialNode;
          partialNode.$cstNode = cstNode;
          cstNode.$implicit = true;
        }
        this.assignMandatoryProperties(partialNode);
        return this.assignNode(partialNode, values);
      }
      /**
       * Assign {@link child} to a parent AST node with {@link info}
       * @param child Child AST node
       * @param info Properties defining {@link child} parent and its relationship
       * @returns child
       */
      assignNode(child, info) {
        const parent = info.$container;
        const property = info.$containerProperty;
        if (!parent || !property)
          return child;
        const member = parent[property];
        const index = info.$containerIndex;
        if (Array.isArray(member)) {
          const array = member;
          if (index !== void 0) {
            array.forEach((v, i) => {
              if (i >= index)
                v.$containerIndex = i + 1;
            });
            array.splice(index, 0, child);
            child.$containerIndex = index;
          } else {
            array.push(child);
            child.$containerIndex = array.length - 1;
          }
        } else {
          if (index !== void 0)
            throw new Error("Cannot assign with an index to a non-array property");
          parent[property] = child;
        }
        child.$container = parent;
        child.$containerProperty = property;
        if (parent.$children) {
          const cst = child.$cstNode;
          if (cst) {
            const index2 = parent.$children.findIndex((node) => {
              if (!node.$cstNode)
                return;
              return node.$cstNode.offset > cst.end;
            });
            if (index2 >= 0) {
              parent.$children.slice(index2).forEach((node) => node.$childIndex++);
              parent.$children.splice(index2, 0, child);
            }
          }
          parent.$children.push(child);
          child.$childIndex = parent.$children.length - 1;
        }
        return child;
      }
      getSubtypes(type) {
        return types_1.typeIndex.getSubtypes(type);
      }
      getSupertypes(type) {
        return types_1.typeIndex.getInheritanceChain(type);
      }
    };
    exports2.SysMLAstReflection = SysMLAstReflection;
    function shallowClone(obj) {
      return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
    }
    function isProgrammaticNode(node) {
      return !node.$cstNode || "$implicit" in node.$cstNode;
    }
    exports2.isProgrammaticNode = isProgrammaticNode;
  }
});

// ../syside-languageserver/lib/services/shared/evaluator.js
var require_evaluator2 = __commonJS({
  "../syside-languageserver/lib/services/shared/evaluator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLExpressionEvaluator = exports2.validationLocation = exports2.isExpressionError = void 0;
    var model_1 = require_model3();
    function isExpressionError(item) {
      return Boolean(typeof item === "object" && item && "message" in item);
    }
    exports2.isExpressionError = isExpressionError;
    function validationLocation(error) {
      var _a;
      return (_a = error.stack.map((e) => e.ast()).find((node) => node)) !== null && _a !== void 0 ? _a : error.expression.ast();
    }
    exports2.validationLocation = validationLocation;
    var SysMLExpressionEvaluator = class {
      constructor(services) {
        this.services = services;
        this.evaluators = (0, model_1.defaultEvaluators)();
      }
      evaluate(expression, target) {
        const evaluator = new model_1.BuiltinFunctionEvaluator(this.services, this.evaluators);
        try {
          return evaluator.evaluate(expression, target);
        } catch (e) {
          return {
            expression,
            message: String(e),
            stack: [...evaluator.currentEvaluationStack]
          };
        }
      }
      /**
       *
       * @param expression element to evaluate
       * @param target expression evaluation context
       * @returns number if `expression` can be evaluated as a number
       * unambiguously, otherwise `ExpressionError`
       */
      evaluateNumber(expression, target) {
        const result = this.evaluate(expression, target);
        if (isExpressionError(result))
          return result;
        const value = result.at(0);
        if (value === void 0) {
          return Number.NaN;
        }
        if (result.length > 1) {
          return {
            expression,
            message: `Too many values (${result.length}), expected 1`,
            stack: [expression]
          };
        }
        if (typeof value !== "number") {
          return {
            expression,
            message: `Value is not a number (${value})`,
            stack: [expression]
          };
        }
        return value;
      }
      tryCast(expression, target, type) {
        const result = this.evaluate(expression, target);
        if (isExpressionError(result))
          return result;
        const value = result.at(0);
        if (result.length !== 1) {
          return {
            expression,
            message: `${result.length === 0 ? "Not enough" : "Too many"} values (${result.length}), expected 1`,
            stack: [expression]
          };
        }
        if (typeof value !== type) {
          return {
            expression,
            message: `Value is not ${type === "object" ? "an" : "a"} ${type} (${value})`,
            stack: [expression]
          };
        }
        return value;
      }
      /**
       *
       * @param expression element to evaluate
       * @param target expression evaluation context
       * @returns boolean if `expression` can be evaluated as a boolean
       * unambiguously, otherwise `ExpressionError`
       */
      evaluateBoolean(expression, target) {
        return this.tryCast(expression, target, "boolean");
      }
      /**
       *
       * @param expression element to evaluate
       * @param target expression evaluation context
       * @returns string if `expression` can be evaluated as a string
       * unambiguously, otherwise `ExpressionError`
       */
      evaluateString(expression, target) {
        return this.tryCast(expression, target, "string");
      }
      /**
       *
       * @param expression element to evaluate
       * @param target expression evaluation context
       * @returns element if `expression` can be evaluated as a single element
       * unambiguously, otherwise `ExpressionError`
       */
      evaluateElement(expression, target) {
        return this.tryCast(expression, target, "object");
      }
    };
    exports2.SysMLExpressionEvaluator = SysMLExpressionEvaluator;
  }
});

// ../syside-languageserver/lib/services/shared/workspace/metamodel-builder.js
var require_metamodel_builder = __commonJS({
  "../syside-languageserver/lib/services/shared/workspace/metamodel-builder.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLMetamodelBuilder = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    var model_1 = require_model3();
    var types_1 = require_types2();
    var implicits_1 = require_implicits();
    var evaluator_1 = require_evaluator2();
    var ast_to_model_1 = require_ast_to_model();
    var utils_1 = require_utils2();
    var MetaclassPackages = [
      "KerML::Root::",
      "KerML::Core::",
      "KerML::Kernel::",
      "SysML::Systems::"
      // "SysML::",
    ];
    var MetaclassOverrides = {
      SysMLFunction: "Function"
      // Function is reserved in TS
    };
    var Builders = {};
    function builder(type, order = 0) {
      return function(_, __, descriptor) {
        const value = descriptor.value;
        if (!value)
          return;
        if (typeof type === "string")
          type = [type];
        type.forEach((t) => {
          var _a;
          ((_a = Builders[t]) !== null && _a !== void 0 ? _a : Builders[t] = []).push([order, value]);
        });
      };
    }
    var SysMLMetamodelBuilder = class {
      constructor(services) {
        this.indexManager = services.workspace.IndexManager;
        this.registry = services.ServiceRegistry;
        this.config = services.workspace.ConfigurationProvider;
        this.astReflection = services.AstReflection;
        this.evaluator = services.Evaluator;
        this.statistics = services.statistics;
        this.util = services.Util;
        this.metaFactories = model_1.META_FACTORY;
        this.preLinkFunctions = this.registerLinkFunctions(Builders);
      }
      buildElement(element, document) {
        this.preLinkModel(element, document);
      }
      buildModel(root, document) {
        for (const element of (0, utils_1.streamModel)(root)) {
          this.preLinkModel(element, document);
        }
      }
      registerLinkFunctions(functions) {
        const map = types_1.typeIndex.expandAndMerge(
          functions,
          // merge from supertypes to most derived types
          true
        );
        const retMap = /* @__PURE__ */ new Map();
        for (const [type, functions2] of map) {
          retMap.set(type, new Set(functions2.sort(([a], [b]) => a - b).map(([_, fn]) => fn)));
        }
        return retMap;
      }
      linker(uri) {
        return this.registry.getServices(uri).references.Linker;
      }
      onLinkedPart(info, document) {
        this.preLinkNode(info.reference.ref, document);
      }
      onLinkedReference(ref, _, __) {
        var _a;
        const owner = ref.$container.$meta;
        if (owner.is(ast_1.MembershipImport)) {
          if (!owner.isRecursive)
            return;
        } else if (owner.is(ast_1.Membership)) {
          (_a = owner.owner()) === null || _a === void 0 ? void 0 : _a.invalidateMemberCaches();
          return;
        }
        const target = ref.$meta.to.target;
        if (target)
          this.preLinkModel(target);
      }
      onParsed(document) {
        const children = document.astNodes;
        for (const child of children) {
          this.addMeta(child, document);
        }
        children.forEach((child) => (0, ast_to_model_1.astToModel)(child.$meta, child));
      }
      onChanged(document) {
        const added = [];
        for (const child of document.astNodes) {
          const meta = child.$meta;
          if (meta)
            (0, ast_to_model_1.clearArtifacts)(meta);
          else {
            this.addMeta(child, document);
            added.push(child);
          }
        }
        added.forEach((child) => (0, ast_to_model_1.astToModel)(child.$meta, child));
      }
      /**
       * Add `$meta` member to {@link child}
       * @param child node to add metamodel member to
       * @param document document containing {@link child}
       */
      addMeta(child, document) {
        const meta = this.constructMetamodelAst(child, document);
        child.$meta = meta;
        if ((0, ast_1.isElementReference)(child))
          child.$meta.document = document;
      }
      /**
       * Construct appropriate metamodel for {@link node}
       * @param node AST node to construct metamodel for
       * @returns Constructed metamodel
       */
      constructMetamodelAst(node, document) {
        return this.constructMetamodel(node.$type, document);
      }
      constructMetamodel(type, document) {
        const factory = this.metaFactories[type];
        if (!factory)
          throw new Error(`Invalid type for metamodel: ${type}`);
        return factory(this.util.idProvider, document);
      }
      preLink(node, document, cancelToken) {
        return __awaiter(this, void 0, void 0, function* () {
          if (node) {
            return this.preLinkNode(node, document);
          }
          const meta = document.parseResult.value.$meta;
          if (meta === null || meta === void 0 ? void 0 : meta.is(ast_1.Element)) {
            for (const element of (0, utils_1.streamModel)(meta)) {
              yield (0, langium_1.interruptAndCheck)(cancelToken);
              this.preLinkModel(element, document);
            }
          }
          for (const node2 of document.astNodes) {
            yield (0, langium_1.interruptAndCheck)(cancelToken);
            this.preLinkNode(node2, document);
          }
        });
      }
      /**
       * Pre-link method that handles all AST nodes in a generic way
       * @param node node to pre-link
       * @param document document that contains {@link node}
       * @returns
       */
      preLinkNode(node, document) {
        const meta = node.$meta;
        if (meta)
          this.preLinkModel(meta, document);
      }
      preLinkModel(meta, document) {
        if (meta.setupState !== "none")
          return;
        document !== null && document !== void 0 ? document : document = meta.document;
        const debug = this.config.get().debug.linkingTrace && meta.is(ast_1.Element);
        if (debug) {
          console.log("  ".repeat(this.statistics.currentDepth), `> ${meta.qualifiedName} [${meta.nodeType()}]`);
        }
        const preprocess = this.preLinkFunctions.get(meta.nodeType());
        meta.setupState = "active";
        if (preprocess) {
          for (const fn of preprocess) {
            this.statistics.enter(fn.name);
            if (debug)
              console.log("  ".repeat(this.statistics.currentDepth), fn.name);
            fn.call(this, meta, document);
            this.statistics.exit(fn.name);
          }
        }
        meta.setupState = "completed";
        if (debug) {
          console.log("  ".repeat(this.statistics.currentDepth), `< ${meta.qualifiedName} [${meta.nodeType()}]`);
        }
      }
      /**
       * Assign a standard library metaclass based on the AST type
       */
      assignMetaclass(node, document) {
        var _a;
        if (((_a = document.buildOptions) === null || _a === void 0 ? void 0 : _a.standardLibrary) === "none")
          return;
        const cache = {
          node,
          document,
          builder: this
        };
        node.setMetaclass(() => {
          var _a2;
          const { node: node2, document: document2, builder: builder2 } = cache;
          const name = (_a2 = MetaclassOverrides[node2.nodeType()]) !== null && _a2 !== void 0 ? _a2 : node2.nodeType();
          let metaclass;
          for (const pack of MetaclassPackages) {
            const meta = builder2.indexManager.findGlobalElement(pack + name, document2, true);
            if (meta === null || meta === void 0 ? void 0 : meta.is(ast_1.Metaclass)) {
              metaclass = meta;
              break;
            }
          }
          let feature;
          if (!metaclass) {
            document2.modelDiagnostics.add(node2, {
              element: node2,
              message: `Could not find metaclass for ${name}`,
              severity: "error",
              info: {}
            });
          } else {
            this.preLinkModel(metaclass);
            feature = model_1.MetadataFeatureMeta.create(this.util.idProvider, document2);
            feature.addAnnotation([
              model_1.AnnotationMeta.create(this.util.idProvider, document2, {
                isImplied: true
              }),
              node2
            ]);
            feature.addHeritage([
              model_1.FeatureTypingMeta.create(this.util.idProvider, document2),
              metaclass
            ]);
          }
          return feature;
        });
      }
      /**
       * Resolve imports of {@link node} and its parents since they are implicitly
       * imported
       */
      resolveNamespaceImports(node, document) {
        if (node.importResolutionState !== "none")
          return;
        node.importResolutionState = "active";
        let parent = node.parent();
        while (parent) {
          this.preLinkModel(parent, document);
          parent = parent.parent();
        }
        this.linker(document.uri).resolveImports(node, document);
        node.importResolutionState = "completed";
        for (const imp of node.imports) {
          if (imp.is(ast_1.MembershipImport) && !imp.isRecursive)
            continue;
          const description = imp.element();
          if (!description)
            continue;
          this.preLinkModel(description);
        }
      }
      linkNamespaceFeatures(node, document) {
        node.featureMembers().forEach((member) => {
          const element = member.element();
          if (element && element.is(ast_1.Feature) && !(element.declaredName || element.declaredName) && // only features with specializations will have naming features
          element.specializations().length > 0)
            this.preLinkModel(element, document);
        });
      }
      /**
       * Setup explicit feature relationships
       */
      collectFeatureClassifiers(node, _document) {
        node.allTypes().forEach((t) => node["_classifier"] |= t.classifier);
      }
      /**
       * Setup implicit specializations from Metaobjects::SemanticMetadata
       */
      addSemanticMetadata(node, document) {
        var _a;
        for (const metadata of node.metadata) {
          this.buildTree(metadata, document);
          const baseTypes = metadata.allFeatures().filter((f) => {
            var _a2;
            return (_a2 = f.element()) === null || _a2 === void 0 ? void 0 : _a2.conforms("Metaobjects::SemanticMetadata::baseType");
          });
          for (const member of baseTypes) {
            const baseType = member.element();
            if (!baseType)
              continue;
            const value = (_a = baseType.value) === null || _a === void 0 ? void 0 : _a.element();
            if (!value)
              continue;
            this.buildTree(value, document);
            const result = this.evaluator.evaluate(value, baseType);
            if ((0, evaluator_1.isExpressionError)(result)) {
              document.modelDiagnostics.add(value, {
                element: value,
                message: result.message,
                severity: "warning",
                info: {}
              });
              continue;
            }
            const meta = result.at(0);
            if (!meta || !(0, model_1.isMetamodel)(meta) || !meta.is(ast_1.MetadataFeature))
              continue;
            for (const annotated of meta.annotatedElements()) {
              if (!annotated.is(ast_1.Type))
                continue;
              const specialization = this.constructMetamodel(node.specializationKind(), document);
              specialization["_isImplied"] = true;
              node.addHeritage([specialization, annotated]);
            }
          }
        }
      }
      linkTypeRelationship(node, document) {
        const source = node.source();
        const target = node.element();
        if (target && target.parent() === node) {
          this.preLinkModel(target, document);
        }
        if (source && source !== node.parent()) {
          this.preLinkModel(source, document);
          if (source.is(ast_1.Feature))
            return source.basicFeature();
        }
        if (!(source === null || source === void 0 ? void 0 : source.is(ast_1.Type)))
          return;
        return source;
      }
      setupSpecialization(node, document) {
        const source = this.linkTypeRelationship(node, document);
        const target = node.finalElement();
        if (target)
          source === null || source === void 0 ? void 0 : source["onHeritageAdded"](node, target);
      }
      setupTypeRelationship(node, document) {
        this.linkTypeRelationship(node, document);
      }
      /**
       * Setup explicit type relationships
       */
      linkTypeRelationships(node, document) {
        node.heritage.filter((s) => !s.is(ast_1.CrossSubsetting)).forEach((r) => this.preLinkModel(r, document));
        node.typeRelationships.forEach((r) => this.preLinkModel(r, document));
      }
      /**
       * Setup implicit classifier relationships
       */
      addClassifierImplicits(node, document) {
        this.addImplicits(node, document, ast_1.Type);
      }
      /**
       * Setup implicit feature relationships
       */
      addFeatureImplicits(node, document) {
        var _a;
        if (((_a = document.buildOptions) === null || _a === void 0 ? void 0 : _a.standardLibrary) === "none")
          return;
        this.addImplicits(node, document, ast_1.Feature);
      }
      /**
       * Setup implicit end feature redefinitions
       * @param node
       */
      redefineEnds(node, document) {
        const endFeatureMembers = (f) => {
          var _a;
          return Boolean(f.is(ast_1.EndFeatureMembership) || ((_a = f.element()) === null || _a === void 0 ? void 0 : _a.isEnd));
        };
        const baseEndIterator = node.basePositionalFeatures(endFeatureMembers).iterator();
        (0, langium_1.stream)(node.featureMembers()).filter(endFeatureMembers).map((m) => m.element()).nonNullable().forEach((end) => {
          const base = baseEndIterator.next();
          if (base.done)
            return;
          if (end.specializations(ast_1.Redefinition).length > 0)
            return;
          const target = base.value.element();
          if (!target)
            return;
          const specialization = model_1.RedefinitionMeta.create(this.util.idProvider, document, {
            isImplied: true
          });
          end.addHeritage([specialization, target]);
          return;
        });
      }
      resolveCrossCartesianFeature(self2, cross, document) {
        const makeCrossSubsetting = self2.specializations(ast_1.CrossSubsetting).length === 0;
        const needsTypeFeaturings = cross.typeFeaturings.length === 0;
        if (!makeCrossSubsetting && !needsTypeFeaturings)
          return;
        const owner = self2.owningType;
        if (!owner)
          return;
        let cartesianFeature;
        let cache;
        let first;
        let i = 0;
        const nameOrShortName = (t) => {
          var _a;
          return (_a = t.name) !== null && _a !== void 0 ? _a : t.shortName ? `<${t.shortName}>` : "";
        };
        (0, langium_1.stream)(owner.featureMembers()).filter((m) => {
          var _a;
          return m.is(ast_1.EndFeatureMembership) || ((_a = m.element()) === null || _a === void 0 ? void 0 : _a.isEnd);
        }).forEach((end) => {
          const endFeature = end.element();
          if (!endFeature || endFeature === self2)
            return;
          ++i;
          if (!first) {
            first = endFeature;
            return;
          }
          if (i == 2) {
            if (needsTypeFeaturings) {
              cache = model_1.MembershipMeta.create(this.util.idProvider, document, {
                isImplied: true
              });
              self2.addChild([cache, self2]);
              cartesianFeature = model_1.FeatureMeta.create(this.util.idProvider, document, {
                declaredName: `${nameOrShortName(first)}_${nameOrShortName(endFeature)}`
              });
              cache.addChild(cartesianFeature);
              cartesianFeature.addFeatureRelationship([
                model_1.TypeFeaturingMeta.create(this.util.idProvider, document, {
                  isImplied: true
                }),
                first
              ]);
            }
            if (makeCrossSubsetting) {
              first = model_1.FeatureMeta.create(this.util.idProvider, document);
              first.addFeatureRelationship([
                model_1.TypeFeaturingMeta.create(this.util.idProvider, document, {
                  isImplied: true
                }),
                owner
              ]);
              self2.addChild([
                model_1.FeatureMembershipMeta.create(this.util.idProvider, document, {
                  isImplied: true
                }),
                first
              ]);
            }
          }
          if (!needsTypeFeaturings)
            return;
          if (i >= 3 && cartesianFeature && cache) {
            const nexCart = model_1.FeatureMeta.create(this.util.idProvider, document, {
              declaredName: `${nameOrShortName(cartesianFeature)}_${nameOrShortName(endFeature)}`
            });
            cache.addChild(nexCart);
            nexCart.addFeatureRelationship([
              model_1.TypeFeaturingMeta.create(this.util.idProvider, document, {
                isImplied: true
              }),
              cartesianFeature
            ]);
            cartesianFeature = nexCart;
          }
          cartesianFeature === null || cartesianFeature === void 0 ? void 0 : cartesianFeature.addHeritage([
            model_1.FeatureTypingMeta.create(this.util.idProvider, document, { isImplied: true }),
            endFeature
          ]);
        });
        if (!first) {
          document.modelDiagnostics.add(self2, {
            element: self2,
            message: "End feature with owned cross feature must be one of two or more end features.",
            severity: "error",
            info: {
              code: "checkFeatureCrossingSpecialization"
            }
          });
          return;
        }
        if (makeCrossSubsetting) {
          if (cartesianFeature) {
            first.declaredName = `${nameOrShortName(owner)}_${nameOrShortName(cartesianFeature)}`;
            first.addHeritage([
              model_1.FeatureTypingMeta.create(this.util.idProvider, document, { isImplied: true }),
              cartesianFeature
            ]);
          }
          const crosses = model_1.CrossSubsettingMeta.create(this.util.idProvider, document, {
            isImplied: true
          });
          const chain = model_1.FeatureMeta.create(this.util.idProvider, document, {
            declaredName: `${first.name}.${cross.name}`,
            parent: crosses
          });
          chain.addFeatureRelationship([
            model_1.FeatureChainingMeta.create(this.util.idProvider, document, { isImplied: true }),
            first
          ]);
          chain.addFeatureRelationship([
            model_1.FeatureChainingMeta.create(this.util.idProvider, document, { isImplied: true }),
            cross
          ]);
          self2.addHeritage([crosses, chain]);
        }
        if (cartesianFeature) {
          cross.allFeaturingTypes().forEach((type) => {
            first === null || first === void 0 ? void 0 : first.addHeritage([
              model_1.FeatureTypingMeta.create(this.util.idProvider, document, { isImplied: true }),
              type
            ]);
          });
          cross.addFeatureRelationship([
            model_1.TypeFeaturingMeta.create(this.util.idProvider, document, { isImplied: true }),
            cartesianFeature
          ]);
        } else {
          (0, langium_1.stream)(first.allTypes()).forEach((type) => {
            cross.addFeatureRelationship([
              model_1.TypeFeaturingMeta.create(this.util.idProvider, document, {
                isImplied: true
              }),
              type
            ]);
          });
        }
        return cartesianFeature;
      }
      /**
       * Setup implicit cross feature specializations
       * @param node
       */
      addCrossFeatureImplicits(node, document) {
        if (node.isEnd && node.owningType) {
          const cross = node.findOwnedCrossFeature();
          if (!cross)
            return;
          node.allTypings().forEach((type) => {
            cross.addHeritage([
              model_1.FeatureTypingMeta.create(this.util.idProvider, document, {
                isImplied: true
              }),
              type
            ]);
          });
          const cartesianFeature = this.resolveCrossCartesianFeature(node, cross, document);
          node.specializations(ast_1.Redefinition).forEach((redef) => {
            const target = redef.element();
            if (!(target === null || target === void 0 ? void 0 : target.isEnd))
              return;
            const feat = target.findOwnedCrossFeature();
            if (feat) {
              cross.addHeritage([
                model_1.SubsettingMeta.create(this.util.idProvider, document, { isImplied: true }),
                feat
              ]);
              if (!cartesianFeature)
                return;
              feat.allFeaturingTypes().forEach((maybeFeature) => {
                if (maybeFeature.is(ast_1.Feature)) {
                  cartesianFeature.addHeritage([
                    model_1.SubsettingMeta.create(this.util.idProvider, document, {
                      isImplied: true
                    }),
                    maybeFeature
                  ]);
                }
              });
            }
          });
        }
      }
      /**
       * Setup implicit definition relationships
       */
      addDefinitionImplicits(node, document) {
        var _a;
        if (((_a = document.buildOptions) === null || _a === void 0 ? void 0 : _a.standardLibrary) === "none")
          return;
        const base = this.findLibraryElement(node, implicits_1.implicitIndex.get(node.nodeType(), node.defaultSupertype()), document, ast_1.Classifier, `Could not find implicit definition specialization for ${node.nodeType()}`);
        if (base && node !== base && !node.allTypes().includes(base)) {
          const specialization = model_1.FeatureTypingMeta.create(this.util.idProvider, document, {
            isImplied: true
          });
          node.addHeritage([specialization, base]);
        }
      }
      /**
       * Setup implicit usage relationships
       */
      addUsageImplicits(node, document) {
        var _a;
        if (((_a = document.buildOptions) === null || _a === void 0 ? void 0 : _a.standardLibrary) === "none")
          return;
        const base = this.findLibraryElement(node, implicits_1.implicitIndex.get(node.nodeType(), node.defaultSupertype()), document, ast_1.Feature, `Could not find implicit usage specialization for ${node.nodeType()}`);
        if (base && node !== base && !node.allTypes().includes(base)) {
          const specialization = model_1.SubsettingMeta.create(this.util.idProvider, document, {
            isImplied: true
          });
          node.addHeritage([specialization, base]);
        }
      }
      /**
       * Setup implicit action parameter redefinitions
       */
      redefineActionParameters(action, document) {
        const baseActions = action.specializationsMatching([ast_1.ActionUsage, ast_1.ActionDefinition]).toArray();
        if (baseActions.length === 0)
          return;
        const ownedParameters = (0, langium_1.stream)(action.featureMembers()).map((member) => member.element()).nonNullable().filter((f) => f.isParameter).filter((f) => !f.isIgnoredParameter());
        const baseParameterIterators = baseActions.map((action2) => {
          var _a, _b;
          return (0, langium_1.stream)((_b = (_a = action2.element()) === null || _a === void 0 ? void 0 : _a.featureMembers()) !== null && _b !== void 0 ? _b : []).map((member) => member.element()).nonNullable().filter((f) => f.isParameter).filter((f) => !f.isIgnoredParameter()).iterator();
        });
        for (const parameter of ownedParameters) {
          this.preLinkModel(parameter, document);
          const explicit = parameter.specializations(ast_1.Redefinition).length > 0;
          for (const baseIter of baseParameterIterators) {
            const baseParameter = baseIter.next();
            if (baseParameter.done || explicit)
              continue;
            const specialization = model_1.RedefinitionMeta.create(this.util.idProvider, document, {
              isImplied: true
            });
            parameter.addHeritage([specialization, baseParameter.value]);
          }
        }
      }
      /**
       * Setup implicit subject parameter redefinition
       */
      redefineSubject(node, _document) {
        var _a;
        if (!((_a = node.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.SubjectMembership)))
          return;
        this.redefineFirstIf(node, (member) => {
          var _a2;
          return member.is(ast_1.SubjectMembership) && !!((_a2 = member.element()) === null || _a2 === void 0 ? void 0 : _a2.is(ast_1.Usage));
        });
      }
      /**
       * Setup implicit objective parameter redefinition
       */
      redefineObjective(node, _document) {
        var _a;
        if (!((_a = node.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.ObjectiveMembership)))
          return;
        this.redefineFirstIf(node, (member) => {
          var _a2;
          return member.is(ast_1.ObjectiveMembership) && !!((_a2 = member.element()) === null || _a2 === void 0 ? void 0 : _a2.is(ast_1.RequirementUsage));
        });
      }
      /**
       * Setup implicit state subactions redefinitions
       */
      redefineStateSubactions(node, _document) {
        const parent = node.parent();
        if (!(parent === null || parent === void 0 ? void 0 : parent.is(ast_1.StateSubactionMembership)))
          return;
        this.redefineFirstIf(node, (member) => {
          var _a;
          return member.is(ast_1.StateSubactionMembership) && member.kind === parent.kind && !!((_a = member.element()) === null || _a === void 0 ? void 0 : _a.is(ast_1.ActionUsage));
        });
      }
      /**
       * Setup implicit transition usage feature redefinitions
       */
      redefineTransitionUsageFeatures(node, document) {
        const collect = (type, out) => {
          let found = 0;
          if (!("trigger" in out) && type.accepter) {
            out.trigger = type.accepter.element();
            ++found;
          }
          if (!("effect" in out) && type.effect) {
            out.effect = type.effect.element();
            ++found;
          }
          if (!("guard" in out) && type.guard) {
            out.guard = type.guard.element();
            ++found;
          }
          return found;
        };
        const findBases = (node2, out) => {
          let found = 0;
          for (const specialization of node2.typesMatching(ast_1.TransitionUsage)) {
            found += collect(specialization, out);
            if (found === 3)
              return found;
          }
          for (const specialization of node2.typesMatching(ast_1.TransitionUsage)) {
            found = findBases(specialization, out);
            if (found === 3)
              return found;
          }
          return found;
        };
        const bases = {};
        findBases(node, bases);
        const owned = {};
        collect(node, owned);
        const redefine = (k, fallback) => {
          const current = owned[k];
          if (!current)
            return;
          let feature = bases[k];
          if (!feature) {
            feature = this.findLibraryElement(node, fallback, document, ast_1.Feature, "Could not find implicit redefinition");
          }
          if (feature) {
            const specialization = model_1.RedefinitionMeta.create(this.util.idProvider, document, {
              isImplied: true
            });
            current.addHeritage([specialization, feature]);
          }
        };
        redefine("trigger", "Actions::TransitionAction::accepter");
        redefine("guard", "TransitionPerformances::TransitionPerformance::guard");
        redefine("effect", "Actions::TransitionAction::effect");
      }
      /**
       * Setup explicit comment references
       */
      linkAnnotations(node, document) {
        const ast2 = node.ast();
        if (!ast2)
          return;
        const linker = this.linker(document.uri);
        ast2.about.forEach((ref) => {
          const target = ref.targetRef;
          if (!target)
            return;
          const element = linker.linkReference(target, document);
          if (element) {
            ref.$meta["setElement"](element);
            element["addExplicitAnnotatingElement"](node);
          }
        });
      }
      /**
       * Setup implicit feature typings from assigned values
       */
      addFeatureValueTypings(node, document) {
        var _a;
        const expression = (_a = node.value) === null || _a === void 0 ? void 0 : _a.element();
        if (!expression || node.direction !== "none" || node.specializations().some((s) => !s.isImplied))
          return;
        this.buildTree(expression, document);
        const type = this.findType(node, expression.returnType(), document);
        if (!type || !type.is(ast_1.Feature))
          return;
        const specialization = model_1.SubsettingMeta.create(this.util.idProvider, document, {
          isImplied: true
        });
        node.addHeritage([specialization, type]);
      }
      setupInvocationArgs(node, document) {
        const children = node.ownedElements().toArray();
        children.forEach((m) => this.buildTree(m, document));
        node["_args"] = node.arguments();
      }
      linkFeatureReferenceExpression(node, document) {
        if (node.expression)
          this.preLinkModel(node.expression, document);
      }
      linkRelationship(node, document) {
        const ast2 = node.ast();
        if (!ast2)
          return;
        const linker = this.linker(document.uri);
        if (ast2.targetRef) {
          node["setElement"](linker.linkReference(ast2.targetRef, document));
        }
        if (ast2.sourceRef) {
          const source = linker.linkReference(ast2.sourceRef, document);
          if (source)
            node["setSource"](source);
        }
      }
      lazilyEvaluateMultiplicityBounds(node, _document) {
        var _a;
        const expr = (_a = node.range) === null || _a === void 0 ? void 0 : _a.element();
        if (!expr) {
          node["setBounds"](void 0);
          return;
        }
        const evaluator = this.evaluator;
        node["setBounds"](function() {
          var _a2;
          const range = expr ? evaluator.evaluate(expr, (_a2 = node.owner()) !== null && _a2 !== void 0 ? _a2 : node) : void 0;
          if (!range || (0, evaluator_1.isExpressionError)(range)) {
            return void 0;
          }
          const lower = range.at(0);
          if (lower === void 0) {
            return void 0;
          }
          const bounds = {};
          let defaultUpper;
          if (typeof lower === "number") {
            bounds.lower = lower;
            defaultUpper = lower;
          } else if (typeof lower === "object" && lower.is(ast_1.LiteralInfinity)) {
            bounds.lower = 0;
            defaultUpper = Number.MAX_SAFE_INTEGER;
          }
          if (range.length < 2) {
            bounds.upper = defaultUpper;
            return bounds;
          }
          const upper = range.at(-1);
          if (typeof upper === "number")
            bounds.upper = upper;
          else if (typeof upper === "object" && upper.is(ast_1.LiteralInfinity))
            bounds.upper = Number.MAX_SAFE_INTEGER;
          return bounds;
        });
      }
      addImplicitVariantSpecialization(node, document) {
        const owner = node.owner();
        const element = node.finalElement();
        if (element && (owner === null || owner === void 0 ? void 0 : owner.isAny(ast_1.Usage, ast_1.Definition)) && owner.isVariation) {
          const options = {
            isImplied: true
          };
          const specialization = owner.is(ast_1.Usage) ? model_1.SubsettingMeta.create(this.util.idProvider, document, options) : model_1.FeatureTypingMeta.create(this.util.idProvider, document, options);
          element.addHeritage([specialization, owner]);
        }
      }
      addImplicitOccurrenceUsageTyping(node, document) {
        if (!node.portionKind || node.specializations(ast_1.FeatureTyping).length !== 0)
          return;
        const owner = node.owner();
        const options = {
          isImplied: true
        };
        if (owner === null || owner === void 0 ? void 0 : owner.is(ast_1.OccurrenceDefinition)) {
          node.addHeritage([
            model_1.FeatureTypingMeta.create(this.util.idProvider, document, options),
            owner
          ]);
        } else if (owner === null || owner === void 0 ? void 0 : owner.is(ast_1.OccurrenceUsage)) {
          node.addHeritage([
            model_1.SubsettingMeta.create(this.util.idProvider, document, options),
            owner
          ]);
        }
      }
      addImplicitConnectorFeaturingType(node, document) {
        if (node.owningType || node.featuredBy.length > 0)
          return;
        const context = node.contextType();
        if (!context)
          return;
        const featuring = model_1.TypeFeaturingMeta.create(this.util.idProvider, document, {
          isImplied: true
        });
        node.addFeatureRelationship([featuring, context]);
      }
      addConnectorEndSubsettings(node, document) {
        var _a;
        for (const end of node.connectorEnds()) {
          const expression = (0, langium_1.stream)(end.featureMembers()).filter(model_1.BasicMetamodel.is(ast_1.FeatureMembership)).map((m) => m.element()).filter(model_1.BasicMetamodel.is(ast_1.Expression)).head();
          if (!expression)
            continue;
          this.buildTree(expression, document);
          const result = (_a = expression.resultParameter()) === null || _a === void 0 ? void 0 : _a.element();
          if (!result)
            continue;
          const subsetting = model_1.SubsettingMeta.create(this.util.idProvider, document, {
            isImplied: true
          });
          end.addHeritage([subsetting, result]);
        }
      }
      addItemFlowEndSubsetting(node, document) {
        var _a;
        if (node.specializations(ast_1.Subsetting).some((s) => !s.isImplied))
          return;
        const feature = (_a = node.featureMembers().find((m) => m.is(ast_1.OwningMembership))) === null || _a === void 0 ? void 0 : _a.element();
        if (!feature)
          return;
        this.preLinkModel(feature, document);
        feature.types(ast_1.Redefinition).limit(1).map((t) => t.owner()).filter(model_1.BasicMetamodel.is(ast_1.Feature)).forEach((f) => {
          const subsetting = model_1.SubsettingMeta.create(this.util.idProvider, document, {
            isImplied: true
          });
          node.addHeritage([subsetting, f]);
        });
      }
      addItemFlowEndMemberRedefinition(node, document) {
        var _a;
        const owner = node.owner();
        if (!(owner === null || owner === void 0 ? void 0 : owner.is(ast_1.Feature)))
          return;
        const feature = (_a = node.featureMembers().find((m) => m.is(ast_1.OwningMembership))) === null || _a === void 0 ? void 0 : _a.element();
        if (!feature)
          return;
        const index = owner.featureMembers().filter((m) => {
          var _a2;
          return m.is(ast_1.EndFeatureMembership) || ((_a2 = m.element()) === null || _a2 === void 0 ? void 0 : _a2.isEnd);
        }).indexOf(node.parent());
        if (index !== 0 && index !== 1)
          return;
        const implicitName = implicits_1.implicitIndex.get(node.nodeType(), index === 0 ? "sourceOutput" : "targetInput");
        if (!implicitName)
          return;
        const implicit = this.findLibraryElement(node, implicitName, document, ast_1.Feature, "Could not find implicit item flow end redefinition");
        if (!implicit)
          return;
        const redef = model_1.RedefinitionMeta.create(this.util.idProvider, document, {
          isImplied: true
        });
        feature.addHeritage([redef, implicit]);
      }
      setupTransitionUsageReferenceUsageMembers(node, document) {
        {
          const link = node.transitionLinkFeature();
          if (link === null || link === void 0 ? void 0 : link.is(ast_1.ReferenceUsage)) {
            const target = this.findLibraryElement(node, "TransitionPerformances::TransitionPerformance::transitionLink", document, ast_1.Feature, "Could not find implicit transition link feature");
            if (target) {
              const redef = model_1.RedefinitionMeta.create(this.util.idProvider, document, {
                isImplied: true
              });
              link.addHeritage([redef, target]);
            }
          }
        }
        {
          const payload = node.payloadParameter();
          const parameter = node.accepterPayloadParameter();
          if ((payload === null || payload === void 0 ? void 0 : payload.is(ast_1.ReferenceUsage)) && parameter) {
            this.preLinkModel(parameter, document);
            const subsetting = model_1.SubsettingMeta.create(this.util.idProvider, document, {
              isImplied: true
            });
            payload.addHeritage([subsetting, parameter]);
            if (parameter.name)
              payload["setName"](parameter.name);
          }
        }
      }
      // executed first so that featuring context can be computed
      setupSuccessionAsUsageEnds(node, document) {
        const ends = node.connectorEnds();
        for (const [index, getter] of [
          // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
          [0, () => node.previousFeature((model) => this.preLinkModel(model, document))],
          [1, node.targetFeature]
        ]) {
          const end = ends.at(index);
          if (!end)
            continue;
          this.preLinkModel(end, document);
          const references = end.specializations().some((r) => r.is(ast_1.ReferenceSubsetting));
          if (references)
            continue;
          const member = getter.call(node);
          if (!member)
            continue;
          this.preLinkModel(member, document);
          const feature = member === null || member === void 0 ? void 0 : member.element();
          if (feature) {
            this.preLinkModel(feature, document);
            const subsetting = model_1.ReferenceSubsettingMeta.create(this.util.idProvider, document, {
              isImplied: true
            });
            end.addHeritage([subsetting, feature]);
          }
        }
      }
      cacheImportedName(node, _document) {
        var _a, _b, _c, _d, _e, _f;
        const ast2 = node.ast();
        let name = ast2 ? (_b = (_a = ast2.targetRef) === null || _a === void 0 ? void 0 : _a.parts.at(-1)) === null || _b === void 0 ? void 0 : _b.$refText : (_d = (_c = node.element()) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : (_e = node.element()) === null || _e === void 0 ? void 0 : _e.shortName;
        if (!name)
          return;
        name = (0, model_1.sanitizeName)(name);
        const children = (_f = node.owner()) === null || _f === void 0 ? void 0 : _f["_memberLookup"];
        if (!children)
          return;
        if (children.has(name))
          return;
        children.set(name, node);
      }
      collectDependencyReferences(node, document) {
        const ast2 = node.ast();
        if (!ast2)
          return;
        const linker = this.linker(document.uri);
        node.client.push(...(0, langium_1.stream)(ast2.client).map((client) => linker.linkReference(client, document)).nonNullable());
        node.supplier.push(...(0, langium_1.stream)(ast2.supplier).map((supplier) => linker.linkReference(supplier, document)).nonNullable());
      }
      addOperatorExpressionTyping(node, document) {
        const func = node.getFunction();
        if (!func)
          return;
        const element = this.findLibraryElement(node, func, document, ast_1.Type, "Could not find operator expression type");
        if (!element)
          return;
        const typing = model_1.FeatureTypingMeta.create(this.util.idProvider, document, {
          isImplied: true
        });
        node.addHeritage([typing, element]);
      }
      addNonDeclarationTypeFeaturing(node, _document) {
        var _a;
        if (!((_a = node.parent()) === null || _a === void 0 ? void 0 : _a.is(ast_1.OwningMembership)))
          return;
        const src = node.source();
        if (!src)
          return;
        src["_typeRelationships"].push(node);
      }
      setFlowEndDirections(node, _document) {
        const ends = node.ends;
        const setDirection = (end, direction) => {
          const mem = end === null || end === void 0 ? void 0 : end.element().children[0];
          if (mem === null || mem === void 0 ? void 0 : mem.is(ast_1.FeatureMembership)) {
            mem.element().direction = direction;
          }
        };
        setDirection(ends[0], "out");
        setDirection(ends[1], "in");
      }
      /**
       * Construct the node fully by linking all its children and optionally specialized types
       * @param node AST node to construct
       * @param document document that owns {@link node}
       * @param specializations if true, also construct base types
       */
      buildTree(node, document, specializations = true) {
        if (node.setupState === "completed")
          return;
        const linker = this.linker(document.uri);
        for (const child of (0, utils_1.streamModel)(node)) {
          this.preLinkModel(child, document);
          const ast2 = child.ast();
          if (ast2)
            linker.linkNode(ast2, document);
        }
        if (!node.is(ast_1.Type) || !specializations)
          return;
        node.allTypes().forEach((t) => {
          const doc = t.document;
          if (doc && t && t !== node)
            this.buildTree(t, doc, false);
        });
      }
      /**
       * Find a specified library type by a simple name lookup
       * @param node context node
       * @param type qualified name of the type or the type itself
       * @param document document that owns {@link node}
       * @returns Type if found, undefined otherwise
       */
      findType(node, type, document) {
        if (!type)
          return;
        if (typeof type !== "string")
          return type;
        return this.findLibraryElement(node, type, document, ast_1.Type, "Could not find library type");
      }
      /**
       * Find a specific library element via name lookup that matches a type predicate {@link is}
       * @param node context node
       * @param qualifiedName qualified type name
       * @param document document that owns {@link node}
       * @param is type check function
       * @param notFoundMessage message in case an element satisfying {@link is} was not found
       * @returns Element satisfying {@link is} if found and undefined otherwise
       */
      findLibraryElement(node, qualifiedName, document, type, notFoundMessage) {
        const element = this.indexManager.findGlobalElement(qualifiedName, document, true);
        if (!(element === null || element === void 0 ? void 0 : element.is(type))) {
          document.modelDiagnostics.add(node, {
            element: node,
            message: `${notFoundMessage} '${qualifiedName}'`,
            severity: "error",
            info: {}
          });
          return;
        }
        this.preLinkModel(element);
        return element;
      }
      /**
       * Helper function that collects implicit base types for {@link node}
       * @param node Element to collect base types for
       * @param document document that owns {@link node}
       * @returns qualified names of implicit base types
       */
      getImplicitSpecializations(node, document) {
        const names = [];
        for (const general of node.defaultGeneralTypes()) {
          const name = typeof general == "string" ? general : general.type;
          const implicitName = implicits_1.implicitIndex.get(node.nodeType(), name);
          if (!implicitName) {
            document.modelDiagnostics.add(node, {
              element: node,
              message: `Could not find implicit specialization for ${node.nodeType()} (${name})`,
              severity: "error",
              info: {}
            });
            continue;
          }
          names.push(typeof general == "string" ? implicitName : { type: implicitName, specialization: general.specialization });
        }
        return names;
      }
      /**
       * Setup implicit base types for {@link node}
       * @param node {@link Type} to add implicit specialization to
       * @param document document that owns  {@link node}
       * @param type type assertion for valid specialization types
       */
      addImplicits(node, document, type) {
        var _a;
        if (((_a = document.buildOptions) === null || _a === void 0 ? void 0 : _a.standardLibrary) === "none")
          return;
        const kind = node.specializationKind();
        for (const general of this.getImplicitSpecializations(node, document)) {
          const name = typeof general == "string" ? general : general.type;
          const implicit = this.findLibraryElement(node, name, document, type, `Could not find implicit specialization for ${kind}`);
          if (implicit && implicit !== node) {
            const specialization = this.constructMetamodel(typeof general == "string" ? kind : general.specialization, document);
            specialization["_isImplied"] = true;
            node.addHeritage([specialization, implicit]);
          }
        }
      }
      /**
       * Redefine the first positional feature satisfying {@link predicate}
       * @param node owner node
       * @param key key of the feature array
       * @param predicate matcher
       * @param document document that owns {@link node}
       */
      redefineFirstIf(feature, predicate, kind) {
        var _a;
        const owner = feature.owner();
        for (const type of owner.allTypes(kind)) {
          const baseFeature = (_a = type.featureMembers().find(predicate)) === null || _a === void 0 ? void 0 : _a.element();
          if (!baseFeature)
            continue;
          const specialization = model_1.RedefinitionMeta.create(this.util.idProvider, feature.document, {
            isImplied: true
          });
          feature.addHeritage([specialization, baseFeature]);
          return;
        }
      }
    };
    exports2.SysMLMetamodelBuilder = SysMLMetamodelBuilder;
    __decorate([
      builder(ast_1.Element)
    ], SysMLMetamodelBuilder.prototype, "assignMetaclass", null);
    __decorate([
      builder(ast_1.Namespace)
    ], SysMLMetamodelBuilder.prototype, "resolveNamespaceImports", null);
    __decorate([
      builder(ast_1.Namespace, 1e4)
    ], SysMLMetamodelBuilder.prototype, "linkNamespaceFeatures", null);
    __decorate([
      builder(ast_1.Feature)
    ], SysMLMetamodelBuilder.prototype, "collectFeatureClassifiers", null);
    __decorate([
      builder(ast_1.Type)
    ], SysMLMetamodelBuilder.prototype, "addSemanticMetadata", null);
    __decorate([
      builder([ast_1.Specialization, ast_1.Conjugation], 100)
    ], SysMLMetamodelBuilder.prototype, "setupSpecialization", null);
    __decorate([
      builder(ast_1.FeatureRelationship, 100)
    ], SysMLMetamodelBuilder.prototype, "setupTypeRelationship", null);
    __decorate([
      builder(ast_1.Type)
    ], SysMLMetamodelBuilder.prototype, "linkTypeRelationships", null);
    __decorate([
      builder(ast_1.Classifier, 10)
    ], SysMLMetamodelBuilder.prototype, "addClassifierImplicits", null);
    __decorate([
      builder(ast_1.Feature, 10)
    ], SysMLMetamodelBuilder.prototype, "addFeatureImplicits", null);
    __decorate([
      builder(ast_1.Type, 1e3)
    ], SysMLMetamodelBuilder.prototype, "redefineEnds", null);
    __decorate([
      builder(ast_1.Feature, 2e3)
    ], SysMLMetamodelBuilder.prototype, "addCrossFeatureImplicits", null);
    __decorate([
      builder(ast_1.Definition, 15)
    ], SysMLMetamodelBuilder.prototype, "addDefinitionImplicits", null);
    __decorate([
      builder(ast_1.Usage, 15)
    ], SysMLMetamodelBuilder.prototype, "addUsageImplicits", null);
    __decorate([
      builder([ast_1.ActionUsage, ast_1.ActionDefinition], 1e3)
    ], SysMLMetamodelBuilder.prototype, "redefineActionParameters", null);
    __decorate([
      builder(ast_1.ReferenceUsage, 1e3)
    ], SysMLMetamodelBuilder.prototype, "redefineSubject", null);
    __decorate([
      builder(ast_1.RequirementUsage)
    ], SysMLMetamodelBuilder.prototype, "redefineObjective", null);
    __decorate([
      builder(ast_1.ActionUsage, 1e3)
    ], SysMLMetamodelBuilder.prototype, "redefineStateSubactions", null);
    __decorate([
      builder(ast_1.TransitionUsage, 1e3)
    ], SysMLMetamodelBuilder.prototype, "redefineTransitionUsageFeatures", null);
    __decorate([
      builder(ast_1.Comment),
      builder(ast_1.MetadataFeature)
    ], SysMLMetamodelBuilder.prototype, "linkAnnotations", null);
    __decorate([
      builder(ast_1.Feature)
    ], SysMLMetamodelBuilder.prototype, "addFeatureValueTypings", null);
    __decorate([
      builder(ast_1.InvocationExpression)
    ], SysMLMetamodelBuilder.prototype, "setupInvocationArgs", null);
    __decorate([
      builder(ast_1.FeatureReferenceExpression)
    ], SysMLMetamodelBuilder.prototype, "linkFeatureReferenceExpression", null);
    __decorate([
      builder(ast_1.Relationship, -1e3)
    ], SysMLMetamodelBuilder.prototype, "linkRelationship", null);
    __decorate([
      builder(ast_1.MultiplicityRange)
    ], SysMLMetamodelBuilder.prototype, "lazilyEvaluateMultiplicityBounds", null);
    __decorate([
      builder(ast_1.VariantMembership, 5)
    ], SysMLMetamodelBuilder.prototype, "addImplicitVariantSpecialization", null);
    __decorate([
      builder(ast_1.OccurrenceUsage, 5)
    ], SysMLMetamodelBuilder.prototype, "addImplicitOccurrenceUsageTyping", null);
    __decorate([
      builder(ast_1.Connector)
    ], SysMLMetamodelBuilder.prototype, "addImplicitConnectorFeaturingType", null);
    __decorate([
      builder(ast_1.Connector)
    ], SysMLMetamodelBuilder.prototype, "addConnectorEndSubsettings", null);
    __decorate([
      builder(ast_1.ItemFlowEnd)
    ], SysMLMetamodelBuilder.prototype, "addItemFlowEndSubsetting", null);
    __decorate([
      builder(ast_1.ItemFlowEnd)
    ], SysMLMetamodelBuilder.prototype, "addItemFlowEndMemberRedefinition", null);
    __decorate([
      builder(ast_1.TransitionUsage)
    ], SysMLMetamodelBuilder.prototype, "setupTransitionUsageReferenceUsageMembers", null);
    __decorate([
      builder(ast_1.SuccessionAsUsage, -1e4)
    ], SysMLMetamodelBuilder.prototype, "setupSuccessionAsUsageEnds", null);
    __decorate([
      builder(ast_1.MembershipImport, 1e4)
    ], SysMLMetamodelBuilder.prototype, "cacheImportedName", null);
    __decorate([
      builder(ast_1.Dependency, 1e3)
    ], SysMLMetamodelBuilder.prototype, "collectDependencyReferences", null);
    __decorate([
      builder(ast_1.OperatorExpression, -1)
    ], SysMLMetamodelBuilder.prototype, "addOperatorExpressionTyping", null);
    __decorate([
      builder(ast_1.TypeFeaturing, 1e3)
    ], SysMLMetamodelBuilder.prototype, "addNonDeclarationTypeFeaturing", null);
    __decorate([
      builder([ast_1.ItemFlow, ast_1.FlowConnectionUsage], 1e3)
    ], SysMLMetamodelBuilder.prototype, "setFlowEndDirections", null);
  }
});

// ../syside-languageserver/lib/services/parser/parser.js
var require_parser3 = __commonJS({
  "../syside-languageserver/lib/services/parser/parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareSysMLParser = exports2.createSysMLParser = exports2.SysMLParser = exports2.SysMLCstNodeBuilder = void 0;
    var langium_1 = require_lib2();
    var parser_builder_base_1 = require_parser_builder_base();
    var cst_node_builder_1 = require_cst_node_builder();
    var ast_1 = require_ast2();
    var types_1 = require_types2();
    var ast_util_1 = require_ast_util2();
    var ast_2 = require_ast();
    var common_1 = require_common();
    var ClassificationTestOperator = ["istype", "hastype", "@", "as"];
    function fixOperatorExpression(expr, services) {
      if (!expr.operands)
        expr.operands = [];
      if (expr.operands.length === 0 && expr.operator && ClassificationTestOperator.includes(expr.operator)) {
        const reflection = services.shared.AstReflection;
        const expression = reflection.createNode(ast_1.FeatureReferenceExpression, {
          $container: expr,
          $containerProperty: "operands",
          $containerIndex: 0
        });
        const member = reflection.createNode(ast_1.ReturnParameterMembership, {
          $container: expression,
          $containerProperty: "expression"
        });
        reflection.createNode(ast_1.Feature, {
          $container: member,
          $containerProperty: "target"
        });
      }
    }
    function addLoopMember(node, services) {
      if (!node.condition) {
        const reflection = services.shared.AstReflection;
        const membership = reflection.createNode(ast_1.ParameterMembership, {
          $container: node,
          $containerProperty: "condition"
        });
        reflection.createNode(ast_1.Usage, {
          $container: membership,
          $containerProperty: "target"
        });
      }
    }
    function finalizeImport(node, services) {
      const type = node.$type;
      if (type !== ast_1.Import && type !== ast_1.Expose)
        return;
      if (node.isNamespace || node.target) {
        if (node.targetRef) {
          node.targetRef.$type = node.isNamespace ? ast_1.NamespaceReference : ast_1.MembershipReference;
        }
        node.$type = type === ast_1.Expose ? ast_1.NamespaceExpose : ast_1.NamespaceImport;
        if (node.target && node.targetRef) {
          const pack = node.target;
          const imp = services.shared.AstReflection.createNode(node.isNamespace ? ast_1.NamespaceImport : ast_1.MembershipImport, {
            $container: pack,
            $containerProperty: "children",
            $containerIndex: 0,
            isRecursive: node.isRecursive
          });
          services.shared.AstReflection.assignNode(node.targetRef, {
            $container: imp,
            $containerProperty: "targetRef"
          });
          (0, common_1.erase)(node.$children, node.targetRef);
          delete node.targetRef;
        }
        delete node.isNamespace;
      } else {
        if (node.targetRef)
          node.targetRef.$type = ast_1.MembershipReference;
        node.$type = type === ast_1.Expose ? ast_1.MembershipExpose : ast_1.MembershipImport;
      }
    }
    function createEmptyParametersInTransitionUsage(node, services) {
      const reflection = services.shared.AstReflection;
      {
        const membership = reflection.createNode(ast_1.ParameterMembership, {
          $container: node,
          $containerProperty: "transitionLinkSource"
        });
        reflection.createNode(ast_1.ReferenceUsage, {
          $container: membership,
          $containerProperty: "target"
        });
      }
      if (!node.accepter)
        return;
      {
        const membership = reflection.createNode(ast_1.ParameterMembership, {
          $container: node,
          $containerProperty: "payload"
        });
        reflection.createNode(ast_1.ReferenceUsage, {
          $container: membership,
          $containerProperty: "target"
        });
      }
    }
    function createMissingEndsInSuccessionAsUsage(node, services) {
      var _a;
      (_a = node.ends) !== null && _a !== void 0 ? _a : node.ends = [];
      const ends = node.ends.length;
      if (ends >= 2)
        return;
      const reflection = services.shared.AstReflection;
      let insert = [0, 1];
      if (ends === 1) {
        if (node.ends[0].target.multiplicity)
          insert = [1];
        else
          insert = [0];
      }
      for (const index of insert) {
        const member = reflection.createNode(ast_1.EndFeatureMembership, {
          $container: node,
          $containerProperty: "ends",
          $containerIndex: index,
          $cstNode: node.$cstNode
        });
        reflection.createNode(ast_1.Feature, {
          $container: member,
          $containerProperty: "target",
          $cstNode: node.$cstNode
        });
      }
    }
    var SysMLCstNodeBuilder = class extends cst_node_builder_1.CstNodeBuilder {
      constructor(services) {
        super();
        this.services = services;
        const map = {
          OperatorExpression: fixOperatorExpression,
          WhileLoopActionUsage: addLoopMember,
          Import: finalizeImport,
          TransitionUsage: createEmptyParametersInTransitionUsage,
          SuccessionAsUsage: createMissingEndsInSuccessionAsUsage
        };
        this.postprocessingMap = types_1.typeIndex.expandToDerivedTypes(map);
      }
      construct(item) {
        var _a;
        super.construct(item);
        if (typeof item.$type === "string") {
          (_a = this.postprocessingMap.get(item.$type)) === null || _a === void 0 ? void 0 : _a.call(void 0, item, this.services);
        }
      }
    };
    exports2.SysMLCstNodeBuilder = SysMLCstNodeBuilder;
    function collectChildren(node) {
      node.$children.length = 0;
      node.$children.push(...(0, langium_1.streamContents)(node).toArray());
      node.$children.sort((a, b) => {
        var _a, _b;
        return (0, ast_util_1.compareRanges)((_a = a.$cstNode) === null || _a === void 0 ? void 0 : _a.range, (_b = b.$cstNode) === null || _b === void 0 ? void 0 : _b.range);
      });
      node.$children.forEach((child, index) => child.$childIndex = index);
    }
    var SysMLParser = class extends langium_1.LangiumParser {
      constructor(services) {
        super(services);
        this.nodeBuilder = new SysMLCstNodeBuilder(services);
      }
      fillNode(node) {
        super["assignMandatoryProperties"](node);
        if ((0, langium_1.isAstNode)(node))
          collectChildren(node);
      }
      construct(pop) {
        const value = super.construct(pop);
        if ((0, langium_1.isAstNode)(value))
          collectChildren(value);
        return value;
      }
    };
    exports2.SysMLParser = SysMLParser;
    function createSysMLParser(services) {
      const parser = prepareSysMLParser(services);
      parser.finalize();
      return parser;
    }
    exports2.createSysMLParser = createSysMLParser;
    function prepareSysMLParser(services) {
      const grammar = services.Grammar;
      const lexer = services.parser.Lexer;
      const parser = new SysMLParser(services);
      return (0, parser_builder_base_1.createParser)(grammar, parser, lexer.definition);
    }
    exports2.prepareSysMLParser = prepareSysMLParser;
    langium_1.LangiumParser.prototype["assignWithoutOverride"] = function(target, source) {
      const hasType = target.$type !== void 0;
      for (const [name, existingValue] of Object.entries(source)) {
        const newValue = target[name];
        if (newValue === void 0) {
          target[name] = existingValue;
        } else if (Array.isArray(newValue) && Array.isArray(existingValue)) {
          existingValue.push(...newValue);
          target[name] = existingValue;
        }
      }
      if (!hasType && source.$type) {
        this["assignMandatoryProperties"](target);
        collectChildren(target);
      }
      if (source.$cstNode) {
        const feature = source.$cstNode.feature;
        if ((0, ast_2.isRuleCall)(feature) && feature.rule.ref && !feature.rule.ref.fragment) {
          const iterator = (0, langium_1.streamCst)(source.$cstNode).iterator();
          let current = iterator.next();
          while (!current.done) {
            const node = current.value;
            if (node.element === source) {
              Object.defineProperty(node, "element", {
                get() {
                  var _a;
                  return (_a = target.$cstNode.element) !== null && _a !== void 0 ? _a : target;
                },
                set(element) {
                  Object.defineProperty(node, "element", element);
                },
                configurable: true
              });
            } else {
              iterator.prune();
            }
            current = iterator.next();
          }
        }
      }
      return target;
    };
  }
});

// ../syside-languageserver/lib/services/shared/workspace/ast-descriptions.js
var require_ast_descriptions2 = __commonJS({
  "../syside-languageserver/lib/services/shared/workspace/ast-descriptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLNodeDescriptionProvider = void 0;
    var langium_1 = require_lib2();
    var SysMLNodeDescriptionProvider = class {
      constructor(services) {
        this.astNodeLocator = services.workspace.AstNodeLocator;
      }
      /**
       * @override
       * @param node an Element
       * @param name name used to identify {@link node}
       * @param document The document containing the Element node. If omitted, it
       * is taken from the root AST node.
       */
      createDescription(node, name, document = (0, langium_1.getDocument)(node)) {
        return {
          node,
          name,
          type: node.$type,
          documentUri: document.uri,
          path: this.astNodeLocator.getAstNodePath(node)
        };
      }
    };
    exports2.SysMLNodeDescriptionProvider = SysMLNodeDescriptionProvider;
  }
});

// ../syside-protocol/lib/protocol-extensions.js
var require_protocol_extensions = __commonJS({
  "../syside-protocol/lib/protocol-extensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FindStdlibRequest = exports2.RegisterTextEditorCommandsRequest = void 0;
    var vscode_languageserver_1 = require_main4();
    var RegisterTextEditorCommandsRequest;
    (function(RegisterTextEditorCommandsRequest2) {
      RegisterTextEditorCommandsRequest2.method = "sysml/registerTextEditorCommands";
      RegisterTextEditorCommandsRequest2.messageDirection = vscode_languageserver_1.MessageDirection.serverToClient;
      RegisterTextEditorCommandsRequest2.type = new vscode_languageserver_1.ProtocolRequestType(RegisterTextEditorCommandsRequest2.method);
    })(RegisterTextEditorCommandsRequest || (exports2.RegisterTextEditorCommandsRequest = RegisterTextEditorCommandsRequest = {}));
    var FindStdlibRequest;
    (function(FindStdlibRequest2) {
      FindStdlibRequest2.method = "sysml/findStdlib";
      FindStdlibRequest2.messageDirection = vscode_languageserver_1.MessageDirection.serverToClient;
      FindStdlibRequest2.type = new vscode_languageserver_1.ProtocolRequestType0(FindStdlibRequest2.method);
      FindStdlibRequest2.ProgressToken = "sysml/findStdlib/progress";
    })(FindStdlibRequest || (exports2.FindStdlibRequest = FindStdlibRequest = {}));
  }
});

// ../syside-protocol/lib/index.js
var require_lib3 = __commonJS({
  "../syside-protocol/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_protocol_extensions(), exports2);
  }
});

// ../syside-languageserver/lib/model/sexp.js
var require_sexp = __commonJS({
  "../syside-languageserver/lib/model/sexp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toSExp = void 0;
    var ast_1 = require_ast2();
    function isImplied(node) {
      const parent = node.parent();
      return node.is(ast_1.Relationship) && node.isImplied || !!parent && (parent === null || parent === void 0 ? void 0 : parent.is(ast_1.Relationship)) && (parent === null || parent === void 0 ? void 0 : parent.isImplied);
    }
    function toSExp(node, depth = 0, options = {
      includeElementId: false,
      includeImplicit: true,
      includeTargets: true,
      indent: 2,
      recursive: true
    }) {
      const finish = (out2) => {
        out2.push(")");
        return out2.join("");
      };
      const out = ["\n", " ".repeat(depth * options.indent), `(${node.nodeType()}`];
      if (node.shortName) {
        out.push(` <${node.shortName}>`);
      }
      if (node.name) {
        out.push(` ${node.name}`);
      }
      if (options.includeElementId) {
        out.push(` [id:${node.elementId}]`);
      }
      if (isImplied(node)) {
        out.push(` (implicit)`);
      }
      if (!options.recursive) {
        return finish(out);
      }
      const exps = node.ownedElements().filter((elem) => !isImplied(elem) || options.includeImplicit).map((elem) => toSExp(elem, depth + 1, options)).toArray();
      out.push(...exps);
      if (exps.length === 0 && options.includeTargets && node.is(ast_1.Relationship)) {
        const element = node.element();
        if (element) {
          out.push(toSExp(element, depth + 1, Object.assign(Object.assign({}, options), { recursive: false })));
        }
      }
      return finish(out);
    }
    exports2.toSExp = toSExp;
  }
});

// ../syside-languageserver/lib/services/lsp/execute-command-handler.js
var require_execute_command_handler2 = __commonJS({
  "../syside-languageserver/lib/services/lsp/execute-command-handler.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLExecuteCommandHandler = void 0;
    var langium_1 = require_lib2();
    var vscode_languageserver_1 = require_main4();
    var vscode_uri_1 = require_umd();
    var ast_1 = require_ast2();
    var common_1 = require_common();
    var syside_protocol_1 = require_lib3();
    var scopes_1 = require_scopes();
    var sexp_1 = require_sexp();
    var CommandMap = Map;
    var TEXT_EDITOR_FUNCTIONS = new CommandMap();
    var SIMPLE_COMMANDS = new CommandMap();
    var DOCUMENT_COMMANDS = new CommandMap();
    function withConsole(fn) {
      return function(args, token) {
        return __awaiter(this, void 0, void 0, function* () {
          const ret = fn.call(this, args, token);
          Promise.resolve(ret).then((value) => {
            if (typeof value === "string")
              console.log(value);
            else
              console.log(JSON.stringify(value, void 0, 2));
          });
          return ret;
        });
      };
    }
    function addCommand(map, name, fn) {
      map.set(name, fn);
      map.set(name + ".console", withConsole(fn));
    }
    function wrapEditorCommand(name, command, thisObj) {
      return function(args, cancelToken) {
        if (args.length > 0)
          return command.call(thisObj !== null && thisObj !== void 0 ? thisObj : this, args[0], cancelToken);
        else
          throw new Error(`No arguments provided for ${name}`);
      };
    }
    function editorCommand(name) {
      return function(_target, _propertyKey, descriptor) {
        const fn = descriptor.value;
        if (!fn)
          return;
        addCommand(TEXT_EDITOR_FUNCTIONS, name, wrapEditorCommand(name, fn));
      };
    }
    function wrapSimpleCommand(name, command, thisObj) {
      return function(_args, cancelToken) {
        return command.call(thisObj !== null && thisObj !== void 0 ? thisObj : this, cancelToken);
      };
    }
    function simpleCommand(name) {
      return (_target, _propertyKey, descriptor) => {
        const fn = descriptor.value;
        if (!fn)
          return;
        addCommand(SIMPLE_COMMANDS, name, wrapSimpleCommand(name, fn));
      };
    }
    function wrapDocumentCommand(name, command, thisObj) {
      return function(args, cancelToken) {
        if (args.length > 0)
          return command.call(thisObj !== null && thisObj !== void 0 ? thisObj : this, args[0], cancelToken);
        else
          throw new Error(`No arguments provided for ${name}`);
      };
    }
    function documentCommand(name) {
      return (_target, _propertyKey, descriptor) => {
        const fn = descriptor.value;
        if (!fn)
          return;
        addCommand(DOCUMENT_COMMANDS, name, wrapDocumentCommand(name, fn));
      };
    }
    var SysMLExecuteCommandHandler = class extends langium_1.AbstractExecuteCommandHandler {
      constructor(services) {
        super();
        this.documents = services.workspace.LangiumDocuments;
        this.builder = services.workspace.DocumentBuilder;
        this.registry = services.ServiceRegistry;
        this.connection = services.lsp.Connection;
        this.shared = services;
        services.lsp.LanguageServer.onInitialized((_) => {
          var _a;
          this.registerCustomClientCommands();
          (_a = this.connection) === null || _a === void 0 ? void 0 : _a.sendRequest(syside_protocol_1.RegisterTextEditorCommandsRequest.type, {
            commands: Array.from(TEXT_EDITOR_FUNCTIONS.keys())
          });
        });
      }
      /**
       * Register a custom command with the first {@link RegisterTextEditorCommandsRequest.Parameters} argument
       * @param name command name, should be unique
       * @param command command that will be executed
       * @param thisObj `this` that will be used to execute `command`
       * @returns a Disposable that will unregister the command
       */
      registerEditorCommand(name, command, thisObj = this) {
        return this.registerCustomCommand(name, command, wrapEditorCommand, thisObj);
      }
      /**
       * Register a custom command with no argument
       * @param name command name, should be unique
       * @param command command that will be executed
       * @param thisObj `this` that will be used to execute `command`
       * @returns a Disposable that will unregister the command
       */
      registerSimpleCommand(name, command, thisObj = this) {
        return this.registerCustomCommand(name, command, wrapSimpleCommand, thisObj);
      }
      /**
       * Register a custom command with the first {@link UriComponents} argument,
       * this is the default argument that is passed by default by the IDE, at
       * least by VS Code.
       * @param name command name, should be unique
       * @param command command that will be executed
       * @param thisObj `this` that will be used to execute `command`
       * @returns a Disposable that will unregister the command
       */
      registerDocumentCommand(name, command, thisObj = this) {
        return this.registerCustomCommand(name, command, wrapDocumentCommand, thisObj);
      }
      registerCustomCommand(name, command, wrapper, thisObj) {
        const wrapped = wrapper(name, command, thisObj);
        this.registeredCommands.set(name, wrapped);
        return vscode_languageserver_1.Disposable.create(() => {
          const current = this.registeredCommands.get(name);
          if (current === wrapped)
            this.registeredCommands.delete(name);
        });
      }
      registerCustomClientCommands() {
        for (const [command, fn] of TEXT_EDITOR_FUNCTIONS.entries())
          this.registeredCommands.set(command, fn);
      }
      registerCommands(acceptor) {
        const register = (commands) => {
          for (const [command, fn] of commands.entries())
            acceptor(command, fn);
        };
        register(SIMPLE_COMMANDS);
        register(DOCUMENT_COMMANDS);
      }
      /**
       * @returns the AST under active cursor as JSON string
       */
      dumpAst(editor, _ = vscode_languageserver_1.CancellationToken.None) {
        const node = this.findCursorNode(editor);
        if (!node)
          return;
        return (0, common_1.toJSON)(node, common_1.JSONreplacer);
      }
      /**
       * @returns the metamodel under active cursor as JSON string
       */
      dumpMeta(editor, _ = vscode_languageserver_1.CancellationToken.None) {
        const node = this.findCursorNode(editor);
        if (!(node === null || node === void 0 ? void 0 : node.$meta))
          return;
        return (0, common_1.toJSON)(node.$meta, common_1.JSONMetaReplacer);
      }
      /**
       * @return array of `"{qualified name} ({specialization kind}, implicit: {is
       * implicit})"` strings of types used in name resolution in the same order
       */
      mro(editor, _ = vscode_languageserver_1.CancellationToken.None) {
        var _a;
        const node = (_a = this.findCursorNode(editor)) === null || _a === void 0 ? void 0 : _a.$meta;
        if (!(node === null || node === void 0 ? void 0 : node.is(ast_1.Type)))
          return [];
        return (0, langium_1.stream)([[node.qualifiedName, node.nodeType(), "self"]]).concat(node.allSpecializations().map((s) => {
          var _a2;
          return [
            (_a2 = s.element()) === null || _a2 === void 0 ? void 0 : _a2.qualifiedName,
            s.nodeType(),
            s.isImplied ? "implicit" : "explicit"
          ];
        })).map(([name, type, kind]) => `${name} (${type}, ${kind})`).toArray();
      }
      /**
       * @return string with S-expression describing the abstract syntax of node
       */
      sexp(editor, _ = vscode_languageserver_1.CancellationToken.None) {
        var _a;
        const node = (_a = this.findCursorNode(editor)) === null || _a === void 0 ? void 0 : _a.$meta;
        if (!(node === null || node === void 0 ? void 0 : node.is(ast_1.Element)))
          return "not an element";
        return (0, sexp_1.toSExp)(node);
      }
      /**
       * @returns array of qualified children names visible to the linker in the
       * scope of the AST node under active cursor
       */
      children(editor, _ = vscode_languageserver_1.CancellationToken.None) {
        var _a;
        const node = (_a = this.findCursorNode(editor)) === null || _a === void 0 ? void 0 : _a.$meta;
        if (!(node === null || node === void 0 ? void 0 : node.is(ast_1.Element)))
          return [];
        return (0, scopes_1.makeLinkingScope)(node, { skipParents: true }).getAllElements().map((d) => `${d.name} [${(0, ast_1.isElement)(d.node) ? d.node.$meta.qualifiedName : ""}]`).toArray();
      }
      /**
       * @returns array of all qualified names visible to linker in the scope of
       * the AST node under active cursor
       */
      scope(editor, _ = vscode_languageserver_1.CancellationToken.None) {
        var _a;
        const node = (_a = this.findCursorNode(editor)) === null || _a === void 0 ? void 0 : _a.$meta;
        if (!(node === null || node === void 0 ? void 0 : node.is(ast_1.Element)))
          return [];
        return (0, scopes_1.makeLinkingScope)(node).getAllExportedElements().map(([name, d]) => {
          var _a2;
          return `${name} [${(_a2 = d.element()) === null || _a2 === void 0 ? void 0 : _a2.qualifiedName}]`;
        }).toArray();
      }
      /**
       * Evaluate the inline expression or the feature value of the AST node under
       * active cursor
       * @returns result of the evaluated inline expression
       */
      evaluate(editor, _ = vscode_languageserver_1.CancellationToken.None) {
        var _a;
        const node = (_a = this.findCursorNode(editor)) === null || _a === void 0 ? void 0 : _a.$meta;
        if (!node)
          return;
        const evaluator = this.shared.Evaluator;
        if (node.is(ast_1.InlineExpression)) {
          let parent = node.owner();
          while (parent && !parent.is(ast_1.Element))
            parent = parent.owner();
          if (parent)
            return (0, common_1.toJSON)(evaluator.evaluate(node, parent), common_1.JSONreplacer);
        } else if (node.is(ast_1.Feature)) {
          if (!node.value)
            return;
          const expression = node.value.element();
          if (!expression)
            return;
          return (0, common_1.toJSON)(evaluator.evaluate(expression, node), common_1.JSONreplacer);
        } else if (node.is(ast_1.FeatureValue)) {
          const expression = node.element();
          if (!expression)
            return;
          return (0, common_1.toJSON)(evaluator.evaluate(expression, node.parent()), common_1.JSONreplacer);
        }
        return;
      }
      /**
       * @see {@link editorCommand}
       * @returns array of available editor commands
       */
      getEditorCommands(_ = vscode_languageserver_1.CancellationToken.None) {
        return Array.from(TEXT_EDITOR_FUNCTIONS.keys());
      }
      /**
       * @see {@link simpleCommand}
       * @returns array of available simple commands
       */
      getSimpleCommands(_ = vscode_languageserver_1.CancellationToken.None) {
        return Array.from(SIMPLE_COMMANDS.keys());
      }
      /**
       * @see {@link editorCommand}
       * @see {@link simpleCommand}
       * @see {@link documentCommand}
       * @returns array of all available commands
       */
      getAllCommands(_ = vscode_languageserver_1.CancellationToken.None) {
        return this.commands;
      }
      /**
       * Try updating a document
       * @param uriComp URI components of the document to update
       * @param token cancellation token
       */
      updateDocument(uriComp, token = vscode_languageserver_1.CancellationToken.None) {
        return __awaiter(this, void 0, void 0, function* () {
          const uri = vscode_uri_1.URI.from(uriComp);
          yield this.builder.update([uri], [], token);
        });
      }
      executeCommand(name, args, cancelToken) {
        return __awaiter(this, void 0, void 0, function* () {
          const command = this.registeredCommands.get(name);
          if (command) {
            return command.call(this, args, cancelToken);
          } else {
            return void 0;
          }
        });
      }
      /**
       * Get active position
       * @param editor
       * @returns `Position` if found, undefined otherwise
       */
      getActivePosition(editor) {
        var _a, _b, _c, _d, _e;
        const getPosition = (selection) => {
          if (Array.isArray(selection))
            return selection === null || selection === void 0 ? void 0 : selection[0];
          return void 0;
        };
        if (!((_a = editor === null || editor === void 0 ? void 0 : editor.document) === null || _a === void 0 ? void 0 : _a.uri)) {
          console.error("findCursorNode called with missing editor or document parameters.", editor);
          return;
        }
        return ((_b = editor.selection) === null || _b === void 0 ? void 0 : _b.active) || ((_d = (_c = editor.selections) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.active) || getPosition(editor.selection) || getPosition((_e = editor.selections) === null || _e === void 0 ? void 0 : _e[0]);
      }
      /**
       * Find node under current selection
       * @param editor
       * @returns `AstNode` if found, undefined otherwise
       */
      findCursorNode(editor) {
        const activePosition = this.getActivePosition(editor);
        if (!activePosition) {
          console.error("Could not determine cursor position from editor parameters.", editor);
          return;
        }
        const uri = vscode_uri_1.URI.parse(editor.document.uri);
        if (!this.documents.hasDocument(uri))
          return;
        const document = this.documents.getOrCreateDocument(uri);
        const rootNode = document.parseResult.value.$cstNode;
        if (!rootNode)
          return;
        const leaf = (0, langium_1.findDeclarationNodeAtOffset)(rootNode, document.textDocument.offsetAt(activePosition));
        return leaf === null || leaf === void 0 ? void 0 : leaf.element;
      }
    };
    exports2.SysMLExecuteCommandHandler = SysMLExecuteCommandHandler;
    __decorate([
      editorCommand("syside.editor.dumpAst")
    ], SysMLExecuteCommandHandler.prototype, "dumpAst", null);
    __decorate([
      editorCommand("syside.editor.dumpMeta")
    ], SysMLExecuteCommandHandler.prototype, "dumpMeta", null);
    __decorate([
      editorCommand("syside.editor.mro")
    ], SysMLExecuteCommandHandler.prototype, "mro", null);
    __decorate([
      editorCommand("syside.editor.sexp")
    ], SysMLExecuteCommandHandler.prototype, "sexp", null);
    __decorate([
      editorCommand("syside.editor.children")
    ], SysMLExecuteCommandHandler.prototype, "children", null);
    __decorate([
      editorCommand("syside.editor.scope")
    ], SysMLExecuteCommandHandler.prototype, "scope", null);
    __decorate([
      editorCommand("syside.editor.evaluate")
    ], SysMLExecuteCommandHandler.prototype, "evaluate", null);
    __decorate([
      simpleCommand("syside.editor.editorCommands")
    ], SysMLExecuteCommandHandler.prototype, "getEditorCommands", null);
    __decorate([
      simpleCommand("syside.editor.simpleCommands")
    ], SysMLExecuteCommandHandler.prototype, "getSimpleCommands", null);
    __decorate([
      simpleCommand("syside.editor.allCommands")
    ], SysMLExecuteCommandHandler.prototype, "getAllCommands", null);
    __decorate([
      documentCommand("syside.editor.updateDocument")
    ], SysMLExecuteCommandHandler.prototype, "updateDocument", null);
  }
});

// ../syside-base/lib/stdlib.js
var require_stdlib = __commonJS({
  "../syside-base/lib/stdlib.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.STDLIB = void 0;
    exports2.STDLIB = {
      version: "2024-12",
      tree: "https://github.com/daumantas-kavolis-sensmetry/SysML-v2-Release/blob/fixes/sysml.library/",
      raw: "https://raw.githubusercontent.com/daumantas-kavolis-sensmetry/SysML-v2-Release/fixes/sysml.library/",
      files: [
        "Systems Library/Actions.sysml",
        "Systems Library/Allocations.sysml",
        "Systems Library/AnalysisCases.sysml",
        "Systems Library/Attributes.sysml",
        "Systems Library/Calculations.sysml",
        "Systems Library/Cases.sysml",
        "Systems Library/Connections.sysml",
        "Systems Library/Constraints.sysml",
        "Systems Library/FlowConnections.sysml",
        "Systems Library/Interfaces.sysml",
        "Systems Library/Items.sysml",
        "Systems Library/Metadata.sysml",
        "Systems Library/Parts.sysml",
        "Systems Library/Ports.sysml",
        "Systems Library/Requirements.sysml",
        "Systems Library/StandardViewDefinitions.sysml",
        "Systems Library/States.sysml",
        "Systems Library/SysML.sysml",
        "Systems Library/UseCases.sysml",
        "Systems Library/VerificationCases.sysml",
        "Systems Library/Views.sysml",
        "Kernel Libraries/Kernel Semantic Library/Base.kerml",
        "Kernel Libraries/Kernel Semantic Library/Clocks.kerml",
        "Kernel Libraries/Kernel Semantic Library/ControlPerformances.kerml",
        "Kernel Libraries/Kernel Semantic Library/FeatureReferencingPerformances.kerml",
        "Kernel Libraries/Kernel Semantic Library/KerML.kerml",
        "Kernel Libraries/Kernel Semantic Library/Links.kerml",
        "Kernel Libraries/Kernel Semantic Library/Metaobjects.kerml",
        "Kernel Libraries/Kernel Semantic Library/Objects.kerml",
        "Kernel Libraries/Kernel Semantic Library/Observation.kerml",
        "Kernel Libraries/Kernel Semantic Library/Occurrences.kerml",
        "Kernel Libraries/Kernel Semantic Library/Performances.kerml",
        "Kernel Libraries/Kernel Semantic Library/SpatialFrames.kerml",
        "Kernel Libraries/Kernel Semantic Library/StatePerformances.kerml",
        "Kernel Libraries/Kernel Semantic Library/Transfers.kerml",
        "Kernel Libraries/Kernel Semantic Library/TransitionPerformances.kerml",
        "Kernel Libraries/Kernel Semantic Library/Triggers.kerml",
        "Kernel Libraries/Kernel Function Library/BaseFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/BooleanFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/CollectionFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/ComplexFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/ControlFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/DataFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/IntegerFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/NaturalFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/NumericalFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/OccurrenceFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/RationalFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/RealFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/ScalarFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/SequenceFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/StringFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/TrigFunctions.kerml",
        "Kernel Libraries/Kernel Function Library/VectorFunctions.kerml",
        "Kernel Libraries/Kernel Data Type Library/Collections.kerml",
        "Kernel Libraries/Kernel Data Type Library/ScalarValues.kerml",
        "Kernel Libraries/Kernel Data Type Library/VectorValues.kerml",
        "Domain Libraries/Requirement Derivation/DerivationConnections.sysml",
        "Domain Libraries/Requirement Derivation/RequirementDerivation.sysml",
        "Domain Libraries/Quantities and Units/ISQ.sysml",
        "Domain Libraries/Quantities and Units/ISQAcoustics.sysml",
        "Domain Libraries/Quantities and Units/ISQAtomicNuclear.sysml",
        "Domain Libraries/Quantities and Units/ISQBase.sysml",
        "Domain Libraries/Quantities and Units/ISQCharacteristicNumbers.sysml",
        "Domain Libraries/Quantities and Units/ISQChemistryMolecular.sysml",
        "Domain Libraries/Quantities and Units/ISQCondensedMatter.sysml",
        "Domain Libraries/Quantities and Units/ISQElectromagnetism.sysml",
        "Domain Libraries/Quantities and Units/ISQInformation.sysml",
        "Domain Libraries/Quantities and Units/ISQLight.sysml",
        "Domain Libraries/Quantities and Units/ISQMechanics.sysml",
        "Domain Libraries/Quantities and Units/ISQSpaceTime.sysml",
        "Domain Libraries/Quantities and Units/ISQThermodynamics.sysml",
        "Domain Libraries/Quantities and Units/MeasurementRefCalculations.sysml",
        "Domain Libraries/Quantities and Units/MeasurementReferences.sysml",
        "Domain Libraries/Quantities and Units/Quantities.sysml",
        "Domain Libraries/Quantities and Units/QuantityCalculations.sysml",
        "Domain Libraries/Quantities and Units/SI.sysml",
        "Domain Libraries/Quantities and Units/SIPrefixes.sysml",
        "Domain Libraries/Quantities and Units/TensorCalculations.sysml",
        "Domain Libraries/Quantities and Units/Time.sysml",
        "Domain Libraries/Quantities and Units/USCustomaryUnits.sysml",
        "Domain Libraries/Quantities and Units/VectorCalculations.sysml",
        "Domain Libraries/Metadata/ImageMetadata.sysml",
        "Domain Libraries/Metadata/ModelingMetadata.sysml",
        "Domain Libraries/Metadata/ParametersOfInterestMetadata.sysml",
        "Domain Libraries/Metadata/RiskMetadata.sysml",
        "Domain Libraries/Geometry/ShapeItems.sysml",
        "Domain Libraries/Geometry/SpatialItems.sysml",
        "Domain Libraries/Cause and Effect/CausationConnections.sysml",
        "Domain Libraries/Cause and Effect/CauseAndEffect.sysml",
        "Domain Libraries/Analysis/AnalysisTooling.sysml",
        "Domain Libraries/Analysis/SampledFunctions.sysml",
        "Domain Libraries/Analysis/StateSpaceRepresentation.sysml",
        "Domain Libraries/Analysis/TradeStudies.sysml"
      ]
    };
  }
});

// ../syside-base/lib/uri.js
var require_uri = __commonJS({
  "../syside-base/lib/uri.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolvePathURI = exports2.pathToURI = exports2.isUriLike = void 0;
    var path_1 = __importDefault(require("path"));
    var vscode_uri_1 = require_umd();
    function isUriLike(path2) {
      return /^[a-zA-Z][a-zA-Z\d+.-]+:/.test(path2);
    }
    exports2.isUriLike = isUriLike;
    function pathToURI(path2) {
      if (isUriLike(path2))
        return vscode_uri_1.URI.parse(path2);
      return vscode_uri_1.URI.file(path2);
    }
    exports2.pathToURI = pathToURI;
    function resolvePathURI(p) {
      if (isUriLike(p))
        return vscode_uri_1.URI.parse(p);
      return vscode_uri_1.URI.file(path_1.default.resolve(p));
    }
    exports2.resolvePathURI = resolvePathURI;
  }
});

// ../syside-base/lib/index.js
var require_lib4 = __commonJS({
  "../syside-base/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_stdlib(), exports2);
    __exportStar(require_uri(), exports2);
  }
});

// ../syside-languageserver/lib/services/shared/workspace/workspace-manager.js
var require_workspace_manager2 = __commonJS({
  "../syside-languageserver/lib/services/shared/workspace/workspace-manager.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLWorkspaceManager = void 0;
    var langium_1 = require_lib2();
    var vscode_languageserver_1 = require_main4();
    var vscode_uri_1 = require_umd();
    var syside_protocol_1 = require_lib3();
    var performance_now_1 = __importDefault(require_performance_now());
    var path_1 = __importDefault(require("path"));
    var syside_base_1 = require_lib4();
    var SysMLWorkspaceManager = class extends langium_1.DefaultWorkspaceManager {
      constructor(services) {
        super(services);
        this.fileSystemProvider = services.workspace.FileSystemProvider;
        this.config = services.workspace.ConfigurationProvider;
        this.connection = services.lsp.Connection;
        this.extensions = services.ExtensionManager;
      }
      initializeWorkspace(folders, cancelToken) {
        const _super = Object.create(null, {
          initializeWorkspace: { get: () => super.initializeWorkspace }
        });
        return __awaiter(this, void 0, void 0, function* () {
          yield this.config.firstTimeSetup();
          const config = this.config.get();
          if (config.skipWorkspaceInit) {
            return;
          }
          yield this.loadPlugins(folders);
          yield _super.initializeWorkspace.call(this, folders, cancelToken);
        });
      }
      /**
       * Load declared .js plugins
       * @param folders workspace folders used to resolve relative paths
       */
      loadPlugins(folders) {
        return __awaiter(this, void 0, void 0, function* () {
          const plugins = this.config.get().plugins;
          const promises = folders.map((folder) => {
            const uri = vscode_uri_1.URI.parse(folder.uri);
            this.extensions.loadScripts(plugins.map((plugin) => {
              if ((0, syside_base_1.isUriLike)(plugin))
                return vscode_uri_1.URI.parse(plugin);
              if (path_1.default.isAbsolute(plugin))
                return vscode_uri_1.URI.file(plugin);
              return vscode_uri_1.Utils.joinPath(uri, plugin);
            }));
          });
          yield Promise.allSettled(promises);
        });
      }
      loadAdditionalDocuments(folders, collector) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const config = this.config.get();
          if (!config.standardLibrary)
            return;
          let dir = this.fileSystemProvider.standardLibrary;
          if (!dir || !this.fileSystemProvider.existsSync(dir)) {
            if (dir) {
              (_a = this.connection) === null || _a === void 0 ? void 0 : _a.sendRequest(vscode_languageserver_1.ShowMessageRequest.type, {
                type: vscode_languageserver_1.MessageType.Error,
                message: `Standard library path '${dir ? dir : ""}' does not exist`
              });
              return;
            }
            const result = yield this.requestClientStdlibDir();
            if (!result)
              return;
            dir = (0, syside_base_1.pathToURI)(result);
          }
          const content = yield this.fileSystemProvider.readDirectory(dir);
          const collected = [];
          const fileExtensions = this.serviceRegistry.all.flatMap((e) => e.LanguageMetaData.fileExtensions);
          for (const node of content) {
            if (!this.includeEntry(folders[0], node, fileExtensions))
              continue;
            if (node.isFile) {
              collected.push(node.uri);
            } else {
              content.push(...yield this.fileSystemProvider.readDirectory(node.uri));
            }
          }
          yield this.fileSystemProvider.preloadFiles(collected);
          for (const uri of collected) {
            const doc = this.langiumDocuments.getOrCreateDocument(uri);
            doc.isStandard = true;
            collector(doc);
          }
          console.log(`Collected standard library:
${JSON.stringify(collected.map((uri) => uri.toString()), void 0, 2)}`);
          return;
        });
      }
      /**
       * Request client to find the path to the standard library
       * @returns a promise that resolves to the standard library path if found or undefined
       */
      requestClientStdlibDir() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.connection)
            return;
          let end = (0, performance_now_1.default)() + 5e3;
          const disposable = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.onProgress(syside_protocol_1.FindStdlibRequest.type, syside_protocol_1.FindStdlibRequest.ProgressToken, () => {
            end = (0, performance_now_1.default)() + 5e3;
          });
          let resolved = false;
          const findRequest = this.connection.sendRequest(syside_protocol_1.FindStdlibRequest.type);
          const timeout = new Promise((resolve, reject) => {
            const check = () => {
              if (resolved)
                resolve();
              else if ((0, performance_now_1.default)() > end)
                reject(langium_1.OperationCancelled);
              else
                setTimeout(check, 1e3);
            };
            check();
          });
          const result = yield Promise.race([findRequest, timeout]).finally(() => {
            disposable.dispose();
            resolved = true;
          });
          if (typeof result !== "string")
            return;
          return result;
        });
      }
    };
    exports2.SysMLWorkspaceManager = SysMLWorkspaceManager;
  }
});

// ../syside-languageserver/lib/services/shared/workspace/documents.js
var require_documents3 = __commonJS({
  "../syside-languageserver/lib/services/shared/workspace/documents.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLDocuments = exports2.SysMLDocumentFactory = void 0;
    var langium_1 = require_lib2();
    var utils_1 = require_utils2();
    var performance_now_1 = __importDefault(require_performance_now());
    var SysMLDocumentFactory = class extends langium_1.DefaultLangiumDocumentFactory {
      constructor(services) {
        super(services);
        this.metamodelBuilder = services.workspace.MetamodelBuilder;
        this.config = services.workspace.ConfigurationProvider;
      }
      update(document) {
        const doc = super.update(document);
        return this.onCreated(doc);
      }
      createLangiumDocument(parseResult, uri, textDocument, text) {
        const doc = super.createLangiumDocument(parseResult, uri, textDocument, text);
        doc.parseDuration = parseResult.duration;
        return this.onCreated(doc);
      }
      onCreated(doc) {
        doc.uriString = doc.uri.toString();
        doc.progress = 0;
        doc.exports = /* @__PURE__ */ new Map();
        doc.namedElements = /* @__PURE__ */ new Map();
        doc.astNodes = (0, utils_1.streamAst)(doc.parseResult.value).toArray();
        doc.modelDiagnostics = new langium_1.MultiMap();
        doc.onInvalidated = new langium_1.MultiMap();
        doc.commentsAttached = false;
        this.metamodelBuilder.onParsed(doc);
        return doc;
      }
      parse(uri, text) {
        const start = (0, performance_now_1.default)();
        const result = super.parse(uri, text);
        const duration = (0, performance_now_1.default)() - start;
        if (this.config.get().logStatistics)
          console.info(`Parsed ${uri.toString()} in ${duration.toFixed(2)} ms (${(text.length / duration).toFixed(0)} bytes/ms)`);
        return Object.assign(Object.assign({}, result), { duration });
      }
    };
    exports2.SysMLDocumentFactory = SysMLDocumentFactory;
    var SysMLDocuments = class extends langium_1.DefaultLangiumDocuments {
      invalidateDocument(uri) {
        const doc = super.invalidateDocument(uri);
        if (doc) {
          doc.progress = 0;
          doc.exports.clear();
          doc.namedElements.clear();
          doc.modelDiagnostics.clear();
          doc.onInvalidated.values().forEach((cb) => cb());
          doc.onInvalidated.clear();
        }
        return doc;
      }
      deleteDocument(uri) {
        const doc = super.deleteDocument(uri);
        doc === null || doc === void 0 ? void 0 : doc.onInvalidated.values().forEach((cb) => cb());
        return doc;
      }
    };
    exports2.SysMLDocuments = SysMLDocuments;
  }
});

// ../syside-languageserver/lib/services/config.js
var require_config = __commonJS({
  "../syside-languageserver/lib/services/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultSysMLConfig = exports2.DefaultTraceConfig = exports2.DefaultBuildOptions = exports2.DefaultDebugConfig = void 0;
    var model_1 = require_model3();
    exports2.DefaultDebugConfig = {
      scopeInLinkingErrors: "none",
      stacktraceInLinkingErrors: true,
      linkingTrace: false
    };
    exports2.DefaultBuildOptions = {
      validationChecks: "all",
      ignoreMetamodelErrors: false,
      standardLibrary: "standard",
      standalone: false
    };
    exports2.DefaultTraceConfig = {
      server: "off"
    };
    exports2.DefaultSysMLConfig = {
      standardLibrary: true,
      standardLibraryPath: void 0,
      skipWorkspaceInit: false,
      debug: exports2.DefaultDebugConfig,
      defaultBuildOptions: exports2.DefaultBuildOptions,
      logStatistics: true,
      trace: exports2.DefaultTraceConfig,
      plugins: [],
      formatting: Object.assign(Object.assign({}, model_1.DefaultFormatOptions), { lineWidth: 120 })
    };
  }
});

// ../syside-languageserver/lib/services/lsp/semantic-token-provider.js
var require_semantic_token_provider2 = __commonJS({
  "../syside-languageserver/lib/services/lsp/semantic-token-provider.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLSemanticTokenProvider = void 0;
    var langium_1 = require_lib2();
    var ast_1 = require_ast2();
    var vscode_languageserver_1 = require_main4();
    var model_1 = require_model3();
    var semantic_tokens_1 = require_semantic_tokens();
    var SysMLSemanticTokenProvider = class extends langium_1.AbstractSemanticTokenProvider {
      constructor(services) {
        super(services);
        this.cachedTokens = /* @__PURE__ */ new Map();
        this.inBuild = /* @__PURE__ */ new Set();
        this.built = 0;
        this.supportsRefresh = false;
        this.connection = services.shared.lsp.Connection;
        this.builder = services.shared.workspace.DocumentBuilder;
        this.highlightMap = model_1.typeIndex.expandAndMerge({
          Element: [this.element],
          ElementReference: [this.elementReference],
          LiteralNumber: [this.literalNumber],
          LiteralString: [this.literalString],
          Comment: [this.comment],
          TextualRepresentation: [this.textualRep],
          OperatorExpression: [this.operatorExpression]
        });
        this.builder.onUpdate((changed, deleted) => __awaiter(this, void 0, void 0, function* () {
          this.inBuild.clear();
          this.built = 0;
          changed.forEach((uri) => {
            const str = uri.toString();
            const old = this.cachedTokens.get(str);
            if (old)
              this.cachedTokens.delete(str);
            else if (old === null)
              this.inBuild.add(str);
          });
          deleted.forEach((uri) => this.cachedTokens.delete(uri.toString()));
        }));
        this.builder.onBuildPhase(langium_1.DocumentState.Linked, (docs) => __awaiter(this, void 0, void 0, function* () {
          return this.refresh(docs);
        }));
        const disposable = services.shared.lsp.LanguageServer.onInitialize((params) => {
          var _a, _b, _c;
          this.supportsRefresh = (_c = this.connection && ((_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.semanticTokens) === null || _b === void 0 ? void 0 : _b.refreshSupport)) !== null && _c !== void 0 ? _c : false;
          disposable.dispose();
        });
        this.builder.onDocumentPhase(langium_1.DocumentState.Linked, (doc) => {
          if (this.inBuild.has(doc.uriString)) {
            this.built++;
            if (this.inBuild.size === this.built) {
              this.refresh(this.inBuild);
              this.inBuild.clear();
              this.built = 0;
            }
          }
        });
      }
      /**
       * Request a refresh of semantic tokens for {@link docs}. If the client
       * doesn't support semantic token refresh or there have been no incomplete
       * highlighting computed for any of the {@link docs}, the refresh request
       * is not sent.
       * @param docs documents that may need to have semantic highlighting refreshed
       */
      refresh(docs) {
        var _a;
        if (!this.supportsRefresh)
          return;
        let containsIncomplete = false;
        for (const doc of docs) {
          const uri = typeof doc === "string" ? doc : doc.uriString;
          if (this.cachedTokens.get(uri) === null) {
            containsIncomplete = true;
            this.tokensBuilders.delete(uri);
            this.cachedTokens.delete(uri);
          }
        }
        if (containsIncomplete) {
          (_a = this.connection) === null || _a === void 0 ? void 0 : _a.sendRequest(vscode_languageserver_1.SemanticTokensRefreshRequest.method);
        }
      }
      /**
       * Generic AST node highlight method that dispatches to the registered
       * highlight functions based on AST node type.
       * @param node AST node to compute highlighting for
       * @param acceptor
       */
      highlightElement(node, acceptor) {
        const highlights = this.highlightMap.get(node.$type);
        if (!highlights)
          return;
        for (const fn of highlights) {
          fn.call(this, node, acceptor);
        }
      }
      /**
       * Highlight {@link node} name and short name
       * @param node
       * @param acceptor
       * @param type optional semantic token type override
       */
      element(node, acceptor, type) {
        type !== null && type !== void 0 ? type : type = (0, semantic_tokens_1.tokenType)(node.$meta);
        if (!type || !(node.declaredName || node.declaredShortName))
          return;
        const mods = (0, semantic_tokens_1.tokenModifiers)(node.$meta);
        mods.push(semantic_tokens_1.SysMLSemanticTokenModifiers.declaration);
        if (node.declaredName)
          acceptor({
            node,
            property: "declaredName",
            type,
            modifier: mods
          });
        if (node.declaredShortName)
          acceptor({
            node,
            property: "declaredShortName",
            type,
            modifier: mods
          });
      }
      /**
       * Highlight all references in the {@link node}. Currently, doesn't do
       * anything unless the reference has been linked.
       */
      elementReference(node, acceptor) {
        var _a;
        const doc = node.$meta.document;
        if (!doc || doc.state < langium_1.DocumentState.ComputedScopes)
          return;
        if (!node.$meta.to.cached)
          return;
        let index = -1;
        for (const ref of node.parts) {
          ++index;
          let target = (_a = ref.ref) === null || _a === void 0 ? void 0 : _a.$meta;
          if (target === null || target === void 0 ? void 0 : target.is(ast_1.Membership))
            target = target.element();
          if (!target)
            continue;
          const type = (0, semantic_tokens_1.tokenType)(target);
          if (!type)
            continue;
          acceptor({
            node,
            property: "parts",
            index,
            type,
            modifier: (0, semantic_tokens_1.tokenModifiers)(target)
          });
        }
      }
      /**
       * Highlight string literals
       */
      literalString(node, acceptor) {
        if (!node.$cstNode)
          return;
        acceptor({
          node,
          cst: node.$cstNode,
          type: semantic_tokens_1.SysMLSemanticTokenTypes.string
        });
      }
      /**
       * Highlight number literals
       */
      literalNumber(node, acceptor) {
        if (!node.$cstNode)
          return;
        acceptor({
          node,
          cst: node.$cstNode,
          type: semantic_tokens_1.SysMLSemanticTokenTypes.number
        });
      }
      /**
       * Highlight comment bodies
       */
      comment(node, acceptor) {
        acceptor({
          node,
          property: "body",
          type: semantic_tokens_1.SysMLSemanticTokenTypes.annotationBody
        });
        if (node.locale) {
          acceptor({
            node,
            property: "locale",
            type: semantic_tokens_1.SysMLSemanticTokenTypes.string
          });
        }
      }
      /**
       * Highlight textual representation language
       */
      textualRep(node, acceptor) {
        acceptor({
          node,
          property: "body",
          type: semantic_tokens_1.SysMLSemanticTokenTypes.annotationBody
        });
        acceptor({
          node,
          property: "language",
          type: semantic_tokens_1.SysMLSemanticTokenTypes.string
        });
      }
      /**
       * Highlight operator expression operator
       */
      operatorExpression(node, acceptor) {
        if (!node.operator)
          return;
        acceptor({
          node,
          property: "operator",
          type: semantic_tokens_1.SysMLSemanticTokenTypes.operator
        });
      }
      createAcceptor() {
        const acceptor = super.createAcceptor();
        return (options) => {
          try {
            acceptor(options);
          } catch (e) {
            console.error(`Error while resolving semantic highlighting ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        };
      }
      /**
       * An extension of default
       * {@link AbstractSemanticTokenProvider.semanticHighlight} to work cached
       * tokens and refresh requests
       * @inheritdoc
       */
      semanticHighlight(document, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const _super = Object.create(null, {
          semanticHighlight: { get: () => super.semanticHighlight }
        });
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const uri = (_a = document.uriString) !== null && _a !== void 0 ? _a : document.uri.toString();
            if (document.state >= langium_1.DocumentState.Linked) {
              const cached = this.cachedTokens.get(uri);
              if (cached) {
                return cached;
              }
            }
            const tokens = yield _super.semanticHighlight.call(this, document, params, cancelToken);
            this.cachedTokens.set(uri, document.state >= langium_1.DocumentState.Linked ? tokens : null);
            return tokens;
          } catch (e) {
            return onSemanticTokenError(e, "full");
          }
        });
      }
      semanticHighlightRange(document, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const _super = Object.create(null, {
          semanticHighlightRange: { get: () => super.semanticHighlightRange }
        });
        return __awaiter(this, void 0, void 0, function* () {
          try {
            return _super.semanticHighlightRange.call(this, document, params, cancelToken);
          } catch (e) {
            return onSemanticTokenError(e, "range");
          }
        });
      }
      semanticHighlightDelta(document, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
        const _super = Object.create(null, {
          semanticHighlightDelta: { get: () => super.semanticHighlightDelta }
        });
        return __awaiter(this, void 0, void 0, function* () {
          try {
            return _super.semanticHighlightDelta.call(this, document, params, cancelToken);
          } catch (e) {
            return onSemanticTokenError(e, "delta");
          }
        });
      }
    };
    exports2.SysMLSemanticTokenProvider = SysMLSemanticTokenProvider;
    function onSemanticTokenError(e, kind) {
      if (e instanceof vscode_languageserver_1.ResponseError || (0, langium_1.isOperationCancelled)(e))
        throw e;
      console.error(`Uncaught error while computing ${kind} semantic highlighting: ${String(e)}`);
      if (e instanceof Error)
        console.error(e.stack);
      return { data: [] };
    }
  }
});

// ../syside-languageserver/lib/services/lsp/language-server.js
var require_language_server2 = __commonJS({
  "../syside-languageserver/lib/services/lsp/language-server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLLanguageServer = void 0;
    var langium_1 = require_lib2();
    var completion_provider_1 = require_completion_provider2();
    var semantic_tokens_1 = require_semantic_tokens();
    var SysMLLanguageServer = class extends langium_1.DefaultLanguageServer {
      buildInitializeResult(params) {
        const result = super.buildInitializeResult(params);
        if (result.capabilities.semanticTokensProvider) {
          result.capabilities.semanticTokensProvider = semantic_tokens_1.DefaultSysMLSemanticTokenOptions;
        }
        if (result.capabilities.completionProvider) {
          result.capabilities.completionProvider.triggerCharacters = [
            ...completion_provider_1.SUPPORTED_TRIGGER_CHARACTERS
          ];
        }
        return result;
      }
    };
    exports2.SysMLLanguageServer = SysMLLanguageServer;
  }
});

// ../syside-languageserver/lib/services/shared/workspace/configuration-provider.js
var require_configuration_provider = __commonJS({
  "../syside-languageserver/lib/services/shared/workspace/configuration-provider.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLConfigurationProvider = exports2.SETTINGS_KEY = void 0;
    var langium_1 = require_lib2();
    var vscode_languageserver_1 = require_main4();
    var common_1 = require_common();
    exports2.SETTINGS_KEY = "syside.editor";
    var SysMLConfigurationProvider = class extends langium_1.DefaultConfigurationProvider {
      constructor(services) {
        super(services);
        this.fs = services.workspace.FileSystemProvider;
        this.updateStdlibPath(services.config);
        this.services = services;
        this.configChanged = services.Events.onConfigurationChanged;
        this.languageConfigChanged = Object.fromEntries(services.ServiceRegistry.all.map((services2) => [
          this.toSectionName(services2.LanguageMetaData.languageId),
          services2.Events.onConfigurationChanged
        ]));
        this.settings[exports2.SETTINGS_KEY] = services.config;
        services.lsp.LanguageServer.onInitialized((_params) => {
          var _a;
          (_a = services.lsp.Connection) === null || _a === void 0 ? void 0 : _a.client.register(vscode_languageserver_1.DidChangeConfigurationNotification.type, {
            section: exports2.SETTINGS_KEY
          });
        });
      }
      initialize() {
        const _super = Object.create(null, {
          initialize: { get: () => super.initialize }
        });
        return __awaiter(this, void 0, void 0, function* () {
          yield _super.initialize.call(this);
          if (this.workspaceConfig && this.connection) {
            const config = yield this.connection.workspace.getConfiguration({
              section: exports2.SETTINGS_KEY
            });
            this.updateSectionConfiguration(exports2.SETTINGS_KEY, config);
          }
        });
      }
      firstTimeSetup() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.initialized)
            yield this.initialize();
        });
      }
      /**
       * Get a specific language server configuration option
       * @param key key of {@link SysMLConfig}
       * @returns config value corresponding to {@link key}
       */
      getOption(key) {
        return this.get()[key];
      }
      /**
       * @returns Most recent language server configuration
       */
      get() {
        return this.settings[exports2.SETTINGS_KEY];
      }
      updateSectionConfiguration(section, configuration) {
        var _a;
        const old = this.settings[section];
        if (section === exports2.SETTINGS_KEY) {
          if (!configuration)
            return;
          const updated = (0, common_1.mergeWithPartial)(this.services.config, configuration);
          super.updateSectionConfiguration(section, updated);
          this.updateStdlibPath(updated);
          this.configChanged.emit(old, updated);
        } else {
          super.updateSectionConfiguration(section, configuration);
        }
        (_a = this.languageConfigChanged[section]) === null || _a === void 0 ? void 0 : _a.emit(old, configuration);
      }
      updateStdlibPath(config) {
        const stdPath = config.standardLibraryPath;
        this.fs.updateStandardLibrary(stdPath);
      }
      toSectionName(languageId) {
        return languageId === exports2.SETTINGS_KEY ? languageId : `[${languageId}]`;
      }
    };
    exports2.SysMLConfigurationProvider = SysMLConfigurationProvider;
  }
});

// ../syside-languageserver/lib/services/lsp/hover-provider.js
var require_hover_provider2 = __commonJS({
  "../syside-languageserver/lib/services/lsp/hover-provider.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLHoverProvider = void 0;
    var langium_1 = require_lib2();
    var vscode_uri_1 = require_umd();
    var ast_1 = require_ast2();
    var utils_1 = require_utils2();
    var SysMLHoverProvider = class extends langium_1.AstNodeHoverProvider {
      constructor(services) {
        super(services);
        this.events = services.Events;
      }
      getAstNodeHoverContent(node) {
        if (!(0, ast_1.isElement)(node))
          return;
        return this.getHoverContents(node.$meta, (0, langium_1.getDocument)(node));
      }
      getHoverContent(document, params) {
        const _super = Object.create(null, {
          getHoverContent: { get: () => super.getHoverContent }
        });
        return __awaiter(this, void 0, void 0, function* () {
          const hover = yield _super.getHoverContent.call(this, document, params);
          const additional = (yield this.events.onHoverRequest.emit(document, params)).filter(utils_1.NonNullable);
          if (additional.length === 0)
            return hover;
          if (!hover) {
            return {
              contents: {
                value: additional.join("\n\n"),
                kind: "markdown"
              }
            };
          }
          if (typeof hover.contents === "string") {
            hover.contents += "\n\n" + additional.join("\n\n");
          } else if (Array.isArray(hover.contents)) {
            hover.contents.push(...additional);
          } else {
            hover.contents.value += "\n\n" + additional.join("\n\n");
          }
          return hover;
        });
      }
      getHoverContents(node, document) {
        let content = `#### \`${node.qualifiedName}\`
\`${node.nodeType()}\``;
        if (document) {
          content += ` in \`${vscode_uri_1.Utils.basename(document.uri)}\`  `;
        }
        content += "\n";
        let docs = node.documentation;
        if (docs.length === 0) {
          if (node.is(ast_1.Membership)) {
            const target = node.element();
            if (target) {
              content += `Alias for \`${target.qualifiedName}\`
`;
              docs = target.documentation;
              node = target;
            }
          }
          if (node.is(ast_1.Type)) {
            for (const type of node.allTypes()) {
              docs = type.documentation;
              if (docs.length > 0)
                break;
            }
          }
        }
        if (docs.length > 0) {
          content += "\n";
          content += docs.map((doc) => doc.body).join("\n\n");
        }
        if (content) {
          return {
            contents: {
              kind: "markdown",
              value: content
            }
          };
        }
        return void 0;
      }
    };
    exports2.SysMLHoverProvider = SysMLHoverProvider;
  }
});

// ../syside-languageserver/lib/services/lsp/formatter.js
var require_formatter2 = __commonJS({
  "../syside-languageserver/lib/services/lsp/formatter.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLFormatter = void 0;
    var vscode_languageserver_1 = require_main4();
    var model_1 = require_model3();
    var vscode_uri_1 = require_umd();
    var utils_1 = require_utils2();
    var SysMLFormatter = class {
      constructor(services) {
        this.config = services.shared.workspace.ConfigurationProvider;
      }
      get contextOptions() {
        return {
          forceFormatting: false,
          format: this.config.get().formatting,
          highlighting: false
        };
      }
      formatDocument(document, params, _cancelToken) {
        return __awaiter(this, void 0, void 0, function* () {
          if (document.parseResult.parserErrors.length > 0 || document.parseResult.lexerErrors.length > 0)
            return [];
          (0, model_1.attachNotes)(document);
          const ext = vscode_uri_1.Utils.extname(document.uri);
          const doc = (0, model_1.printModelElement)(document.parseResult.value.$meta, ext === ".sysml" ? (0, model_1.defaultSysMLPrinterContext)(this.contextOptions) : (0, model_1.defaultKerMLPrinterContext)(this.contextOptions));
          const formatted = (0, utils_1.printDoc)(doc, yield this.getPrinterOptions(document, params)).text;
          return [
            vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(document.textDocument.positionAt(0), document.textDocument.positionAt(document.textDocument.getText().length)), formatted)
          ];
        });
      }
      formatDocumentRange(document, params, cancelToken) {
        return this.doFormatRange(document, params.range, params, cancelToken);
      }
      formatDocumentOnType(document, params, cancelToken) {
        return this.doFormatRange(document, vscode_languageserver_1.Range.create(params.position, params.position), params, cancelToken);
      }
      /* istanbul ignore */
      get formatOnTypeOptions() {
        return;
      }
      doFormatRange(document, range, params, _cancelToken) {
        return __awaiter(this, void 0, void 0, function* () {
          if (document.parseResult.parserErrors.length > 0 || document.parseResult.lexerErrors.length > 0)
            return [];
          (0, model_1.attachNotes)(document);
          const ext = vscode_uri_1.Utils.extname(document.uri);
          const printRange = (0, model_1.collectPrintRange)(document, {
            offset: document.textDocument.offsetAt(range.start),
            end: document.textDocument.offsetAt(range.end)
          });
          if (!printRange)
            return [];
          const doc = (0, model_1.printModelRange)(printRange, ext === ".sysml" ? (0, model_1.defaultSysMLPrinterContext)(this.contextOptions) : (0, model_1.defaultKerMLPrinterContext)(this.contextOptions));
          const options = yield this.getPrinterOptions(document, params);
          options.addFinalNewline = false;
          const formatted = (0, utils_1.printDoc)(doc, options).text;
          const editRange = vscode_languageserver_1.Range.create(document.textDocument.positionAt(printRange.range.offset), document.textDocument.positionAt(printRange.range.end));
          return [vscode_languageserver_1.TextEdit.replace(editRange, formatted)];
        });
      }
      getPrinterOptions(document, params) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const lineWidth = (_a = yield this.config.getConfiguration(vscode_uri_1.Utils.extname(document.uri).replace(".", ""), "syside.editor.formatter.lineWidth")) !== null && _a !== void 0 ? _a : this.config.get().formatting.lineWidth;
          const text = document.textDocument.getText();
          const newlinePos = text.lastIndexOf("\n");
          return {
            lineEnd: text.charAt(newlinePos - 1) === "\r" ? "\r\n" : "\n",
            lineWidth: lineWidth !== null && lineWidth !== void 0 ? lineWidth : 100,
            tabWidth: params.options.tabSize,
            useSpaces: params.options.insertSpaces,
            addFinalNewline: params.options.insertFinalNewline || document.textDocument.getText().endsWith("\n"),
            highlighting: false
          };
        });
      }
    };
    exports2.SysMLFormatter = SysMLFormatter;
  }
});

// ../syside-languageserver/lib/services/parser/grammar-config.js
var require_grammar_config2 = __commonJS({
  "../syside-languageserver/lib/services/parser/grammar-config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createSysMLGrammarConfig = void 0;
    var ast_1 = require_ast();
    var grammar_config_1 = require_grammar_config();
    var SysMLGrammarConfig;
    var NAME_TERMINALS = ["ID", "UNRESTRICTED_NAME"];
    function createSysMLGrammarConfig(services) {
      if (SysMLGrammarConfig)
        return SysMLGrammarConfig;
      const config = (0, grammar_config_1.createGrammarConfig)(services);
      const grammar = services.Grammar;
      let name = "";
      for (const terminal of NAME_TERMINALS) {
        const rule = grammar.rules.find((rule2) => rule2.name === terminal);
        if (!rule || !(0, ast_1.isRegexToken)(rule.definition))
          continue;
        const regex2 = `^${rule.definition.regex}$`;
        if (name.length === 0)
          name = regex2;
        else
          name += "|" + regex2;
      }
      if (name.length > 0)
        config.nameRegexp = new RegExp(name);
      SysMLGrammarConfig = config;
      return config;
    }
    exports2.createSysMLGrammarConfig = createSysMLGrammarConfig;
  }
});

// ../syside-languageserver/lib/services/validation/kerml-validation-registry.js
var require_kerml_validation_registry = __commonJS({
  "../syside-languageserver/lib/services/validation/kerml-validation-registry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KerMLValidationRegistry = void 0;
    var validation_registry_1 = require_validation_registry2();
    var KerMLValidationRegistry = class extends validation_registry_1.BaseValidationRegistry {
      constructor(services) {
        super(services);
        const validator = services.validation.KerMLValidator;
        this.registerBoundRules(validation_registry_1.ValidationRules.kerml, validator);
      }
    };
    exports2.KerMLValidationRegistry = KerMLValidationRegistry;
  }
});

// ../syside-languageserver/lib/services/validation/kerml-validator.js
var require_kerml_validator = __commonJS({
  "../syside-languageserver/lib/services/validation/kerml-validator.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KerMLValidator = void 0;
    var langium_1 = require_lib2();
    var ast2 = __importStar(require_ast2());
    var model_1 = require_model3();
    var validation_registry_1 = require_validation_registry2();
    var utils_1 = require_utils2();
    var KerMLValidator = class {
      constructor(services) {
        this.typeRelationshipNotSelf = {
          [ast2.Differencing]: {
            code: "validateTypeDifferencingTypesNotSelf",
            message: "A Type cannot be one of its own differencingTypes."
          },
          [ast2.Intersecting]: {
            code: "validateTypeIntersectingTypesNotSelf",
            message: "A Type cannot be one of its own intersectingTypes."
          },
          [ast2.Unioning]: {
            code: "validateTypeUnioningTypesNotSelf",
            message: "A Type cannot be one of its own unioningTypes."
          },
          [ast2.FeatureChaining]: {
            code: "validateFeatureChainingFeaturesNotSelf",
            message: "A Feature cannot be one of its own chainingFeatures."
          }
        };
        this.typeRelationshipNotOne = {
          [ast2.Differencing]: {
            code: "validateTypeOwnedDifferencingNotOne",
            message: "A Type cannot have exactly one ownedDifferencing."
          },
          [ast2.Intersecting]: {
            code: "validateTypeOwnedIntersectingNotOne",
            message: "A Type cannot have exactly one ownedIntersecting."
          },
          [ast2.Unioning]: {
            code: "validateTypeOwnedUnioningNotOne",
            message: "A Type cannot have exactly one ownedUnioning."
          },
          [ast2.FeatureChaining]: {
            code: "validateFeatureChainingFeatureNotOne",
            message: "A Feature cannot have exactly one chainingFeatures."
          }
        };
        this.BooleanOperators = [
          model_1.OPERATORS.NOT,
          model_1.OPERATORS.XOR,
          model_1.OPERATORS.AND,
          model_1.OPERATORS.BITWISE_AND,
          model_1.OPERATORS.OR,
          model_1.OPERATORS.BITWISE_OR
        ];
        this.ComparisonOperators = [
          model_1.OPERATORS.EQUALS,
          model_1.OPERATORS.SAME,
          model_1.OPERATORS.NOT_EQUALS,
          model_1.OPERATORS.NOT_SAME,
          model_1.OPERATORS.IS_TYPE,
          model_1.OPERATORS.HAS_TYPE,
          model_1.OPERATORS.LESS,
          model_1.OPERATORS.LESS_EQUAL,
          model_1.OPERATORS.GREATER,
          model_1.OPERATORS.GREATER_EQUAL
        ];
        this.index = services.workspace.IndexManager;
        this.fs = services.workspace.FileSystemProvider;
      }
      validateElementIsImpliedIncluded(node, accept) {
        if (!node.isImpliedIncluded && node.ownedElements().filter(model_1.BasicMetamodel.is(ast2.Relationship)).some((r) => r.isImplied)) {
          accept("error", "Element cannot have implied relationships included.", {
            element: node,
            code: "validateElementIsImpliedIncluded"
          });
        }
      }
      validateImportTopLevelVisibility(node, accept) {
        var _b, _c;
        if (((_b = node.parent()) === null || _b === void 0 ? void 0 : _b.is(ast2.Namespace)) && !((_c = node.parent()) === null || _c === void 0 ? void 0 : _c.parent())) {
          if (node.visibility === 2)
            return;
          else {
            accept("error", "Top Level Import must be private", {
              element: node,
              property: "visibility",
              code: "validateImportTopLevelVisibility"
            });
          }
        }
      }
      validateImportExplicitVisibility(node, accept) {
        if (!node.is(ast2.Expose) && !node.hasExplicitVisibility) {
          accept("error", "An Import must have explicit visibility.", {
            element: node,
            code: "validateImportExplicitVisibility"
          });
        }
      }
      validateNamespaceDistinguishability(element, accept) {
        const duplicates = new langium_1.MultiMap();
        for (const child of element.ownedElements()) {
          let member;
          let target;
          if (child.is(ast2.Membership)) {
            if (child.nodeType() === ast2.Membership && !child.isAlias)
              return;
            const element2 = child.isAlias ? child : child.element();
            if (!element2)
              continue;
            member = child;
            target = element2;
          } else if (child.is(ast2.MembershipImport) && !child.isRecursive) {
            const element2 = child.element();
            if (!element2)
              continue;
            member = element2;
            target = child;
          } else {
            continue;
          }
          if (member.name) {
            duplicates.add(member.name, [target, "declaredName"]);
          }
          if (member.shortName && member.shortName !== member.name) {
            duplicates.add(member.shortName, [target, "declaredShortName"]);
          }
        }
        for (const [name, members] of duplicates.entriesGroupedByKey()) {
          if (members.length < 2)
            continue;
          for (const [target, property] of members) {
            accept("warning", `Duplicate of another member named ${name}.`, {
              element: target,
              code: "validateNamespaceDistinguishability",
              property
            });
          }
        }
      }
      validateSpecializationSpecificNotConjugated(node, accept) {
        if (node.isImplied)
          return;
        const specific = node.source();
        if ((specific === null || specific === void 0 ? void 0 : specific.is(ast2.Type)) && specific.specializations(ast2.Conjugation).length > 0) {
          const parsed = node.ast();
          accept("error", "Conjugated type cannot be a specialized type.", {
            element: node,
            code: "validateSpecializationSpecificNotConjugated",
            property: (parsed === null || parsed === void 0 ? void 0 : parsed.sourceRef) ? "sourceRef" : (parsed === null || parsed === void 0 ? void 0 : parsed.sourceChain) ? "sourceChain" : "source"
          });
        }
      }
      validateTypeAtMostOneConjugator(node, accept) {
        const conjugations = node.specializations(ast2.Conjugation);
        if (conjugations.length > 1) {
          this.apply("warning", conjugations, "Type can have at most one conjugator.", accept, {
            code: "validateTypeAtMostOneConjugator"
          });
        }
      }
      validateTypeRelatesTypesNotSelf(node, accept) {
        node.typeRelationships.forEach((r) => {
          if (r.element() !== node)
            return;
          const info = this.typeRelationshipNotSelf[r.nodeType()];
          if (!info)
            return;
          accept("error", info.message, {
            element: r,
            code: info.code
          });
        });
      }
      validateTypeRelationshipNotOne(node, accept) {
        const relationships = {};
        node.typeRelationships.forEach((r) => {
          var _b;
          var _c;
          ((_b = relationships[_c = r.nodeType()]) !== null && _b !== void 0 ? _b : relationships[_c] = []).push(r);
        });
        Object.entries(relationships).forEach(([type, relationships2]) => {
          const info = this.typeRelationshipNotOne[type];
          if (!info || relationships2.length !== 1)
            return;
          this.apply("error", relationships2, info.message, accept, {
            code: info.code
          });
        });
      }
      // sysml has no multiplicity types/members outside of declaration so this
      // would always pass
      validateTypeOwnedMultiplicity(node, accept) {
        const multiplicities = (0, langium_1.stream)(node.children).filter(model_1.BasicMetamodel.is(ast2.OwningMembership)).map((m) => m.element()).nonNullable().filter(model_1.BasicMetamodel.is(ast2.Multiplicity)).tail(node.multiplicity ? 0 : 1);
        this.apply("warning", multiplicities, "A Type may have at most one ownedMember that is a Multiplicity.", accept, { code: "validateTypeOwnedMultiplicity" });
      }
      // validateEndFeatureMembershipIsEnd - model implicitly ensures this, no
      // need to check
      validateMultiplicityDomain(node, accept) {
        const owningType = node.owner();
        if (!(owningType === null || owningType === void 0 ? void 0 : owningType.is(ast2.Type)))
          return;
        const multi = node.featuredBy;
        if (owningType.is(ast2.Feature)) {
          const owner = owningType.featuredBy;
          if (multi !== owner && multi.length !== owner.length && multi.some((tf) => !owner.includes(tf))) {
            this.apply("warning", multi, "Feature multiplicity featuringTypes must be the same as those of the Feature itself.", accept, { code: "validateFeatureMultiplicityDomain" });
          }
        } else if (multi.length !== 0) {
          this.apply("warning", multi, "Classifier multiplicity featuringTypes must be empty.", accept, {
            code: "validateClassifierMultiplicityDomain"
          });
        }
      }
      validateFeatureTyping(node, accept) {
        if (node.allTypings().length === 0 && // in case failed to link
        !node.typeRelationships.find((r) => r.is(ast2.FeatureTyping))) {
          accept("error", "A Feature must be typed by at least one type.", {
            element: node,
            property: "heritage",
            // not in the spec
            code: "validateFeatureTyping"
          });
        }
      }
      validateCrossSubsettingCrossedFeature(node, accept) {
        var _b;
        const crossingFeature = node.source();
        if (!(crossingFeature === null || crossingFeature === void 0 ? void 0 : crossingFeature.is(ast2.Feature)) || !crossingFeature.isEnd || !crossingFeature.owningType)
          return;
        const target = node.element();
        if (!(target === null || target === void 0 ? void 0 : target.is(ast2.Feature)) || target.chainings.length !== 2) {
          accept("error", "Cross subsetting must chain exactly 2 features.", {
            element: node,
            code: "validateCrossSubsettingCrossedFeature"
          });
        } else {
          let count = 0;
          let opposite = void 0;
          for (const member of crossingFeature.owningType.featureMembers()) {
            const f = member.element();
            if (!member.is(ast2.EndFeatureMembership) && !(f === null || f === void 0 ? void 0 : f.isEnd))
              continue;
            if (++count > 2)
              break;
            if (!opposite && crossingFeature !== f)
              opposite = f;
          }
          if (count == 2 && ((_b = target.chainings.at(0)) === null || _b === void 0 ? void 0 : _b.element()) !== opposite) {
            accept("error", "Cross subsetting must chain through an opposite end feature.", {
              element: target,
              code: "validateCrossSubsettingCrossedFeature"
            });
          }
        }
      }
      // Only doing validateCrossSubsettingCrossingFeature for explicit CrossSubsettings as otherwise
      // Occurrences::Occurrence::surroundedByOccurrences::surroundingSpace in the standard library
      // fails validation
      validateCrossSubsettingCrossingFeature(node, accept) {
        var _b;
        const crossingFeature = node.source();
        if (node.isImplied || !(crossingFeature === null || crossingFeature === void 0 ? void 0 : crossingFeature.is(ast2.Feature)))
          return;
        const numEndFeatures = (_b = crossingFeature.owningType) === null || _b === void 0 ? void 0 : _b.basePositionalFeatures((f) => {
          var _b2;
          return f.is(ast2.EndFeatureMembership) || !!((_b2 = f.element()) === null || _b2 === void 0 ? void 0 : _b2.isEnd);
        }, void 0, true).toArray().length;
        if (!crossingFeature.isEnd || !numEndFeatures || numEndFeatures < 2) {
          accept("error", "Cross subsetting must be owned by one of two or more end features.", {
            element: node,
            code: "validateCrossSubsettingCrossingFeature"
          });
        }
      }
      validateFeatureCrossFeatureSpecialization(node, accept) {
        var _b, _c;
        const cross = node.crossFeature;
        if (!cross || cross === node.findOwnedCrossFeature())
          return;
        const redefinitions = (0, langium_1.stream)(node.specializations(ast2.Redefinition)).map((redefinition) => {
          var _b2;
          return (_b2 = redefinition.element()) === null || _b2 === void 0 ? void 0 : _b2.crossFeature;
        }).nonNullable().filter((redefinitionCross) => !cross.conforms(redefinitionCross)).toArray();
        if (redefinitions.length > 0) {
          accept("error", "Cross feature must specialize redefined end cross features.", {
            element: (_c = (_b = node.findOwnedCrossFeature()) !== null && _b !== void 0 ? _b : node.ownedCrossSubsetting) !== null && _c !== void 0 ? _c : node,
            code: "validateFeatureCrossFeatureSpecialization"
          });
        }
      }
      validateFeatureCrossFeatureType(node, accept) {
        var _b, _c;
        const cross = node.crossFeature;
        if (!cross)
          return;
        if (cross === node.findOwnedCrossFeature() && node.specializations().every((s) => s.isImplied))
          return;
        const nodeTypings = node.allTypings();
        const crossTypings = cross.allTypings();
        if (nodeTypings.length === crossTypings.length && nodeTypings.every((t) => crossTypings.includes(t)))
          return;
        accept("error", "Cross feature must have same types as its feature.", {
          element: (_c = (_b = node.findOwnedCrossFeature()) !== null && _b !== void 0 ? _b : node.ownedCrossSubsetting) !== null && _c !== void 0 ? _c : node,
          code: "validateFeatureCrossFeatureType"
        });
      }
      checkFeatureCrossingSpecialization(node, accept) {
        if (!node.isEnd)
          return;
        const cross = node.findOwnedCrossFeature();
        if (cross && node.crossFeature && cross !== node.crossFeature) {
          accept("error", "Must cross the owned cross feature.", {
            element: node.ownedCrossSubsetting,
            code: "checkFeatureCrossingSpecialization"
          });
        }
      }
      validateFeatureEndMultiplicity(node, accept) {
        var _b;
        if (node.isEnd && node.multiplicity) {
          const bounds = (_b = node.multiplicity.element()) === null || _b === void 0 ? void 0 : _b.bounds;
          if (bounds && (bounds.lower !== 1 || bounds.upper !== 1)) {
            accept("warning", "End feature must have a multiplicity 1..1.", {
              element: node.multiplicity,
              code: "validateFeatureEndMultiplicity"
            });
          }
        }
      }
      validateFeatureOwnedCrossSubsetting(node, accept) {
        const cross = node.specializations(ast2.CrossSubsetting);
        if (cross.length > 1) {
          this.apply("error", cross, "A Feature must have at most one ownedSubsetting that is a CrossSubsetting.", accept, { code: "validateFeatureOwnedCrossSubsetting" });
        }
      }
      validateFeatureOwnedReferenceSubsetting(node, accept) {
        const refs = node.specializations(ast2.ReferenceSubsetting);
        if (refs.length > 1) {
          this.apply("warning", refs, "A Feature must have at most one ownedSubsetting that is a ReferenceSubsetting.", accept, { code: "validateFeatureOwnedReferenceSubsetting" });
        }
      }
      // this is broken until linking can be done to our custom model structures w/o langium AstNode
      // @validateKerML(ast.Redefinition)
      // validateRedefinitionDirectionConformance(
      //     node: RedefinitionMeta,
      //     accept: ModelValidationAcceptor
      // ): void {
      //     const redefining = node.source() as FeatureMeta | undefined;
      //     const redefined = node.element();
      //     if (!redefining || !redefined || redefined.parent() === node) return;
      //     const dstFeaturings = redefined.featuredBy;
      //     const direction = redefining.direction;
      //     for (const featuring of dstFeaturings) {
      //         const redefinedDir = featuring.directionOf(redefined);
      //         if (
      //             ((redefinedDir == "in" || redefinedDir == "out") && direction != redefinedDir) ||
      //             (redefinedDir == "inout" && direction == "none")
      //         ) {
      //             accept("error", "Redefining feature must have a compatible direction", {
      //                 element: node,
      //                 code: "validateRedefinitionDirectionConformance",
      //             });
      //         }
      //     }
      // }
      validateFeatureChainingFeatureConformance(node, accept) {
        const feature = node.element();
        if (!feature)
          return;
        const chainings = node.source().chainings;
        const i = chainings.indexOf(node);
        if (i > 0) {
          const previous = chainings[i - 1].element();
          if (!previous)
            return;
          if (!feature.featuredBy.every((t) => previous.conforms(t))) {
            accept("error", "A chainingFeature must be featured by the previous chainingFeature", { element: node, code: "validateFeatureChainingFeatureConformance" });
          }
        }
      }
      validateRedefinitionFeaturingTypes(node, accept) {
        const redefining = node.source();
        const redefined = node.element();
        if (!redefining || !redefined || redefined.parent() === node)
          return;
        const srcFeaturings = redefining.featuredBy;
        const dstFeaturings = redefined.featuredBy;
        if (srcFeaturings.every((t) => dstFeaturings.includes(t))) {
          accept("error", srcFeaturings.length === 0 ? "A package level Feature cannot redefine other Features." : "Owner of redefining feature cannot be the same as owner of the redefined feature.", {
            element: node,
            code: "validateRedefinitionFeaturingTypes"
          });
        }
      }
      validateSubsettingMultiplicityConformance(node, subsetting, subsetted, accept) {
        var _b, _c, _d, _e;
        const bounds = (_c = (_b = subsetting.multiplicity) === null || _b === void 0 ? void 0 : _b.element()) === null || _c === void 0 ? void 0 : _c.bounds;
        const end = subsetting.isEnd;
        if (!bounds)
          return;
        if (end !== subsetted.isEnd)
          return;
        const subBounds = (_e = (_d = subsetted.multiplicity) === null || _d === void 0 ? void 0 : _d.element()) === null || _e === void 0 ? void 0 : _e.bounds;
        if (!subBounds)
          return;
        const [src, dst] = node.nodeType() === ast2.Redefinition ? ["Redefining", "redefined"] : ["Subsetting", "subsetted"];
        if (node.nodeType() === ast2.Redefinition && !end) {
          if (bounds.lower !== void 0 && subBounds.lower !== void 0 && bounds.lower < subBounds.lower) {
            accept("warning", `${src} feature should not have smaller multiplicity lower bound (${bounds.lower}) than ${dst} feature (${subBounds.lower})`, {
              element: subsetting,
              property: "multiplicity",
              code: "validateRedefinitionMultiplicityConformance"
            });
          }
        }
        if (bounds.upper !== void 0 && subBounds.upper !== void 0 && bounds.upper > subBounds.upper) {
          accept("warning", `${src} feature should not have larger multiplicity upper bound (${bounds.upper}) than ${dst} feature (${subBounds.upper})`, {
            element: subsetting,
            property: "multiplicity",
            code: "validateSubsettingMultiplicityConformance"
          });
        }
      }
      validateSubsettingUniquenessConformance(node, subsetting, subsetted, accept) {
        if (!subsetted.isNonUnique && subsetting.isNonUnique) {
          accept("error", node.nodeType() === ast2.Redefinition ? "Redefining feature cannot be nonunique if redefined feature is unique" : "Subsetting feature cannot be nonunique if subsetted feature is unique", {
            element: node,
            property: "sourceRef",
            code: "validateSubsettingUniquenessConformance"
          });
        }
      }
      validateSubsettingFeaturingTypes(node, subsetting, subsetted, accept) {
        var _b;
        const subsettedTypes = subsetted.featuredBy;
        if (subsettedTypes.length > 0 && !subsettedTypes.every((t) => this.isAccessibleFrom(subsetting, t))) {
          accept(((_b = subsetting.owner()) === null || _b === void 0 ? void 0 : _b.is(ast2.ItemFlowEnd)) ? "error" : "warning", "Invalid subsetting, must be an accessible feature (use dot notation for nesting).", { element: node, code: "validateSubsettingFeaturingTypes" });
        }
      }
      isAccessibleFrom(feature, type) {
        const featurings = feature.featuredBy;
        return featurings.length == 0 && type.qualifiedName == "Base::Anything" || featurings.some((featuring) => {
          return featuring.conforms(type) || featuring.is(ast2.Feature) && this.isAccessibleFrom(featuring, type);
        });
      }
      validateSubsetting(node, accept) {
        var _b, _c;
        if (node.isImplied)
          return;
        const subsetting = node.source();
        const subsetted = node.element();
        if (!subsetting || !subsetted)
          return;
        if (((_b = subsetting.owner()) === null || _b === void 0 ? void 0 : _b.is(ast2.Connector)) || ((_c = subsetted.owner()) === null || _c === void 0 ? void 0 : _c.is(ast2.Connector)))
          return;
        this.validateSubsettingMultiplicityConformance(node, subsetting, subsetted, accept);
        this.validateSubsettingUniquenessConformance(node, subsetting, subsetted, accept);
        this.validateSubsettingFeaturingTypes(node, subsetting, subsetted, accept);
      }
      validateDatatypeSpecialization(node, accept) {
        this.apply("error", node.specializations(ast2.Specialization).filter((s) => {
          var _b;
          return (_b = s.element()) === null || _b === void 0 ? void 0 : _b.isAny(ast2.Class, ast2.Association);
        }), "A DataType must not specialize a Class or an Association.", accept, { code: "validateDatatypeSpecialization", property: "targetRef" });
      }
      validateClassSpecialization(node, accept) {
        this.apply("error", node.specializations(ast2.Specialization).filter((s) => {
          var _b;
          return (_b = s.element()) === null || _b === void 0 ? void 0 : _b.isAny(ast2.DataType, ast2.Association);
        }), "A Class must not specialize a DataType or an Association.", accept, { code: "validateClassSpecialization", property: "targetRef" });
      }
      validateStructSpecialization(node, accept) {
        this.apply("error", node.specializations(ast2.Specialization).filter((s) => {
          var _b;
          return (_b = s.element()) === null || _b === void 0 ? void 0 : _b.is(ast2.Behavior);
        }), "A Structure must not specialize a Behavior.", accept, { code: "validateStructSpecialization", property: "targetRef" });
      }
      validateAssocStructSpecialization(node, accept) {
        this.apply("error", node.specializations(ast2.Specialization).filter((s) => {
          var _b;
          return (_b = s.element()) === null || _b === void 0 ? void 0 : _b.isAny(ast2.DataType);
        }), `An ${node.is(ast2.Interaction) ? ast2.Interaction : ast2.AssociationStructure} must not specialize a DataType.`, accept, { code: "validateClassSpecialization", property: "targetRef" });
      }
      validateBinarySpecialization(node, accept) {
        const ends = node.ownedEnds();
        if (ends.length > 2 && node.conforms("Links::BinaryLink")) {
          const isConn = node.is(ast2.Connector);
          accept("error", `Invalid binary ${isConn ? ast2.Connector : ast2.Association} - cannot have more than two ends.`, {
            element: node,
            code: isConn ? "validateConnectorBinarySpecialization" : "validateAssociationBinarySpecialization"
          });
        }
      }
      validateRelatedTypes(node, accept) {
        if (node.isAbstract)
          return;
        if (node.allEnds().length < 2) {
          const isConn = node.is(ast2.Connector);
          accept("error", `Invalid concrete  ${isConn ? ast2.Connector : ast2.Association}, must have at least 2 related elements`, {
            element: node,
            code: isConn ? "validateConnectorRelatedFeatures" : "validateAssociationRelatedTypes"
          });
        }
      }
      // validateAssociationStructureIntersection - is implicitly ensured by the
      // type hierarchy
      validateBindingConnectorIsBinary(node, accept) {
        if (node.relatedFeatures().length !== 2) {
          accept("error", "A BindingConnector must be binary.", {
            element: node,
            property: "ends",
            code: "validateBindingConnectorIsBinary"
          });
        }
      }
      validateBindingConnectorTypeConformance(node, accept) {
        const related = node.relatedFeatures().filter(utils_1.NonNullable);
        if (related.length !== 2)
          return;
        const notConformsBoolean = (i) => {
          const owningType = related[i].owningType;
          return owningType && this.isBooleanExpression(owningType) && !related[i].allTypings().some((t) => this.index.conforms(t, "Performances::BooleanEvaluation"));
        };
        if (!this.conformsSymmetrical(related[0].allTypings(), related[1].allTypings()) || notConformsBoolean(0) || notConformsBoolean(1)) {
          accept("warning", "Bound features should have conforming types", {
            element: node,
            code: "validateBindingConnectorTypeConformance"
          });
        }
      }
      validateConnectorEnds(node, accept) {
        var _b;
        const featuringTypes = node.featuredBy;
        const ends = node.connectorEnds();
        const skip = !node.owningType && node.is(ast2.ItemFlow) && ((_b = node.owner()) === null || _b === void 0 ? void 0 : _b.is(ast2.Feature));
        if (skip)
          return;
        ends.forEach((end, index) => {
          var _b2;
          const related = (_b2 = end.specializations(ast2.ReferenceSubsetting).at(0)) === null || _b2 === void 0 ? void 0 : _b2.element();
          if (!related || (featuringTypes.length == 0 ? related.isFeaturedWithin(void 0) : featuringTypes.every((t) => related === null || related === void 0 ? void 0 : related.isFeaturedWithin(t)))) {
            return;
          }
          accept("warning", `Invalid connector end #${index}, should be an accessible feature (use dot notation for nesting)`, {
            element: end,
            code: "checkConnectorTypeFeaturing"
          });
        });
      }
      validateBehaviorSpecialization(node, accept) {
        this.apply("error", node.specializations(ast2.Specialization).filter((s) => {
          var _b;
          return (_b = s.element()) === null || _b === void 0 ? void 0 : _b.is(ast2.Structure);
        }), "A Behavior must not specialize a Structure.", accept, { code: "validateBehaviorSpecialization", property: "targetRef" });
      }
      // this is implicitly ensured by the grammar but not the type system
      validateParameterMembershipOwningType(node, accept) {
        const owner = node.owner();
        if (owner && !owner.isAny(ast2.Behavior, ast2.Step)) {
          accept("error", "A ParameterMembership must be owned by a Behavior or a Step.", {
            element: node,
            code: "validateParameterMembershipOwningType"
          });
        }
      }
      // implicitly ensured by the grammar but not the type system
      validateReturnParameterMembershipCount(node, accept) {
        const isFn = node.is(ast2.SysMLFunction);
        const results = node.children.filter(model_1.BasicMetamodel.is(ast2.ReturnParameterMembership));
        if (results.length > 1)
          this.apply("error", results, `${isFn ? "A Function" : "An Expression"} must own at most one ReturnParameterMembership.`, accept, {
            code: isFn ? "validateFunctionReturnParameterMembership" : "validateExpressionReturnParameterMembership"
          });
      }
      // implicitly ensured by the grammar but not the type system
      validateResultExpressionMembershipOwningType(node, accept) {
        const owner = node.owner();
        if (owner && !owner.isAny(ast2.SysMLFunction, ast2.Expression)) {
          accept("error", `The owningType of a ${node.nodeType()} must be a Function or Expression.`, {
            element: node,
            code: node.nodeType() === ast2.ReturnParameterMembership ? "validateReturnParameterMembershipOwningType" : "validateResultExpressionMembershipOwningType"
          });
        }
      }
      // validateReturnParameterMembershipParameterHasDirectionOut - implicitly
      // ensured by the model
      // validateCollectExpressionOperator - implicitly ensured by the model
      // validateIndexExpressionOperator - implicitly ensured by the model
      validateFeatureChainExpressionFeatureConformance(node, accept) {
        const target = node.targetFeature();
        const left = node.args.at(0);
        if (!target || !left)
          return;
        const ns = left.is(ast2.Expression) ? this.index.findType(left.returnType()) : left;
        if (!ns)
          return;
        if (target.featuredBy.length > 0 && !target.featuredBy.some((t) => ns.conforms(t)))
          accept("error", "FeatureChainExpression target must be accessible.", {
            element: node,
            property: "children",
            index: 0,
            code: "validateFeatureChainExpressionFeatureConformance"
          });
      }
      /* istanbul ignore next (grammar and type system doesn't allow anything
      other than feature to be used) */
      validateFeatureReferenceExpressionReferentIsFeature(node, accept) {
        var _b;
        const target = (_b = node.expression) === null || _b === void 0 ? void 0 : _b.element();
        if (target && !target.is(ast2.Feature))
          accept("error", "Invalid feature reference expression, must refer to a feature", {
            element: node,
            property: "expression",
            code: "validateFeatureReferenceExpressionReferentIsFeature"
          });
      }
      validateInvocationExpressionArgs(node, accept) {
        var _b;
        const type = (_b = node.invokes()) !== null && _b !== void 0 ? _b : this.index.findType(node.getFunction());
        if (!type)
          return;
        const expected = new Set(type.allTypes(void 0, true).flatMap((t) => t.ownedFeatures()).nonNullable().filter((f) => f.direction !== "out"));
        if (expected.size === 0)
          return;
        const visited = /* @__PURE__ */ new Set();
        node.ownedInputParameters().forEach((param) => {
          const redefinitions = param.types(ast2.Redefinition).toArray();
          if (redefinitions.length === 0)
            return;
          const redefinedParams = redefinitions.filter((t) => expected.has(t));
          if (redefinedParams.length === 0) {
            accept("error", "Input parameter must redefine a parameter of the expression type.", { element: param, code: "validateInvocationExpressionParameterRedefinition" });
          } else if (redefinedParams.some((f) => visited.has(f))) {
            accept("error", "Two parameters cannot redefine the same type parameter.", {
              element: param,
              code: "validateInvocationExpressionNoDuplicateParameterRedefinition"
            });
          }
          redefinedParams.forEach((p) => visited.add(p));
        });
      }
      validateOperatorExpressionCastConformance(node, accept) {
        if (node.operator !== model_1.OPERATORS.AS)
          return;
        const left = node.args.at(0);
        const type = (0, model_1.typeArgument)(node);
        if (!type || !(left === null || left === void 0 ? void 0 : left.isAny(ast2.Expression, ast2.SysMLFunction)))
          return;
        const arg = this.index.findType(left.returnType());
        if (!arg)
          return;
        const argTypes = arg.is(ast2.Feature) ? arg.allTypings() : [arg];
        const types = type.is(ast2.Feature) ? type.allTypings() : [type];
        if (!this.conformsSymmetrical(argTypes, types)) {
          accept("error", `Cast argument should have conforming types.`, {
            element: node,
            code: "validateOperatorExpressionCastConformance"
          });
        }
      }
      validateOperatorExpressionBracketOperator(node, accept) {
        if (node.operator === model_1.OPERATORS.QUANTITY) {
          accept("warning", "Use #(...) operator instead.", {
            element: node,
            property: "operator",
            code: "validateOperatorExpressionBracketOperator"
          });
        }
      }
      // implicitly ensured by the grammar but not the type system
      validateItemFlowItemFeature(node, accept) {
        this.atMostOne("error", node.ownedFeatures().filter(model_1.BasicMetamodel.is(ast2.ItemFeature)), accept, "An ItemFlow must have at most one ownedFeature that is an ItemFeature.", { code: "validateItemFlowItemFeature" });
      }
      // validateItemFlowEndIsEnd - implicitly ensured by the model
      // implicitly ensured by the grammar but not the type system
      validateItemFlowEndNestedFeature(node, accept) {
        const features = node.ownedFeatureMemberships().count();
        if (features !== 1) {
          accept("error", "An ItemFlowEnd must have exactly one ownedFeature.", {
            element: node,
            code: "validateItemFlowEndNestedFeature"
          });
        }
      }
      // implicitly ensured by the grammar but not the type system
      validateItemFlowEndOwningType(node, accept) {
        var _b;
        if (!((_b = node.owningType) === null || _b === void 0 ? void 0 : _b.is(ast2.ItemFlow))) {
          accept("error", "The owningType of an ItemFlowEnd must be an ItemFlow.", {
            element: node,
            code: "validateItemFlowEndOwningType"
          });
        }
      }
      validateItemFlowEndSubsetting(node, accept) {
        if (!node.specializations(ast2.Subsetting).some((sub) => sub.nodeType() !== ast2.Redefinition)) {
          accept("error", "Cannot identify ItemFlowEnd (use dot notation).", {
            element: node,
            code: "validateItemFlowEndSubsetting"
          });
        } else if (!node.specializations(ast2.Subsetting).some((sub) => !sub.isImplied)) {
          const child = node.ownedFeatures().head();
          if (child && child.specializations(ast2.Redefinition).some((r) => !r.isImplied))
            accept("warning", "ItemFlowEnd should use dot notation.", {
              element: node,
              code: "validateItemFlowEndImplicitSubsetting"
            });
        }
      }
      validateFeatureValueOverriding(node, accept) {
        const feature = node.owner();
        if (!(feature === null || feature === void 0 ? void 0 : feature.is(ast2.Feature))) {
          return;
        }
        if (feature.allRedefinedFeatures().map((f) => f.value).some((fv) => fv && fv != node && !fv.isDefault)) {
          accept("error", "Cannot override a non-default feature value.", {
            element: node,
            code: "validateFeatureValueOverriding"
          });
        }
      }
      validateMultiplicityRangeBoundResultTypes(node, accept) {
        if (node.range && !this.isInteger(node.range.element(), KerMLValidator.IntegerRangeOperators)) {
          accept("error", "The results of the bound Expression(s) of a MultiplicityRange must be Naturals.", { element: node.range, code: "validateMultiplicityRangeBoundResultTypes" });
        }
      }
      validateMetadataFeatureMetaclass(node, accept) {
        this.validateExactlyOneTyping(node, ast2.Metaclass, accept, "MetadataFeature must be typed by exactly one Metaclass.", { code: "validateMetadataFeatureMetaclass" });
      }
      validateMetadataFeatureMetaclassNotAbstract(node, accept) {
        this.apply("error", node.specializations(ast2.FeatureTyping).filter((s) => {
          var _b;
          return (_b = s.element()) === null || _b === void 0 ? void 0 : _b.isAbstract;
        }), "MetadataFeature must be typed by concrete types.", accept, { code: "validateMetadataFeatureMetaclassNotAbstract" });
      }
      validateMetadataFeatureAnnotatedElement(node, accept) {
        const annotatedElementFeatures = node.allFeatures().map((m) => m.element()).nonNullable().filter((f) => !f.isAbstract && f.conforms("Metaobjects::Metaobject::annotatedElement")).toArray();
        if (annotatedElementFeatures.length === 0)
          return;
        node.annotatedElements().forEach((element) => {
          var _b;
          const meta = (_b = element.metaclass) === null || _b === void 0 ? void 0 : _b.types().head();
          if (!meta)
            return;
          if (!annotatedElementFeatures.find((f) => f.types(ast2.FeatureTyping).every((t) => meta.conforms(t))))
            accept("error", `Cannot annotate ${meta.name}.`, {
              element: node,
              code: "validateMetadataFeatureAnnotatedElement"
            });
        });
      }
      validateMetadataFeatureBody(node, accept) {
        node.ownedFeatures().forEach((feature) => {
          var _b;
          if (!feature.types(ast2.Redefinition).map((t) => t.owner()).find((t) => node.conforms(t))) {
            accept("error", "MetadataFeature owned features must redefine owning-type feature.", {
              element: feature,
              code: "validateMetadataFeatureBody"
            });
          }
          const fvalue = (_b = feature.value) === null || _b === void 0 ? void 0 : _b.element();
          if (fvalue && !fvalue.isModelLevelEvaluable()) {
            accept("error", "MetadataFeature owned feature values must be model-level evaluable.", { element: fvalue, code: "validateMetadataFeatureBody" });
          }
          this.validateMetadataFeatureBody(feature, accept);
        });
      }
      validateElementFilterMembership(node, accept) {
        const expr = node.element();
        const func = expr.getFunction();
        if (func && !(expr === null || expr === void 0 ? void 0 : expr.isModelLevelEvaluable()))
          accept("error", "The condition Expression must be model-level evaluable", {
            element: expr,
            code: "validatePackageElementFilterIsModelLevelEvaluable"
          });
        else if (!this.isBoolean(expr)) {
          accept("error", "The result parameter of the condition Expression must directly or indirectly specialize ScalarValues::Boolean.", {
            element: node,
            property: "target",
            code: "validatePackageElementFilterIsBoolean"
          });
        }
      }
      checkStandardLibraryPackage(node, accept) {
        if (!node.isStandard)
          return;
        const emit = () => {
          accept("error", "User library packages should not be marked as standard.", {
            element: node,
            property: "isStandard",
            code: "validateLibraryPackageNotStandard"
          });
        };
        if (!node.document.isStandard) {
          emit();
        }
      }
      atMostOneMember(node, type, accept, message, info) {
        this.atMostOne(
          "error",
          node.featureMembers().filter(model_1.BasicMetamodel.is(type)),
          accept,
          message,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          info
        );
      }
      atMostOne(severity, items, accept, message, info) {
        const matches = Array.from(items);
        if (matches.length < 2)
          return;
        this.apply(severity, matches, message, accept, info);
      }
      apply(severity, elements, message, accept, info) {
        elements.forEach((element) => accept(severity, message, Object.assign(Object.assign({}, info), { element })));
      }
      conformsSymmetrical(left, right) {
        return left.every((l) => right.some((r) => r.conforms(l))) || right.every((r) => left.some((l) => l.conforms(r)));
      }
      expressionResult(expr) {
        let result = expr.returnType();
        const func = expr.getFunction();
        if (!result && func) {
          if (typeof func === "string") {
            const element = this.index.findGlobalElement(func);
            if (element === null || element === void 0 ? void 0 : element.isAny(ast2.SysMLFunction, ast2.Expression))
              result = element.returnType();
          } else {
            result = func.returnType();
          }
        }
        return result;
      }
      isBoolean(expr) {
        if (expr.is(ast2.LiteralBoolean)) {
          return true;
        }
        const result = this.expressionResult(expr);
        if (result && this.index.conforms(result, "ScalarValues::Boolean"))
          return true;
        return expr.is(ast2.OperatorExpression) && this.BooleanOperators.includes(expr.operator) && expr.args.every((arg) => !arg || arg.is(ast2.Expression) && this.isBoolean(arg));
      }
      isBooleanExpression(expr) {
        var _b;
        if (!expr.is(ast2.Expression)) {
          return false;
        }
        if (expr.isAny(ast2.LiteralBoolean, ast2.Predicate)) {
          return true;
        }
        if (expr.is(ast2.OperatorExpression) && this.ComparisonOperators.includes(expr.operator)) {
          return true;
        }
        const result = this.expressionResult(expr);
        if (result && this.index.conforms(result, "Performances::BooleanEvaluation"))
          return true;
        if (expr.is(ast2.FeatureReferenceExpression)) {
          const referent = (_b = expr.expression) === null || _b === void 0 ? void 0 : _b.element();
          if (!(referent === null || referent === void 0 ? void 0 : referent.is(ast2.Expression)))
            return false;
          if (this.isBoolean(referent))
            return true;
          const refResult = this.index.findType(this.expressionResult(referent));
          return Boolean((refResult === null || refResult === void 0 ? void 0 : refResult.is(ast2.Expression)) && this.isBoolean(refResult));
        }
        return false;
      }
      isInteger(expr, operators = KerMLValidator.IntegerOperators) {
        if (expr.is(ast2.LiteralInfinity)) {
          return true;
        }
        if (expr.is(ast2.LiteralNumber)) {
          return expr.isInteger;
        }
        const result = this.expressionResult(expr);
        if (result && this.index.conforms(result, "ScalarValues::Integer"))
          return true;
        return expr.is(ast2.OperatorExpression) && operators.includes(expr.operator) && expr.args.every((arg) => this.isInteger(arg));
      }
      validateExactlyOneTyping(node, bound, accept, message, info) {
        const typings = node.allTypings();
        if (typings.length !== 1 || !typings.find((t) => t.is(bound))) {
          accept("error", message, Object.assign(Object.assign({}, info), { element: node }));
          return false;
        }
        return true;
      }
    };
    exports2.KerMLValidator = KerMLValidator;
    _a = KerMLValidator;
    KerMLValidator.IntegerOperators = [
      model_1.OPERATORS.MINUS,
      model_1.OPERATORS.PLUS,
      model_1.OPERATORS.MULTIPLY,
      model_1.OPERATORS.MODULO,
      model_1.OPERATORS.EXPONENT_1,
      model_1.OPERATORS.EXPONENT_2
    ];
    KerMLValidator.IntegerRangeOperators = [
      ..._a.IntegerOperators,
      model_1.OPERATORS.RANGE
    ];
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Element)
    ], KerMLValidator.prototype, "validateElementIsImpliedIncluded", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Import)
    ], KerMLValidator.prototype, "validateImportTopLevelVisibility", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Import)
    ], KerMLValidator.prototype, "validateImportExplicitVisibility", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Namespace, { bounds: [ast2.InlineExpression] })
    ], KerMLValidator.prototype, "validateNamespaceDistinguishability", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Specialization)
    ], KerMLValidator.prototype, "validateSpecializationSpecificNotConjugated", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Type)
    ], KerMLValidator.prototype, "validateTypeAtMostOneConjugator", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Type, { sysml: false })
    ], KerMLValidator.prototype, "validateTypeRelatesTypesNotSelf", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Type)
    ], KerMLValidator.prototype, "validateTypeRelationshipNotOne", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Type, { sysml: false })
    ], KerMLValidator.prototype, "validateTypeOwnedMultiplicity", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Multiplicity, { sysml: false })
    ], KerMLValidator.prototype, "validateMultiplicityDomain", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Feature)
    ], KerMLValidator.prototype, "validateFeatureTyping", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.CrossSubsetting)
    ], KerMLValidator.prototype, "validateCrossSubsettingCrossedFeature", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.CrossSubsetting)
    ], KerMLValidator.prototype, "validateCrossSubsettingCrossingFeature", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Feature)
    ], KerMLValidator.prototype, "validateFeatureCrossFeatureSpecialization", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Feature)
    ], KerMLValidator.prototype, "validateFeatureCrossFeatureType", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Feature)
    ], KerMLValidator.prototype, "checkFeatureCrossingSpecialization", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Feature)
    ], KerMLValidator.prototype, "validateFeatureEndMultiplicity", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Feature)
    ], KerMLValidator.prototype, "validateFeatureOwnedCrossSubsetting", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Feature)
    ], KerMLValidator.prototype, "validateFeatureOwnedReferenceSubsetting", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.FeatureChaining)
    ], KerMLValidator.prototype, "validateFeatureChainingFeatureConformance", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Redefinition)
    ], KerMLValidator.prototype, "validateRedefinitionFeaturingTypes", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Subsetting)
    ], KerMLValidator.prototype, "validateSubsetting", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.DataType, { sysml: false })
    ], KerMLValidator.prototype, "validateDatatypeSpecialization", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Class, { sysml: false, bounds: [ast2.AssociationStructure, ast2.Interaction] })
    ], KerMLValidator.prototype, "validateClassSpecialization", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Structure, { sysml: false })
    ], KerMLValidator.prototype, "validateStructSpecialization", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.AssociationStructure, { sysml: false }),
      (0, validation_registry_1.validateKerML)(ast2.Interaction, { sysml: false })
    ], KerMLValidator.prototype, "validateAssocStructSpecialization", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Connector),
      (0, validation_registry_1.validateKerML)(ast2.Association)
    ], KerMLValidator.prototype, "validateBinarySpecialization", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Connector),
      (0, validation_registry_1.validateKerML)(ast2.Association)
    ], KerMLValidator.prototype, "validateRelatedTypes", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.BindingConnector)
    ], KerMLValidator.prototype, "validateBindingConnectorIsBinary", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.BindingConnector)
    ], KerMLValidator.prototype, "validateBindingConnectorTypeConformance", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Connector)
    ], KerMLValidator.prototype, "validateConnectorEnds", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.Behavior)
    ], KerMLValidator.prototype, "validateBehaviorSpecialization", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.ParameterMembership)
    ], KerMLValidator.prototype, "validateParameterMembershipOwningType", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.SysMLFunction),
      (0, validation_registry_1.validateKerML)(ast2.Expression)
    ], KerMLValidator.prototype, "validateReturnParameterMembershipCount", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.ReturnParameterMembership),
      (0, validation_registry_1.validateKerML)(ast2.ResultExpressionMembership)
    ], KerMLValidator.prototype, "validateResultExpressionMembershipOwningType", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.FeatureChainExpression)
    ], KerMLValidator.prototype, "validateFeatureChainExpressionFeatureConformance", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.FeatureReferenceExpression)
      /* istanbul ignore next (grammar and type system doesn't allow anything
      other than feature to be used) */
    ], KerMLValidator.prototype, "validateFeatureReferenceExpressionReferentIsFeature", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.InvocationExpression)
    ], KerMLValidator.prototype, "validateInvocationExpressionArgs", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.OperatorExpression)
    ], KerMLValidator.prototype, "validateOperatorExpressionCastConformance", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.OperatorExpression, {
        sysml: false,
        bounds: [ast2.CollectExpression, ast2.SelectExpression, ast2.FeatureChainExpression]
      })
    ], KerMLValidator.prototype, "validateOperatorExpressionBracketOperator", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.ItemFlow)
    ], KerMLValidator.prototype, "validateItemFlowItemFeature", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.ItemFlowEnd)
    ], KerMLValidator.prototype, "validateItemFlowEndNestedFeature", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.ItemFlowEnd)
    ], KerMLValidator.prototype, "validateItemFlowEndOwningType", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.ItemFlowEnd)
    ], KerMLValidator.prototype, "validateItemFlowEndSubsetting", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.FeatureValue)
    ], KerMLValidator.prototype, "validateFeatureValueOverriding", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.MultiplicityRange)
    ], KerMLValidator.prototype, "validateMultiplicityRangeBoundResultTypes", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.MetadataFeature, { bounds: [ast2.MetadataUsage] })
    ], KerMLValidator.prototype, "validateMetadataFeatureMetaclass", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.MetadataFeature)
    ], KerMLValidator.prototype, "validateMetadataFeatureMetaclassNotAbstract", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.MetadataFeature)
    ], KerMLValidator.prototype, "validateMetadataFeatureAnnotatedElement", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.MetadataFeature)
    ], KerMLValidator.prototype, "validateMetadataFeatureBody", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.ElementFilterMembership)
    ], KerMLValidator.prototype, "validateElementFilterMembership", null);
    __decorate([
      (0, validation_registry_1.validateKerML)(ast2.LibraryPackage)
    ], KerMLValidator.prototype, "checkStandardLibraryPackage", null);
  }
});

// ../syside-languageserver/lib/services/validation/sysml-validator.js
var require_sysml_validator = __commonJS({
  "../syside-languageserver/lib/services/validation/sysml-validator.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLValidator = void 0;
    var langium_1 = require_lib2();
    var ast2 = __importStar(require_ast2());
    var model_1 = require_model3();
    var kerml_validator_1 = require_kerml_validator();
    var validation_registry_1 = require_validation_registry2();
    var SysMLValidator = class extends kerml_validator_1.KerMLValidator {
      // validateDefinitionNonVariationMembership - duplicate with validateVariantMembershipOwningNamespace
      isVariation(node) {
        return node.isAny(ast2.Usage, ast2.Definition) ? node.isVariation : false;
      }
      validateVariationMembership(node, accept) {
        if (node.isVariation) {
          const [type, code] = node.is(ast2.Usage) ? [ast2.Usage, "validateUsageVariationMembership"] : [ast2.Definition, "validateDefinitionVariationMembership"];
          this.apply("error", node.ownedElements().filter(model_1.BasicMetamodel.is(ast2.FeatureMembership)).filter((m) => !m.isAny(ast2.ParameterMembership, ast2.ObjectiveMembership)), `All ownedMemberships of variation ${type} must be VariantMemberships.`, accept, { code });
        }
      }
      validateVariationSpecialization(node, accept) {
        if (node.isVariation) {
          const [type, code, sup] = node.is(ast2.Usage) ? [ast2.Usage, "validateUsageVariationSpecialization", "Definition or Usage"] : [ast2.Definition, "validateDefinitionVariationSpecialization", ast2.Definition];
          this.apply("error", node.specializations().filter((s) => {
            const target = s.element();
            return target && this.isVariation(target);
          }), `A variation ${type} may not specialize any other variation ${sup}.`, accept, { code });
        }
      }
      // validateReferenceUsageIsReference - implicitly ensured by the model
      // validateUsageNonVariationMembership - duplicate with validateVariantMembershipOwningNamespace
      validateVariantMembershipOwningNamespace(node, accept) {
        const owner = node.parent();
        if (!owner || !this.isVariation(owner)) {
          accept("error", "The membershipOwningNamespace of a VariantMembership must be a variation-point Definition or Usage.", {
            element: node,
            keyword: "variant",
            code: "validateVariantMembershipOwningNamespace"
          });
        }
      }
      // TODO: validateAttributeUsageFeatures - seems to be blocked by KERML-4
      // validateAttributeUsageIsReference - implicitly ensured by the model
      // TODO: validateAttributeDefinitionFeatures - seems to be blocked by KERML-4
      validateAttributeUsageTyping(node, accept) {
        this.validateAllTypings(node, ast2.DataType, accept, "An AttributeUsage must be typed by DataTypes only.", { code: "validateAttributeUsageTyping" });
      }
      // validateEnumerationDefinitionIsVariation - implicitly ensured by the model
      validateEnumerationUsageTyping(node, accept) {
        this.validateExactlyOneTyping(node, ast2.EnumerationDefinition, accept, "An EnumerationUsage must be typed by exactly one EnumerationDefinition.", { code: "validateEnumerationUsageTyping" });
      }
      // validateEventOccurrenceUsageIsReference - implicitly ensured by the model
      validateEventOccurrenceUsageReference(node, accept) {
        this.checkReferencing(node, accept, {
          type: ast2.EventOccurrenceUsage,
          reference: ast2.OccurrenceUsage,
          info: { code: "validateEventOccurrenceUsageReference" }
        });
      }
      // validateLifeClassIsSufficient - implicitly ensured by the model
      validateOccurrenceDefinitionLifeClass(node, accept) {
        const members = node.children.filter(model_1.BasicMetamodel.is(ast2.OwningMembership)).filter((m) => m.element().nodeType() === ast2.LifeClass);
        if (node.lifeClass)
          members.push(node.lifeClass);
        if (node.isIndividual) {
          if (members.length !== 1) {
            this.apply("error", members, "Individual OccurrenceDefinitions must have exactly one LifeClass ownedMember", accept, { code: "validateOccurrenceDefinitionLifeClass" });
          }
        } else if (members.length > 0) {
          this.apply("error", members, "Non-individual OccurrenceDefinitions must have node LifeClass ownedMember", accept, { code: "validateOccurrenceDefinitionLifeClass" });
        }
      }
      validateOccurrenceUsageTyping(node, accept) {
        this.validateAllTypings(node, ast2.Class, accept, "OccurrenceDefinition must be typed by Classes only.", { code: "validateOccurrenceUsageTyping" });
      }
      validateOccurrenceUsageIndividual(node, accept) {
        const types = node.allTypings().filter(model_1.BasicMetamodel.is(ast2.OccurrenceDefinition)).filter((t) => t.isIndividual);
        if (types.length > 1) {
          accept("error", "An OccurrenceUsage must have at most one occurrenceDefinition with isIndividual = true.", { element: node, code: "validateOccurrenceUsageIndividualDefinition" });
        } else if (node.isIndividual && types.length !== 1) {
          accept("error", "An individual OccurrenceUsage must an individualDefinition.", {
            element: node,
            code: "validateOccurrenceUsageIndividualUsage"
          });
        }
      }
      validateItemUsageTyping(node, accept) {
        this.validateAllTypings(node, ast2.Structure, accept, "ItemUsage must be typed by Structures only.", { code: "validateItemUsageTyping" });
      }
      validatePartUsageTyping(node, accept) {
        if (this.validateAllTypings(node, ast2.Structure, accept, "PartUsage must be typed by Structures only", { code: "validatePartUsageTyping" })) {
          this.validateAtLeastTyping(node, ast2.PartDefinition, accept, "At least one of the itemDefinitions of a PartUsage must be a PartDefinition.", { code: "validatePartUsagePartDefinition" });
        }
      }
      // validateConjugatedPortDefinitionConjugatedPortDefinitionIsEmpty - implicitly ensured by the model
      // this will usually be satisfied implictly by the model
      validateConjugatedPortDefinitionOriginalPortDefinition(node, accept) {
        var _a;
        if (node.originalPortDefinition !== ((_a = node.specializations(ast2.PortConjugation).at(0)) === null || _a === void 0 ? void 0 : _a.element())) {
          accept("error", "The originalPortDefinition of the ownedPortConjugator of a ConjugatedPortDefinition must be the originalPortDefinition of the ConjugatedPortDefinition.", { element: node, code: "validateConjugatedPortDefinitionOriginalPortDefinition" });
        }
      }
      // this will be satisfied by the grammar but not when creating through code
      validatePortDefinitionConjugatedPortDefinition(node, accept) {
        const conjugates = node.children.filter(model_1.BasicMetamodel.is(ast2.OwningMembership)).filter((m) => m.element().is(ast2.ConjugatedPortDefinition));
        if (node.conjugatedDefinition)
          conjugates.push(node.conjugatedDefinition);
        if (conjugates.length !== 1) {
          this.apply("error", conjugates, "A PortDefinition must have exactly one ownedMember that is a ConjugatedPortDefinition.", accept, { code: "validatePortDefinitionConjugatedPortDefinition" });
        }
      }
      validatePortOwnedUsagesNotComposite(node, accept) {
        const usages = node.ownedFeatures().filter(model_1.BasicMetamodel.is(ast2.Usage)).filter((u) => !u.is(ast2.PortUsage) && u.isComposite);
        const [type, member, code] = node.is(ast2.PortDefinition) ? [ast2.PortDefinition, "ownedUsages", "validatePortDefinitionOwnedUsagesNotComposite"] : [ast2.PortUsage, "nestedUsages", "validatePortUsageNestedUsagesNotComposite"];
        this.apply("error", usages, `The ${member} of a ${type} that are not PortUsages must not be composite.`, accept, { code });
      }
      validatePortUsageTyping(node, accept) {
        this.validateAllTypings(node, ast2.PortDefinition, accept, "PortUsages must be typed by PortDefinitions only.", { code: "validatePortUsageTyping" });
      }
      // validatePortUsageIsReference - implicitly ensured by the model
      validateConnectionUsageTyping(node, accept) {
        this.validateAllTypings(node, ast2.Association, accept, "ConnectionUsages must be typed by Associations only.", { code: "validateConnectionUsageTyping" });
      }
      validateFlowConnectionEnd(node, accept) {
        const ends = node.ownedEnds();
        if (ends.length <= 2)
          return;
        this.apply("error", ends, "FlowConnectionDefinition can have at most 2 ends.", accept, {
          code: "validateFlowConnectionEnd"
        });
      }
      validateFlowConnectionUsageTyping(node, accept) {
        this.validateAllTypings(node, ast2.Interaction, accept, "FlowConnectionUsages must be typed by Interactions only.", { code: "validateFlowConnectionUsageTyping" });
      }
      validateInterfaceEnds(node, accept) {
        const [type, code] = node.is(ast2.InterfaceDefinition) ? [ast2.InterfaceDefinition, "validateInterfaceDefinitionEnd"] : [ast2.InterfaceUsage, "validateInterfaceUsageEnd"];
        this.apply("error", node.ownedEnds().filter((f) => !f.is(ast2.PortUsage)), `An ${type} end must be a port.`, accept, { code });
      }
      validateInterfaceUsageTyping(node, accept) {
        this.validateAllTypings(node, ast2.InterfaceDefinition, accept, "InterfaceUsages must be typed by InterfaceDefinitions only.", { code: "validateInterfaceUsageTyping" });
      }
      validateAllocationUsageTyping(node, accept) {
        this.validateAllTypings(node, ast2.AllocationDefinition, accept, "AllocationUsages must be typed by AllocationDefinitions only.", { code: "validateAllocationUsageTyping" });
      }
      validateAcceptActionUsageParameters(node, accept) {
        this.checkParameters(node, ["payload", "receiver"], accept, {
          type: ast2.AcceptActionUsage,
          info: { code: "validateAcceptActionUsageParameters" }
        });
      }
      validateActionUsageTyping(node, accept) {
        this.validateAllTypings(node, ast2.Behavior, accept, "ActionUsages must be typed by Behaviors only.", { code: "validateActionUsageTyping" });
      }
      validateAssignmentActionUsageReferent(node, accept) {
        if (!node.targetMember) {
          accept("error", `An assignment must have a Feature referent.`, {
            element: node,
            code: "validateAssignmentActionUsageReferent"
          });
        }
      }
      validateTriggerInvocationExpression(node, accept) {
        const arg = node.args.at(0);
        switch (node.kind) {
          case "at":
            if (!arg || !this.isTime(arg)) {
              accept("error", "An at expression must be a TimeInstantValue.", {
                element: node,
                code: "validateTriggerInvocationActionAtArgument"
              });
            }
            break;
          case "when":
            if (!arg || !this.isBooleanExpression(arg)) {
              accept("error", "A when expression must be Boolean.", {
                element: node,
                code: "validateTriggerInvocationActionWhenArgument"
              });
            }
            break;
          case "after":
            if (!arg || !this.isDuration(arg)) {
              accept("error", "An after expression must be a DurationValue.", {
                element: node,
                code: "validateTriggerInvocationActionAfterArgument"
              });
            }
            break;
        }
      }
      isTime(expr) {
        const result = this.expressionResult(expr);
        if (result && this.index.conforms(result, "Time::TimeInstantValue"))
          return true;
        return expr.is(ast2.OperatorExpression) && SysMLValidator.IntegerOperators.includes(expr.operator) && expr.args.every((arg) => this.isTime(arg) || this.isDuration(arg));
      }
      isDuration(expr) {
        if (this.isDurationExpression(expr)) {
          return true;
        }
        const result = this.expressionResult(expr);
        if (result && this.index.conforms(result, "ISQBase::DurationValue"))
          return true;
        return expr.is(ast2.OperatorExpression) && SysMLValidator.IntegerOperators.includes(expr.operator) && expr.args.every((arg) => this.isTime(arg) || this.isDuration(arg));
      }
      isDurationExpression(expr) {
        if (!expr.is(ast2.OperatorExpression) || expr.operator != model_1.OPERATORS.QUANTITY) {
          return false;
        }
        const arg = expr.args.at(1);
        if (!arg) {
          return false;
        }
        const result = this.expressionResult(arg);
        return Boolean(result && this.index.conforms(result, "ISQBase::DurationUnit"));
      }
      // TODO: validateControlNodeIncomingSuccessions (not in pilot)
      // TODO: validateControlNodeOutgoingSuccessions (not in pilot)
      validateControlNodeOwningType(node, accept) {
        var _a;
        if (!((_a = node.owningType) === null || _a === void 0 ? void 0 : _a.isAny(ast2.ActionDefinition, ast2.ActionUsage))) {
          accept("error", "The owningType of a ControlNode must be an ActionDefinition or ActionUsage.", { element: node, code: "validateControlNodeOwningType" });
        }
      }
      // TODO: validateDecisionNodeIncomingSuccessions (not in pilot)
      // TODO: validateDecisionNodeOutgoingSuccessions (not in pilot)
      // TODO: validateForkNodeIncomingSuccessions (not in pilot)
      // TODO: validateJoinNodeOutgoingSuccessions (not in pilot)
      // TODO: validateMergeNodeIncomingSuccessions (not in pilot)
      // TODO: validateMergeNodeOutgoingSuccessions (not in pilot)
      validatePerformActionUsageReference(node, accept) {
        this.checkReferencing(node, accept, {
          type: ast2.PerformActionUsage,
          reference: ast2.ActionUsage,
          info: { code: "validatePerformActionUsageReference" }
        });
      }
      validateSendActionParameters(node, accept) {
        this.checkParameters(node, ["payload", "sender", "receiver"], accept, {
          type: ast2.SendActionUsage,
          info: { code: "validateSendActionParameters" }
        });
      }
      validateSendActionReceiver(node, accept) {
        var _a, _b, _c, _d, _e, _f;
        const receiver = (_c = (_b = (_a = node.receiver) === null || _a === void 0 ? void 0 : _a.element()) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.element();
        if ((receiver === null || receiver === void 0 ? void 0 : receiver.is(ast2.FeatureReferenceExpression)) && ((_e = (_d = receiver.expression) === null || _d === void 0 ? void 0 : _d.element()) === null || _e === void 0 ? void 0 : _e.is(ast2.PortUsage)) || (receiver === null || receiver === void 0 ? void 0 : receiver.is(ast2.FeatureChainExpression)) && ((_f = receiver.featureMembers()[0].element()) === null || _f === void 0 ? void 0 : _f.basicFeature().is(ast2.PortUsage))) {
          accept("warning", "Sending to a port should be done through 'via' instead of 'to'", {
            element: node.receiver,
            code: "validateSendActionReceiver"
          });
        }
      }
      // we use explicit members for each of the features/parameters so checking
      // would only be needed for incomplete elements, e.g. programmatic creation:
      // validateForLoopActionUsageLoopVariable;
      // validateForLoopActionUsageParameters;
      // validateIfActionUsageParameters;
      // validateWhileLoopActionUsageParameters;
      validateExhibitStateUsageReference(node, accept) {
        this.checkReferencing(node, accept, {
          type: ast2.ExhibitStateUsage,
          reference: ast2.StateUsage,
          info: { code: "validateExhibitStateUsageReference" }
        });
      }
      validateStateSubactionMembershipOwningType(node, accept) {
        var _a;
        if (!((_a = node.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast2.StateDefinition, ast2.StateUsage))) {
          accept("error", "The owningType of a StateSubactionMembership must be a StateDefinition or a StateUsage.", { element: node, code: "validateStateSubactionMembershipOwningType" });
        }
      }
      validateStateParallelSubactions(node, accept) {
        const owner = node.owningType;
        if ((owner === null || owner === void 0 ? void 0 : owner.isAny(ast2.StateDefinition, ast2.StateUsage)) && owner.isParallel) {
          const [type, member, code] = owner.is(ast2.StateDefinition) ? [ast2.StateDefinition, "ownedActions", "validateStateDefinitionParallelSubactions"] : [ast2.StateUsage, "nestedActions", "validateStateUsageParallelSubactions"];
          accept("error", `Parallel ${type} ${member} must not have any incomingTransitions or outgoingTransitions.`, { element: node, code });
        }
      }
      validateStateSubactionKind(node, accept) {
        const subactions = node.featureMembers().filter(model_1.BasicMetamodel.is(ast2.StateSubactionMembership));
        const [type, code] = node.is(ast2.StateDefinition) ? [ast2.StateDefinition, "validateStateDefinitionStateSubactionKind"] : [ast2.StateUsage, "validateStateUsageStateSubactionKind"];
        for (const kind of ["do", "entry", "exit"])
          this.atMostOne("error", subactions.filter((m) => m.kind === kind), accept, `A ${type} must not have more than one owned StateSubactionMembership of kind ${kind}.`, { code });
      }
      validateStateUsageTyping(node, accept) {
        this.validateAllTypings(node, ast2.Behavior, accept, "StateUsages must be typed by Behaviors only.", { code: "validateStateUsageTyping" });
      }
      // implicitly ensured by the type system for the most part
      validateTransitionFeatureMembership(node, accept) {
        const target = node.element();
        if (!target)
          return;
        switch (node.kind) {
          case "effect": {
            if (!target.is(ast2.ActionUsage))
              accept("error", "TransitionFeature of kind effect must be an ActionUsage.", {
                element: target,
                code: "validateTransitionFeatureMembershipEffectAction"
              });
            return;
          }
          case "guard": {
            if (!target.is(ast2.Expression) || !this.isBoolean(target))
              accept("error", "TransitionFeature of kind guard must be a boolean expression.", {
                element: target,
                code: "validateTransitionFeatureMembershipGuardExpression"
              });
            return;
          }
          case "trigger": {
            if (!target.is(ast2.AcceptActionUsage))
              accept("error", "TransitionFeature of kind trigger must be an AcceptActionUsage.", {
                element: target,
                code: "validateTransitionFeatureMembershipTriggerAction"
              });
            return;
          }
        }
      }
      validateTransitionFeatureMembershipOwningType(node, accept) {
        var _a;
        if (!((_a = node.owner()) === null || _a === void 0 ? void 0 : _a.is(ast2.TransitionUsage)))
          accept("error", "The owningType of a TransitionFeatureMembership must be a TransitionUsage.", { element: node, code: "validateTransitionFeatureMembershipOwningType" });
      }
      /* istanbul ignore next */
      // here for parity with pilot
      validateTransitionUsageParameters(node, accept) {
        if (!node.transitionLinkSource)
          accept("error", "A TransitionUsage must have a transitionLinkSource.", {
            element: node,
            code: "validateTransitionUsageParameters"
          });
        if (node.accepter && !node.payload) {
          accept("error", "A TransitionUsage with a triggerAction must have a payload.", {
            element: node,
            code: "validateTransitionUsageParameters"
          });
        }
      }
      validateTransitionUsageSuccession(node, accept) {
        const succession = (0, langium_1.stream)([node.then, node.else], node.children).filter(model_1.BasicMetamodel.is(ast2.OwningMembership)).map((m) => m.element()).filter(model_1.BasicMetamodel.is(ast2.SuccessionAsUsage)).head();
        if (!(succession === null || succession === void 0 ? void 0 : succession.relatedFeatures().slice(1).every((f) => f === null || f === void 0 ? void 0 : f.basicFeature().is(ast2.ActionUsage)))) {
          accept("error", "A TransitionUsage must have an ownedMember that is a Succession with an ActionUsage as its targetFeature.", { element: succession !== null && succession !== void 0 ? succession : node, code: "validateTransitionUsageSuccession" });
        }
      }
      validateCalculationUsageTyping(node, accept) {
        this.validateExactlyOneTyping(node, ast2.SysMLFunction, accept, "CalculationUsages must be typed by exactly one Function.", { code: "validateCalculationUsageTyping" });
      }
      validateAssertConstraintUsageReference(node, accept) {
        this.checkReferencing(node, accept, {
          type: ast2.AssertConstraintUsage,
          reference: ast2.ConstraintUsage,
          info: { code: "validateAssertConstraintUsageReference" }
        });
      }
      validateConstraintUsageTyping(node, accept) {
        this.validateExactlyOneTyping(node, ast2.Predicate, accept, "ConstraintUsages must be typed by exactly one Predicate.", { code: "validateConstraintUsageTyping" });
      }
      validateSubjectMembershipOwningType(node, accept) {
        var _a;
        if (!((_a = node.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast2.RequirementUsage, ast2.RequirementDefinition, ast2.CaseDefinition, ast2.CaseUsage)))
          accept("error", `The owningType of SubjectMembership must be a RequirementDefinition, RequirementUsage, CaseDefinition, or CaseUsage.`, { element: node, code: `validateSubjectMembershipOwningType` });
      }
      validateActorMembershipOwningType(node, accept) {
        var _a;
        if (!((_a = node.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast2.RequirementUsage, ast2.RequirementDefinition, ast2.CaseDefinition, ast2.CaseUsage)))
          accept("error", `The owningType of ActorMembership must be a RequirementDefinition, RequirementUsage, CaseDefinition, or CaseUsage.`, { element: node, code: `validateActorMembershipOwningType` });
      }
      // validateFramedConcernUsageConstraintKind - implicitly ensured by the model
      validateRequirementConstraintMembershipIsComposite(node, accept) {
        var _a;
        if (!((_a = node.element()) === null || _a === void 0 ? void 0 : _a.isComposite))
          accept("error", "The ownedConstraint of a RequirementConstraintMembership must be composite.", { element: node, code: "validateRequirementConstraintMembershipIsComposite" });
      }
      validateRequirementMembershipOwningType(node, accept) {
        var _a;
        if (!((_a = node.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast2.RequirementUsage, ast2.RequirementDefinition)))
          accept("error", `The owningType of an ${node.nodeType()} must be a RequirementDefinition or RequirementUsage.`, { element: node, code: `validate${node.nodeType()}OwningType` });
      }
      validateRequirementOnlyOneSubject(node, accept) {
        const [type, code] = node.is(ast2.RequirementDefinition) ? [ast2.RequirementDefinition, "validateRequirementDefinitionOnlyOneSubject"] : [ast2.RequirementUsage, "validateRequirementUsageOnlyOneSubject"];
        this.atMostOneMember(node, ast2.SubjectMembership, accept, `A ${type} must have at most one featureMembership that is a SubjectMembership.`, { code });
      }
      validateRequirementSubjectParameterPosition(node, accept) {
        const [type, code] = node.is(ast2.RequirementDefinition) ? [ast2.RequirementDefinition, "validateRequirementDefinitionSubjectParameterPosition"] : [ast2.RequirementUsage, "validateRequirementUsageSubjectParameterPosition"];
        this.checkFirstInput(node, node.featuresByMembership(ast2.SubjectMembership).head(), accept, `The subjectParameter of a ${type} must be its first input.`, { code });
      }
      validateRequirementUsageTyping(node, accept) {
        this.validateExactlyOneTyping(node, ast2.RequirementDefinition, accept, "RequirementUsages must be typed by exactly one RequirementDefinition.", { code: "validateRequirementUsageTyping" });
      }
      validateSatisfyRequirementUsageReference(node, accept) {
        this.checkReferencing(node, accept, {
          type: ast2.SatisfyRequirementUsage,
          reference: ast2.RequirementUsage,
          info: { code: "validateSatisfyRequirementUsageReference" }
        });
      }
      validateCaseDefinitionOnlyOneSubject(node, accept) {
        const [type, code] = node.is(ast2.CaseDefinition) ? [ast2.CaseDefinition, "validateCaseDefinitionOnlyOneSubject"] : [ast2.CaseUsage, "validateCaseUsageOnlyOneSubject"];
        this.atMostOneMember(node, ast2.SubjectMembership, accept, `A ${type} must have at most one featureMembership that is a SubjectMembership.`, { code });
      }
      validateCaseOnlyOneObjective(node, accept) {
        const [type, code] = node.is(ast2.CaseDefinition) ? [ast2.CaseDefinition, "validateCaseDefinitionOnlyOneObjective"] : [ast2.CaseUsage, "validateCaseUsageOnlyOneObjective"];
        this.atMostOneMember(node, ast2.ObjectiveMembership, accept, `A ${type} must have at most one featureMembership that is a ObjectiveMembership.`, { code });
      }
      validateCaseSubjectParameterPosition(node, accept) {
        const [type, code] = node.is(ast2.CaseDefinition) ? [ast2.CaseDefinition, "validateCaseDefinitionSubjectParameterPosition"] : [ast2.CaseUsage, "validateCaseUsageSubjectParameterPosition"];
        this.checkFirstInput(node, node.featuresByMembership(ast2.SubjectMembership).head(), accept, `The subjectParameter of a ${type} must be its first input.`, { code });
      }
      validateCaseUsageTyping(node, accept) {
        this.validateExactlyOneTyping(node, ast2.CaseDefinition, accept, "CaseUsages must be typed by exactly one CaseDefinition.", { code: "validateCaseUsageTyping" });
      }
      validateObjectiveMembershipIsComposite(node, accept) {
        var _a;
        if (!((_a = node.element()) === null || _a === void 0 ? void 0 : _a.isComposite))
          accept("error", "The ownedConstraint of a ObjectiveMembership must be composite.", {
            element: node,
            code: "validateObjectiveMembershipIsComposite"
          });
      }
      validateObjectiveMembershipOwningType(node, accept) {
        var _a;
        if (!((_a = node.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast2.CaseUsage, ast2.CaseDefinition)))
          accept("error", `The owningType of an ObjectiveMembership must be a CaseDefinition or CaseUsage.`, { element: node, code: `validateObjectiveMembershipOwningType` });
      }
      validateAnalysisCaseUsageTyping(node, accept) {
        this.validateExactlyOneTyping(node, ast2.AnalysisCaseDefinition, accept, "AnalysisCaseUsages must be typed by exactly one AnalysisCaseDefinition", { code: "validateAnalysisCaseUsageTyping" });
      }
      // validateRequirementVerificationMembershipKind - implicitly ensured by the model
      validateRequirementVerificationMembershipOwningType(node, accept) {
        if (!node.isLegalVerification())
          accept("error", "The owningType of a RequirementVerificationMembership must be a RequirementUsage that is owned by an ObjectiveMembership.", { element: node, code: "validateRequirementVerificationMembershipOwningType" });
      }
      validateVerificationCaseUsageTyping(node, accept) {
        this.validateExactlyOneTyping(node, ast2.VerificationCaseDefinition, accept, "VerificationCaseUsages must be typed by exactly one VerificationCaseDefinition.", { code: "validateVerificationCaseUsageTyping" });
      }
      validateIncludeUseCaseUsageReference(node, accept) {
        this.checkReferencing(node, accept, {
          type: ast2.IncludeUseCaseUsage,
          reference: ast2.UseCaseUsage,
          info: { code: "validateIncludeUseCaseUsageReference" }
        });
      }
      validateUseCaseUsageTyping(node, accept) {
        this.validateExactlyOneTyping(node, ast2.UseCaseDefinition, accept, "UseCaseUsages must be typed by exactly one UseCaseDefinition.", { code: "validateUseCaseUsageTyping" });
      }
      // validateExposeIsImportAll - implicitly ensured by the model
      validateExposeNoExplicitVisibility(node, accept) {
        if (node.hasExplicitVisibility) {
          accept("error", "An Expose cannot have an explicit visibility.", {
            element: node,
            code: "validateExposeNoExplicitVisibility"
          });
        }
      }
      validateExposeOwningNamespace(node, accept) {
        var _a;
        if (!((_a = node.owner()) === null || _a === void 0 ? void 0 : _a.is(ast2.ViewUsage))) {
          accept("error", "The importOwningNamespace of an Expose must be a ViewUsage.", {
            element: node,
            code: "validateExposeOwningNamespace"
          });
        }
      }
      validateRenderingUsageTyping(node, accept) {
        this.validateExactlyOneTyping(node, ast2.RenderingDefinition, accept, "RenderingUsages must be typed by exactly one RenderingDefinition.", { code: "validateRenderingUsageTyping" });
      }
      validateViewDefinitionOnlyOneViewRendering(node, accept) {
        const [type, code] = node.is(ast2.ViewDefinition) ? [ast2.ViewDefinition, "validateViewDefinitionOnlyOneViewRendering"] : [ast2.ViewUsage, "validateViewUsageOnlyOneViewRendering"];
        this.atMostOneMember(node, ast2.ViewRenderingMembership, accept, `A ${type} must have at most one ViewRenderingMembership.`, { code });
      }
      validateViewpointUsageTyping(node, accept) {
        this.validateExactlyOneTyping(node, ast2.ViewpointDefinition, accept, "ViewpointUsages must be typed by exactly one ViewpointDefinition.", { code: "validateViewpointUsageTyping" });
      }
      validateViewRenderingMembershipOwningType(node, accept) {
        var _a;
        if (!((_a = node.owner()) === null || _a === void 0 ? void 0 : _a.isAny(ast2.ViewUsage, ast2.ViewDefinition)))
          accept("error", `The owningType of an ViewRenderingMembership must be a CaseDefinition or CaseUsage.`, { element: node, code: `validateViewRenderingMembershipOwningType` });
      }
      validateViewUsageTyping(node, accept) {
        this.validateExactlyOneTyping(node, ast2.ViewDefinition, accept, "ViewUsages must be typed by exactly one ViewDefinition.", { code: "validateViewUsageTyping" });
      }
      validateMetadataUsageTyping(node, accept) {
        this.validateExactlyOneTyping(node, ast2.Metaclass, accept, "MetadataUsages must be typed by exactly one Metaclass.", { code: "validateMetadataUsageTyping" });
      }
      validateDatatypeSpecialization(node, accept) {
        this.apply("error", node.specializations(ast2.Specialization).filter((s) => {
          var _a;
          return (_a = s.element()) === null || _a === void 0 ? void 0 : _a.isAny(ast2.Class, ast2.Association);
        }), "An AttributeDefinition must not specialize a Class or an Association.", accept, { code: "validateDatatypeSpecialization", property: "targetRef" });
      }
      validateClassSpecialization(node, accept) {
        this.apply("error", node.specializations(ast2.Specialization).filter((s) => {
          var _a;
          return (_a = s.element()) === null || _a === void 0 ? void 0 : _a.isAny(ast2.DataType, ast2.Association);
        }), "An ItemDefinition must not specialize a DataType or an Association.", accept, { code: "validateClassSpecialization", property: "targetRef" });
      }
      validateAssocStructSpecialization(node, accept) {
        this.apply("error", node.specializations(ast2.Specialization).filter((s) => {
          var _a;
          return (_a = s.element()) === null || _a === void 0 ? void 0 : _a.isAny(ast2.DataType);
        }), "A ConnectionDefinition must not specialize a DataType.", accept, { code: "validateClassSpecialization", property: "targetRef" });
      }
      validateOperatorExpressionQuantity(node, accept) {
        if (node.operator === model_1.OPERATORS.QUANTITY) {
          const arg = node.operands.at(1);
          if (!arg)
            return;
          if (!this.resultConforms(arg, "MeasurementReferences::TensorMeasurementReference")) {
            accept("warning", "Invalid quantity expression, expected a measurement reference unit", {
              element: node,
              property: "operands",
              index: 1,
              code: "validateOperatorExpressionQuantity"
            });
          }
        }
      }
      resultConforms(expr, type) {
        const result = expr.returnType();
        if (result && this.index.conforms(result, type))
          return true;
        if (expr.is(ast2.OperatorExpression)) {
          if (!result) {
            const t = this.index.findType(result);
            if (t && !t.types().some((t2) => this.index.conforms(type, t2)))
              return false;
          }
          return expr.args.filter(model_1.BasicMetamodel.is(ast2.Expression)).some((arg) => this.resultConforms(arg, type));
        }
        return false;
      }
      validateAllTypings(node, bound, accept, message, info) {
        if (node.allTypings().some((t) => !t.is(bound))) {
          accept("error", message, Object.assign(Object.assign({}, info), { element: node }));
          return false;
        }
        return true;
      }
      validateAtLeastTyping(node, bound, accept, message, info) {
        if (!node.allTypings().find((t) => t.is(bound))) {
          accept("error", message, Object.assign(Object.assign({}, info), { element: node }));
          return false;
        }
        return true;
      }
      checkReferencing(node, accept, options) {
        const ref = node.specializations(ast2.ReferenceSubsetting).at(0);
        const target = ref === null || ref === void 0 ? void 0 : ref.finalElement();
        if (ref && target && !target.is(options.reference)) {
          accept("error", `ReferenceSubsettings owned by ${options.type} must reference ${options.reference}`, Object.assign(Object.assign({}, options.info), { element: ref }));
        }
      }
      checkParameters(node, keys, accept, options) {
        keys.forEach((key) => {
          if (!node[key])
            accept("error", `${options.type} must have ${key} parameter.`, Object.assign(Object.assign({}, options.info), { element: node }));
        });
      }
      checkFirstInput(node, expected, accept, message, info) {
        if (!expected)
          return;
        const first = node.ownedInputParameters()[0];
        if (first !== expected) {
          accept("error", message, Object.assign(Object.assign({}, info), { element: node.ownedInputParameters()[0] }));
        }
      }
    };
    exports2.SysMLValidator = SysMLValidator;
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.Definition),
      (0, validation_registry_1.validateSysML)(ast2.Usage)
    ], SysMLValidator.prototype, "validateVariationMembership", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.Definition),
      (0, validation_registry_1.validateSysML)(ast2.Usage)
    ], SysMLValidator.prototype, "validateVariationSpecialization", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.VariantMembership)
    ], SysMLValidator.prototype, "validateVariantMembershipOwningNamespace", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.AttributeUsage)
    ], SysMLValidator.prototype, "validateAttributeUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.EnumerationUsage)
    ], SysMLValidator.prototype, "validateEnumerationUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.EventOccurrenceUsage)
    ], SysMLValidator.prototype, "validateEventOccurrenceUsageReference", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.OccurrenceDefinition)
    ], SysMLValidator.prototype, "validateOccurrenceDefinitionLifeClass", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.OccurrenceUsage, [ast2.ItemUsage, ast2.PortUsage, ast2.Step])
    ], SysMLValidator.prototype, "validateOccurrenceUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.OccurrenceUsage)
    ], SysMLValidator.prototype, "validateOccurrenceUsageIndividual", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ItemUsage, [ast2.PartUsage, ast2.PortUsage, ast2.MetadataUsage])
    ], SysMLValidator.prototype, "validateItemUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.PartUsage, [ast2.ConnectionUsage])
    ], SysMLValidator.prototype, "validatePartUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ConjugatedPortDefinition)
    ], SysMLValidator.prototype, "validateConjugatedPortDefinitionOriginalPortDefinition", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.PortDefinition, [ast2.ConjugatedPortDefinition])
    ], SysMLValidator.prototype, "validatePortDefinitionConjugatedPortDefinition", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.PortDefinition),
      (0, validation_registry_1.validateSysML)(ast2.PortUsage)
    ], SysMLValidator.prototype, "validatePortOwnedUsagesNotComposite", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.PortUsage)
    ], SysMLValidator.prototype, "validatePortUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ConnectionUsage, [
        ast2.FlowConnectionUsage,
        ast2.InterfaceUsage,
        ast2.AllocationUsage
      ])
    ], SysMLValidator.prototype, "validateConnectionUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.FlowConnectionDefinition)
    ], SysMLValidator.prototype, "validateFlowConnectionEnd", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.FlowConnectionUsage)
    ], SysMLValidator.prototype, "validateFlowConnectionUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.InterfaceDefinition),
      (0, validation_registry_1.validateSysML)(ast2.InterfaceUsage)
    ], SysMLValidator.prototype, "validateInterfaceEnds", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.InterfaceUsage)
    ], SysMLValidator.prototype, "validateInterfaceUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.AllocationUsage)
    ], SysMLValidator.prototype, "validateAllocationUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.AcceptActionUsage)
    ], SysMLValidator.prototype, "validateAcceptActionUsageParameters", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ActionUsage, [ast2.StateUsage, ast2.CalculationUsage, ast2.FlowConnectionUsage])
    ], SysMLValidator.prototype, "validateActionUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.AssignmentActionUsage)
    ], SysMLValidator.prototype, "validateAssignmentActionUsageReferent", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.TriggerInvocationExpression)
    ], SysMLValidator.prototype, "validateTriggerInvocationExpression", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ControlNode)
    ], SysMLValidator.prototype, "validateControlNodeOwningType", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.PerformActionUsage, [ast2.ExhibitStateUsage, ast2.IncludeUseCaseUsage])
    ], SysMLValidator.prototype, "validatePerformActionUsageReference", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.SendActionUsage)
    ], SysMLValidator.prototype, "validateSendActionParameters", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.SendActionUsage)
    ], SysMLValidator.prototype, "validateSendActionReceiver", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ExhibitStateUsage)
    ], SysMLValidator.prototype, "validateExhibitStateUsageReference", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.StateSubactionMembership)
    ], SysMLValidator.prototype, "validateStateSubactionMembershipOwningType", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.SuccessionAsUsage),
      (0, validation_registry_1.validateSysML)(ast2.TransitionUsage)
    ], SysMLValidator.prototype, "validateStateParallelSubactions", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.StateDefinition),
      (0, validation_registry_1.validateSysML)(ast2.StateUsage)
    ], SysMLValidator.prototype, "validateStateSubactionKind", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.StateUsage)
    ], SysMLValidator.prototype, "validateStateUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.TransitionFeatureMembership)
    ], SysMLValidator.prototype, "validateTransitionFeatureMembership", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.TransitionFeatureMembership)
    ], SysMLValidator.prototype, "validateTransitionFeatureMembershipOwningType", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.TransitionUsage)
    ], SysMLValidator.prototype, "validateTransitionUsageParameters", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.TransitionUsage)
    ], SysMLValidator.prototype, "validateTransitionUsageSuccession", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.CalculationUsage, [ast2.CaseUsage])
    ], SysMLValidator.prototype, "validateCalculationUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.AssertConstraintUsage)
    ], SysMLValidator.prototype, "validateAssertConstraintUsageReference", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ConstraintUsage, [ast2.RequirementUsage])
    ], SysMLValidator.prototype, "validateConstraintUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.SubjectMembership)
    ], SysMLValidator.prototype, "validateSubjectMembershipOwningType", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ActorMembership)
    ], SysMLValidator.prototype, "validateActorMembershipOwningType", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.RequirementConstraintMembership)
    ], SysMLValidator.prototype, "validateRequirementConstraintMembershipIsComposite", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.RequirementConstraintMembership),
      (0, validation_registry_1.validateSysML)(ast2.StakeholderMembership)
    ], SysMLValidator.prototype, "validateRequirementMembershipOwningType", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.RequirementDefinition),
      (0, validation_registry_1.validateSysML)(ast2.RequirementUsage)
    ], SysMLValidator.prototype, "validateRequirementOnlyOneSubject", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.RequirementDefinition),
      (0, validation_registry_1.validateSysML)(ast2.RequirementUsage)
    ], SysMLValidator.prototype, "validateRequirementSubjectParameterPosition", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.RequirementUsage, [ast2.ViewpointUsage])
    ], SysMLValidator.prototype, "validateRequirementUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.SatisfyRequirementUsage)
    ], SysMLValidator.prototype, "validateSatisfyRequirementUsageReference", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.CaseDefinition),
      (0, validation_registry_1.validateSysML)(ast2.CaseUsage)
    ], SysMLValidator.prototype, "validateCaseDefinitionOnlyOneSubject", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.CaseDefinition),
      (0, validation_registry_1.validateSysML)(ast2.CaseUsage)
    ], SysMLValidator.prototype, "validateCaseOnlyOneObjective", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.CaseDefinition),
      (0, validation_registry_1.validateSysML)(ast2.CaseUsage)
    ], SysMLValidator.prototype, "validateCaseSubjectParameterPosition", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.CaseUsage, [
        ast2.AnalysisCaseUsage,
        ast2.VerificationCaseUsage,
        ast2.UseCaseUsage
      ])
    ], SysMLValidator.prototype, "validateCaseUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ObjectiveMembership)
    ], SysMLValidator.prototype, "validateObjectiveMembershipIsComposite", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ObjectiveMembership)
    ], SysMLValidator.prototype, "validateObjectiveMembershipOwningType", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.AnalysisCaseUsage)
    ], SysMLValidator.prototype, "validateAnalysisCaseUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.RequirementVerificationMembership)
    ], SysMLValidator.prototype, "validateRequirementVerificationMembershipOwningType", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.VerificationCaseUsage)
    ], SysMLValidator.prototype, "validateVerificationCaseUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.IncludeUseCaseUsage)
    ], SysMLValidator.prototype, "validateIncludeUseCaseUsageReference", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.UseCaseUsage)
    ], SysMLValidator.prototype, "validateUseCaseUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.Expose)
    ], SysMLValidator.prototype, "validateExposeNoExplicitVisibility", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.Expose)
    ], SysMLValidator.prototype, "validateExposeOwningNamespace", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.RenderingUsage)
    ], SysMLValidator.prototype, "validateRenderingUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ViewDefinition),
      (0, validation_registry_1.validateSysML)(ast2.ViewUsage)
    ], SysMLValidator.prototype, "validateViewDefinitionOnlyOneViewRendering", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ViewpointUsage)
    ], SysMLValidator.prototype, "validateViewpointUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ViewRenderingMembership)
    ], SysMLValidator.prototype, "validateViewRenderingMembershipOwningType", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.ViewUsage)
    ], SysMLValidator.prototype, "validateViewUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.MetadataUsage)
    ], SysMLValidator.prototype, "validateMetadataUsageTyping", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.DataType)
    ], SysMLValidator.prototype, "validateDatatypeSpecialization", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.Class, [ast2.AssociationStructure, ast2.Interaction])
    ], SysMLValidator.prototype, "validateClassSpecialization", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.AssociationStructure),
      (0, validation_registry_1.validateSysML)(ast2.Interaction)
    ], SysMLValidator.prototype, "validateAssocStructSpecialization", null);
    __decorate([
      (0, validation_registry_1.validateSysML)(ast2.OperatorExpression, [
        ast2.CollectExpression,
        ast2.SelectExpression,
        ast2.FeatureChainExpression
      ])
    ], SysMLValidator.prototype, "validateOperatorExpressionQuantity", null);
  }
});

// ../syside-languageserver/lib/services/events.js
var require_events2 = __commonJS({
  "../syside-languageserver/lib/services/events.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LanguageEvents = exports2.SharedEvents = exports2.Event = exports2.AsyncEvent = void 0;
    var vscode_languageserver_1 = require_main4();
    var common_1 = require_common();
    var BaseEvent = class {
      constructor() {
        this.listeners = [];
      }
      /**
       * Register a callback for the event
       * @param listener The listener function will be called when the event happens.
       * @param thisArg The 'this' which will be used when calling the event listener.
       * @param disposables An array to which a {@link Disposable} will be added.
       * @returns
       */
      add(listener, thisArg, disposables) {
        const data = {
          context: thisArg,
          listener
        };
        this.listeners.push(data);
        const disposable = vscode_languageserver_1.Disposable.create(() => {
          (0, common_1.erase)(this.listeners, data);
        });
        if (disposables)
          disposables.push(disposable);
        return disposable;
      }
      /**
       * Log a message on listener error
       * @param index index of the listener in {@link listeners} array
       * @param reason error
       */
      reportFailure(index, reason) {
        let message = `'${this.listeners[index].listener.name}' failed: ${reason}`;
        if (reason instanceof Error)
          message += "\n" + reason.stack;
        console.error(message);
      }
      dispatch(...args) {
        const resolved = [];
        this.listeners.forEach((cb, index) => {
          try {
            resolved.push(cb.listener.call(cb.context, ...args));
          } catch (reason) {
            this.reportFailure(index, reason);
          }
        });
        return resolved;
      }
    };
    var AsyncEvent = class extends BaseEvent {
      /**
       * Trigger an event
       * @param args event arguments
       * @returns successful listener return values
       */
      emit(...args) {
        return __awaiter(this, void 0, void 0, function* () {
          const results = yield Promise.allSettled(this.dispatch(...args));
          const resolved = [];
          results.forEach((result, index) => {
            if (result.status === "rejected") {
              this.reportFailure(index, result.reason);
            } else {
              resolved.push(result.value);
            }
          });
          return resolved;
        });
      }
    };
    exports2.AsyncEvent = AsyncEvent;
    var Event = class extends BaseEvent {
      /**
       * Trigger an event
       * @param args event arguments
       * @returns successful listener return values
       */
      emit(...args) {
        return this.dispatch(...args);
      }
    };
    exports2.Event = Event;
    var SharedEvents = class {
      constructor() {
        this.onConfigurationChanged = new Event();
      }
    };
    exports2.SharedEvents = SharedEvents;
    var LanguageEvents = class {
      constructor() {
        this.onHoverRequest = new AsyncEvent();
        this.onConfigurationChanged = new Event();
      }
    };
    exports2.LanguageEvents = LanguageEvents;
  }
});

// ../syside-languageserver/lib/services/shared/extension-manager.js
var require_extension_manager = __commonJS({
  "../syside-languageserver/lib/services/shared/extension-manager.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtensionManager = void 0;
    var vscode_uri_1 = require_umd();
    var common_1 = require_common();
    var ExtensionManager = class {
      constructor(services) {
        this.services = services;
        this.fileSystem = services.workspace.FileSystemProvider;
      }
      /**
       * Dynamically load additional JS plugins through `activate` function. All
       * JS scripts will be loaded from directory paths.
       * @param paths path or paths to plugins, either to directories or files
       */
      loadScripts(paths) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!Array.isArray(paths))
            paths = [paths];
          yield (0, common_1.waitAllPromises)(paths.map((p) => this.loadFromPath(p)), (result, index) => `Failed to load script path ${paths[index].fsPath}: ${result.reason}`);
        });
      }
      /**
       * Load scripts from a single path (directory or file)
       * @see {@link loadScripts}
       * @param p path
       */
      loadFromPath(p) {
        return __awaiter(this, void 0, void 0, function* () {
          const ext = vscode_uri_1.Utils.extname(p);
          if (ext.length === 0) {
            const scripts = yield this.fileSystem.readDirectory(p).then((nodes) => nodes.filter((node) => node.isFile && vscode_uri_1.Utils.extname(node.uri) === ".js"));
            yield (0, common_1.waitAllPromises)(scripts.map((node) => this.loadScript(node.uri)));
          } else if (ext === ".js") {
            yield this.loadScript(p);
          }
        });
      }
      /**
       * Load a script from a path, assuming it is a JS file
       * @param file path to the script
       */
      loadScript(file) {
        return __awaiter(this, void 0, void 0, function* () {
          const module3 = yield this.fileSystem.loadScript(file);
          let reason = "no 'activate' function found";
          if (module3 && "activate" in module3) {
            if (typeof module3.activate === "function") {
              yield module3.activate(this.services);
              console.log(`Plugin '${file.fsPath}' was activated.`);
              return;
            }
            reason = "'activate' is not a function";
          }
          console.log(`Could not load plugin at ${file.fsPath}: ${reason}`);
        });
      }
    };
    exports2.ExtensionManager = ExtensionManager;
  }
});

// ../syside-languageserver/lib/services/shared/model-utils.js
var require_model_utils = __commonJS({
  "../syside-languageserver/lib/services/shared/model-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ModelUtil = void 0;
    var model_1 = require_model3();
    var ModelUtil = class {
      constructor() {
        this.idProvider = (0, model_1.basicIdProvider)();
      }
      /**
       *
       * @returns An element ID for use when creating internal models programmatically
       */
      createId() {
        return this.idProvider();
      }
      /**
       * Constructs a feature chaining from {@link chained} to {@link chaining}
       * @param chained
       * @param chaining
       * @returns {@link chained}
       */
      addChainingFeature(chained, chaining) {
        const relationship = model_1.FeatureChainingMeta.create(this.idProvider, chained.document);
        chained.addFeatureRelationship([relationship, chaining]);
        return chained;
      }
      /**
       * Constructs a feature that chains all {@link features}
       * @param features chaining features
       * @returns
       */
      chainFeatures(feature, ...features) {
        const chained = model_1.FeatureMeta.create(this.idProvider, feature.document);
        for (const feat of [feature, ...features]) {
          const chaining = feat.chainingFeatures;
          if (chaining.length === 0)
            this.addChainingFeature(chained, feat);
          else
            chaining.forEach((f) => this.addChainingFeature(chained, f));
        }
        return chained;
      }
    };
    exports2.ModelUtil = ModelUtil;
  }
});

// ../syside-languageserver/lib/services/lsp/index.js
var require_lsp2 = __commonJS({
  "../syside-languageserver/lib/services/lsp/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_completion_provider2(), exports2);
    __exportStar(require_execute_command_handler2(), exports2);
    __exportStar(require_formatter2(), exports2);
    __exportStar(require_hover_provider2(), exports2);
    __exportStar(require_language_server2(), exports2);
    __exportStar(require_semantic_token_provider2(), exports2);
  }
});

// ../syside-languageserver/lib/services/parser/index.js
var require_parser4 = __commonJS({
  "../syside-languageserver/lib/services/parser/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_grammar_config2(), exports2);
    __exportStar(require_parser3(), exports2);
  }
});

// ../syside-languageserver/lib/services/references/index.js
var require_references5 = __commonJS({
  "../syside-languageserver/lib/services/references/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_linker2(), exports2);
    __exportStar(require_name_provider2(), exports2);
    __exportStar(require_scope_computation2(), exports2);
    __exportStar(require_scope_provider2(), exports2);
  }
});

// ../syside-languageserver/lib/services/services.js
var require_services2 = __commonJS({
  "../syside-languageserver/lib/services/services.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../syside-languageserver/lib/services/shared/service-registry.js
var require_service_registry2 = __commonJS({
  "../syside-languageserver/lib/services/shared/service-registry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLServiceRegistry = void 0;
    var langium_1 = require_lib2();
    var SysMLServiceRegistry = class extends langium_1.DefaultServiceRegistry {
      getServices(uri) {
        var _a, _b;
        try {
          return super.getServices(uri);
        } catch (_) {
          const services = (_a = this.singleton) !== null && _a !== void 0 ? _a : (_b = this.map) === null || _b === void 0 ? void 0 : _b[".sysml"];
          if (!services)
            throw new Error("No services registered!");
          return services;
        }
      }
    };
    exports2.SysMLServiceRegistry = SysMLServiceRegistry;
  }
});

// ../syside-languageserver/lib/services/shared/workspace/file-system-provider.js
var require_file_system_provider2 = __commonJS({
  "../syside-languageserver/lib/services/shared/workspace/file-system-provider.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLEmptyFileSystem = exports2.SysMLEmptyFileSystemProvider = void 0;
    var langium_1 = require_lib2();
    var SysMLEmptyFileSystemProvider = class extends langium_1.EmptyFileSystemProvider {
      get standardLibrary() {
        return;
      }
      updateStandardLibrary(value) {
        return;
      }
      get extensionDir() {
        return;
      }
      exists(path2) {
        return __awaiter(this, void 0, void 0, function* () {
          return false;
        });
      }
      existsSync(path2) {
        return false;
      }
      loadScript(path2) {
        throw new Error("Method not implemented.");
      }
      preloadFiles(paths) {
        return __awaiter(this, void 0, void 0, function* () {
          return;
        });
      }
    };
    exports2.SysMLEmptyFileSystemProvider = SysMLEmptyFileSystemProvider;
    exports2.SysMLEmptyFileSystem = {
      fileSystemProvider: () => new SysMLEmptyFileSystemProvider()
    };
  }
});

// ../syside-languageserver/lib/services/shared/workspace/index.js
var require_workspace2 = __commonJS({
  "../syside-languageserver/lib/services/shared/workspace/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_ast_descriptions2(), exports2);
    __exportStar(require_configuration_provider(), exports2);
    __exportStar(require_document_builder2(), exports2);
    __exportStar(require_documents3(), exports2);
    __exportStar(require_file_system_provider2(), exports2);
    __exportStar(require_index_manager2(), exports2);
    __exportStar(require_metamodel_builder(), exports2);
    __exportStar(require_workspace_manager2(), exports2);
  }
});

// ../syside-languageserver/lib/services/shared/index.js
var require_shared = __commonJS({
  "../syside-languageserver/lib/services/shared/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_evaluator2(), exports2);
    __exportStar(require_extension_manager(), exports2);
    __exportStar(require_model_utils(), exports2);
    __exportStar(require_service_registry2(), exports2);
    __exportStar(require_workspace2(), exports2);
  }
});

// ../syside-languageserver/lib/services/sysml-validation.js
var require_sysml_validation = __commonJS({
  "../syside-languageserver/lib/services/sysml-validation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeError = void 0;
    var langium_1 = require_lib2();
    function makeError(source, info, extra) {
      if (!(0, langium_1.isAstNode)(source)) {
        const ast2 = source.ast();
        if (ast2) {
          return Object.assign(Object.assign(Object.assign({}, info), { node: ast2 }), extra === null || extra === void 0 ? void 0 : extra.call(void 0, ast2));
        }
        return Object.assign(Object.assign({}, info), { model: source });
      }
      return Object.assign(Object.assign(Object.assign({}, info), { node: source }), extra === null || extra === void 0 ? void 0 : extra.call(void 0, source));
    }
    exports2.makeError = makeError;
  }
});

// ../syside-languageserver/lib/services/validation/index.js
var require_validation2 = __commonJS({
  "../syside-languageserver/lib/services/validation/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_document_validator2(), exports2);
    __exportStar(require_kerml_validation_registry(), exports2);
    __exportStar(require_kerml_validator(), exports2);
    __exportStar(require_sysml_validation_registry(), exports2);
    __exportStar(require_sysml_validator(), exports2);
    __exportStar(require_validation_registry2(), exports2);
  }
});

// ../syside-languageserver/lib/services/index.js
var require_services3 = __commonJS({
  "../syside-languageserver/lib/services/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_config(), exports2);
    __exportStar(require_events2(), exports2);
    __exportStar(require_lsp2(), exports2);
    __exportStar(require_parser4(), exports2);
    __exportStar(require_references5(), exports2);
    __exportStar(require_services2(), exports2);
    __exportStar(require_shared(), exports2);
    __exportStar(require_sysml_ast_reflection(), exports2);
    __exportStar(require_sysml_validation(), exports2);
    __exportStar(require_validation2(), exports2);
  }
});

// ../syside-languageserver/lib/sysml-module.js
var require_sysml_module = __commonJS({
  "../syside-languageserver/lib/sysml-module.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createSysMLServices = exports2.SysMLSharedModule = exports2.KerMLModule = exports2.SysMLModule = exports2.SysMLDefaultModule = void 0;
    var langium_1 = require_lib2();
    var module_1 = require_module2();
    var sysml_validation_registry_1 = require_sysml_validation_registry();
    var scope_computation_1 = require_scope_computation2();
    var name_provider_1 = require_name_provider2();
    var document_builder_1 = require_document_builder2();
    var linker_1 = require_linker2();
    var index_manager_1 = require_index_manager2();
    var scope_provider_1 = require_scope_provider2();
    var completion_provider_1 = require_completion_provider2();
    var document_validator_1 = require_document_validator2();
    var sysml_ast_reflection_1 = require_sysml_ast_reflection();
    var metamodel_builder_1 = require_metamodel_builder();
    var parser_1 = require_parser3();
    var ast_node_locator_1 = require_ast_node_locator();
    var ast_descriptions_1 = require_ast_descriptions2();
    var execute_command_handler_1 = require_execute_command_handler2();
    var workspace_manager_1 = require_workspace_manager2();
    var documents_1 = require_documents3();
    var config_1 = require_config();
    var common_1 = require_common();
    var semantic_token_provider_1 = require_semantic_token_provider2();
    var language_server_1 = require_language_server2();
    var configuration_provider_1 = require_configuration_provider();
    var hover_provider_1 = require_hover_provider2();
    var formatter_1 = require_formatter2();
    var grammar_config_1 = require_grammar_config2();
    var kerml_validation_registry_1 = require_kerml_validation_registry();
    var kerml_validator_1 = require_kerml_validator();
    var sysml_validator_1 = require_sysml_validator();
    var events_1 = require_events2();
    var extension_manager_1 = require_extension_manager();
    var model_utils_1 = require_model_utils();
    var evaluator_1 = require_evaluator2();
    var services_1 = require_services3();
    exports2.SysMLDefaultModule = {
      parser: {
        LangiumParser: (services) => (0, parser_1.createSysMLParser)(services),
        GrammarConfig: (services) => (0, grammar_config_1.createSysMLGrammarConfig)(services)
      },
      references: {
        ScopeComputation: (services) => new scope_computation_1.SysMLScopeComputation(services),
        ScopeProvider: (services) => new scope_provider_1.SysMLScopeProvider(services),
        NameProvider: () => new name_provider_1.SysMLNameProvider(),
        Linker: (services) => new linker_1.SysMLLinker(services)
      },
      validation: {
        DocumentValidator: (services) => new document_validator_1.SysMLDocumentValidator(services)
      },
      lsp: {
        Formatter: (services) => new formatter_1.SysMLFormatter(services),
        // RenameProvider: (services) => new SysMLRenameProvider(services),
        CompletionProvider: (services) => new completion_provider_1.SysMLCompletionProvider(services),
        SemanticTokenProvider: (services) => new semantic_token_provider_1.SysMLSemanticTokenProvider(services),
        HoverProvider: (services) => new hover_provider_1.SysMLHoverProvider(services)
      },
      workspace: {
        AstNodeDescriptionProvider: (services) => new ast_descriptions_1.SysMLNodeDescriptionProvider(services.shared)
      },
      Events: () => new events_1.LanguageEvents()
    };
    exports2.SysMLModule = {
      validation: {
        ValidationRegistry: (services) => new sysml_validation_registry_1.SysMLValidationRegistry(services),
        SysMLValidator: (services) => new sysml_validator_1.SysMLValidator(services.shared)
      }
    };
    exports2.KerMLModule = {
      validation: {
        ValidationRegistry: (services) => new kerml_validation_registry_1.KerMLValidationRegistry(services),
        KerMLValidator: (services) => new kerml_validator_1.KerMLValidator(services.shared)
      }
    };
    exports2.SysMLSharedModule = {
      ServiceRegistry: () => new services_1.SysMLServiceRegistry(),
      AstReflection: () => new sysml_ast_reflection_1.SysMLAstReflection(),
      workspace: {
        DocumentBuilder: (services) => new document_builder_1.SysMLDocumentBuilder(services),
        IndexManager: (services) => new index_manager_1.SysMLIndexManager(services),
        MetamodelBuilder: (services) => new metamodel_builder_1.SysMLMetamodelBuilder(services),
        AstNodeLocator: () => new ast_node_locator_1.DefaultAstNodeLocator(),
        AstNodeDescriptionProvider: (services) => new ast_descriptions_1.SysMLNodeDescriptionProvider(services),
        WorkspaceManager: (services) => new workspace_manager_1.SysMLWorkspaceManager(services),
        LangiumDocumentFactory: (services) => new documents_1.SysMLDocumentFactory(services),
        ConfigurationProvider: (services) => new configuration_provider_1.SysMLConfigurationProvider(services),
        LangiumDocuments: (services) => new documents_1.SysMLDocuments(services)
      },
      lsp: {
        ExecuteCommandHandler: (services) => new execute_command_handler_1.SysMLExecuteCommandHandler(services),
        LanguageServer: (services) => new language_server_1.SysMLLanguageServer(services)
      },
      config: () => config_1.DefaultSysMLConfig,
      Evaluator: (services) => new evaluator_1.SysMLExpressionEvaluator(services),
      statistics: () => new common_1.Statistics(),
      ExtensionManager: (services) => new extension_manager_1.ExtensionManager(services),
      Events: () => new events_1.SharedEvents(),
      Util: () => new model_utils_1.ModelUtil()
    };
    function createSysMLServices2(context, config) {
      const sharedModule = Object.assign(Object.assign({}, exports2.SysMLSharedModule), { config: () => (0, common_1.mergeWithPartial)(config_1.DefaultSysMLConfig, config) });
      const shared = (0, langium_1.inject)((0, langium_1.createDefaultSharedModule)(context), module_1.SysMlGeneratedSharedModule, sharedModule);
      const SysML = (0, langium_1.inject)((0, langium_1.createDefaultModule)({ shared }), module_1.SysMLGeneratedModule, exports2.SysMLDefaultModule, exports2.SysMLModule);
      const KerML = (0, langium_1.inject)((0, langium_1.createDefaultModule)({ shared }), module_1.KerMLGeneratedModule, exports2.SysMLDefaultModule, exports2.KerMLModule);
      shared.ServiceRegistry.register(SysML);
      shared.ServiceRegistry.register(KerML);
      return { shared, SysML, KerML };
    }
    exports2.createSysMLServices = createSysMLServices2;
  }
});

// ../syside-languageserver/lib/launch/server.js
var require_server2 = __commonJS({
  "../syside-languageserver/lib/launch/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.startServer = void 0;
    var langium_1 = require_lib2();
    var sysml_module_1 = require_sysml_module();
    function startServer(connection, context, options) {
      const services = (0, sysml_module_1.createSysMLServices)(Object.assign({ connection }, context), options);
      (0, langium_1.startLanguageServer)(services.shared);
      return services;
    }
    exports2.startServer = startServer;
  }
});

// ../syside-languageserver/lib/launch/index.js
var require_launch = __commonJS({
  "../syside-languageserver/lib/launch/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_server2(), exports2);
  }
});

// ../syside-languageserver/lib/version.js
var require_version2 = __commonJS({
  "../syside-languageserver/lib/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Version = void 0;
    exports2.Version = "0.9.0";
  }
});

// ../syside-languageserver/lib/index.js
var require_lib5 = __commonJS({
  "../syside-languageserver/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ast = void 0;
    exports2.ast = __importStar(require_ast2());
    __exportStar(require_grammar3(), exports2);
    __exportStar(require_module2(), exports2);
    __exportStar(require_model3(), exports2);
    __exportStar(require_sysml_module(), exports2);
    __exportStar(require_services3(), exports2);
    __exportStar(require_utils2(), exports2);
    __exportStar(require_launch(), exports2);
    __exportStar(require_version2(), exports2);
  }
});

// ../syside-languageserver/lib/node/arg-parser.js
var require_arg_parser = __commonJS({
  "../syside-languageserver/lib/node/arg-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultLauncherOptions = void 0;
    exports2.DefaultLauncherOptions = {};
  }
});

// ../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/node.js
var require_node3 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver@8.0.2/node_modules/vscode-languageserver/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main4();
  }
});

// ../syside-languageserver/lib/node/cli.js
var require_cli = __commonJS({
  "../syside-languageserver/lib/node/cli.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTransport = exports2.createServerSocketTransport = exports2.parsePort = exports2.parsePositiveInt = exports2.createArgParser = exports2.DefaultNodeLauncherOptions = exports2.sanitizedArgHandler = exports2.sanitizeArg = void 0;
    var commander_1 = require_commander();
    var langium_1 = require_lib2();
    var net_1 = require("net");
    var node_1 = require_node3();
    var arg_parser_1 = require_arg_parser();
    var version_1 = require_version2();
    function sanitizeArg(arg) {
      return arg.startsWith("=") ? arg.substring(1) : arg;
    }
    exports2.sanitizeArg = sanitizeArg;
    function sanitizedArgHandler(handler) {
      return (arg, previous) => handler(sanitizeArg(arg), previous);
    }
    exports2.sanitizedArgHandler = sanitizedArgHandler;
    exports2.DefaultNodeLauncherOptions = Object.assign({}, arg_parser_1.DefaultLauncherOptions);
    function createArgParser(options = exports2.DefaultNodeLauncherOptions) {
      const command = new commander_1.Command().version(version_1.Version).description("SysIDE").showHelpAfterError(true).name("Launch SysIDE");
      command.addOption(new commander_1.Option("--node-ipc", "Use Node IPC for LSP communication").conflicts([
        "stdio",
        "socket",
        "pipe",
        "host",
        "encoding"
      ])).addOption(new commander_1.Option("--stdio", "Use stdio for LSP communication").conflicts([
        "node-ipc",
        "socket",
        "pipe",
        "host",
        "encoding"
      ])).addOption(new commander_1.Option("-s, --socket <socket>", "Use socket for LSP communication").conflicts(["node-ipc", "stdio", "pipe"]).argParser(sanitizedArgHandler(parsePort))).addOption(new commander_1.Option("--pipe <pipe>", "Use named pipe for LSP communication").conflicts(["node-ipc", "stdio", "socket", "host"]).argParser(sanitizeArg)).addOption(new commander_1.Option("--host <hostname>", "Socket hostname").default("localhost").conflicts(["node-ipc", "stdio", "pipe"])).addOption(new commander_1.Option("-e, --encoding <encoding>", "Socket/pipe encoding").default("utf-8").choices(["utf-8", "ascii"]).conflicts(["node-ipc", "stdio"])).option("--clientProcessId <id>", "Client process ID. The server will shutdown if the client dies unexpectedly", sanitizedArgHandler(parsePositiveInt));
      return {
        command,
        parse: (argv, opts) => {
          command.parse(argv, opts);
          return Object.assign(Object.assign({}, options), command.opts());
        }
      };
    }
    exports2.createArgParser = createArgParser;
    function parsePositiveInt(value) {
      const int = Number.parseInt(value, 10);
      if (isNaN(int)) {
        throw new commander_1.InvalidArgumentError("Value is not a number!");
      }
      if (int < 0) {
        throw new commander_1.InvalidArgumentError("Value has to be positive!");
      }
      return int;
    }
    exports2.parsePositiveInt = parsePositiveInt;
    function parsePort(value) {
      const port = Number.parseInt(value, 10);
      if (isNaN(port)) {
        throw new commander_1.InvalidArgumentError("Port is not a number!");
      }
      if (port < 0 || port > 65535) {
        throw new commander_1.InvalidArgumentError("Port has to be between in range (0, 65535)!");
      }
      return port;
    }
    exports2.parsePort = parsePort;
    function createServerSocketTransport(port, host, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, host);
      return [new node_1.SocketMessageReader(socket, encoding), new node_1.SocketMessageWriter(socket, encoding)];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function createTransport(options) {
      if ("nodeIpc" in options) {
        return [new node_1.IPCMessageReader(process), new node_1.IPCMessageWriter(process)];
      }
      if ("stdio" in options) {
        return [process.stdin, process.stdout];
      }
      if ("pipe" in options) {
        return (0, node_1.createServerPipeTransport)(options.pipe, options.encoding);
      }
      if ("socket" in options) {
        return createServerSocketTransport(options.socket, options.host, options.encoding);
      }
      (0, langium_1.assertUnreachable)(options);
    }
    exports2.createTransport = createTransport;
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/node/node-file-system-provider.js
var require_node_file_system_provider = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/node/node-file-system-provider.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeFileSystem = exports2.NodeFileSystemProvider = void 0;
    var fs_1 = __importDefault(require("fs"));
    var vscode_uri_1 = require_umd();
    var NodeFileSystemProvider = class {
      constructor() {
        this.encoding = "utf-8";
      }
      readFile(uri) {
        return fs_1.default.promises.readFile(uri.fsPath, this.encoding);
      }
      readFileSync(uri) {
        return fs_1.default.readFileSync(uri.fsPath, this.encoding);
      }
      async readDirectory(folderPath) {
        const dirents = await fs_1.default.promises.readdir(folderPath.fsPath, { withFileTypes: true });
        return dirents.map((dirent) => ({
          dirent,
          isFile: dirent.isFile(),
          isDirectory: dirent.isDirectory(),
          uri: vscode_uri_1.Utils.joinPath(folderPath, dirent.name)
        }));
      }
    };
    exports2.NodeFileSystemProvider = NodeFileSystemProvider;
    exports2.NodeFileSystem = {
      fileSystemProvider: () => new NodeFileSystemProvider()
    };
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/node/index.js
var require_node4 = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/lib/node/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_node_file_system_provider(), exports2);
  }
});

// ../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/node.js
var require_node5 = __commonJS({
  "../../node_modules/.pnpm/langium@1.2.1/node_modules/langium/node.js"(exports2, module2) {
    module2.exports = require_node4();
  }
});

// ../syside-languageserver/lib/node/node-file-system-provider.js
var require_node_file_system_provider2 = __commonJS({
  "../syside-languageserver/lib/node/node-file-system-provider.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SysMLNodeFileSystem = exports2.SysMLNodeFileSystemProvider = void 0;
    var node_1 = require_node5();
    var fs_1 = __importDefault(require("fs"));
    var syside_base_1 = require_lib4();
    var utils_1 = require_utils2();
    var SysMLNodeFileSystemProvider = class extends node_1.NodeFileSystemProvider {
      get standardLibrary() {
        return this.stdlib;
      }
      /**
       * Extension root directory
       */
      get extensionDir() {
        var _a;
        if (this._extensionDir === void 0) {
          const extensionDir = (0, utils_1.backtrackToDirname)(__dirname, /out|src/);
          this._extensionDir = extensionDir ? (0, syside_base_1.pathToURI)(extensionDir) : null;
        }
        return (_a = this._extensionDir) !== null && _a !== void 0 ? _a : void 0;
      }
      updateStandardLibrary(value) {
        this.stdlib = value ? (0, syside_base_1.resolvePathURI)(value) : void 0;
      }
      exists(path2) {
        return __awaiter(this, void 0, void 0, function* () {
          return fs_1.default.promises.stat(path2.fsPath).then(
            /* resolved */
            () => true,
            /* rejected */
            () => false
          );
        });
      }
      existsSync(path2) {
        return fs_1.default.existsSync(path2.fsPath);
      }
      loadScript(path2) {
        return __awaiter(this, void 0, void 0, function* () {
          return Promise.resolve(`${path2.fsPath}`).then((s) => __importStar(require(s)));
        });
      }
      preloadFiles() {
        return __awaiter(this, void 0, void 0, function* () {
          return;
        });
      }
    };
    exports2.SysMLNodeFileSystemProvider = SysMLNodeFileSystemProvider;
    exports2.SysMLNodeFileSystem = {
      fileSystemProvider: () => new SysMLNodeFileSystemProvider()
    };
  }
});

// ../syside-languageserver/lib/node/server.js
var require_server3 = __commonJS({
  "../syside-languageserver/lib/node/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.startServer = void 0;
    var node_1 = require_node3();
    var cli_1 = require_cli();
    var node_file_system_provider_1 = require_node_file_system_provider2();
    var launch_1 = require_launch();
    function startServer(options) {
      const [input, output] = (0, cli_1.createTransport)(options);
      const connection = (0, node_1.createConnection)(node_1.ProposedFeatures.all, input, output);
      return (0, launch_1.startServer)(connection, node_file_system_provider_1.SysMLNodeFileSystem, options);
    }
    exports2.startServer = startServer;
  }
});

// ../syside-languageserver/lib/node/index.js
var require_node6 = __commonJS({
  "../syside-languageserver/lib/node/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_arg_parser(), exports2);
    __exportStar(require_cli(), exports2);
    __exportStar(require_node_file_system_provider2(), exports2);
    __exportStar(require_server3(), exports2);
  }
});

// ../syside-languageserver/node.js
var require_node7 = __commonJS({
  "../syside-languageserver/node.js"(exports2, module2) {
    module2.exports = require_node6();
  }
});

// package.json
var require_package2 = __commonJS({
  "package.json"(exports2, module2) {
    module2.exports = {
      name: "syside-cli",
      displayName: "SysIDE-CLI",
      description: "CLI for SysIDE.",
      publisher: "Sensmetry",
      author: {
        name: "Sensmetry",
        url: "https://sensmetry.com/",
        email: "opensource@sensmetry.com"
      },
      version: "0.9.0",
      preview: true,
      repository: {
        url: "https://gitlab.com/sensmetry/public/sysml-2ls",
        type: "git",
        directory: "packages/syside-cli"
      },
      bugs: {
        url: "https://gitlab.com/sensmetry/public/sysml-2ls/-/issues"
      },
      files: [
        "bin",
        "out",
        "lib",
        "src"
      ],
      main: "./out/index.js",
      scripts: {
        lint: "eslint src --ext ts --max-warnings 0",
        clean: "shx rm -rf out lib coverage *.tsbuildinfo",
        build: "tsc",
        watch: "tsc --watch",
        test: "jest --passWithNoTests",
        prepack: "pnpm clean && pnpm build && pnpm esbuild --minify",
        typecheck: "tsc -p tsconfig.json --noEmit && tsc -p tsconfig.test.json --noEmit",
        "esbuild-base": "node ../../scripts/build.mjs node src/index.ts",
        esbuild: "pnpm run esbuild-base --sourcemap",
        "esbuild:watch": "pnpm run esbuild-base --sourcemap --watch"
      },
      dependencies: {
        chalk: "^5.2.0",
        commander: "^10.0.1",
        "syside-languageserver": "workspace:*",
        "vscode-uri": "3.0.7"
      },
      devDependencies: {
        langium: "~1.2.0",
        "vscode-languageserver": "~8.0.2"
      }
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// ../../node_modules/.pnpm/commander@10.0.1/node_modules/commander/esm.mjs
var import_index = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  // deprecated old name
  Command,
  Argument,
  Option,
  Help
} = import_index.default;

// src/cli-util.ts
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));

// ../../node_modules/.pnpm/chalk@5.3.0/node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// ../../node_modules/.pnpm/chalk@5.3.0/node_modules/chalk/source/vendor/supports-color/index.js
var import_node_process = __toESM(require("node:process"), 1);
var import_node_os = __toESM(require("node:os"), 1);
var import_node_tty = __toESM(require("node:tty"), 1);
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : import_node_process.default.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = import_node_process.default;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (import_node_process.default.platform === "win32") {
    const osRelease = import_node_os.default.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if ("GITHUB_ACTIONS" in env || "GITEA_ACTIONS" in env) {
      return 3;
    }
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
  stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) })
};
var supports_color_default = supportsColor;

// ../../node_modules/.pnpm/chalk@5.3.0/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// ../../node_modules/.pnpm/chalk@5.3.0/node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk2 = (...strings) => strings.join(" ");
  applyOptions(chalk2, options);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// src/cli-util.ts
var import_vscode_uri = __toESM(require_umd());
function extractDocument(_0, _1, _2) {
  return __async(this, arguments, function* (fileName, extensions, services, { validate = false, standardLibrary = "standard" } = {}) {
    var _a;
    if (!extensions.includes(import_path.default.extname(fileName))) {
      console.error(
        source_default.yellow(`Please, choose a file with one of these extensions: ${extensions}.`)
      );
      process.exit(1);
    }
    if (!import_fs.default.existsSync(fileName)) {
      console.error(source_default.red(`File ${fileName} doesn't exist.`));
      process.exit(1);
    }
    const document = services.shared.workspace.LangiumDocuments.getOrCreateDocument(
      import_vscode_uri.URI.file(import_path.default.resolve(fileName))
    );
    const buildOptions = {
      validationChecks: validate ? "all" : "none",
      standardLibrary
    };
    yield services.shared.workspace.DocumentBuilder.build([document], buildOptions);
    const validationErrors = ((_a = document.diagnostics) != null ? _a : []).filter((e) => e.severity === 1);
    if (validationErrors.length > 0) {
      console.error(source_default.red("There are validation errors:"));
      for (const validationError of validationErrors) {
        console.error(
          source_default.red(
            `line ${validationError.range.start.line + 1}: ${validationError.message} [${document.textDocument.getText(validationError.range)}]`
          )
        );
      }
      process.exit(1);
    }
    return document;
  });
}

// src/sysml-util.ts
var import_syside_languageserver = __toESM(require_lib5());
var import_node = __toESM(require_node7());
var Extensions = import_syside_languageserver.KerMLLanguageMetaData.fileExtensions.concat(
  import_syside_languageserver.SysMLLanguageMetaData.fileExtensions
);
var evalAction = (fileName, options) => __async(void 0, null, function* () {
  const services = (0, import_syside_languageserver.createSysMLServices)(import_node.SysMLNodeFileSystem).KerML;
  const document = yield extractDocument(fileName, Extensions, services, {
    validate: options.validate,
    standardLibrary: options.stdlib
  });
  const module2 = document.parseResult.value;
  console.log((0, import_syside_languageserver.stringify)(module2));
});

// src/index.ts
function src_default() {
  const program2 = new Command();
  program2.version(require_package2().version);
  program2.command("dump").argument("<file>", `possible file extensions: ${Extensions.join(", ")}`).option("-v, --validate", "Enable validation checks", false).addOption(
    new Option("-l, --stdlib <standardLibrary>", "Set standard library type").choices(["none", "standard", "local"]).default("standard")
  ).description("Dump AST as JSON to console").action(evalAction);
  program2.parse(process.argv);
}
//! import metamodel types last to let decorators run
//! Changes to the following need to be reflected in package.json
//! -------------------------------------------------------------------
//# sourceMappingURL=index.js.map
src_default();